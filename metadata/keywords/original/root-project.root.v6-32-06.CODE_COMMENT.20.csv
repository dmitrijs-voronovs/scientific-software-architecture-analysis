id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:173,Integrability,contract,contract,173,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:64,Usability,simpl,simplified,64,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:99,Usability,simpl,simplified,99,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:210,Usability,simpl,simplification,210,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:303,Usability,simpl,simplification,303,"/// Given a constrained FP intrinsic call, tries to compute its simplified; /// version. Returns a simplified result or null.; ///; /// This function provides an additional contract: it guarantees that if; /// simplification succeeds that the intrinsic is side effect free. As a result,; /// successful simplification can be used to delete the intrinsic not just; /// replace its result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:12,Performance,load,load,12,"/// Given a load instruction and its pointer operand, fold the result or return; /// null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:28,Usability,simpl,simplified,28,"/// See if we can compute a simplified version of this instruction. If not,; /// return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:12,Usability,simpl,simplifyInstruction,12,"/// Like \p simplifyInstruction but the operands of \p I are replaced with; /// \p NewOps. Returns a simplified value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:101,Usability,simpl,simplified,101,"/// Like \p simplifyInstruction but the operands of \p I are replaced with; /// \p NewOps. Returns a simplified value, or null if none was found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:13,Usability,simpl,simplifies,13,"/// See if V simplifies when its operand Op is replaced with RepOp. If not,; /// return null.; /// AllowRefinement specifies whether the simplification can be a refinement; /// (e.g. 0 instead of poison), or whether it needs to be strictly identical.; /// Op and RepOp can be assumed to not be poison when determining refinement.; ///; /// If DropFlags is passed, then the replacement result is only valid if; /// poison-generating flags/metadata on those instructions are dropped. This; /// is only useful in conjunction with AllowRefinement=false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:137,Usability,simpl,simplification,137,"/// See if V simplifies when its operand Op is replaced with RepOp. If not,; /// return null.; /// AllowRefinement specifies whether the simplification can be a refinement; /// (e.g. 0 instead of poison), or whether it needs to be strictly identical.; /// Op and RepOp can be assumed to not be poison when determining refinement.; ///; /// If DropFlags is passed, then the replacement result is only valid if; /// poison-generating flags/metadata on those instructions are dropped. This; /// is only useful in conjunction with AllowRefinement=false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:199,Deployability,update,updated,199,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:99,Performance,perform,performs,99,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:470,Performance,perform,performed,470,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:34,Usability,Simpl,SimpleV,34,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:47,Usability,simpl,simplify,47,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:132,Usability,Simpl,SimpleV,132,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:178,Usability,simpl,simplify,178,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:275,Usability,simpl,simplified,275,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:293,Usability,Simpl,SimpleV,293,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:373,Usability,simpl,simplified,373,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:449,Usability,simpl,simplifications,449,"/// Replace all uses of 'I' with 'SimpleV' and simplify the uses recursively.; ///; /// This first performs a normal RAUW of I with SimpleV. It then recursively; /// attempts to simplify those users updated by the operation. The 'I'; /// instruction must not be equal to the simplified value 'SimpleV'.; /// If UnsimplifiedUsers is provided, instructions that could not be simplified; /// are added to it.; ///; /// The function returns true if any simplifications were performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:35,Usability,Simpl,SimplifyQuery,35,// These helper functions return a SimplifyQuery structure that contains as; // many of the optional analysis we use as are currently valid. This is the; // strongly preferred way of constructing SimplifyQuery in passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h:196,Usability,Simpl,SimplifyQuery,196,// These helper functions return a SimplifyQuery structure that contains as; // many of the optional analysis we use as are currently valid. This is the; // strongly preferred way of constructing SimplifyQuery in passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstructionSimplify.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:175,Usability,simpl,simplified,175,//===--------------------------------------------------------------------===//; // Value-based folders.; //; // Return an existing value or a constant if the operation can be simplified.; // Otherwise return nullptr.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InstSimplifyFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:984,Safety,avoid,avoid,984,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:224,Testability,log,logger,224,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:310,Testability,log,log,310,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:568,Testability,log,log,568,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h:583,Testability,log,log,583,"/// A MLModelRunner that asks for advice from an external agent, or host. It; /// uses 2 files - ideally named pipes - one to send data to that agent, and; /// one to receive advice.; /// The data exchange uses the training logger (Utils/TrainingLogger.h) format.; /// Specifically, the compiler will send the log header, set the context, and; /// send observations; the host is expected to reply with a tensor value after; /// each observation as a binary buffer that's conforming to the shape of the; /// advice. Interleaved, the data closely resembles the training log for a; /// log where we don't capture the reward signal.; ///; /// Note that the correctness of the received data is the responsibility of the; /// host. In particular, if insufficient data were sent, the compiler will block; /// when waiting for an advice.; ///; /// Note that the host can either open the pipes RW, or open first the pipe to; /// the compiler - i.e. the ""Inbound"" - and then the ""Outbound"", to avoid; /// deadlock. This is because the compiler first tries to open the inbound; /// (which will hang until there's a writer on the other end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/InteractiveModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,Integrability,depend,dependency,20,"// I don't want the dependency on <algorithm>; //return find(Nodes.begin(), Nodes.end(), BB) != Nodes.end();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h:20,Integrability,depend,dependency,20,"// I don't want the dependency on <algorithm>; //return find(Successors.begin(), Successors.end(), BB) != Successors.end();",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Interval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:1260,Safety,safe,safe,1260,"//===- IntervalIterator.h - Interval Iterator Declaration -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines an iterator that enumerates the intervals in a control flow; // graph of some sort. This iterator is parametric, allowing iterator over the; // following types of graphs:; //; // 1. A Function* object, composed of BasicBlock nodes.; // 2. An IntervalPartition& object, composed of Interval nodes.; //; // This iterator is defined to walk the control flow graph, returning intervals; // in depth first order. These intervals are completely filled in except for; // the predecessor fields (the successor information is filled in however).; //; // By default, the intervals created by this iterator are deleted after they; // are no longer any use to the iterator. This behavior can be changed by; // passing a false value into the intervals_begin() function. This causes the; // IOwnMem member to be set, and the intervals to not be deleted.; //; // It is only safe to use this if all of the intervals are deleted by the caller; // and all of the intervals are processed. However, the user of the iterator is; // not allowed to modify or delete the intervals until after the iterator has; // been used completely. The IntervalPartition class uses this functionality.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,Integrability,depend,depending,132,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h:132,Integrability,depend,depending,132,"// addNodeToInterval - This method exists to assist the generic ProcessNode; // with the task of adding a node to the new interval, depending on the; // type of the source node. In the case of a CFG source graph (BasicBlock; // case), the BasicBlock itself is added to the interval. In the case of; // an IntervalPartition source graph (Interval case), all of the member; // BasicBlocks are added to the interval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:644,Availability,down,down,644,"//===- IntervalPartition.h - Interval partition Calculation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the IntervalPartition class, which; // calculates and represents the interval partition of a function, or a; // preexisting interval partition.; //; // In this way, the interval partition may be used to reduce a flow graph down; // to its degenerate single node interval partition (unless it is irreducible).; //; // TODO: The IntervalPartition class should take a bool parameter that tells; // whether it should add the ""tails"" of an interval to an interval itself or if; // they should be represented as distinct intervals.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:624,Energy Efficiency,reduce,reduce,624,"//===- IntervalPartition.h - Interval partition Calculation -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the IntervalPartition class, which; // calculates and represents the interval partition of a function, or a; // preexisting interval partition.; //; // In this way, the interval partition may be used to reduce a flow graph down; // to its degenerate single node interval partition (unless it is irreducible).; //; // TODO: The IntervalPartition class should take a bool parameter that tells; // whether it should add the ""tails"" of an interval to an interval itself or if; // they should be represented as distinct intervals.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:302,Usability,Intuit,Intuitively,302,"//===----------------------------------------------------------------------===//; //; // IntervalPartition - This class builds and holds an ""interval partition"" for; // a function. This partition divides the control flow graph into a set of; // maximal intervals, as defined with the properties above. Intuitively, an; // interval is a (possibly nonexistent) loop with a ""tail"" of non-looping; // nodes following it.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:36,Energy Efficiency,reduce,reduced,36,// IntervalPartition ctor - Build a reduced interval partition from an; // existing interval graph. This takes an additional boolean parameter to; // distinguish it from a copy constructor. Always pass in false for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:119,Usability,simpl,simplified,119,"// isDegeneratePartition() - Returns true if the interval partition contains; // a single interval, and thus cannot be simplified anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Integrability,Interface,Interface,3,// Interface to Intervals vector...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Deployability,release,releaseMemory,3,// releaseMemory - Reset state back to before function was analyzed,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h:3,Deployability,update,updatePredecessors,3,"// updatePredecessors - Interval generation only sets the successor fields of; // the interval data structures. After interval generation is complete,; // run through all of the intervals and propagate successor info as; // predecessor info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IntervalPartition.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:393,Integrability,Interface,Interface,393,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1501,Integrability,wrap,wrapped,1501,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:632,Performance,perform,perform,632,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1313,Security,hash,hash,1313,"//===- IRSimilarityIdentifier.h - Find similarity in a module --------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // Interface file for the IRSimilarityIdentifier for identifying similarities in; // IR including the IRInstructionMapper, which maps an Instruction to unsigned; // integers.; //; // Two sequences of instructions are called ""similar"" if they perform the same; // series of operations for all inputs.; //; // \code; // %1 = add i32 %a, 10; // %2 = add i32 %a, %1; // %3 = icmp slt icmp %1, %2; // \endcode; //; // and; //; // \code; // %1 = add i32 11, %a; // %2 = sub i32 %a, %1; // %3 = icmp sgt icmp %2, %1; // \endcode; //; // ultimately have the same result, even if the inputs, and structure are; // slightly different.; //; // For instructions, we do not worry about operands that do not have fixed; // semantic meaning to the program. We consider the opcode that the instruction; // has, the types, parameters, and extra information such as the function name,; // or comparison predicate. These are used to create a hash to map instructions; // to integers to be used in similarity matching in sequences of instructions; //; // Terminology:; // An IRSimilarityCandidate is a region of IRInstructionData (wrapped; // Instructions), usually used to denote a region of similarity has been found.; //; // A SimilarityGroup is a set of IRSimilarityCandidates that are structurally; // similar to one another.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:469,Integrability,wrap,wrappers,469,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:179,Performance,perform,perform,179,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Security,hash,hashing,36,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:128,Security,hash,hash,128,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:508,Security,hash,hashed,508,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:614,Security,hash,hash,614,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:676,Security,Hash,Hash,676,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:714,Security,Hash,Hash,714,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:814,Security,hash,hashes,814,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:873,Security,Hash,Hash,873,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:915,Security,hash,hashing,915,"/// This provides the utilities for hashing an Instruction to an unsigned; /// integer. Two IRInstructionDatas produce the same hash value when their; /// underlying Instructions perform the same operation (even if they don't have; /// the same input operands.); /// As a more concrete example, consider the following:; ///; /// \code; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// \endcode; ///; // Then the IRInstructionData wrappers for these Instructions may be hashed like; /// so:; ///; /// \code; /// ; These two adds have the same types and operand types, so they hash to the; /// ; same number.; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d ; Hash: 1; /// ; This add produces an i64. This differentiates it from %add1 and %add2. So,; /// ; it hashes to a different number.; /// %add3 = add i64 %e, %f; Hash: 2; /// \endcode; ///; ///; /// This hashing scheme will be used to represent the program as a very long; /// string. This string can then be placed in a data structure which can be used; /// for similarity queries.; ///; /// TODO: Handle types of Instructions which can be equal even with different; /// operands. (E.g. comparisons with swapped predicates.); /// TODO: Handle CallInsts, which are only checked for function type; /// by \ref isSameOperationAs.; /// TODO: Handle GetElementPtrInsts, as some of the operands have to be the; /// exact same, and some do not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:41,Integrability,wrap,wrapped,41,/// The source Instruction that is being wrapped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:24,Integrability,wrap,wrapped,24,"/// The legality of the wrapped instruction. This is informed by InstrType,; /// and is used when checking when two instructions are considered similar.; /// If either instruction is not legal, the instructions are automatically not; /// considered similar.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Integrability,wrap,wrapping,36,/// This is only relevant if we are wrapping a CmpInst where we needed to; /// change the predicate of a compare instruction from a greater than form; /// to a less than form. It is std::nullopt otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:36,Integrability,wrap,wrapping,36,"/// This is only relevant if we are wrapping a CallInst. If we are requiring; /// that the function calls have matching names as well as types, and the; /// call is not an indirect call, this will hold the name of the function. If; /// it is an indirect string, it will be the empty string. However, if this; /// requirement is not in place it will be the empty string regardless of the; /// function call type. The value held here is used to create the hash of the; /// instruction, and check to make sure two instructions are close to one; /// another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:454,Security,hash,hash,454,"/// This is only relevant if we are wrapping a CallInst. If we are requiring; /// that the function calls have matching names as well as types, and the; /// call is not an indirect call, this will hold the name of the function. If; /// it is an indirect string, it will be the empty string. However, if this; /// requirement is not in place it will be the empty string regardless of the; /// function call type. The value held here is used to create the hash of the; /// instruction, and check to make sure two instructions are close to one; /// another.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:325,Performance,perform,performs,325,"/// Gather the information that is difficult to gather for an Instruction, or; /// is changed. i.e. the operands of an Instruction and the Types of those; /// operands. This extra information allows for similarity matching to make; /// assertions that allow for more flexibility when checking for whether an; /// Instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:236,Testability,assert,assertions,236,"/// Gather the information that is difficult to gather for an Instruction, or; /// is changed. i.e. the operands of an Instruction and the Types of those; /// operands. This extra information allows for similarity matching to make; /// assertions that allow for more flexibility when checking for whether an; /// Instruction performs the same operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:124,Integrability,wrap,wrapping,124,/// Get the predicate that the compare instruction is using for hashing the; /// instruction. the IRInstructionData must be wrapping a CmpInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:64,Security,hash,hashing,64,/// Get the predicate that the compare instruction is using for hashing the; /// instruction. the IRInstructionData must be wrapping a CmpInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:123,Integrability,wrap,wrapping,123,/// Get the callee name that the call instruction is using for hashing the; /// instruction. The IRInstructionData must be wrapping a CallInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:63,Security,hash,hashing,63,/// Get the callee name that the call instruction is using for hashing the; /// instruction. The IRInstructionData must be wrapping a CallInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:136,Performance,perform,perform,136,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:468,Performance,perform,performing,468,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:4,Security,Hash,Hashes,4,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:121,Security,hash,hash,121,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:514,Security,hash,hashed,514,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:636,Security,hash,hashed,636,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:786,Security,hash,hashed,786,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:922,Security,hash,hashed,922,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:184,Usability,simpl,simple,184,"/// Hashes \p Value based on its opcode, types, and operand types.; /// Two IRInstructionData instances produce the same hash when they perform; /// the same operation.; ///; /// As a simple example, consider the following instructions.; ///; /// \code; /// %add1 = add i32 %x1, %y1; /// %add2 = add i32 %x2, %y2; ///; /// %sub = sub i32 %x1, %y1; ///; /// %add_i64 = add i64 %x2, %y2; /// \endcode; ///; /// Because the first two adds operate the same types, and are performing the; /// same action, they will be hashed to the same value.; ///; /// However, the subtraction instruction is not the same as an addition, and; /// will be hashed to a different value.; ///; /// Finally, the last add has a different type compared to the first two add; /// instructions, so it will also be hashed to a different value that any of; /// the previous instructions.; ///; /// \param [in] ID - The IRInstructionData instance to be hashed.; /// \returns A hash_value of the IRInstructionData.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:6,Security,hash,hash,6,"// To hash intrinsics, we use the opcode, and types like the other; // instructions, but also, the Intrinsic ID, and the Name of the; // intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:101,Performance,perform,performing,101,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:205,Security,hash,hash,205,"/// Compare one IRInstructionData class to another IRInstructionData class for; /// whether they are performing a the same operation, and can mapped to the; /// same value. For regular instructions if the hash value is the same, then; /// they will also be close.; ///; /// \param A - The first IRInstructionData class to compare; /// \param B - The second IRInstructionData class to compare; /// \returns true if \p A and \p B are similar enough to be mapped to the same; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:429,Integrability,wrap,wrapped,429,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:525,Integrability,depend,depends,525,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1759,Integrability,interface,interface,1759,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:306,Security,hash,hashing,306,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:355,Security,hash,hash,355,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:548,Security,hash,hash,548,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1249,Security,hash,hash,1249,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1357,Security,Hash,Hash,1357,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1394,Security,Hash,Hash,1394,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1431,Security,Hash,Hash,1431,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1477,Security,Hash,Hash,1477,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:1515,Security,Hash,Hash,1515,"/// Helper struct for converting the Instructions in a Module into a vector of; /// unsigned integers. This vector of unsigned integers can be thought of as a; /// ""numeric string"". This numeric string can then be queried by, for example,; /// data structures that find repeated substrings.; ///; /// This hashing is done per BasicBlock in the module. To hash Instructions; /// based off of their operations, each Instruction is wrapped in an; /// IRInstructionData struct. The unsigned integer for an IRInstructionData; /// depends on:; /// - The hash provided by the IRInstructionData.; /// - Which member of InstrType the IRInstructionData is classified as.; // See InstrType for more details on the possible classifications, and how they; // manifest in the numeric string.; ///; /// The numeric string for an individual BasicBlock is terminated by an unique; /// unsigned integer. This prevents data structures which rely on repetition; /// from matching across BasicBlocks. (For example, the SuffixTree.); /// As a concrete example, if we have the following two BasicBlocks:; /// \code; /// bb0:; /// %add1 = add i32 %a, %b; /// %add2 = add i32 %c, %d; /// %add3 = add i64 %e, %f; /// bb1:; /// %sub = sub i32 %c, %d; /// \endcode; /// We may hash the Instructions like this (via IRInstructionData):; /// \code; /// bb0:; /// %add1 = add i32 %a, %b ; Hash: 1; /// %add2 = add i32 %c, %d; Hash: 1; /// %add3 = add i64 %e, %f; Hash: 2; /// bb1:; /// %sub = sub i32 %c, %d; Hash: 3; /// %add4 = add i32 %c, %d ; Hash: 1; /// \endcode; /// And produce a ""numeric string representation"" like so:; /// 1, 1, 2, unique_integer_1, 3, 1, unique_integer_2; ///; /// TODO: This is very similar to the MachineOutliner, and should be; /// consolidated into the same interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Availability,avail,available,13,/// The next available integer to assign to a legal Instruction to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:33,Energy Efficiency,charge,charge,33,/// This allocator pointer is in charge of holding on to the IRInstructionData; /// so it is not deallocated until whatever external tool is using it is done; /// with the information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:33,Energy Efficiency,charge,charge,33,/// This allocator pointer is in charge of creating the IRInstructionDataList; /// so it is not deallocated until whatever external tool is using it is done; /// with the information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,Energy Efficiency,allocate,allocated,11,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:383,Energy Efficiency,allocate,allocated,383,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:115,Integrability,wrap,wrap,115,"/// Get an allocated IRInstructionData struct using the InstDataAllocator.; ///; /// \param I - The Instruction to wrap with IRInstructionData.; /// \param Legality - A boolean value that is true if the instruction is to; /// be considered for similarity, and false if not.; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:17,Energy Efficiency,allocate,allocated,17,/// Get an empty allocated IRInstructionData struct using the; /// InstDataAllocator.; ///; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:200,Energy Efficiency,allocate,allocated,200,/// Get an empty allocated IRInstructionData struct using the; /// InstDataAllocator.; ///; /// \param IDL - The InstructionDataList that the IRInstructionData is; /// inserted into.; /// \returns An allocated IRInstructionData struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:11,Energy Efficiency,allocate,allocated,11,/// Get an allocated IRInstructionDataList object using the IDLAllocator.; ///; /// \returns An allocated IRInstructionDataList object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:96,Energy Efficiency,allocate,allocated,96,/// Get an allocated IRInstructionDataList object using the IDLAllocator.; ///; /// \returns An allocated IRInstructionDataList object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:14,Modifiability,variab,variable,14,// We exclude variable argument instructions since variable arguments; // requires extra checking of the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:51,Modifiability,variab,variable,51,// We exclude variable argument instructions since variable arguments; // requires extra checking of the argument list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:73,Integrability,depend,dependent,73,// We exclude all exception handling cases since they are so context; // dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:178,Availability,down,down,178,"// Functions marked with the swifttailcc and tailcc calling conventions; // require special handling when outlining musttail functions. The; // calling convention must be passed down to the outlined function as; // well. Further, there is special handling for musttail calls as well,; // requiring a return call directly after. For now, the outliner does not; // support this, so we do not handle matching this case either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that lets the classifier know whether we should; // allow branches to be checked for similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that lets the classifier know whether we should; // allow indirect calls to be considered legal instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:25,Integrability,wrap,wraps,25,"/// This is a class that wraps a range of IRInstructionData from one point to; /// another in the vector of IRInstructionData, which is a region of the; /// program. It is also responsible for defining the structure within this; /// region of instructions.; ///; /// The structure of a region is defined through a value numbering system; /// assigned to each unique value in a region at the creation of the; /// IRSimilarityCandidate.; ///; /// For example, for each Instruction we add a mapping for each new; /// value seen in that Instruction.; /// IR: Mapping Added:; /// %add1 = add i32 %a, c1 %add1 -> 3, %a -> 1, c1 -> 2; /// %add2 = add i32 %a, %1 %add2 -> 4; /// %add3 = add i32 c2, c1 %add3 -> 6, c2 -> 5; ///; /// We can compare IRSimilarityCandidates against one another.; /// The \ref isSimilar function compares each IRInstructionData against one; /// another and if we have the same sequences of IRInstructionData that would; /// create the same hash, we have similar IRSimilarityCandidates.; ///; /// We can also compare the structure of IRSimilarityCandidates. If we can; /// create a mapping of registers in the region contained by one; /// IRSimilarityCandidate to the region contained by different; /// IRSimilarityCandidate, they can be considered structurally similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, %e; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// Can have the following mapping from candidate to candidate of:; /// %a -> %d, %b -> %e, %c -> %f, c1 -> c3, c2 -> c4; /// and can be considered similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, c4; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// We cannot create the same mapping since the use of c4 is not used in the; /// same way as %b or c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:960,Security,hash,hash,960,"/// This is a class that wraps a range of IRInstructionData from one point to; /// another in the vector of IRInstructionData, which is a region of the; /// program. It is also responsible for defining the structure within this; /// region of instructions.; ///; /// The structure of a region is defined through a value numbering system; /// assigned to each unique value in a region at the creation of the; /// IRSimilarityCandidate.; ///; /// For example, for each Instruction we add a mapping for each new; /// value seen in that Instruction.; /// IR: Mapping Added:; /// %add1 = add i32 %a, c1 %add1 -> 3, %a -> 1, c1 -> 2; /// %add2 = add i32 %a, %1 %add2 -> 4; /// %add3 = add i32 c2, c1 %add3 -> 6, c2 -> 5; ///; /// We can compare IRSimilarityCandidates against one another.; /// The \ref isSimilar function compares each IRInstructionData against one; /// another and if we have the same sequences of IRInstructionData that would; /// create the same hash, we have similar IRSimilarityCandidates.; ///; /// We can also compare the structure of IRSimilarityCandidates. If we can; /// create a mapping of registers in the region contained by one; /// IRSimilarityCandidate to the region contained by different; /// IRSimilarityCandidate, they can be considered structurally similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, %e; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// Can have the following mapping from candidate to candidate of:; /// %a -> %d, %b -> %e, %c -> %f, c1 -> c3, c2 -> c4; /// and can be considered similar.; ///; /// IRSimilarityCandidate1: IRSimilarityCandidate2:; /// %add1 = add i32 %a, %b %add1 = add i32 %d, c4; /// %add2 = add i32 %a, %c %add2 = add i32 %d, %f; /// %add3 = add i32 c1, c2 %add3 = add i32 c3, c4; ///; /// We cannot create the same mapping since the use of c4 is not used in the; /// same way as %b or c2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:112,Usability,guid,guide,112,"/// Create a mapping from the value numbering to a different separate set of; /// numbers. This will serve as a guide for relating one candidate to another.; /// The canonical number gives use the ability identify which global value; /// number in one candidate relates to the global value number in the other.; ///; /// \param [in, out] CurrCand - The IRSimilarityCandidate to create a; /// canonical numbering for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:456,Integrability,bridg,bridge,456,"/// Create a mapping for the value numbering of the calling; /// IRSimilarityCandidate, to a different separate set of numbers, based on; /// the canonical ordering in \p SourceCand. These are defined based on the; /// canonical mapping defined between \p SoureCandLarge and; /// \p TargetCandLarge. These IRSimilarityCandidates are already structurally; /// similar, and fully encapsulate the IRSimilarityCandidates in question.; /// These are used as a ""bridge"" from the \p SourceCand to the target.; ///; /// \param [in, out] SourceCand - The IRSimilarityCandidate to create a; /// canonical numbering from.; /// \param SoureCandLarge - The IRSimilarityCandidate fully containing; /// \p SourceCand.; /// \param TargetCandLarge - The IRSimilarityCandidate fully containing; /// this Candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:3,Usability,Clear,Clears,3,// Clears \ref SimilarityCandidates if it is already filled by a previous run.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:68,Usability,clear,clear,68,"// If we've already analyzed a Module or set of Modules, so we must clear; // the SimilarityCandidates to make sure we do not have only old values; // hanging around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:46,Integrability,wrap,wraps,46,/// Map Instructions to unsigned integers and wraps the Instruction in an; /// instance of IRInstructionData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we should check branches for; /// similarity, or only look within basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we allow indirect calls to be checked; /// for similarity, or exclude them as a legal instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,"/// The flag variable that marks whether we allow calls to be marked as; /// similar if they do not have the same name, only the same calling; /// convention, attributes and type signature.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:13,Modifiability,variab,variable,13,/// The flag variable that marks whether we should check intrinsics for; /// similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h:12,Modifiability,variab,variable,12,// The flag variable that marks whether we should allow tailcalls; // to be checked for similarity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IRSimilarityIdentifier.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:430,Modifiability,variab,variables,430,"//===- llvm/Analysis/IVDescriptors.h - IndVar Descriptors -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file ""describes"" induction and recurrence variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical OR of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical AND of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:16,Testability,log,logical,16,///< Bitwise or logical XOR of integers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:61,Modifiability,variab,variables,61,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:166,Modifiability,variab,variable,166,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:654,Modifiability,variab,variables,654,"/// The RecurrenceDescriptor is used to identify recurrences variables in a; /// loop. Reduction is a special case of recurrence that has uses of the; /// recurrence variable outside the loop. The method isReductionPHI identifies; /// reductions that are basic recurrences.; ///; /// Basic recurrences are defined as the summation, product, OR, AND, XOR, min,; /// or max of a set of terms. For example: for(i=0; i<n; i++) { total +=; /// array[i]; } is a summation of array elements. Basic recurrences are a; /// special case of chains of recurrences (CR). See ScalarEvolution for CR; /// references.; /// This struct holds information about recurrence variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:80,Modifiability,variab,variable,80,/// Returns a struct describing if the instruction 'I' can be a recurrence; /// variable of type 'Kind' for a Loop \p L and reduction PHI \p Phi.; /// If the recurrence is a min/max pattern of select(icmp()) this function; /// advances the instruction pointer 'I' from the compare instruction to the; /// select instruction and stores this pointer in 'PatternLastInst' member of; /// the returned struct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:613,Performance,perform,perform,613,"/// Returns true if Phi is a fixed-order recurrence. A fixed-order recurrence; /// is a non-reduction recurrence relation in which the value of the; /// recurrence in the current loop iteration equals a value defined in a; /// previous iteration (e.g. if the value is defined in the previous; /// iteration, we refer to it as first-order recurrence, if it is defined in; /// the iteration before the previous, we refer to it as second-order; /// recurrence and so on). Note that this function optimistically assumes that; /// uses of the recurrence can be re-ordered if necessary and users need to; /// check and perform the re-ordering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:4,Security,Expose,Expose,4,/// Expose an ordered FP reduction to the instance users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:52,Modifiability,variab,variables,52,/// A struct for saving information about induction variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:22,Modifiability,variab,variable,22,///< Not an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:23,Modifiability,variab,variable,23,///< Integer induction variable. Step = C.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:30,Modifiability,variab,variable,30,///< Floating point induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:262,Testability,assert,assert,262,"/// Returns true if \p Phi is an induction in the loop \p L. If \p Phi is an; /// induction, the induction descriptor \p D will contain the data describing; /// this induction. Since Induction Phis can only be present inside loop; /// headers, the function will assert if it is passed a Phi whose parent is; /// not the loop header. If by some other means the caller has a better SCEV; /// expression for \p Phi than the one returned by the ScalarEvolution; /// analysis, it can be passed through \p Expr. If the def-use chain; /// associated with the phi includes casts (that we know we can ignore; /// under proper runtime checks), they are passed through \p CastsToIgnore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,Availability,redundant,redundant,99,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Deployability,update,update,76,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:99,Safety,redund,redundant,99,"/// Returns a reference to the type cast instructions in the induction; /// update chain, that are redundant when guarded with a runtime; /// SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:39,Modifiability,variab,variable,39,// Instruction that advances induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Availability,redundant,redundant,76,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:53,Modifiability,variab,variable,53,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h:76,Safety,redund,redundant,76,"// Instructions used for type-casts of the induction variable,; // that are redundant when guarded with a runtime SCEV overflow check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVDescriptors.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:43,Modifiability,Variab,Variable,43,"//===- llvm/Analysis/IVUsers.h - Induction Variable Users -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:483,Modifiability,variab,variables,483,"//===- llvm/Analysis/IVUsers.h - Induction Variable Users -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements bookkeeping for ""interesting"" users of expressions; // computed from induction variables.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:63,Modifiability,variab,variable,63,"/// IVStrideUse - Keep track of one use of a strided induction variable.; /// The Expr member keeps track of the expression, User is the actual user; /// instruction of the operand, and 'OperandValToReplace' is the operand of; /// the User that is the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:56,Modifiability,variab,variable,56,/// IVUses - A list of all tracked IV uses of induction variable expressions; /// we are interested in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c IVUsers for a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/IVUsers.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:4,Integrability,Wrap,Wraps,4,/// Wraps a BFI to allow lazy computation of the block frequencies.; ///; /// A pass that only conditionally uses BFI can uncondtionally require the; /// analysis without paying for the overhead if BFI doesn't end up being used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:429,Integrability,depend,dependent,429,"/// This is an alternative analysis pass to; /// BlockFrequencyInfoWrapperPass. The difference is that with this pass the; /// block frequencies are not computed when the analysis pass is executed but; /// rather when the BFI result is explicitly requested by the analysis client.; ///; /// There are some additional requirements for any client pass that wants to use; /// the analysis:; ///; /// 1. The pass needs to initialize dependent passes with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LazyBFIPass); ///; /// 2. Similarly, getAnalysisUsage should call:; ///; /// LazyBlockFrequencyInfoPass::getLazyBFIAnalysisUsage(AU); ///; /// 3. The computed BFI should be requested with; /// getAnalysis<LazyBlockFrequencyInfoPass>().getBFI() before either LoopInfo; /// or BPI could be invalidated for example by changing the CFG.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h:43,Integrability,depend,dependent,43,/// Helper for client passes to initialize dependent passes for LBFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:436,Integrability,depend,dependent,436,"/// This is an alternative analysis pass to; /// BranchProbabilityInfoWrapperPass. The difference is that with this pass the; /// branch probabilities are not computed when the analysis pass is executed but; /// rather when the BPI results is explicitly requested by the analysis client.; ///; /// There are some additional requirements for any client pass that wants to use; /// the analysis:; ///; /// 1. The pass needs to initialize dependent passes with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LazyBPIPass); ///; /// 2. Similarly, getAnalysisUsage should call:; ///; /// LazyBranchProbabilityInfoPass::getLazyBPIAnalysisUsage(AU); ///; /// 3. The computed BPI should be requested with; /// getAnalysis<LazyBranchProbabilityInfoPass>().getBPI() before LoopInfo; /// could be invalidated for example by changing the CFG.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:4,Integrability,Wrap,Wraps,4,/// Wraps a BPI to allow lazy computation of the branch probabilities.; ///; /// A pass that only conditionally uses BPI can uncondtionally require the; /// analysis without paying for the overhead if BPI doesn't end up being used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:43,Integrability,depend,dependent,43,/// Helper for client passes to initialize dependent passes for LBPI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h:4,Usability,Simpl,Simple,4,/// Simple trait class that provides a mapping between BPI passes and the; /// corresponding BPInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1036,Performance,optimiz,optimizations,1036,"//===- LazyCallGraph.h - Analysis of a Module's call graph ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Implements a lazy call graph analysis and related passes for the new pass; /// manager.; ///; /// NB: This is *not* a traditional call graph! It is a graph which models both; /// the current calls and potential calls. As a consequence there are many; /// edges in this call graph that do not correspond to a 'call' or 'invoke'; /// instruction.; ///; /// The primary use cases of this graph analysis is to facilitate iterating; /// across the functions of a module in ways that ensure all callees are; /// visited prior to a caller (given any SCC constraints), or vice versa. As; /// such is it particularly well suited to organizing CGSCC optimizations such; /// as inlining, outlining, argument promotion, etc. That is its primary use; /// case and motivates the design. It may not be appropriate for other; /// purposes. The use graph of functions or some other conservative analysis of; /// call instructions may be interesting for optimizations and subsequent; /// analyses which don't work in the context of an overly specified; /// potential-call-edge graph.; ///; /// To understand the specific rules and nature of this call graph analysis,; /// see the documentation of the \c LazyCallGraph below.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1332,Performance,optimiz,optimizations,1332,"//===- LazyCallGraph.h - Analysis of a Module's call graph ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Implements a lazy call graph analysis and related passes for the new pass; /// manager.; ///; /// NB: This is *not* a traditional call graph! It is a graph which models both; /// the current calls and potential calls. As a consequence there are many; /// edges in this call graph that do not correspond to a 'call' or 'invoke'; /// instruction.; ///; /// The primary use cases of this graph analysis is to facilitate iterating; /// across the functions of a module in ways that ensure all callees are; /// visited prior to a caller (given any SCC constraints), or vice versa. As; /// such is it particularly well suited to organizing CGSCC optimizations such; /// as inlining, outlining, argument promotion, etc. That is its primary use; /// case and motivates the design. It may not be appropriate for other; /// purposes. The use graph of functions or some other conservative analysis of; /// call instructions may be interesting for optimizations and subsequent; /// analyses which don't work in the context of an overly specified; /// potential-call-edge graph.; ///; /// To understand the specific rules and nature of this call graph analysis,; /// see the documentation of the \c LazyCallGraph below.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2205,Deployability,update,updates,2205,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1918,Modifiability,variab,variables,1918,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:190,Performance,optimiz,optimization,190,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:221,Performance,optimiz,optimizations,221,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:240,Performance,optimiz,optimizations,240,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:400,Performance,optimiz,optimizations,400,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:919,Performance,optimiz,optimizing,919,"/// A lazily constructed view of the call graph of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unk",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1000,Performance,optimiz,optimizations,1000,"of a module.; ///; /// With the edges of this graph, the motivating constraint that we are; /// attempting to maintain is that function-local optimization, CGSCC-local; /// optimizations, and optimizations transforming a pair of functions connected; /// by an edge in the graph, do not invalidate a bottom-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1420,Performance,optimiz,optimizations,1420,"om-up traversal of the SCC; /// DAG. That is, no optimizations will delete, remove, or add an edge such; /// that functions already visited in a bottom-up order of the SCC DAG are no; /// longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates und",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1632,Performance,optimiz,optimization,1632,"longer valid to have visited, or such that functions not yet visited in; /// a bottom-up order of the SCC DAG are not required to have already been; /// visited.; ///; /// Within this constraint, the desire is to minimize the merge points of the; /// SCC DAG. The greater the fanout of the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt complete",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2135,Performance,load,load,2135,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2235,Performance,optimiz,optimizations,2235,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:2477,Performance,optimiz,optimizations,2477,"f the SCC DAG and the fewer merge points; /// in the SCC DAG, the more independence there is in optimizing within it.; /// There is a strong desire to enable parallelization of optimizations over; /// the call graph, and both limited fanout and merge points will (artificially; /// in some cases) limit the scaling of such an effort.; ///; /// To this end, graph represents both direct and any potential resolution to; /// an indirect call edge. Another way to think about it is that it represents; /// both the direct call edges and any direct call edges that might be formed; /// through static optimizations. Specifically, it considers taking the address; /// of a function to be an edge in the call graph because this might be; /// forwarded to become a direct call by some subsequent function-local; /// optimization. The result is that the graph closely follows the use-def; /// edges for functions. Walking ""up"" the graph can be done by looking at all; /// of the uses of a function.; ///; /// The roots of the call graph are the external functions and functions; /// escaped into global variables. Those functions can be called from outside; /// of the module or via unknowable means in the IR -- we may not be able to; /// form even a potential call edge from a function body which may dynamically; /// load the function and call it.; ///; /// This analysis still requires updates to remain valid after optimizations; /// which could potentially change the set of potential callees. The; /// constraints it operates under only make the traversal order remain valid.; ///; /// The entire analysis must be re-computed if full interprocedural; /// optimizations run at any point. For example, globalopt completely; /// invalidates the information in this analysis.; ///; /// FIXME: This class is named LazyCallGraph in a lame attempt to distinguish; /// it from the existing CallGraph. At some point, it is expected that this; /// will be the only call graph and it will be renamed accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether the edge is null.; ///; /// This happens when an edge has been deleted. We leave the edge objects; /// around but clear them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:131,Usability,clear,clear,131,/// Test whether the edge is null.; ///; /// This happens when an edge has been deleted. We leave the edge objects; /// around but clear them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether the edge represents a direct call to a function.; ///; /// This requires that the edge is not null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:270,Performance,cache,cached,270,/// The edge sequence object.; ///; /// This typically exists entirely within the node but is exposed as; /// a separate type because a node doesn't initially have edges. An explicit; /// population step is required to produce this sequence at first and it is; /// then cached in the node. It is also used to represent edges entering the; /// graph from outside the module to model the graph's roots.; ///; /// The sequence itself both iterable and indexable. The indexes remain; /// stable even as the sequence mutates (including removal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:94,Security,expose,exposed,94,/// The edge sequence object.; ///; /// This typically exists entirely within the node but is exposed as; /// a separate type because a node doesn't initially have edges. An explicit; /// population step is required to produce this sequence at first and it is; /// then cached in the node. It is also used to represent edges entering the; /// graph from outside the module to model the graph's roots.; ///; /// The sequence itself both iterable and indexable. The indexes remain; /// stable even as the sequence mutates (including removal).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:96,Performance,cache,cache,96,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:430,Security,access,access,430,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:158,Testability,test,testing,158,"/// A node in the call graph.; ///; /// This represents a single node. Its primary roles are to cache the list of; /// callees, de-duplicate and provide fast testing of whether a function is a; /// callee, and facilitate iteration of child nodes in the graph.; ///; /// The node works much like an optional in order to lazily populate the; /// edges of each node. Until populated, there are no edges. Once populated,; /// you can access the edges by dereferencing the node or using the `->`; /// operator as if the node was an `std::optional<EdgeSequence>`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Tests,4,/// Tests whether the node has been populated with edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Tests,4,/// Tests whether this is actually a dead node and no longer valid.; ///; /// Users rarely interact with nodes in this state and other methods are; /// invalid. This is used to model a node in an edge list where the; /// function has been completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:94,Integrability,wrap,wrapping,94,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:12,Security,access,accessing,12,"// We allow accessing the edges by dereferencing or using the arrow; // operator, essentially wrapping the internal optional.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:293,Deployability,update,updates,293,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:412,Deployability,update,update,412,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:496,Performance,cache,cached,496,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:367,Usability,simpl,simplify,367,"/// Populate the edges of this node if necessary.; ///; /// The first time this is called it will populate the edges for this node; /// in the graph. It does this by scanning the underlying function, so once; /// this is done, any changes to that function must be explicitly reflected; /// in updates to the graph.; ///; /// \returns the populated \c EdgeSequence to simplify walking it.; ///; /// This will not update or re-scan anything if called repeatedly. Instead,; /// the edge sequence is cached and returned immediately on subsequent; /// calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:112,Integrability,wrap,wrapped,112,/// Print a short description useful for debugging or logging.; ///; /// We print the function names in the SCC wrapped in '()'s and skipping; /// the middle functions if there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Testability,log,logging,54,/// Print a short description useful for debugging or logging.; ///; /// We print the function names in the SCC wrapped in '()'s and skipping; /// the middle functions if there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:68,Security,validat,validate,68,"/// Verify invariants about the SCC.; ///; /// This will attempt to validate all of the basic invariants within an; /// SCC, but not that it is a strongly connected component per se.; /// Primarily useful while building and updating the graph to check that; /// basic properties are in place rather than having inexplicable crashes; /// later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a parent of \a C.; ///; /// Note that this is linear in the number of edges departing the current; /// SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is an ancestor of \a C.; ///; /// Note that in the worst case this is linear in the number of edges; /// departing the current SCC and every SCC in the entire graph reachable; /// from this SCC. Thus this very well may walk every edge in the entire; /// call graph! Do not call this in a tight loop!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:139,Integrability,rout,routine,139,/// Test if this SCC is a child of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a child of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:144,Integrability,rout,routine,144,/// Test if this SCC is a descendant of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this SCC is a descendant of \a C.; ///; /// See the comments for \c isParentOf for detailed notes about the; /// complexity of this routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:200,Testability,log,logging,200,/// Provide a short name by printing this SCC to a std::string.; ///; /// This copes with the fact that we don't have a name per se for an SCC; /// while still making the use of this in debugging and logging useful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:91,Integrability,wrap,wrapped,91,/// Print a short description useful for debugging or logging.; ///; /// We print the SCCs wrapped in '[]'s and skipping the middle SCCs if; /// there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Testability,log,logging,54,/// Print a short description useful for debugging or logging.; ///; /// We print the SCCs wrapped in '[]'s and skipping the middle SCCs if; /// there are a large number.; //; // Note: this is defined inline to dodge issues with GCC's interpretation; // of enclosing namespaces for friend function declarations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:273,Deployability,update,update,273,"/// Verify invariants about the RefSCC and all its SCCs.; ///; /// This will attempt to validate all of the invariants *within* the; /// RefSCC, but not that it is a strongly connected component of the larger; /// graph. This makes it useful even when partially through an update.; ///; /// Invariants checked:; /// - SCCs and their indices match.; /// - The SCCs list is in fact in post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:88,Security,validat,validate,88,"/// Verify invariants about the RefSCC and all its SCCs.; ///; /// This will attempt to validate all of the invariants *within* the; /// RefSCC, but not that it is a strongly connected component of the larger; /// graph. This makes it useful even when partially through an update.; ///; /// Invariants checked:; /// - SCCs and their indices match.; /// - The SCCs list is in fact in post-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,"/// Test if this RefSCC is a parent of \a RC.; ///; /// CAUTION: This method walks every edge in the \c RefSCC, it can be very; /// expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this RefSCC is an ancestor of \a RC.; ///; /// CAUTION: This method walks the directed graph of edges as far as; /// necessary to find a possible path to the argument. In the worst case; /// this may walk the entire graph and can be extremely expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,"/// Test if this RefSCC is a child of \a RC.; ///; /// CAUTION: This method walks every edge in the argument \c RefSCC, it can; /// be very expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test if this RefSCC is a descendant of \a RC.; ///; /// CAUTION: This method walks the directed graph of edges as far as; /// necessary to find a possible path from the argument. In the worst case; /// this may walk the entire graph and can be extremely expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:206,Testability,log,logging,206,/// Provide a short name by printing this RefSCC to a std::string.; ///; /// This copes with the fact that we don't have a name per se for an RefSCC; /// while still making the use of this in debugging and logging useful.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:569,Performance,perform,performing,569,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:918,Performance,cache,cached,918,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:909,Usability,clear,clearing,909,"///@{; /// \name Mutation API; ///; /// These methods provide the core API for updating the call graph in the; /// presence of (potentially still in-flight) DFS-found RefSCCs and SCCs.; ///; /// Note that these methods sometimes have complex runtimes, so be careful; /// how you call them.; /// Make an existing internal ref edge into a call edge.; ///; /// This may form a larger cycle and thus collapse SCCs into TargetN's SCC.; /// If that happens, the optional callback \p MergedCB will be invoked (if; /// provided) on the SCCs being merged away prior to actually performing; /// the merge. Note that this will never include the target SCC as that; /// will be the SCC functions are merged into to resolve the cycle. Once; /// this function returns, these merged SCCs are not in a valid state but; /// the pointers will remain valid until destruction of the parent graph; /// instance for the purpose of clearing cached information. This function; /// also returns 'true' if a cycle was formed and some SCCs merged away as; /// a convenience.; ///; /// After this operation, both SourceN's SCC and TargetN's SCC may move; /// position within this RefSCC's postorder list. Any SCCs merged are; /// merged into the TargetN's SCC in order to preserve reachability analyses; /// which took place on that SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:264,Integrability,rout,routine,264,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:925,Integrability,rout,routine,925,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:912,Usability,simpl,simpler,912,"/// Make an existing internal call edge within a single SCC into a ref; /// edge.; ///; /// Since SourceN and TargetN are part of a single SCC, this SCC may be; /// split up due to breaking a cycle in the call edges that formed it. If; /// that happens, then this routine will insert new SCCs into the postorder; /// list *before* the SCC of TargetN (previously the SCC of both). This; /// preserves postorder as the TargetN can reach all of the other nodes by; /// definition of previously being in a single SCC formed by the cycle from; /// SourceN to TargetN.; ///; /// The newly added SCCs are added *immediately* and contiguously; /// prior to the TargetN SCC and return the range covering the new SCCs in; /// the RefSCC's postorder sequence. You can directly iterate the returned; /// range to observe all of the new SCCs in postorder.; ///; /// Note that if SourceN and TargetN are in separate SCCs, the simpler; /// routine `switchTrivialInternalEdgeToRef` should be used instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:636,Integrability,rout,routine,636,"/// Insert a ref edge from one node in this RefSCC to another in this; /// RefSCC.; ///; /// This is always a trivial operation as it doesn't change any part of the; /// graph structure besides connecting the two nodes.; ///; /// Note that we don't support directly inserting internal *call* edges; /// because that could change the graph structure and requires returning; /// information about what became invalid. As a consequence, the pattern; /// should be to first insert the necessary ref edge, and then to switch it; /// to a call edge if needed and handle any invalidation that results. See; /// the \c switchInternalEdgeToCall routine for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:604,Integrability,rout,routine,604,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:823,Integrability,interface,interfaces,823,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1059,Performance,cache,cached,1059,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1119,Performance,optimiz,optimize,1119,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:535,Safety,avoid,avoid,535,"/// Insert an edge whose source is in a descendant RefSCC and target is in; /// this RefSCC.; ///; /// There must be an existing path from the target to the source in this; /// case.; ///; /// NB! This is has the potential to be a very expensive function. It; /// inherently forms a cycle in the prior RefSCC DAG and we have to merge; /// RefSCCs to resolve that cycle. But finding all of the RefSCCs which; /// participate in the cycle can in the worst case require traversing every; /// RefSCC in the graph. Every attempt is made to avoid that, but passes; /// must still exercise caution calling this routine repeatedly.; ///; /// Also note that this can only insert ref edges. In order to insert; /// a call edge, first insert a ref edge and then switch it to a call edge.; /// These are intentionally kept as separate interfaces because each step; /// of the operation invalidates a different set of data structures.; ///; /// This returns all the RefSCCs which were merged into the this RefSCC; /// (the target's). This allows callers to invalidate any cached; /// information.; ///; /// FIXME: We could possibly optimize this quite a bit for cases where the; /// caller and callee are very nearby in the graph. See comments in the; /// implementation for details, but that use case might impact users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:256,Safety,safe,safe,256,"/// Remove an edge whose source is in this RefSCC and target is *not*.; ///; /// This removes an inter-RefSCC edge. All inter-RefSCC edges originating; /// from this SCC have been fully explored by any in-flight DFS graph; /// formation, so this is always safe to call once you have the source; /// RefSCC.; ///; /// This operation does not change the cyclic structure of the graph and so; /// is very inexpensive. It may change the connectivity graph of the SCCs; /// though, so be careful calling this while iterating over them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1199,Deployability,pipeline,pipelines,1199,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1267,Deployability,update,update,1267,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1384,Integrability,rout,routine,1384,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:1186,Performance,optimiz,optimization,1186,"Removing these edges may break cycles that form this RefSCC and; /// thus this operation may change the RefSCC graph significantly. In; /// particular, this operation will re-form new RefSCCs based on the; /// remaining connectivity of the graph. The following invariants are; /// guaranteed to hold after calling this method:; ///; /// 1) If a ref-cycle remains after removal, it leaves this RefSCC intact; /// and in the graph. No new RefSCCs are built.; /// 2) Otherwise, this RefSCC will be dead after this call and no longer in; /// the graph or the postorder traversal of the call graph. Any iterator; /// pointing at this RefSCC will become invalid.; /// 3) All newly formed RefSCCs will be returned and the order of the; /// RefSCCs returned will be a valid postorder traversal of the new; /// RefSCCs.; /// 4) No RefSCC other than this RefSCC has its member set changed (this is; /// inherent in the definition of removing such an edge).; ///; /// These invariants are very important to ensure that we can build; /// optimization pipelines on top of the CGSCC pass manager which; /// intelligently update the RefSCC graph without invalidating other parts; /// of the RefSCC graph.; ///; /// Note that we provide no routine to remove a *call* edge. Instead, you; /// must first switch it to a ref edge using \c switchInternalEdgeToRef.; /// This split API is intentional as each of these two steps can invalidate; /// a different aspect of the graph structure and needs to have the; /// invalidation handled independently.; ///; /// The runtime complexity of this method is, in the worst case, O(V+E); /// where V is the number of nodes in this RefSCC and E is the number of; /// edges leaving the nodes in this RefSCC. Note that E includes both edges; /// within this RefSCC and edges from this RefSCC to child RefSCCs. Some; /// effort has been made to minimize the overhead of common cases such as; /// self-edges and edge removals which result in a spanning tree with no; /// more cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,Integrability,wrap,wrapper,18,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new call edge.; ///; /// This is trivial whenever the target is in the same SCC as the source or; /// the edge is an outgoing edge to some descendant SCC. In these cases; /// there is no change to the cyclic structure of SCCs or RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:18,Integrability,wrap,wrapper,18,"/// A convenience wrapper around the above to handle trivial cases of; /// inserting a new ref edge.; ///; /// This is trivial whenever the target is in the same RefSCC as the source; /// or the edge is an outgoing edge to some descendant RefSCC. In these; /// cases there is no change to the cyclic structure of the RefSCCs.; ///; /// To further make calling this convenient, it also handles inserting; /// already existing edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:100,Performance,cache,cached,100,"/// A post-order depth-first RefSCC iterator over the call graph.; ///; /// This iterator walks the cached post-order sequence of RefSCCs. However,; /// it trades stability for flexibility. It is restricted to a forward; /// iterator but will survive mutations which insert new RefSCCs and continue; /// to point to the same RefSCC even if it moves in the post-order sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Testability,Test,Test,4,/// Test whether a function is a known and defined library function tracked by; /// the call graph.; ///; /// Because these functions are known to LLVM they are specially modeled in; /// the call graph and even when all IR-level references have been removed; /// remain active and reachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:157,Deployability,update,update,157,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:439,Deployability,Update,Update,439,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:365,Performance,perform,performed,365,"///@{; /// \name Pre-SCC Mutation API; ///; /// These methods are only valid to call prior to forming any SCCs for this; /// call graph. They can be used to update the core node-graph during; /// a node-based inorder traversal that precedes any SCC-based traversal.; ///; /// Once you begin manipulating a call graph's SCCs, most mutation of the; /// graph must be performed via a RefSCC method. There are some exceptions; /// below.; /// Update the call graph after inserting a new edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after inserting a new edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after deleting an edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Deployability,Update,Update,4,/// Update the call graph after deleting an edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:177,Integrability,rout,routines,177,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:198,Integrability,contract,contracts,198,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:593,Integrability,rout,routine,593,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:886,Integrability,rout,routine,886,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:787,Safety,safe,safely,787,"///@}; ///@{; /// \name General Mutation API; ///; /// There are a very limited set of mutations allowed on the graph as a whole; /// once SCCs have started to be formed. These routines have strict contracts; /// but may be called at any point.; /// Remove a dead function from the call graph (typically to delete it).; ///; /// Note that the function must have an empty use list, and the call graph; /// must be up-to-date prior to calling this. That means it is by itself in; /// a maximal SCC which is by itself in a maximal RefSCC, etc. No structural; /// changes result from calling this routine other than potentially removing; /// entry points into the call graph.; ///; /// If SCC formation has begun, this function must not be part of the current; /// DFS in order to call this safely. Typically, the function will have been; /// fully visited by the DFS prior to calling this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:54,Deployability,update,updates,54,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:190,Deployability,update,updates,190,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:499,Deployability,update,updates,499,"///@}; ///@{; /// \name Static helpers for code doing updates to the call graph.; ///; /// These helpers are used to implement parts of the call graph but are also; /// useful to code doing updates or otherwise wanting to walk the IR in the; /// same patterns as when we build the call graph.; /// Recursively visits the defined functions whose address is reachable from; /// every constant in the \p Worklist.; ///; /// Doesn't recurse through any constants already in the \p Visited set, and; /// updates that set with every constant visited.; ///; /// For each defined function, calls \p Callback with that function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:75,Performance,optimiz,optimizer,75,/// Defined functions that are also known library functions which the; /// optimizer can reason about and therefore might introduce calls to out of; /// thin air.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:14,Deployability,update,update,14,/// Helper to update pointers back to the graph object during moves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates an SCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:4,Energy Efficiency,Allocate,Allocates,4,/// Allocates a RefSCC and constructs it using the graph allocator.; ///; /// The arguments are forwarded to the constructor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:11,Testability,log,logic,11,/// Common logic for building SCCs from a sequence of roots.; ///; /// This is a very generic implementation of the depth-first walk and SCC; /// formation algorithm. It uses a generic sequence of roots and generic; /// callbacks for each step. This is designed to be used to implement both; /// the RefSCC formation and SCC formation with shared logic.; ///; /// Currently this is a relatively naive implementation of Tarjan's DFS; /// algorithm to form the SCCs.; ///; /// FIXME: We should consider newer variants such as Nuutila.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:347,Testability,log,logic,347,/// Common logic for building SCCs from a sequence of roots.; ///; /// This is a very generic implementation of the depth-first walk and SCC; /// formation algorithm. It uses a generic sequence of roots and generic; /// callbacks for each step. This is designed to be used to implement both; /// the RefSCC formation and SCC formation with shared logic.; ///; /// Currently this is a relatively naive implementation of Tarjan's DFS; /// algorithm to form the SCCs.; ///; /// FIXME: We should consider newer variants such as Nuutila.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h:99,Testability,test,testing,99,/// A pass which prints the call graph to a \c raw_ostream.; ///; /// This is primarily useful for testing the analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyCallGraph.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:405,Integrability,interface,interface,405,"//===- LazyValueInfo.h - Value constraint analysis --------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for lazy computation of value constraint; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,caches,24,"/// This pass computes, caches, and vends lazy value constraint information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:16,Integrability,interface,interface,16,// Public query interface.; /// Determine whether the specified value comparison with a constant is; /// known to be true or false on the specified CFG edge. Pred is a CmpInst; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,cache,24,/// Inform the analysis cache that we have threaded an edge from; /// PredBB to OldSucc to be from PredBB to NewSucc instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:54,Performance,cache,cache,54,/// Remove information related to this value from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:24,Performance,cache,cache,24,/// Inform the analysis cache that we have erased a block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper around LazyValueInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LazyValueInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h:406,Integrability,interface,interfaces,406,"//===-- llvm/Analysis/Lint.h - LLVM IR Lint ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines lint interfaces that can be used for some validation of; // input to the system, and for checking that transformations haven't done; // something bad. In contrast to the Verifier, the Lint checker checks for; // undefined behavior or constructions with likely unintended behavior.; //; // To see what specifically is checked, look at Lint.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h:443,Security,validat,validation,443,"//===-- llvm/Analysis/Lint.h - LLVM IR Lint ---------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines lint interfaces that can be used for some validation of; // input to the system, and for checking that transformations haven't done; // something bad. In contrast to the Verifier, the Lint checker checks for; // undefined behavior or constructions with likely unintended behavior.; //; // To see what specifically is checked, look at Lint.cpp; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Lint.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:7,Performance,Load,Loads,7,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:23,Performance,load,load,23,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:428,Performance,load,load,428,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:402,Usability,simpl,simple,402,"//===- Loads.h - Local load analysis --------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares simple local analyses for load instructions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:106,Performance,perform,perform,106,/// Return true if this is always a dereferenceable pointer. If the context; /// instruction is specified perform context-sensitive analysis and return true; /// if the pointer is dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:156,Performance,perform,performs,156,/// Returns true if V is always a dereferenceable pointer with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:160,Performance,perform,performs,160,/// Returns true if V is always dereferenceable for Size byte with alignment; /// greater or equal than requested. If the context instruction is specified; /// performs context-sensitive analysis and returns true if the pointer is; /// dereferenceable at the specified instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:44,Performance,load,load,44,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:133,Performance,perform,performs,133,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:208,Performance,load,load,208,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:283,Performance,load,load,283,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:200,Safety,safe,safe,200,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:275,Safety,safe,safe,275,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:430,Security,access,accessed,430,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:420,Energy Efficiency,power,powerful,420,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:47,Performance,load,load,47,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:475,Performance,load,loaded,475,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:114,Security,access,access,114,"/// Return true if we can prove that the given load (which is assumed to be; /// within the specified loop) would access only dereferenceable memory, and; /// be properly aligned on every iteration of the specified loop regardless of; /// its placement within the loop. (i.e. does not require predication beyond; /// that required by the header itself and could be hoisted into the header; /// if desired.) This is more powerful than the variants above when the; /// address loaded from is analyzeable by SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:44,Performance,load,load,44,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:133,Performance,perform,performs,133,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:208,Performance,load,load,208,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:283,Performance,load,load,283,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:200,Safety,safe,safe,200,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:275,Safety,safe,safe,275,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:430,Security,access,accessed,430,"/// Return true if we know that executing a load from this value cannot trap.; ///; /// If DT and ScanFrom are specified this method performs context-sensitive; /// analysis and returns true if it is safe to load immediately before ScanFrom.; ///; /// If it is not obviously safe to load from the specified pointer, we do a; /// quick local scan of the basic block containing ScanFrom, to determine if; /// the address is already accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:65,Availability,avail,available,65,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:60,Performance,load,load,60,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:354,Performance,perform,performing,354,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:365,Performance,load,load,365,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:541,Performance,load,load,541,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:588,Performance,load,load,588,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:625,Performance,Load,Load,625,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:634,Performance,load,load,634,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:1119,Performance,load,load,1119,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:285,Safety,safe,safe,285,"/// Scan backwards to see if we have the value of the given load available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// Note that performing load CSE requires special care to make sure the; /// metadata is set appropriately. In particular, aliasing metadata needs; /// to be merged. (This doesn't matter for store-to-load forwarding because; /// the only relevant load gets deleted.); ///; /// \param Load The load we want to replace.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:192,Availability,avail,available,192,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:34,Energy Efficiency,efficient,efficient,34,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:202,Performance,load,load,202,/// This overload provides a more efficient implementation of; /// FindAvailableLoadedValue() for the case where we are not interested in; /// finding the closest clobbering instruction if no available load is found.; /// This overload cannot be used to scan across multiple blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:68,Availability,avail,available,68,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:383,Performance,load,load,383,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:534,Performance,load,load,534,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:611,Performance,load,load,611,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:679,Performance,load,load,679,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:1154,Performance,load,load,1154,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:288,Safety,safe,safe,288,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:429,Security,Access,AccessTy,429,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:442,Security,access,access,442,"/// Scan backwards to see if we have the value of the given pointer available; /// locally within a small number of instructions.; ///; /// You can use this function to scan across multiple blocks: after you call; /// this function, if ScanFrom points at the beginning of the block, it's safe; /// to continue scanning the predecessors.; ///; /// \param Loc The location we want the load and store to originate from.; /// \param AccessTy The access type of the pointer.; /// \param AtLeastAtomic Are we looking for at-least an atomic load/store ? In; /// case it is false, we can return an atomic or non-atomic load or store. In; /// case it is true, we need to return an atomic load or store.; /// \param ScanBB The basic block to scan.; /// \param [in,out] ScanFrom The location to start scanning from. When this; /// function returns, it points at the last instruction scanned.; /// \param MaxInstsToScan The maximum number of instructions to scan. If this; /// is zero, the whole block will be scanned.; /// \param AA Optional pointer to alias analysis, to make the scan more; /// precise.; /// \param [out] IsLoadCSE Whether the returned value is a load from the same; /// location in memory, as opposed to the value operand of a store.; ///; /// \returns The found value, or nullptr if no value is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h:407,Safety,safe,safe,407,"/// Returns true if a pointer value \p A can be replace with another pointer; /// value \B if they are deemed equal through some means (e.g. information from; /// conditions).; /// NOTE: the current implementations is incomplete and unsound. It does not; /// reject all invalid cases yet, but will be made stricter in the future. In; /// particular this means returning true means unknown if replacement is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Loads.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:405,Integrability,interface,interface,405,"//===- llvm/Analysis/LoopAccessAnalysis.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the loop memory dependence framework that; // was originally developed for the Loop Vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:435,Integrability,depend,dependence,435,"//===- llvm/Analysis/LoopAccessAnalysis.h -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface for the loop memory dependence framework that; // was originally developed for the Loop Vectorizer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:83,Security,Access,Access,83,/// Collection of parameters shared beetween the Loop Vectorizer and the; /// Loop Access Analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Performance,perform,performing,10,/// \When performing memory disambiguation checks at runtime do not; /// make more than this number of comparisons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:18,Integrability,depend,dependences,18,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:234,Integrability,depend,dependence,234,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:374,Integrability,depend,dependencies,374,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1017,Modifiability,variab,variable,1017,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:639,Safety,safe,safety,639,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:696,Safety,safe,safe,696,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:776,Safety,Safe,Safe,776,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:871,Safety,safe,safe,871,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1470,Safety,Safe,Safe,1470,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Security,access,accesses,36,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:249,Security,access,access,249,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:488,Security,access,access,488,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:611,Security,access,accesses,611,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:684,Security,access,accesses,684,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1389,Security,access,access,1389,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:1574,Security,access,accesses,1574,"/// Checks memory dependences among accesses to the same underlying; /// object to determine whether there vectorization is legal or not (and at; /// which vectorization factor).; ///; /// Note: This class will compute a conservative dependence for access to; /// different underlying pointers. Clients, such as the loop vectorizer, will; /// sometimes deal these potential dependencies by emitting runtime checks.; ///; /// We use the ScalarEvolution framework to symbolically evalutate access; /// functions pairs. Since we currently don't restructure the loop we can rely; /// on the program order of memory accesses to determine their safety.; /// At the moment we will only deem accesses as safe for:; /// * A negative constant distance assuming program order.; ///; /// Safe: tmp = a[i + 1]; OR a[i + 1] = x;; /// a[i] = tmp; y = a[i];; ///; /// The latter case is safe because later checks guarantuee that there can't; /// be a cycle through a phi node (that is, we check that ""x"" and ""y"" is not; /// the same variable: a header phi can only be an induction or a reduction, a; /// reduction can't have a memory sink, an induction can't have a memory; /// source). This is important and must not be violated (or we have to; /// resort to checking for cycles through memory).; ///; /// * A positive constant distance assuming program order that is bigger; /// than the biggest memory access.; ///; /// tmp = a[i] OR b[i] = x; /// a[i+2] = tmp y = b[i+2];; ///; /// Safe distance: 2 x sizeof(a[0]), and 2 x sizeof(b[0]), respectively.; ///; /// * Zero distances and all accesses have the same size.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:21,Integrability,depend,dependent,21,/// Set of potential dependent memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:38,Security,access,accesses,38,/// Set of potential dependent memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:44,Integrability,depend,dependence,44,/// Type to keep track of the status of the dependence check. The order of; /// the elements is important and has to be from most permissive to least; /// permissive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:47,Integrability,depend,dependences,47,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Safety,safe,safely,17,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:79,Safety,safe,safe,79,// Can vectorize safely without RT checks. All dependences are known to be; // safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:61,Integrability,depend,dependencies,61,// Can possibly vectorize with RT checks to overcome unknown dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:40,Integrability,depend,dependencies,40,// Cannot vectorize due to known unsafe dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Safety,unsafe,unsafe,33,// Cannot vectorize due to known unsafe dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Integrability,Depend,Dependece,4,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:29,Security,access,access,29,/// Dependece between memory access instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:20,Integrability,depend,dependence,20,/// The type of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,Integrability,depend,dependence,6,// No dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,Performance,load,loaded,129,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:30,Security,access,access,30,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:54,Security,access,access,54,"// At least one of the memory access instructions may access a loop; // varying object, e.g. the address of underlying object is loaded inside; // the loop, like A[B[i]]. We cannot determine direction or distance in; // those cases, and also are unable to generate any runtime checks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:78,Integrability,depend,dependences,78,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:153,Integrability,depend,dependence,153,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:277,Integrability,depend,dependences,277,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:442,Integrability,depend,dependence,442,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:165,Safety,safe,safe,165,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:373,Security,access,access,373,"// Lexically forward.; //; // FIXME: If we only have loop-independent forward dependences (e.g. a; // read and write of A[i]), LAA will locally deem the dependence ""safe""; // without querying the MemoryDepChecker. Therefore we can miss; // enumerating loop-independent forward dependences in; // getDependences. Note that as soon as there are different; // indices used to access the same array, the MemoryDepChecker *is*; // queried and the dependence list is complete.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:61,Performance,load,load,61,"// Forward, but if vectorized, is likely to prevent store-to-load; // forwarding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:63,Integrability,depend,dependent,63,"// Backward, but the distance allows a vectorization factor of dependent; // on MinDepDistBytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:34,Performance,load,load,34,"// Same, but may prevent store-to-load forwarding.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:31,Integrability,depend,dependence,31,/// Index of the source of the dependence in the InstMap vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Integrability,depend,dependence,36,/// Index of the destination of the dependence in the InstMap vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:20,Integrability,depend,dependence,20,/// The type of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:41,Integrability,depend,dependence,41,/// Return the source instruction of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:46,Integrability,depend,dependence,46,/// Return the destination instruction of the dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Integrability,Depend,Dependence,4,/// Dependence types that don't prevent vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:22,Integrability,depend,dependence,22,/// Lexically forward dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:23,Integrability,depend,dependence,23,/// Lexically backward dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:32,Integrability,depend,dependence,32,/// May be a lexically backward dependence type (includes Unknown).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:14,Integrability,depend,dependence,14,/// Print the dependence. \p Instr is used to map the instruction; /// indices to instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:86,Security,access,access,86,/// Register the location (instructions are given increasing numbers); /// of a write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:86,Security,access,access,86,/// Register the location (instructions are given increasing numbers); /// of a write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:22,Integrability,depend,dependencies,22,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:60,Safety,safe,safe,60,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:47,Security,access,accesses,47,/// Check whether the dependencies between the accesses are safe.; ///; /// Only checks sets with elements in \p CheckDeps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:14,Integrability,depend,dependence,14,/// No memory dependence was encountered that would inhibit; /// vectorization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:51,Safety,safe,safe,51,/// Return true if the number of elements that are safe to operate on; /// simultaneously is not bounded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:43,Safety,safe,safe,43,"/// Return the number of elements that are safe to operate on; /// simultaneously, multiplied by the size of the element in bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependency,27,/// In same cases when the dependency check fails we can still; /// vectorize the loop with a dynamic array access check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:108,Security,access,access,108,/// In same cases when the dependency check fails we can still; /// vectorize the loop with a dynamic array access check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:135,Availability,avail,available,135,/// Returns the memory dependences. If null is returned we exceeded; /// the MaxDependences threshold and this information is not; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:23,Integrability,depend,dependences,23,/// Returns the memory dependences. If null is returned we exceeded; /// the MaxDependences threshold and this information is not; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:106,Integrability,Depend,Dependence,106,/// The vector of memory access instructions. The indices are used as; /// instruction identifiers in the Dependence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:25,Security,access,access,25,/// The vector of memory access instructions. The indices are used as; /// instruction identifiers in the Dependence class.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:45,Security,access,access,45,"/// Return the program order indices for the access location (Ptr, IsWrite).; /// Returns an empty ArrayRef if there are no accesses for the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,"/// Return the program order indices for the access location (Ptr, IsWrite).; /// Returns an empty ArrayRef if there are no accesses for the location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:6,Integrability,wrap,wrapper,6,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:283,Integrability,depend,dependences,283,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:424,Integrability,wrap,wrap,424,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:269,Safety,avoid,avoid,269,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:394,Security,access,access,394,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:109,Usability,simpl,simplify,109,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:167,Usability,usab,usable,167,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks, and; /// applies dynamic knowledge to simplify SCEV expressions and convert them; /// to a more usable form. We need this in case assumptions about SCEV; /// expressions need to be made in order to avoid unknown dependences. For; /// example we might assume a unit stride for a pointer in order to prove; /// that a memory access is strided and doesn't wrap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:9,Security,access,access,9,"/// Maps access locations (ptr, read/write) to program order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:11,Security,access,access,11,/// Memory access instructions in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Integrability,depend,dependence,17,/// The smallest dependence distance in bytes in the loop. This may not be; /// the same as the maximum number of bytes that are safe to operate on; /// simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:129,Safety,safe,safe,129,/// The smallest dependence distance in bytes in the loop. This may not be; /// the same as the maximum number of bytes that are safe to operate on; /// simultaneously.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:62,Safety,safe,safe,62,"/// Number of elements (from consecutive iterations) that are safe to; /// operate on simultaneously, multiplied by the size of the element in bits.; /// The size of the element is taken from the memory access that is most; /// restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:203,Security,access,access,203,"/// Number of elements (from consecutive iterations) that are safe to; /// operate on simultaneously, multiplied by the size of the element in bits.; /// The size of the element is taken from the memory access that is most; /// restrictive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:29,Integrability,depend,dependence,29,/// If we see a non-constant dependence distance we can still try to; /// vectorize this loop with runtime checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:18,Integrability,depend,dependence,18,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:73,Integrability,depend,dependences,73,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:89,Safety,safe,safe,89,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:155,Safety,unsafe,unsafe,155,"/// Result of the dependence checks, indicating whether the checked; /// dependences are safe for vectorization, require RT checks or are known to; /// be unsafe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:13,Integrability,Depend,Dependences,13,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:38,Integrability,depend,dependences,38,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:115,Integrability,Depend,Dependences,115,//// True if Dependences reflects the dependences in the; //// loop. If false we exceeded MaxDependences and; //// Dependences is invalid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:11,Integrability,depend,dependences,11,/// Memory dependences collected during the analysis. Only valid if; /// RecordDependences is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:39,Integrability,depend,dependence,39,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:273,Integrability,depend,dependence,273,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:385,Integrability,depend,dependence,385,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:404,Integrability,depend,dependence,404,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:653,Integrability,depend,dependence,653,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:71,Security,access,accesses,71,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:91,Security,Access,Access,91,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:346,Security,access,accesses,346,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:456,Security,access,access,456,"/// Check whether there is a plausible dependence between the two; /// accesses.; ///; /// Access \p A must happen before \p B in program order. The two indices; /// identify the index into the program order map.; ///; /// This function checks whether there is a plausible dependence (or the; /// absence of such can't be proved) between the two accesses. If there is a; /// plausible dependence but the dependence distance is bigger than one; /// element access it records this distance in \p MinDepDistBytes (if this; /// distance is smaller than any other distance encountered so far).; /// Otherwise, this function returns true signaling a possible dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:58,Performance,load,load,58,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:140,Safety,avoid,avoid,140,/// Check whether the data dependence could prevent store-load; /// forwarding.; ///; /// \return false if we shouldn't vectorize at all or avoid larger; /// vectorization factors by limiting MinDepDistBytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Deployability,Update,Updates,4,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:24,Safety,safe,safety,24,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:64,Safety,Safe,Safe,64,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:112,Safety,Unsafe,Unsafe,112,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:161,Safety,Unsafe,Unsafe,161,/// Updates the current safety status with \p S. We can go from Safe to; /// either PossiblySafeWithRtChecks or Unsafe and from; /// PossiblySafeWithRtChecks to Unsafe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:36,Security,access,accessed,36,/// Holds the smallest byte address accessed by the pointer throughout all; /// iterations of the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:35,Security,access,accessed,35,"/// Holds the largest byte address accessed by the pointer throughout all; /// iterations of the loop, plus 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:54,Integrability,depend,dependent,54,/// Holds the id of the set of pointers that could be dependent because of a; /// shared underlying object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:17,Security,access,access,17,/// SCEV for the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:90,Energy Efficiency,reduce,reduce,90,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:48,Performance,perform,performs,48,/// Generate the checks and store it. This also performs the grouping; /// of pointers to reduce the number of memchecks necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:98,Security,access,accesses,98,/// Returns the checks that generateChecks created. They can be used to ensure; /// no read/write accesses overlap across all loop iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:160,Integrability,depend,dependencies,160,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:225,Integrability,depend,dependency,225,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:64,Security,access,access,64,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:295,Security,access,access,295,"// Returns an optional list of (pointer-difference expressions, access size); // pairs that can be used to prove that there are no vectorization-preventing; // dependencies at runtime. There are is a vectorization-preventing dependency; // if any pointer-difference is <u VF * InterleaveCount * access size. Returns; // std::nullopt if pointer-difference checks cannot be used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:180,Integrability,depend,dependecies,180,"/// Groups pointers such that a single memcheck is required; /// between two different groups. This will clear the CheckingGroups vector; /// and re-compute it. We will only group dependecies if \p UseDependencies; /// is true, otherwise we will create a separate group for each pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:105,Usability,clear,clear,105,"/// Groups pointers such that a single memcheck is required; /// between two different groups. This will clear the CheckingGroups vector; /// and re-compute it. We will only group dependecies if \p UseDependencies; /// is true, otherwise we will create a separate group for each pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:49,Security,access,access,49,"/// Try to create add a new (pointer-difference, access size) pair to; /// DiffCheck for checking groups \p CGI and \p CGJ. If pointer-difference; /// checks cannot be used for the groups, set CanUseDiffCheck to false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:128,Integrability,depend,dependencies,128,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:35,Security,access,access,35,"/// A list of (pointer-difference, access size) pairs that can be used to; /// prove that there are no vectorization-preventing dependencies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:246,Integrability,depend,dependences,246,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:303,Integrability,depend,dependences,303,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:384,Integrability,depend,dependence,384,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:518,Integrability,depend,dependences,518,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:778,Integrability,wrap,wrap,778,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:964,Integrability,depend,dependences,964,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Security,access,accesses,33,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:115,Security,access,accesses,115,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:156,Security,access,accesses,156,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:194,Security,Access,AccessAnalysis,194,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:651,Security,Access,AccessAnalysis,651,"/// Drive the analysis of memory accesses in the loop; ///; /// This class is responsible for analyzing the memory accesses of a loop. It; /// collects the accesses and then its main helper the AccessAnalysis class; /// finds and categorizes the dependences in buildDependenceSets.; ///; /// For memory dependences that can be analyzed at compile time, it determines; /// whether the dependence is part of cycle inhibiting vectorization. This work; /// is delegated to the MemoryDepChecker class.; ///; /// For memory dependences that cannot be determined at compile time, it; /// generates run-time checks to prove independence. This is done by; /// AccessAnalysis::canCheckPtrAtRT and the checks are maintained by the; /// RuntimePointerCheck class.; ///; /// If pointers can wrap or can't be expressed as affine AddRec expressions by; /// ScalarEvolution, we will generate run-time checks by emitting a; /// SCEVUnionPredicate.; ///; /// Checks for both memory dependences and the SCEV predicates contained in the; /// PSE must be emitted in order for the results of this analysis to be valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:92,Integrability,depend,dependence,92,/// Return true we can analyze the memory accesses in the loop and there are; /// no memory dependence cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:42,Security,access,accesses,42,/// Return true we can analyze the memory accesses in the loop and there are; /// no memory dependence cycles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:15,Integrability,Depend,Dependence,15,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:97,Integrability,depend,dependences,97,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Security,access,access,10,"/// If an access has a symbolic strides, this maps the pointer value to; /// the stride symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:43,Security,access,accesses,43,/// Print the information about the memory accesses in the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,"/// If the loop has memory dependence involving an invariant address, i.e. two; /// stores or a store and a load, then return true, else return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:108,Performance,load,load,108,"/// If the loop has memory dependence involving an invariant address, i.e. two; /// stores or a store and a load, then return true, else return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:37,Usability,Simpl,Simplifies,37,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:98,Usability,usab,usable,98,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:193,Usability,simpl,simplified,193,/// Used to add runtime SCEV checks. Simplifies SCEV expressions and converts; /// them to a more usable form. All SCEV expressions during the analysis; /// should be re-written (and therefore simplified) according to PSE.; /// A user of LoopAccessAnalysis will need to emit the runtime checks; /// associated with this predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,Security,access,access,19,"/// Collect memory access with loop invariant strides.; ///; /// Looks for accesses like ""a[i * StrideA]"" where ""StrideA"" is loop; /// invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:75,Security,access,accesses,75,"/// Collect memory access with loop invariant strides.; ///; /// Looks for accesses like ""a[i * StrideA]"" where ""StrideA"" is loop; /// invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:33,Integrability,depend,dependence,33,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:96,Integrability,depend,dependences,96,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:122,Integrability,depend,dependences,122,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:19,Safety,unsafe,unsafe,19,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:89,Safety,unsafe,unsafe,89,// Emits the first unsafe memory dependence in a loop.; // Emits nothing if there are no unsafe dependences; // or if the dependences were not recorded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:135,Usability,simpl,simpler,135,/// We need to check that all of the pointers in this list are disjoint; /// at runtime. Using std::unique_ptr to make using move ctor simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:15,Integrability,Depend,Dependence,15,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:97,Integrability,depend,dependences,97,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:124,Security,access,accesses,124,/// the Memory Dependence Checker which can determine the; /// loop-independent and loop-carried dependences between memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:4,Performance,Cache,Cache,4,/// Cache the result of analyzeLoop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:10,Security,access,access,10,"/// If an access has a symbolic strides, this maps the pointer value to; /// the stride symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:155,Integrability,wrap,wrap,155,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:67,Security,access,access,67,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:593,Security,access,access,593,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:621,Security,access,access,621,"/// If the pointer has a constant stride return it in units of the access type; /// size. Otherwise return std::nullopt.; ///; /// Ensure that it does not wrap in the address space, assuming the predicate; /// associated with \p PSE is true.; ///; /// If necessary this method will version the stride of the pointer according; /// to \p PtrToStride and therefore add further predicates to \p PSE.; /// The \p Assume parameter indicates if we are allowed to make additional; /// run-time assumptions.; ///; /// Note that the analysis results are defined if-and-only-if the original; /// memory access was defined. If that access was dead, or UB, then the; /// result of this function is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:194,Integrability,depend,depend,194,/// Returns the distance between the pointers \p PtrA and \p PtrB iff they are; /// compatible and it is possible to calculate the distance between them. This; /// is a simple API that does not depend on the analysis pass.; /// \param StrictCheck Ensure that the calculated distance matches the; /// type-based one after all the bitcasts removal in the provided pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:169,Usability,simpl,simple,169,/// Returns the distance between the pointers \p PtrA and \p PtrB iff they are; /// compatible and it is possible to calculate the distance between them. This; /// is a simple API that does not depend on the analysis pass.; /// \param StrictCheck Ensure that the calculated distance matches the; /// type-based one after all the bitcasts removal in the provided pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:456,Availability,mask,mask,456,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:249,Security,access,accesses,249,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:479,Security,access,accesses,479,"/// Attempt to sort the pointers in \p VL and return the sorted indices; /// in \p SortedIndices, if reordering is required.; ///; /// Returns 'true' if sorting is legal, otherwise returns 'false'.; ///; /// For example, for a given \p VL of memory accesses in program order, a[i+4],; /// a[i+0], a[i+1] and a[i+7], this function will sort the \p VL and save the; /// sorted indices in \p SortedIndices as a[i+0], a[i+1], a[i+4], a[i+7] and; /// saves the mask for actual memory accesses in program order in; /// \p SortedIndices as <1,2,0,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:113,Integrability,depend,depend,113,/// Returns true if the memory operations \p A and \p B are consecutive.; /// This is a simple API that does not depend on the analysis pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:88,Usability,simpl,simple,88,/// Returns true if the memory operations \p A and \p B are consecutive.; /// This is a simple API that does not depend on the analysis pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:8,Performance,cache,cache,8,/// The cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:27,Integrability,depend,dependence,27,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:70,Security,access,accesses,70,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h:191,Security,access,access,191,/// This analysis provides dependence information for the memory; /// accesses of a loop.; ///; /// It runs the analysis for a loop on demand. This can be initiated by; /// querying the loop access info via AM.getResult<LoopAccessAnalysis>.; /// getResult return a LoopAccessInfo object. See this class for the; /// specifics of what information is provided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAccessAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:775,Availability,avail,available,775,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:510,Deployability,pipeline,pipeline,510,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:608,Usability,simpl,simplifying,608,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:671,Usability,simpl,simplified,671,"//===- LoopAnalysisManager.h - Loop analysis management ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This header provides classes for managing per-loop analyses. These are; /// typically used as part of a loop pass pipeline over the loop nests of; /// a function.; ///; /// Loop analyses are allowed to make some simplifying assumptions:; /// 1) Loops are, where possible, in simplified form.; /// 2) Loops are *always* in LCSSA form.; /// 3) A collection of analysis results are available:; /// - LoopInfo; /// - DominatorTree; /// - ScalarEvolution; /// - AAManager; ///; /// The primary mechanism to provide these invariants is the loop pass manager,; /// but they can also be manually provided in order to reason about a loop from; /// outside of a dedicated pass manager.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:96,Availability,avail,available,96,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:172,Deployability,update,update,172,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:8,Energy Efficiency,adapt,adaptor,8,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:8,Modifiability,adapt,adaptor,8,"/// The adaptor from a function pass to a loop pass computes these analyses and; /// makes them available to the loop passes ""for free"". Each loop pass is; /// expected to update these analyses if necessary to ensure they're; /// valid after it runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:235,Deployability,integrat,integrate,235,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:206,Energy Efficiency,adapt,adaptors,206,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:235,Integrability,integrat,integrate,235,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:206,Modifiability,adapt,adaptors,206,/// The loop analysis manager.; ///; /// See the documentation for the AnalysisManager template for detail; /// documentation. This typedef serves as a convenient way to refer to this; /// construct in the adaptors and proxies used to integrate this into the larger; /// pass manager infrastructure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:201,Performance,cache,cached,201,/// A specialized result for the \c LoopAnalysisManagerFunctionProxy which; /// retains a \c LoopInfo reference.; ///; /// This allows it to collect loop objects for which analysis results may be; /// cached in the \c LoopAnalysisManager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:128,Usability,clear,clear,128,// We have to null out the analysis manager in the moved-from state; // because we are taking ownership of the responsibilty to clear the; // analysis state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:128,Usability,clear,clear,128,// We have to null out the analysis manager in the moved-from state; // because we are taking ownership of the responsibilty to clear the; // analysis state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:14,Usability,clear,cleared,14,// InnerAM is cleared in a moved from state where there is nothing to do.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:3,Usability,Clear,Clear,3,// Clear out the analysis manager if we're being destroyed -- it means we; // didn't even see an invalidate call when we got invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:4,Security,Access,Accessor,4,/// Accessor for the analysis manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:205,Performance,cache,cached,205,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:377,Performance,cache,cached,377,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h:360,Usability,clear,clear,360,"/// Handler for invalidation of the proxy for a particular function.; ///; /// If the proxy, \c LoopInfo, and associated analyses are preserved, this; /// will merely forward the invalidation event to any cached loop analysis; /// results for loops within this function.; ///; /// If the necessary loop infrastructure is not preserved, this will forcibly; /// clear all of the cached analysis results that are keyed on the \c; /// LoopInfo for this function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopAnalysisManager.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:418,Integrability,interface,interface,418,"//===- llvm/Analysis/LoopCacheAnalysis.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop cache analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:441,Performance,cache,cache,441,"//===- llvm/Analysis/LoopCacheAnalysis.h ------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop cache analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:107,Performance,cache,cache,107,/// Return true/false if the current object and the indexed reference \p Other; /// are/aren't in the same cache line of size \p CLS. Two references are in; /// the same chace line iff the distance between them in the innermost; /// dimension is less than the cache line size. Return std::nullopt if unsure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:260,Performance,cache,cache,260,/// Return true/false if the current object and the indexed reference \p Other; /// are/aren't in the same cache line of size \p CLS. Two references are in; /// the same chace line iff the distance between them in the innermost; /// dimension is less than the cache line size. Return std::nullopt if unsure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:395,Modifiability,variab,variable,395,"/// Compute the cost of the reference w.r.t. the given loop \p L when it is; /// considered in the innermost position in the loop nest.; /// The cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if:; /// + the reference stride is less than the cache line size, and; /// + the coefficient of this loop's index variable used in all other; /// subscripts is zero; /// - or otherwise equal to 'TripCount'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:330,Performance,cache,cache,330,"/// Compute the cost of the reference w.r.t. the given loop \p L when it is; /// considered in the innermost position in the loop nest.; /// The cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if:; /// + the reference stride is less than the cache line size, and; /// + the coefficient of this loop's index variable used in all other; /// subscripts is zero; /// - or otherwise equal to 'TripCount'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:30,Security,Access,AccessFn,30,/// Attempt to delinearize \p AccessFn for fixed-size arrays.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:173,Modifiability,variab,variable,173,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:251,Performance,cache,cache,251,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:212,Security,access,access,212,"/// Return true if the indexed reference is 'consecutive' in loop \p L.; /// An indexed reference is 'consecutive' if the only coefficient that uses; /// the loop induction variable is the rightmost one, and the access stride is; /// smaller than the cache line size \p CLS. Provide a valid \p Stride value; /// if the indexed reference is 'consecutive'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:62,Modifiability,variab,variable,62,/// Return true if the coefficient corresponding to induction variable of; /// loop \p L in the given \p Subscript is zero or is loop invariant in \p L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:67,Usability,simpl,simple,67,/// Verify that the given \p Subscript is 'well formed' (must be a simple add; /// recurrence).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:233,Integrability,depend,dependency,233,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:281,Integrability,depend,dependence,281,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:305,Integrability,depend,dependence,305,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:526,Performance,cache,cache,526,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:643,Performance,cache,cache,643,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:622,Security,access,access,622,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:558,Usability,Intuit,Intuitively,558,"/// A reference group represents a set of memory references that exhibit; /// temporal or spacial reuse. Two references belong to the same; /// reference group with respect to a inner loop L iff:; /// 1. they have a loop independent dependency, or; /// 2. they have a loop carried dependence with a small dependence distance; /// (e.g. less than 2) carried by the inner loop, or; /// 3. they refer to the same array, and the subscript in their innermost; /// dimension is less than or equal to 'd' (where 'd' is less than the cache; /// line size); ///; /// Intuitively a reference group represents memory references that access; /// the same cache line. Conditions 1,2 above account for temporal reuse, while; /// contition 3 accounts for spacial reuse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:845,Modifiability,variab,variable,845,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:7,Performance,Cache,CacheCost,7,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:85,Performance,cache,cache,85,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:150,Performance,cache,cache,150,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:231,Performance,cache,cache,231,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:428,Performance,cache,cache,428,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:692,Performance,cache,cache,692,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:776,Performance,cache,cache,776,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:1041,Performance,cache,cache,1041,"/// \c CacheCost represents the estimated cost of a inner loop as the number of; /// cache lines used by the memory references it contains.; /// The 'cache cost' of a loop 'L' in a loop nest 'LN' is computed as the sum of; /// the cache costs of all of its reference groups when the loop is considered; /// to be in the innermost position in the nest.; /// A reference group represents memory references that fall into the same cache; /// line. Each reference group is analysed with respect to the innermost loop in; /// a loop nest. The cost of a reference is defined as follow:; /// - one if it is loop invariant w.r.t the innermost loop,; /// - equal to the loop trip count divided by the cache line times the; /// reference stride if the reference stride is less than the cache line; /// size (CLS), and the coefficient of this loop's index variable used in all; /// other subscripts is zero (e.g. RefCost = TripCount/(CLS/RefStride)); /// - equal to the innermost loop trip count if the reference stride is greater; /// or equal to the cache line size CLS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:16,Performance,Cache,CacheCost,16,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:178,Security,access,accessed,178,/// Construct a CacheCost object for the loop nest described by \p Loops.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:13,Performance,Cache,CacheCost,13,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:164,Security,access,accessed,164,/// Create a CacheCost for the loop nest rooted by \p Root.; /// The optional parameter \p TRT can be used to specify the max. distance; /// between array elements accessed in a loop so that the elements are; /// classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:18,Performance,cache,cache,18,/// Calculate the cache footprint of each loop in the nest (when it is; /// considered to be in the innermost position).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:20,Performance,load,load,20,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:174,Performance,cache,cache,174,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:102,Security,access,accesses,102,/// Partition store/load instructions in the loop nest into reference groups.; /// Two or more memory accesses belong in the same reference group if they; /// share the same cache line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:456,Modifiability,variab,variable,456,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:211,Performance,cache,cache,211,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:583,Performance,cache,cache,583,"/// Compute the cost of a representative reference in reference group \p RG; /// when the given loop \p L is considered as the innermost loop in the nest.; /// The computed cost is an estimate for the number of cache lines used by the; /// reference group. The representative reference cost is defined as:; /// - equal to one if the reference is loop invariant, or; /// - equal to '(TripCount * stride) / cache_line_size' if (a) loop \p L's; /// induction variable is used only in the reference subscript associated; /// with loop \p L, and (b) the reference stride is less than the cache; /// line size, or; /// - TripCount otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:44,Performance,cache,cache,44,/// Sort the LoopCosts vector by decreasing cache cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:4,Performance,Cache,Cache,4,/// Cache costs for the loops in the loop nest associated with this object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:45,Security,access,accessed,45,/// The max. distance between array elements accessed in a loop so that the; /// elements are classified to have temporal reuse.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h:28,Performance,Cache,CacheCost,28,/// Printer pass for the \c CacheCost results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopCacheAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:55,Modifiability,variab,variable,55,"/// Check to see if the loop has a canonical induction variable: an integer; /// recurrence that starts at 0 and increments by one each time through the; /// loop. If so, return the phi node that corresponds to it.; ///; /// The IndVarSimplify pass transforms loops to have a canonical induction; /// variable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:301,Modifiability,variab,variable,301,"/// Check to see if the loop has a canonical induction variable: an integer; /// recurrence that starts at 0 and increments by one each time through the; /// loop. If so, return the phi node that corresponds to it.; ///; /// The IndVarSimplify pass transforms loops to have a canonical induction; /// variable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:83,Modifiability,variab,variable,83,"/// Below are some utilities to get the loop guard, loop bounds and induction; /// variable, and to check if a given phinode is an auxiliary induction; /// variable, if the loop is guarded, and if the loop is canonical.; ///; /// Here is an example:; /// \code; /// for (int i = lb; i < ub; i+=step); /// <loop body>; /// --- pseudo LLVMIR ---; /// beforeloop:; /// guardcmp = (lb < ub); /// if (guardcmp) goto preheader; else goto afterloop; /// preheader:; /// loop:; /// i_1 = phi[{lb, preheader}, {i_2, latch}]; /// <loop body>; /// i_2 = i_1 + step; /// latch:; /// cmp = (i_2 < ub); /// if (cmp) goto loop; /// exit:; /// afterloop:; /// \endcode; ///; /// - getBounds; /// - getInitialIVValue --> lb; /// - getStepInst --> i_2 = i_1 + step; /// - getStepValue --> step; /// - getFinalIVValue --> ub; /// - getCanonicalPredicate --> '<'; /// - getDirection --> Increasing; ///; /// - getInductionVariable --> i_1; /// - isAuxiliaryInductionVariable(x) --> true if x == i_1; /// - getLoopGuardBranch(); /// --> `if (guardcmp) goto preheader; else goto afterloop`; /// - isGuarded() --> true; /// - isCanonical --> false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:156,Modifiability,variab,variable,156,"/// Below are some utilities to get the loop guard, loop bounds and induction; /// variable, and to check if a given phinode is an auxiliary induction; /// variable, if the loop is guarded, and if the loop is canonical.; ///; /// Here is an example:; /// \code; /// for (int i = lb; i < ub; i+=step); /// <loop body>; /// --- pseudo LLVMIR ---; /// beforeloop:; /// guardcmp = (lb < ub); /// if (guardcmp) goto preheader; else goto afterloop; /// preheader:; /// loop:; /// i_1 = phi[{lb, preheader}, {i_2, latch}]; /// <loop body>; /// i_2 = i_1 + step; /// latch:; /// cmp = (i_2 < ub); /// if (cmp) goto loop; /// exit:; /// afterloop:; /// \endcode; ///; /// - getBounds; /// - getInitialIVValue --> lb; /// - getStepInst --> i_2 = i_1 + step; /// - getStepValue --> step; /// - getFinalIVValue --> ub; /// - getCanonicalPredicate --> '<'; /// - getDirection --> Increasing; ///; /// - getInductionVariable --> i_1; /// - isAuxiliaryInductionVariable(x) --> true if x == i_1; /// - getLoopGuardBranch(); /// --> `if (guardcmp) goto preheader; else goto afterloop`; /// - isGuarded() --> true; /// - isCanonical --> false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:79,Modifiability,variab,variable,79,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:130,Modifiability,variab,variable,130,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:197,Modifiability,variab,variable,197,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:259,Modifiability,variab,variable,259,/// Return the LoopBounds object if; /// - the given \p IndVar is an induction variable; /// - the initial value of the induction variable can be found; /// - the step instruction of the induction variable can be found; /// - the final value of the induction variable can be found; ///; /// Else std::nullopt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:48,Modifiability,variab,variable,48,/// Get the initial value of the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:29,Deployability,update,updates,29,/// Get the instruction that updates the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:56,Modifiability,variab,variable,56,/// Get the instruction that updates the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:55,Deployability,update,updated,55,/// Get the step that the loop induction variable gets updated by in each; /// loop iteration. Return nullptr if not found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:41,Modifiability,variab,variable,41,/// Get the step that the loop induction variable gets updated by in each; /// loop iteration. Return nullptr if not found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:46,Modifiability,variab,variable,46,/// Get the final value of the loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:562,Safety,safe,safe,562,"/// Return the canonical predicate for the latch compare instruction, if; /// able to be calcuated. Else BAD_ICMP_PREDICATE.; ///; /// A predicate is considered as canonical if requirements below are all; /// satisfied:; /// 1. The first successor of the latch branch is the loop header; /// If not, inverse the predicate.; /// 2. One of the operands of the latch comparison is StepInst; /// If not, and; /// - if the current calcuated predicate is not ne or eq, flip the; /// predicate.; /// - else if the loop is increasing, return slt; /// (notice that it is safe to change from ne or eq to sign compare); /// - else if the loop is decreasing, return sgt; /// (notice that it is safe to change from ne or eq to sign compare); ///; /// Here is an example when both (1) and (2) are not satisfied:; /// \code; /// loop.header:; /// %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]; /// %inc = add %iv, %step; /// %cmp = slt %iv, %finaliv; /// br %cmp, %loop.exit, %loop.header; /// loop.exit:; /// \endcode; /// - The second successor of the latch branch is the loop header instead; /// of the first successor (slt -> sge); /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv); /// instead of the StepInst (%inc) (sge -> sgt); ///; /// The predicate would be sgt if both (1) and (2) are satisfied.; /// getCanonicalPredicate() returns sgt for this example.; /// Note: The IR is not changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:682,Safety,safe,safe,682,"/// Return the canonical predicate for the latch compare instruction, if; /// able to be calcuated. Else BAD_ICMP_PREDICATE.; ///; /// A predicate is considered as canonical if requirements below are all; /// satisfied:; /// 1. The first successor of the latch branch is the loop header; /// If not, inverse the predicate.; /// 2. One of the operands of the latch comparison is StepInst; /// If not, and; /// - if the current calcuated predicate is not ne or eq, flip the; /// predicate.; /// - else if the loop is increasing, return slt; /// (notice that it is safe to change from ne or eq to sign compare); /// - else if the loop is decreasing, return sgt; /// (notice that it is safe to change from ne or eq to sign compare); ///; /// Here is an example when both (1) and (2) are not satisfied:; /// \code; /// loop.header:; /// %iv = phi [%initialiv, %loop.preheader], [%inc, %loop.header]; /// %inc = add %iv, %step; /// %cmp = slt %iv, %finaliv; /// br %cmp, %loop.exit, %loop.header; /// loop.exit:; /// \endcode; /// - The second successor of the latch branch is the loop header instead; /// of the first successor (slt -> sge); /// - The first operand of the latch comparison (%cmp) is the IndVar (%iv); /// instead of the StepInst (%inc) (sge -> sgt); ///; /// The predicate would be sgt if both (1) and (2) are satisfied.; /// getCanonicalPredicate() returns sgt for this example.; /// Note: The IR is not changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:43,Modifiability,variab,variable,43,// The initial value of the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:24,Deployability,update,updates,24,// The instruction that updates the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:51,Modifiability,variab,variable,51,// The instruction that updates the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:51,Deployability,update,updated,51,// The value that the loop induction variable gets updated by in each loop; // iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:37,Modifiability,variab,variable,37,// The value that the loop induction variable gets updated by in each loop; // iteration,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:41,Modifiability,variab,variable,41,// The final value of the loop induction variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:30,Modifiability,variab,variable,30,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:126,Modifiability,variab,variable,126,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:164,Modifiability,variab,variable,164,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:297,Modifiability,variab,variable,297,"/// Return the loop induction variable if found, else return nullptr.; /// An instruction is considered as the loop induction variable if; /// - it is an induction variable of the loop; and; /// - it is used to determine the condition of the branch in the loop latch; ///; /// Note: the induction variable doesn't need to be canonical, i.e. starts at; /// zero and increments by one each time through the loop (but it can be).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:61,Modifiability,variab,variable,61,/// Get the loop induction descriptor for the loop induction variable. Return; /// true if the loop induction variable is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:110,Modifiability,variab,variable,110,/// Get the loop induction descriptor for the loop induction variable. Return; /// true if the loop induction variable is found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:266,Modifiability,variab,variable,266,/// Return true if the given PHINode \p AuxIndVar is; /// - in the loop header; /// - not used outside of the loop; /// - incremented by a loop invariant step for each loop iteration; /// - step instruction opcode should be add or sub; /// Note: auxiliary induction variable is not required to be used in the; /// conditional branch in the loop latch. (but it can be),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:87,Usability,simpl,simplified,87,"/// Return the loop guard branch, if it exists.; ///; /// This currently only works on simplified loop, as it requires a preheader; /// and a latch to identify the guard. It will work on loops of the form:; /// \code; /// GuardBB:; /// br cond1, Preheader, ExitSucc <== GuardBranch; /// Preheader:; /// br Header; /// Header:; /// ...; /// br Latch; /// Latch:; /// br cond2, Header, ExitBlock; /// ExitBlock:; /// br ExitSucc; /// ExitSucc:; /// \endcode",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:42,Usability,simpl,simplify,42,"/// Return true iff the loop is; /// - in simplify rotated form, and; /// - guarded by a loop guard branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:38,Modifiability,variab,variable,38,/// Return true if the loop induction variable starts at zero and increments; /// by one each time through the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:36,Safety,safe,safe,36,/// Return true if the loop body is safe to clone in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:112,Integrability,depend,dependencies,112,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:192,Integrability,depend,dependency,192,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:500,Integrability,depend,dependencies,500,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:664,Performance,concurren,concurrent,664,"/// Returns true if the loop is annotated parallel.; ///; /// A parallel loop can be assumed to not contain any dependencies between; /// iterations by the compiler. That is, any loop-carried dependency checking; /// can be skipped completely when parallelizing the loop on the target; /// machine. Thus, if the parallel loop information originates from the; /// programmer, e.g. via the OpenMP parallel for pragma, it is the; /// programmer's responsibility to ensure there are no loop-carried; /// dependencies. The final execution order of the instructions across; /// iterations is not guaranteed, thus, the end result might or might not; /// implement actual concurrent execution of instructions across multiple; /// iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:67,Deployability,Update,Update,67,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:134,Deployability,update,updates,134,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:352,Deployability,release,released,352,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:22,Integrability,interface,interface,22,"// Most of the public interface is provided via LoopInfoBase.; /// Update LoopInfo after removing the last backedge from a loop. This updates; /// the loop forest and parent loops for each block so that \c L is no longer; /// referenced, but does not actually delete \c L immediately. The pointer; /// will remain valid until this LoopInfo's memory is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:59,Safety,safe,safely,59,// If the instruction is not defined in a loop then it can safely replace; // anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:84,Safety,avoid,avoid,84,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:98,Security,hash,hashtable,98,// Movement within the same loop does not break LCSSA (the equality check is; // to avoid doing a hashtable lookup in case of intra-block movement).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:95,Usability,simpl,simply,95,// This would need adjustment if we allow Inst to be a phi node -- the; // new use block won't simply be NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c LoopInfo for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:48,Security,access,access,48,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:72,Security,Access,Access,72,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h:403,Security,access,access,403,/// Return whether an MDNode might represent an access group.; ///; /// Access group metadata nodes have to be distinct and empty. Being; /// always-empty ensures that it never needs to be changed (which -- because; /// MDNodes are designed immutable -- would require creating a new MDNode). Note; /// that this is not a sufficient condition: not every distinct and empty NDNode; /// is representing an access group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:549,Energy Efficiency,efficient,efficient,549,"//===--------- LoopIterator.h - Iterate over loop blocks --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This file defines iterators to visit the basic blocks within a loop.; //; // These iterators currently visit blocks within subloops as well.; // Unfortunately we have no efficient way of summarizing loop exits which would; // allow skipping subloops during traversal.; //; // If you want to visit all blocks in a loop and don't need an ordered traveral,; // use Loop::block_begin() instead.; //; // This is intentionally designed to work with ill-formed loops in which the; // backedge has been deleted. The only prerequisite is that all blocks; // contained within the loop according to the most recent LoopInfo analysis are; // reachable from the loop header.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:8,Integrability,wrap,wraps,8,"// This wraps a const Loop * into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:21,Performance,cache,cached,21,/// Iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:29,Performance,cache,cached,29,/// Reverse iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper class to LoopBlocksDFS that provides a standard begin()/end(); /// interface for the DFS reverse post-order traversal of blocks in a loop body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:79,Integrability,interface,interface,79,/// Wrapper class to LoopBlocksDFS that provides a standard begin()/end(); /// interface for the DFS reverse post-order traversal of blocks in a loop body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:29,Performance,cache,cached,29,/// Reverse iterate over the cached postorder blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h:14,Integrability,interface,interface,14,"// po_ext_end interface requires a basic block, but ignores its value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h:418,Integrability,interface,interface,418,"//===- llvm/Analysis/LoopNestAnalysis.h -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file defines the interface for the loop nest analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h:53,Usability,simpl,simplify,53,/// Return true if all loops in the loop nest are in simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopNestAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:426,Performance,optimiz,optimization,426,"//===- LoopPass.h - LoopPass class ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines LoopPass class. All loop optimization; // and transformation passes are derived from LoopPass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:68,Performance,perform,perform,68,// runOnLoop - This method should be implemented by the subclass to perform; // whatever action is necessary for the specified Loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:72,Availability,avail,available,72,"// Check if this pass is suitable for the current LPPassManager, if; // available. This pass P is not suitable for a LPPassManager if P; // is not preserving higher level analysis info used by other; // LPPassManager passes. In such case, pop LPPassManager from the; // stack. This will force assignPassManager() to create new; // LPPassManger as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:122,Performance,Optimiz,OptimizeNone,122,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:155,Performance,optimiz,optimization,155,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when Attribute::OptimizeNone is set or when; /// optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:36,Energy Efficiency,schedul,scheduled,36,"/// run - Execute all of the passes scheduled for execution. Keep track of; /// whether any of the passes modifies the module, and if so, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h:32,Performance,queue,queue,32,// Add a new loop into the loop queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:563,Performance,optimiz,optimizations,563,"//===- llvm/Analysis/LoopUnrollAnalyzer.h - Loop Unroll Analyzer-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:446,Safety,predict,predicting,446,"//===- llvm/Analysis/LoopUnrollAnalyzer.h - Loop Unroll Analyzer-*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements UnrolledInstAnalyzer class. It's used for predicting; // potential effects that loop unrolling might have, such as enabling constant; // propagation and other optimizations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:48,Performance,optimiz,optimization,48,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:158,Performance,load,loads,158,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:262,Usability,simpl,simplifications,262,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:509,Usability,simpl,simplified,509,"// This class is used to get an estimate of the optimization effects that we; // could get from complete loop unrolling. It comes from the fact that some; // loads might be replaced with concrete constant values and that could trigger; // a chain of instruction simplifications.; //; // E.g. we might have:; // int a[] = {0, 1, 0};; // v = 0;; // for (i = 0; i < 3; i ++); // v += b[i]*a[i];; // If we completely unroll the loop, we would get:; // v = b[0]*a[0] + b[1]*a[1] + b[2]*a[2]; // Which then will be simplified to:; // v = b[0]* 0 + b[1]* 1 + b[2]* 0; // And finally:; // v = b[1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:9,Security,access,access,9,// Allow access to the initial visit method.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:6,Performance,cache,cache,6,"/// A cache of pointer bases and constant-folded offsets corresponding; /// to GEP (or derived from GEP) instructions.; ///; /// In order to find the base pointer one needs to perform non-trivial; /// traversal of the corresponding SCEV expression, so it's good to have the; /// results saved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:176,Performance,perform,perform,176,"/// A cache of pointer bases and constant-folded offsets corresponding; /// to GEP (or derived from GEP) instructions.; ///; /// In order to find the base pointer one needs to perform non-trivial; /// traversal of the corresponding SCEV expression, so it's good to have the; /// results saved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:198,Performance,load,loads,198,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:84,Usability,simpl,simplified,84,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h:294,Usability,simpl,simplifications,294,"/// While we walk the loop instructions, we build up and maintain a mapping; /// of simplified values specific to this iteration. The idea is to propagate; /// any special information we have about loads that can be replaced with; /// constants after complete unrolling, and account for likely simplifications; /// post-unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/LoopUnrollAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:451,Energy Efficiency,allocate,allocate,451,"//==- llvm/Analysis/MemoryBuiltins.h - Calls to memory builtins --*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions identifies calls to builtin functions that allocate; // or free memory.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates or reallocates memory (either malloc, calloc, realloc, or strdup; /// like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory via new.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,/// Tests if a value is a call or invoke to a library function that; /// allocates memory similar to malloc or calloc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:73,Energy Efficiency,allocate,allocates,73,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a value is a call or invoke to a library function that; /// allocates memory (either malloc, calloc, or strdup like).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:4,Testability,Test,Tests,4,"/// Tests if a function is a call or invoke to a library function that; /// reallocates memory (e.g., realloc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:386,Energy Efficiency,allocate,allocated,386,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:333,Integrability,rout,routine,333,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:505,Integrability,depend,dependent,505,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:725,Integrability,rout,routines,725,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:465,Performance,optimiz,optimization,465,"//===----------------------------------------------------------------------===//; // Properties of allocation functions; //; /// Return true if this is a call to an allocation function that does not have; /// side effects that we are required to preserve beyond the effect of; /// allocating a new object.; /// Ex: If our allocation routine has a counter for the number of objects; /// allocated, and the program prints it on exit, can the value change due; /// to optimization? Answer is highly language dependent.; /// Note: *Removable* really does mean removable; it does not mean observable.; /// A language (e.g. C++) can allow removing allocations without allowing; /// insertion or speculative execution of allocation routines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:97,Modifiability,variab,variables,97,"/// Whether to round the result up to the alignment of allocas, byval; /// arguments, and global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h:106,Availability,failure,failure,106,"/// Try to turn a call to \@llvm.objectsize into an integer value of the given; /// Type. Returns null on failure. If MustSucceed is true, this function will; /// not return null, and may return conservative values governed by the second; /// argument of the call to objectsize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryBuiltins.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:13,Integrability,depend,dependence,13,/// A memory dependence query can return one of three different answers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:14,Integrability,depend,dependence,14,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:362,Performance,Load,Loads,362,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:411,Performance,Load,Loads,411,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:463,Performance,load,loads,463,"/// This is a dependence on the specified instruction which clobbers the; /// desired value. The pointer member of the MemDepResult pair holds the; /// instruction that clobbers the memory. For example, this occurs when we; /// see a may-aliased store to the memory location we care about.; ///; /// There are several cases that may be interesting here:; /// 1. Loads are clobbered by may-alias stores.; /// 2. Loads are considered clobbered by partially-aliased loads. The; /// client may choose to analyze deeper into these cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:14,Integrability,depend,dependence,14,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:281,Integrability,depend,dependence,281,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:809,Integrability,Depend,Dependence,809,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:263,Performance,load,load,263,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:308,Performance,load,load,308,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:330,Performance,load,loaded,330,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:619,Performance,load,loads,619,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:701,Performance,load,load,701,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:709,Performance,load,loading,709,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:1053,Performance,load,loads,1053,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:972,Security,validat,validation,972,"/// This is a dependence on the specified instruction which defines or; /// produces the desired memory location. The pointer member of the; /// MemDepResult pair holds the instruction that defines the memory.; ///; /// Cases of interest:; /// 1. This could be a load or store for dependence queries on; /// load/store. The value loaded or stored is the produced value.; /// Note that the pointer operand may be different than that of the; /// queried pointer due to must aliases and phi translation. Note; /// that the def may not be the same type as the query, the pointers; /// may just be must aliases.; /// 2. For loads and stores, this could be an allocation instruction. In; /// this case, the load is loading an undef value or a store is the; /// first store to (that part of) the allocation.; /// 3. Dependence queries on calls return Def only when they are readonly; /// calls or memory use intrinsics with identical callees and no; /// intervening clobbers. No validation is done that the operands to; /// the calls are the same.; /// 4. For loads and stores, this could be a select instruction that; /// defines pointer to this memory location. In this case, users can; /// find non-clobbered Defs for both select values that are reaching; // the desired memory location (there is still a guarantee that there; // are no clobbers between analyzed memory location and select).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:54,Integrability,depend,dependency,54,/// This marker indicates that the query has no known dependency in the; /// specified block.; ///; /// More detailed state info is encoded in the upper part of the pair (i.e.; /// the Instruction*),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:48,Integrability,depend,dependency,48,"/// This marker indicates that the query has no dependency in the specified; /// block.; ///; /// To find out more, the client should query other predecessor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:48,Integrability,depend,dependency,48,/// This marker indicates that the query has no dependency in the specified; /// function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:41,Integrability,depend,dependency,41,/// This marker indicates that the query dependency is unknown.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:86,Integrability,depend,dependency,86,/// Tests if this MemDepResult represents a query that is an instruction; /// clobber dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is an instruction; /// clobber dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:89,Integrability,depend,dependency,89,/// Tests if this MemDepResult represents a query that is an instruction; /// definition dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is an instruction; /// definition dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a valid local query (Clobber/Def).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,"/// Tests if this MemDepResult represents a query that is transparent to the; /// start of the block, but where a non-local hasn't been done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query that is transparent to the; /// start of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this MemDepResult represents a query which cannot and/or will; /// not be computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:24,Integrability,depend,dependency,24,"/// If this is a normal dependency, returns the instruction that is depended; /// on. Otherwise, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:68,Integrability,depend,depended,68,"/// If this is a normal dependency, returns the instruction that is depended; /// on. Otherwise, returns null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Testability,Test,Tests,4,/// Tests if this is a MemDepResult in its dirty/invalid. state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:44,Performance,cache,cache,44,/// This is an entry in the NonLocalDepInfo cache.; ///; /// For each BasicBlock (the BB entry) it keeps a MemDepResult.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:37,Integrability,depend,dependence,37,/// This is a result from a NonLocal dependence query.; ///; /// For each BasicBlock (the BB entry) it keeps a MemDepResult and the; /// (potentially phi translated) address that was live in the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:216,Availability,avail,available,216,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:400,Integrability,depend,dependence,400,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:296,Performance,cache,cached,296,/// Returns the address of this pointer in this block.; ///; /// This can be different than the address queried for the non-local result; /// because of phi translation. This returns null if the address was not; /// available in a block (i.e. because phi translation failed) or if this is; /// a cached result and that address was deleted.; ///; /// The address is always null for a non-local 'call' dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:29,Integrability,interface,interface,29,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:153,Integrability,depend,dependency,153,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:668,Integrability,depend,dependence,668,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:353,Performance,load,load,353,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:414,Performance,load,load,414,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:570,Performance,load,loads,570,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:621,Performance,load,load,621,"/// Provides a lazy, caching interface for making common memory aliasing; /// information queries, backed by LLVM's alias analysis passes.; ///; /// The dependency information returned is somewhat unusual, but is pragmatic.; /// If queried about a store or call that might modify memory, the analysis; /// will return the instruction[s] that may either load from that memory or; /// store to it. If queried with a load or call that can never modify memory,; /// the analysis will return calls and stores that might modify the pointer,; /// but generally does not return loads unless a) they are volatile, or; /// b) they load from *must-aliased* pointers. Returning a dependence on; /// must-alias'd pointers instead of all pointers interacts well with the; /// internal caching mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:36,Integrability,depend,dependency,36,// A map from instructions to their dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:55,Integrability,depend,dependence,55,"/// A pair<Value*, bool> where the bool is true if the dependence is a read; /// only dependence, false if read/write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:86,Integrability,depend,dependence,86,"/// A pair<Value*, bool> where the bool is true if the dependence is a read; /// only dependence, false if read/write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:98,Performance,cache,cache,98,"/// This pair is used when caching information for a block.; ///; /// If the pointer is null, the cache value is not a full query that starts; /// at the specified block. If non-null, the bool indicates whether or not; /// the contents of the block was skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:60,Performance,load,load,60,"/// This record is the information kept for each (value, is load) pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:145,Integrability,depend,dependencies,145,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Cache,Cache,4,/// Cache storing single nonlocal def for the instruction.; /// It is set when nonlocal def would be found in function returning only; /// local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:24,Performance,cache,cached,24,"/// This map stores the cached results of doing a pointer lookup at the; /// bottom of a block.; ///; /// The key of this map is the pointer+isload bit, the value is a list of; /// <bb->result> mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:54,Integrability,depend,dependencies,54,// A map from instructions to their non-local pointer dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:45,Performance,cache,cached,45,/// This is the instruction we keep for each cached access that we have for; /// an instruction.; ///; /// The pointer is an owning pointer and the bool indicates whether we have; /// any dirty bits in the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:52,Security,access,access,52,/// This is the instruction we keep for each cached access that we have for; /// an instruction.; ///; /// The pointer is an owning pointer and the bool indicates whether we have; /// any dirty bits in the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:46,Integrability,depend,dependencies,46,// A map from instructions to their non-local dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:26,Integrability,depend,dependencies,26,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:46,Integrability,depend,dependees,46,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:113,Performance,cache,cache,113,// A reverse mapping from dependencies to the dependees. This is; // used when removing instructions to keep the cache coherent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:26,Integrability,depend,dependencies,26,// A reverse mapping from dependencies to the non-local dependees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:56,Integrability,depend,dependees,56,// A reverse mapping from dependencies to the non-local dependees.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:38,Performance,cache,cache,38,"/// Current AA implementation, just a cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:15,Integrability,depend,dependant,15,/// Offsets to dependant clobber loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:33,Performance,load,loads,33,/// Offsets to dependant clobber loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:56,Integrability,depend,depends,56,/// Returns the instruction on which a memory operation depends.; ///; /// See the class comment for more details. It is illegal to call this on; /// non-memory instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:19,Integrability,depend,dependency,19,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:326,Integrability,depend,dependency,326,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Perform,Perform,4,"/// Perform a full dependency query for the specified call, returning the set; /// of blocks that the value is potentially live across.; ///; /// The returned set of results will include a ""NonLocal"" result for all; /// blocks where the value is live across.; ///; /// This method assumes the instruction returns a ""NonLocal"" dependency; /// within its own block.; ///; /// This returns a reference to an internal data structure that may be; /// invalidated on the next non-local query or when an instruction is; /// removed. Clients must copy this data if they want it around longer than; /// that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:19,Integrability,depend,dependency,19,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:238,Integrability,depend,dependencies,238,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:425,Integrability,depend,dependency,425,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Performance,Perform,Perform,4,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:43,Security,access,access,43,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:283,Usability,usab,usable,283,"/// Perform a full dependency query for an access to the QueryInst's; /// specified memory location, returning the set of instructions that either; /// define or clobber the value.; ///; /// Warning: For a volatile query instruction, the dependencies will be; /// accurate, and thus usable for reordering, but it is never legal to; /// remove the query instruction.; ///; /// This method assumes the pointer has a ""NonLocal"" dependency within; /// QueryInst's parent basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:36,Integrability,depend,dependence,36,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:75,Integrability,depend,dependence,75,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:118,Integrability,depend,depended,118,"/// Removes an instruction from the dependence analysis, updating the; /// dependence of instructions that previously depended on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:314,Availability,avail,available,314,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:16,Performance,cache,cached,16,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:349,Performance,cache,cached,349,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:183,Safety,detect,detects,183,"/// Invalidates cached information about the specified pointer, because it; /// may be too conservative in memdep.; ///; /// This is an optional call that can be used when the client detects an; /// equivalence between the pointer and some other value and replaces the; /// other value with ptr. This can make Ptr available in more places that; /// cached info does not necessarily keep.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Usability,Clear,Clears,4,"/// Clears the PredIteratorCache info.; ///; /// This needs to be done when the CFG changes, e.g., due to splitting; /// critical edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:55,Integrability,depend,depends,55,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:98,Integrability,rout,routine,98,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:183,Integrability,rout,routine,183,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:533,Integrability,depend,dependency,533,"/// Returns the instruction on which a memory location depends.; ///; /// If isLoad is true, this routine ignores may-aliases with read-only; /// operations. If isLoad is false, this routine ignores may-aliases; /// with reads from read-only locations. If possible, pass the query; /// instruction as well; this function may take advantage of the metadata; /// annotated to the query instruction to refine the result. \p Limit; /// can be used to set the maximum number of instructions that will be; /// examined to find the pointer dependency. On return, it will be set to; /// the number of instructions left to examine. If a null pointer is passed; /// in, the limit will default to the value of -memdep-block-scan-limit.; ///; /// Note that this is an uncached query, and thus may be inefficient.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:34,Performance,load,loads,34,"/// This analysis looks for other loads and stores with invariant.group; /// metadata and the same pointer operand. Returns Unknown if it does not; /// find anything, and Def if it can be assumed that 2 instructions load or; /// store the same value and NonLocal which indicate that non-local Def was; /// found, which can be retrieved by calling getNonLocalPointerDependency; /// with the same queried instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:216,Performance,load,load,216,"/// This analysis looks for other loads and stores with invariant.group; /// metadata and the same pointer operand. Returns Unknown if it does not; /// find anything, and Def if it can be assumed that 2 instructions load or; /// store the same value and NonLocal which indicate that non-local Def was; /// found, which can be retrieved by calling getNonLocalPointerDependency; /// with the same queried instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:4,Deployability,Release,Release,4,/// Release memory in caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:22,Performance,cache,caches,22,/// Release memory in caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:33,Integrability,depend,dependent,33,/// Return the clobber offset to dependent instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:6,Integrability,wrap,wrapper,6,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h:61,Security,expose,exposes,61,/// A wrapper analysis pass for the legacy pass manager that exposes a \c; /// MemoryDepnedenceResults instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryDependenceAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:568,Modifiability,layers,layers,568,"//===- MemoryLocation.h - Memory location descriptions ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file provides utility analysis objects describing memory locations.; /// These are used both by the Alias Analysis infrastructure and more; /// specialized memory analysis layers.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1175,Performance,Scalab,Scalable,1175,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1216,Performance,Scalab,Scalable,1216,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:1277,Performance,Scalab,Scalable,1277,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:44,Testability,Log,Logically,44,"// Represents the size of a MemoryLocation. Logically, it's an; // std::optional<uint63_t> that also carries a bit to represent whether the; // integer it contains, N, is 'precise'. Precise, in this context, means that we; // know that the area of storage referenced by the given MemoryLocation must be; // precisely N bytes. An imprecise value is formed as the union of two or more; // precise values, and can conservatively represent all of the values unioned; // into it. Importantly, imprecise values are an *upper-bound* on the size of a; // MemoryLocation.; //; // Concretely, a precise MemoryLocation is (%p, 4) in; // store i32 0, i32* %p; //; // Since we know that %p must be at least 4 bytes large at this point.; // Otherwise, we have UB. An example of an imprecise MemoryLocation is (%p, 4); // at the memcpy in; //; // %n = select i1 %foo, i64 1, i64 4; // call void @llvm.memcpy.p0i8.p0i8.i64(i8* %p, i8* %baz, i64 %n, i32 1,; // i1 false); //; // ...Since we'll copy *up to* 4 bytes into %p, but we can't guarantee that; // we'll ever actually do so.; //; // If asked to represent a pathologically large value, this will degrade to; // std::nullopt.; // Store Scalable information in bit 62 of Value. Scalable information is; // required to do Alias Analysis on Scalable quantities",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:14,Performance,scalab,scalable,14,// Create non-scalable LocationSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:2,Performance,Scalab,Scalable,2,/*Scalable*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:12,Security,access,accesses,12,/// Whether accesses before the base pointer are possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:76,Availability,reliab,reliably,76,// Returns an opaque value that represents this LocationSize. Cannot be; // reliably converted back into a LocationSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:383,Integrability,interface,interface,383,"/// Representation for a specific memory location.; ///; /// This abstraction can be used to represent a specific location in memory.; /// The goal of the location is to represent enough information to describe; /// abstract aliasing, modification, and reference behaviors of whatever; /// value(s) are stored in memory at the particular location.; ///; /// The primary user of this interface is LLVM's Alias Analysis, but other; /// memory analyses such as MemoryDependence can use it as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:31,Security,access,access,31,"/// Return a location that may access any location after Ptr, while remaining; /// within the underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h:31,Security,access,access,31,"/// Return a location that may access any location before or after Ptr, while; /// remaining within the underlying object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryLocation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:243,Availability,down,down,243,"/// Add a call stack context with the given allocation type to the Trie.; /// The context is represented by the list of stack ids (computed during; /// matching via a debug location hash), expected to be in order from the; /// allocation call down to the bottom of the call stack (i.e. callee to; /// caller order).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:182,Security,hash,hash,182,"/// Add a call stack context with the given allocation type to the Trie.; /// The context is represented by the list of stack ids (computed during; /// matching via a debug location hash), expected to be in order from the; /// allocation call down to the bottom of the call stack (i.e. callee to; /// caller order).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:332,Performance,optimiz,optimization,332,"/// Build and attach the minimal necessary MIB metadata. If the alloc has a; /// single allocation type, add a function attribute instead. The reason for; /// adding an attribute in this case is that it matches how the behavior for; /// allocation calls will be communicated to lib call simplification after; /// cloning or another optimization to distinguish the allocation types,; /// which is lower overhead and more direct than maintaining this metadata.; /// Returns true if memprof metadata attached, false if not (attribute added).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:287,Usability,simpl,simplification,287,"/// Build and attach the minimal necessary MIB metadata. If the alloc has a; /// single allocation type, add a function attribute instead. The reason for; /// adding an attribute in this case is that it matches how the behavior for; /// allocation calls will be communicated to lib call simplification after; /// cloning or another optimization to distinguish the allocation types,; /// which is lower overhead and more direct than maintaining this metadata.; /// Returns true if memprof metadata attached, false if not (attribute added).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h:187,Usability,simpl,simplifies,187,"/// Helper class to iterate through stack ids in both metadata (memprof MIB and; /// callsite) and the corresponding ThinLTO summary data structures; /// (CallsiteInfo and MIBInfo). This simplifies implementation of client code; /// which doesn't need to worry about whether we are operating with IR (Regular; /// LTO), or summary (ThinLTO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemoryProfileInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:416,Integrability,interface,interface,416,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:617,Performance,load,loads,617,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1219,Performance,load,load,1219,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1251,Performance,load,load,1251,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1756,Performance,load,load,1756,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1808,Performance,load,load,1808,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:1955,Performance,load,load,1955,"e/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2835,Performance,optimiz,optimized,2835," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2867,Performance,optimiz,optimized,2867," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:2950,Performance,optimiz,optimized,2950," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3127,Performance,optimiz,optimized,3127," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3207,Performance,optimiz,optimized,3207," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3379,Performance,optimiz,optimized,3379," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:405,Security,expose,exposes,405,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:584,Security,access,access,584,"//===- MemorySSA.h - Build Memory SSA ---------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file exposes an interface to building/using memory SSA to; /// walk memory instructions using a use/def graph.; ///; /// Memory SSA class builds an SSA form that links together memory access; /// instructions such as loads, stores, atomics, and calls. Additionally, it; /// does a trivial form of ""heap versioning"" Every time the memory state changes; /// in the program, we generate a new heap version. It generates; /// MemoryDef/Uses/Phis that are overlayed on top of the existing instructions.; ///; /// As a trivial example,; /// define i32 @main() #0 {; /// entry:; /// %call = call noalias i8* @_Znwm(i64 4) #2; /// %0 = bitcast i8* %call to i32*; /// %call1 = call noalias i8* @_Znwm(i64 4) #2; /// %1 = bitcast i8* %call1 to i32*; /// store i32 5, i32* %0, align 4; /// store i32 7, i32* %1, align 4; /// %2 = load i32* %0, align 4; /// %3 = load i32* %1, align 4; /// %add = add nsw i32 %2, %3; /// ret i32 %add; /// }; ///; /// Will become; /// define i32 @main() #0 {; /// entry:; /// ; 1 = MemoryDef(0); /// %call = call noalias i8* @_Znwm(i64 4) #3; /// %2 = bitcast i8* %call to i32*; /// ; 2 = MemoryDef(1); /// %call1 = call noalias i8* @_Znwm(i64 4) #3; /// %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the Mem",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3287,Security,access,access,3287," %4 = bitcast i8* %call1 to i32*; /// ; 3 = MemoryDef(2); /// store i32 5, i32* %2, align 4; /// ; 4 = MemoryDef(3); /// store i32 7, i32* %4, align 4; /// ; MemoryUse(3); /// %7 = load i32* %2, align 4; /// ; MemoryUse(4); /// %8 = load i32* %4, align 4; /// %add = add nsw i32 %7, %8; /// ret i32 %add; /// }; ///; /// Given this form, all the stores that could ever effect the load at %8 can be; /// gotten by using the MemoryUse associated with it, and walking from use to; /// def until you hit the top of the function.; ///; /// Each def also has a list of users associated with it, so you can walk from; /// both def to users, and users to defs. Note that we disambiguate MemoryUses,; /// but not the RHS of MemoryDefs. You can see this above at %7, which would; /// otherwise be a MemoryUse(4). Being disambiguated means that for a given; /// store, all the MemoryUses on its use lists are may-aliases of that store; /// (but the MemoryDefs on its use list may not be).; ///; /// MemoryDefs are not disambiguated because it would require multiple reaching; /// definitions, which would require multiple phis, and multiple memoryaccesses; /// per instruction.; ///; /// In addition to the def/use graph described above, MemoryDefs also contain; /// an ""optimized"" definition use. The ""optimized"" use points to some def; /// reachable through the memory def chain. The optimized def *may* (but is; /// not required to) alias the original MemoryDef, but no def *closer* to the; /// source def may alias it. As the name implies, the purpose of the optimized; /// use is to allow caching of clobber searches for memory defs. The optimized; /// def may be nullptr, in which case clients must walk the defining access; /// chain.; ///; /// When iterating the uses of a MemoryDef, both defining uses and optimized; /// uses will be encountered. If only one type is needed, the client must; /// filter the use walk.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Security,access,accesses,27,// The base for all memory accesses. All memory accesses in a block are; // linked together using an intrusive list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Security,access,accesses,48,// The base for all memory accesses. All memory accesses in a block are; // linked together using an intrusive list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:36,Security,access,access,36,/// The user iterators for a memory access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:172,Security,access,access,172,"/// This iterator walks over all of the defs in a given; /// MemoryAccess. For MemoryPhi nodes, this walks arguments. For; /// MemoryUse/MemoryDef, this walks the defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Security,access,access,34,/// Get the iterators for the all access list and the defs only list; /// We default to the all access list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:96,Security,access,access,96,/// Get the iterators for the all access list and the defs only list; /// We default to the all access list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:12,Security,access,access,12,/// Get the access that produces the memory state used by this Use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:18,Performance,optimiz,optimized,18,/// Do we have an optimized use?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Performance,optimiz,optimized,48,"/// Return the MemoryAccess associated with the optimized use, or nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:13,Performance,optimiz,optimized,13,/// Sets the optimized use for a MemoryDef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:44,Performance,optimiz,optimized,44,"/// Reset the ID of what this MemoryUse was optimized to, causing it to; /// be rewalked by the walker if necessary.; /// This really should only be called by tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:159,Testability,test,tests,159,"/// Reset the ID of what this MemoryUse was optimized to, causing it to; /// be rewalked by the walker if necessary.; /// This really should only be called by tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:25,Security,access,accesses,25,"/// Represents read-only accesses to memory; ///; /// In particular, the set of Instructions that will be represented by; /// MemoryUse's is exactly the set of Instructions for which; /// AliasAnalysis::getModRefInfo returns ""Ref"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly one operand,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:29,Performance,optimiz,optimized,29,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:103,Performance,optimiz,optimized,103,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:176,Performance,optimiz,optimization,176,"/// Whether the MemoryUse is optimized. If ensureOptimizedUses() was called,; /// uses will usually be optimized, but this is not guaranteed (e.g. due to; /// invalidation and optimization limits.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:28,Security,access,access,28,"/// Represents a read-write access to memory, whether it is a must-alias,; /// or a may-alias.; ///; /// In particular, the set of Instructions that will be represented by; /// MemoryDef's is exactly the set of Instructions for which; /// AliasAnalysis::getModRefInfo returns ""Mod"" or ""ModRef"".; /// Note that, in order to provide def-def chains, all defs also have a use; /// associated with them. This use points to the nearest reaching; /// MemoryDef/MemoryPhi.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly two operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:36,Security,access,accesses,36,"/// Represents phi nodes for memory accesses.; ///; /// These have the same semantic as regular phi nodes, with the exception that; /// only one phi will ever exist in a given basic block.; /// Guaranteeing one phi per block means guaranteeing there is only ever one; /// valid reaching MemoryDef/MemoryPHI along each path to the phi node.; /// This is ensured by not allowing disambiguation of the RHS of a MemoryDef or; /// a MemoryPhi's operands.; /// That is, given; /// if (a) {; /// store %a; /// store %b; /// }; /// it *must* be transformed into; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// 2 = MemoryDef(1); /// store %b; /// }; /// and *not*; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// even if the two stores do not conflict. Otherwise, both 1 and 2 reach the; /// end of the branch, and if there are not two phi nodes, one will be; /// disconnected completely from the SSA graph below that point.; /// Because MemoryUse's do not generate new definitions, they do not have this; /// issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Energy Efficiency,allocate,allocate,3,// allocate space for exactly zero operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:25,Security,access,accessors,25,/// Provide fast operand accessors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:18,Integrability,interface,interface,18,"// Block iterator interface. This provides access to the list of incoming; // basic blocks, which parallels the list of incoming values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:43,Security,access,access,43,"// Block iterator interface. This provides access to the list of incoming; // basic blocks, which parallels the list of incoming values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Security,access,access,34,"// After deleting incoming memory access MA, the incoming accesses order may; // be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:58,Security,access,accesses,58,"// After deleting incoming memory access MA, the incoming accesses order may; // be changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:94,Energy Efficiency,allocate,allocate,94,"/// this is more complicated than the generic; /// User::allocHungoffUses, because we have to allocate Uses for the incoming; /// values and pointers to the incoming blocks, all in one allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:75,Security,access,accesses,75,"/// Encapsulates MemorySSA, including all data associated with memory; /// accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:67,Security,access,access,67,"/// Given a memory Mod/Ref'ing instruction, get the MemorySSA; /// access associated with it. If passed a basic block gets the memory phi; /// node that exists for that block, if there is one. Otherwise, this will get; /// a MemoryUseOrDef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:70,Performance,Load,Loads,70,"/// Return true if \p MA represents the live on entry value; ///; /// Loads and stores from pointer arguments and other global values may be; /// defined by memory operations that do not occur in the current function, so; /// they may be live on entry to the function. MemorySSA represents such; /// memory state by the live on entry definition, which is guaranteed to occur; /// before any other memory access in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:404,Security,access,access,404,"/// Return true if \p MA represents the live on entry value; ///; /// Loads and stores from pointer arguments and other global values may be; /// defined by memory operations that do not occur in the current function, so; /// they may be live on entry to the function. MemorySSA represents such; /// memory state by the live on entry definition, which is guaranteed to occur; /// before any other memory access in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:21,Security,access,accesses,21,"/// Given two memory accesses in the same basic block, determine; /// whether MemoryAccess \p A dominates MemoryAccess \p B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:21,Security,access,accesses,21,"/// Given two memory accesses in potentially different blocks,; /// determine whether MemoryAccess \p A dominates MemoryAccess \p B.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:140,Testability,test,tests,140,"/// Verify that MemorySSA is self consistent (IE definitions dominate; /// all uses, uses appear in the right places). This is used by unit tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:31,Performance,optimiz,optimized,31,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:113,Performance,optimiz,optimize,113,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:262,Security,access,access,262,"/// By default, uses are *not* optimized during MemorySSA construction.; /// Calling this method will attempt to optimize all MemoryUses, if this has; /// not happened yet for this MemorySSA instance. This should be done if you; /// plan to query the clobbering access for most uses, or if you walk the; /// def-use chain of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:34,Integrability,wrap,wrapper,34,// Used by Memory SSA dumpers and wrapper pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:41,Deployability,update,updater,41,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Performance,optimiz,optimizer,27,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:41,Deployability,update,updater,41,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:27,Performance,optimiz,optimizer,27,// This is used by the use optimizer and updater.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:24,Deployability,update,updater,24,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:163,Deployability,update,updater,163,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:35,Performance,perform,perform,35,"// These is used by the updater to perform various internal MemorySSA; // machinsations. They do not always leave the IR in a correct state, and; // relies on the updater to fixup what it breaks, so it is not public.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:48,Security,access,access,48,"// These two mappings contain the main block to access/def mappings for; // MemorySSA. The list contained in PerBlockAccesses really owns all the; // MemoryAccesses.; // Both maps maintain the invariant that if a block is found in them, the; // corresponding list is not empty, and if a block is not found in them, the; // corresponding list is empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:3,Integrability,Wrap,Wrap,3,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:114,Integrability,wrap,wrapper,114,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:174,Safety,avoid,avoid,174,// Wrap MemorySSA result to ensure address stability of internal MemorySSA; // pointers after construction. Use a wrapper class instead of plain; // unique_ptr<MemorySSA> to avoid build breakage on MSVC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:31,Integrability,interface,interface,31,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:709,Integrability,interface,interface,709,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:571,Security,access,accesses,571,"/// This is the generic walker interface for walkers of MemorySSA.; /// Walkers are used to be able to further disambiguate the def-use chains; /// MemorySSA gives you, or otherwise produce better info than MemorySSA gives; /// you.; /// In particular, while the def-use chains provide basic information, and are; /// guaranteed to give, for example, the nearest may-aliasing MemoryDef for a; /// MemoryUse as AliasAnalysis considers it, a user mant want better or other; /// information. In particular, they may want to use SCEV info to further; /// disambiguate memory accesses, or they may want the nearest dominating; /// may-aliasing MemoryDef for a call or a store. This API enables a; /// standardized interface to getting and using that info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:699,Performance,load,load,699,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:737,Performance,load,load,737,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:164,Security,access,accesses,164,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:249,Security,access,accessed,249,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:331,Security,access,access,331,"/// Given a memory Mod/Ref/ModRef'ing instruction, calling this; /// will give you the nearest dominating MemoryAccess that Mod's the location; /// the instruction accesses (by skipping any def which AA can prove does not; /// alias the location(s) accessed by the instruction given).; ///; /// Note that this will return a single access, and it must dominate the; /// Instruction, so if an operand of a MemoryPhi node Mod's the instruction,; /// this will return the MemoryPhi, not the operand. This means that; /// given:; /// if (a) {; /// 1 = MemoryDef(liveOnEntry); /// store %a; /// } else {; /// 2 = MemoryDef(liveOnEntry); /// store %b; /// }; /// 3 = MemoryPhi(2, 1); /// MemoryUse(3); /// load %a; ///; /// calling this API on load(%a) will return the MemoryPhi, not the MemoryDef; /// in the if (a) branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:42,Security,access,access,42,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:366,Security,access,access,366,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:472,Security,access,access,472,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:570,Security,access,access,570,"/// Given a potentially clobbering memory access and a new location,; /// calling this will give you the nearest dominating clobbering MemoryAccess; /// (by skipping non-aliasing def links).; ///; /// This version of the function is mainly used to disambiguate phi translated; /// pointers, where the value of a pointer may have changed from the initial; /// memory access. Note that this expects to be handed either a MemoryUse,; /// or an already potentially clobbering access. Unlike the above API, if; /// given a MemoryDef that clobbers the pointer as the starting access, it; /// will return that MemoryDef, whereas the above would return the clobber; /// starting from the use side of the memory def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:148,Performance,perform,perform,148,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:162,Performance,cache,cache,162,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:19,Security,access,access,19,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:81,Security,access,access,81,"/// Given a memory access, invalidate anything this walker knows about; /// that access.; /// This API is used by walkers that store information to perform basic cache; /// invalidation. This will be called by MemorySSA at appropriate times for; /// the walker it uses or returns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:76,Usability,simpl,simply,76,"/// A MemorySSAWalker that does no alias queries, or anything else. It; /// simply returns the links as they were constructed by the builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:95,Security,access,accesses,95,/// Iterator base class used to implement const and non-const iterators; /// over the defining accesses of a MemoryAccess.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:236,Safety,avoid,avoid,236,"// This is a bit ugly, but for MemoryPHI's, unlike PHINodes, you can't get the; // block from the operand in constant time (In a PHINode, the uselist has; // both, so it's just subtraction). We provide it as part of the; // iterator to avoid callers having to linear walk to get the block.; // If the operation becomes constant time on MemoryPHI's, this bit of; // abstraction breaking should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:55,Security,access,access,55,"// Go to the first argument for phis, and the defining access for everything; // else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:64,Security,access,access,64,"/// Provide an iterator that walks defs, giving both the memory access,; /// and the current pointer location, updating the pointer location as it; /// changes due to phi node translation.; ///; /// This iterator, while somewhat specialized, is what most clients actually; /// want when walking upwards through MemorySSA def chains. It takes a pair of; /// <MemoryAccess,MemoryLocation>, and walks defs, properly translating the; /// memory location through phi nodes for the user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:308,Integrability,depend,dependences,308,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:182,Security,access,accesses,182,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:196,Security,access,access,196,"// Mark size as unknown, if the location is not guaranteed to be; // loop-invariant for any possible loop in the function. Setting the size; // to unknown guarantees that any memory accesses that access locations; // after the pointer are considered as clobbers, which is important to; // catch loop carried dependences.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:582,Performance,optimiz,optimized,582,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:770,Performance,optimiz,optimized,770,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:23,Security,access,accesses,23,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:360,Security,access,access,360,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:385,Security,access,accesses,385,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:619,Security,access,access,619,"/// Walks the defining accesses of MemoryDefs. Stops after we hit something that; /// has no defining use (e.g. a MemoryPhi or liveOnEntry). Note that, when; /// comparing against a null def_chain_iterator, this will compare equal only; /// after walking said Phi/liveOnEntry.; ///; /// The UseOptimizedChain flag specifies whether to walk the clobbering; /// access chain, or all the accesses.; ///; /// Normally, MemoryDef are all just def/use linked together, so a def_chain on; /// a MemoryDef will walk all MemoryDefs above it in the program until it hits; /// a phi node. The optimized chain walks the clobbering access of a store.; /// So if you are just trying to find, given a store, what the next; /// thing that would clobber the same memory is, you want the optimized chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h:40,Security,access,access,40,// N.B. liveOnEntry has a null defining access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:39,Deployability,Update,Updater,39,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:406,Deployability,update,updater,406,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:552,Deployability,update,updates,552,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:1003,Integrability,depend,depending,1003,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:490,Performance,perform,performs,490,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:611,Performance,load,loads,611,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:803,Security,access,access,803,"//===- MemorySSAUpdater.h - Memory SSA Updater-------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // \file; // An automatic updater for MemorySSA that handles arbitrary insertion,; // deletion, and moves. It performs phi insertion where necessary, and; // automatically updates the MemorySSA IR to be correct.; // While updating loads or removing instructions is often easy enough to not; // need this, updating stores should generally not be attemped outside this; // API.; //; // Basic API usage:; // Create the memory access you want for the instruction (this is mainly so; // we know where it is, without having to duplicate the entire set of create; // functions MemorySSA supports).; // Call insertDef or insertUse depending on whether it's a MemoryUse or a; // MemoryDef.; // That's it.; //; // For moving, first, move the instruction itself using the normal SSA; // instruction moving API, then just call moveBefore, moveAfter,or moveTo with; // the right arguments.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:214,Performance,load,loads,214,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:420,Performance,load,load,420,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:604,Performance,load,load,604,"/// Insert a definition into the MemorySSA IR. RenameUses will rename any use; /// below the new def block (and any inserted phis). RenameUses should be set; /// to true if the definition may cause new aliases for loads below it. This; /// is not the case for hoisting or sinking or other forms of code *movement*.; /// It *is* the case for straight code insertion.; /// For example:; /// store a; /// if (foo) { }; /// load a; ///; /// Moving the store into the if block, and calling insertDef, does not; /// require RenameUses.; /// However, changing it to:; /// store a; /// if (foo) { store b }; /// load a; /// Where a mayalias b, *does* require RenameUses be set to true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update the MemoryPhi in `To` following an edge deletion between `From` and; /// `To`. If `To` becomes unreachable, a call to removeBlocks should be made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update the MemoryPhi in `To` to have a single incoming edge from `From`,; /// following a CFG change that replaced multiple edges (switch) with a direct; /// branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,/// Update MemorySSA when inserting a unique backedge block for a loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,"/// Update MemorySSA after a loop was cloned, given the blocks in RPO order,; /// the exit blocks and a 1:1 mapping of all blocks and instructions; /// cloned. This involves duplicating all defs and uses in the cloned blocks; /// Updating phi nodes in exit block successors is done separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:4,Deployability,Update,Update,4,/// Update phi nodes in exit block successors following cloning. Exit blocks; /// that were not cloned don't have additional predecessors added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:14,Deployability,update,updates,14,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:50,Deployability,update,updates,50,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:123,Deployability,Update,UpdateDTFirst,123,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:157,Deployability,update,update,157,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:185,Deployability,update,updates,185,"/// Apply CFG updates, analogous with the DT edge updates. By default, the; /// DT is assumed to be already up to date. If UpdateDTFirst is true, first; /// update the DT with the same updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:21,Deployability,update,updates,21,"/// Apply CFG insert updates, analogous with the DT edge updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:57,Deployability,update,updates,57,"/// Apply CFG insert updates, analogous with the DT edge updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:261,Deployability,update,updated,261,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:321,Deployability,update,update,321,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:106,Security,access,accesses,106,"/// `From` block was spliced into `From` and `To`. There is a CFG edge from; /// `From` to `To`. Move all accesses from `From` to `To` starting at; /// instruction `Start`. `To` is newly created BB, so empty of; /// MemorySSA::MemoryAccesses. Edges are already updated, so successors of; /// `To` with MPhi nodes need to update incoming block.; /// |------| |------|; /// | From | | From |; /// | | |------|; /// | | ||; /// | | => \/; /// | | |------| <- Start; /// | | | To |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:231,Security,access,accesses,231,"/// `From` block was merged into `To`. There is a CFG edge from `To` to; /// `From`.`To` still branches to `From`, but all instructions were moved and; /// `From` is now an empty block; `From` is about to be deleted. Move all; /// accesses from `From` to `To` starting at instruction `Start`. `To` may; /// have multiple successors, `From` has a single predecessor. `From` may have; /// successors with MPhi nodes, replace their incoming block with `To`.; /// |------| |------|; /// | To | | To |; /// |------| | |; /// || => | |; /// \/ | |; /// |------| | | <- Start; /// | From | | |; /// |------| |------|",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:297,Deployability,update,update,297,"/// A new empty BasicBlock (New) now branches directly to Old. Some of; /// Old's predecessors (Preds) are now branching to New instead of Old.; /// If New is the only predecessor, move Old's Phi, if present, to New.; /// Otherwise, add a new Phi in New with appropriate incoming values, and; /// update the incoming values in Old's Phi node too, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:171,Deployability,update,update,171,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:813,Deployability,update,updates,813,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:782,Performance,perform,perform,782,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:59,Security,access,accesses,59,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:121,Security,access,accesses,121,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:491,Security,access,access,491,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:915,Security,access,access,915,"// The below are utility functions. Other than creation of accesses to pass; // to insertDef, and removeAccess to remove accesses, you should generally; // not attempt to update memoryssa yourself. It is very non-trivial to get; // the edge cases right, and the above calls already operate in near-optimal; // time bounds.; /// Create a MemoryAccess in MemorySSA at a specified point in a block.; ///; /// When used by itself, this method will only insert the new MemoryAccess; /// into the access list, but not make any other changes, such as inserting; /// MemoryPHI nodes, or updating users to point to the new MemoryAccess. You; /// must specify a correct Definition in this case.; ///; /// Usually, this API is instead combined with insertUse() or insertDef(),; /// which will perform all the necessary MSSA updates. If these APIs are used,; /// then nullptr can be used as Definition, as the correct defining access; /// will be automatically determined.; ///; /// Note: If a MemoryAccess already exists for I, this function will make it; /// inaccessible and it *must* have removeMemoryAccess called on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:253,Performance,load,load,253,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:367,Performance,load,load,367,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:261,Usability,simpl,simply,261,"/// Remove a MemoryAccess from MemorySSA, including updating all; /// definitions and uses.; /// This should be called when a memory instruction that has a MemoryAccess; /// associated with it is erased from the program. For example, if a store or; /// load is simply erased (not replaced), removeMemoryAccess should be called; /// on the MemoryAccess for that store/load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:123,Performance,load,load,123,"/// Remove MemoryAccess for a given instruction, if a MemoryAccess exists.; /// This should be called when an instruction (load/store) is deleted from; /// the program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:399,Deployability,update,updated,399,"/// Remove all MemoryAcceses in a set of BasicBlocks about to be deleted.; /// Assumption we make here: all uses of deleted defs and phi must either; /// occur in blocks about to be deleted (thus will be deleted as well), or; /// they occur in phis that will simply lose an incoming value.; /// Deleted blocks still have successor info, but their predecessor edges and; /// Phi nodes may already be updated. Instructions in DeadBlocks should be; /// deleted after this call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:259,Usability,simpl,simply,259,"/// Remove all MemoryAcceses in a set of BasicBlocks about to be deleted.; /// Assumption we make here: all uses of deleted defs and phi must either; /// occur in blocks about to be deleted (thus will be deleted as well), or; /// they occur in phis that will simply lose an incoming value.; /// Deleted blocks still have successor info, but their predecessor edges and; /// Phi nodes may already be updated. Instructions in DeadBlocks should be; /// deleted after this call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:122,Deployability,update,update,122,"/// Instruction I will be changed to an unreachable. Remove all accesses in; /// I's block that follow I (inclusive), and update the Phis in the blocks'; /// successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:64,Security,access,accesses,64,"/// Instruction I will be changed to an unreachable. Remove all accesses in; /// I's block that follow I (inclusive), and update the Phis in the blocks'; /// successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:104,Integrability,wrap,wrappers,104,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:19,Security,access,accesses,19,"// Move all memory accesses from `From` to `To` starting at `Start`.; // Restrictions apply, see public wrappers of this method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h:747,Usability,simpl,simplifications,747,"// Clone all uses and defs from BB to NewBB given a 1:1 map of all; // instructions and blocks cloned, and a map of MemoryPhi : Definition; // (MemoryAccess Phi or Def). VMap maps old instructions to cloned; // instructions and old blocks to cloned blocks. MPhiMap, is created in the; // caller of this private method, and maps existing MemoryPhis to new; // definitions that new MemoryAccesses must point to. These definitions may; // not necessarily be MemoryPhis themselves, they may be MemoryDefs. As such,; // the map is between MemoryPhis and MemoryAccesses, where the MemoryAccesses; // may be MemoryPhis or MemoryDefs and not MemoryUses.; // If CloneWasSimplified = true, the clone was exact. Otherwise, assume that; // the clone involved simplifications that may have: (1) turned a MemoryUse; // into an instruction that MemorySSA has no representation for, or (2) turned; // a MemoryDef into a MemoryUse or an instruction that MemorySSA has no; // representation for. No other cases are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MemorySSAUpdater.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:131,Deployability,update,updated,131,"// Get the initial 'level' of the function, or 0 if the function has been; // introduced afterwards.; // TODO: should we keep this updated?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:191,Safety,avoid,avoid,191,"// Using std::map to benefit from its iterator / reference non-invalidating; // semantics, which make it easy to use `getCachedFPI` results from multiple; // calls without needing to copy to avoid invalidation effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:98,Deployability,update,update,98,"// Make a copy of the FPI of the caller right before inlining. If inlining; // fails, we can just update the cache with that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h:109,Performance,cache,cache,109,"// Make a copy of the FPI of the caller right before inlining. If inlining; // fails, we can just update the cache with that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:44,Integrability,interface,interface,44,"//===- MLModelRunner.h ---- ML model runner interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:18,Integrability,interface,interface,18,"/// MLModelRunner interface: abstraction of a mechanism for evaluating a; /// ML model. More abstractly, evaluating a function that has as tensors as; /// arguments, described via TensorSpecs, and returns a tensor. Currently, the; /// latter is assumed to be a scalar, in absence of more elaborate scenarios.; /// NOTE: feature indices are expected to be consistent all accross; /// MLModelRunners (pertaining to the same model), and also Loggers (see; /// TFUtils.h)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h:439,Testability,Log,Loggers,439,"/// MLModelRunner interface: abstraction of a mechanism for evaluating a; /// ML model. More abstractly, evaluating a function that has as tensors as; /// arguments, described via TensorSpecs, and returns a tensor. Currently, the; /// latter is assumed to be a scalar, in absence of more elaborate scenarios.; /// NOTE: feature indices are expected to be consistent all accross; /// MLModelRunners (pertaining to the same model), and also Loggers (see; /// TFUtils.h)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MLModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:96,Performance,load,load,96,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:266,Performance,perform,performance,266,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h:163,Usability,guid,guide,163,/// ModelUnderTrainingRunner - training mode implementation. It uses TFLite; /// to dynamically load and evaluate a TF SavedModel; /// (https://www.tensorflow.org/guide/saved_model) converted to TFLite. see; /// lib/Analysis/models/saved-model-to-tflite.py. Runtime performance is; /// sacrificed for ease of use while training.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModelUnderTrainingRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:403,Integrability,interface,interface,403,"//===- ModuleSummaryAnalysis.h - Module summary index builder ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface to build a ModuleSummaryIndex for a module.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:280,Integrability,rout,routine,280,"/// Direct function to compute a \c ModuleSummaryIndex from a given module.; ///; /// If operating within a pass manager which has defined ways to compute the \c; /// BlockFrequencyInfo for a given function, that can be provided via; /// a std::function callback. Otherwise, this routine will manually construct; /// that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ModuleSummaryIndex object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ModuleSummaryIndex object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h:138,Integrability,wrap,wrap,138,"//===--------------------------------------------------------------------===//; //; // ImmutableModuleSummaryIndexWrapperPass - This pass wrap provided; // ModuleSummaryIndex object for the module, to be used by other passes.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ModuleSummaryAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:716,Availability,avail,available,716,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:416,Integrability,rout,routines,416,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:705,Integrability,interface,interfaces,705,"//===- MustExecute.h - Is an instruction known to execute--------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// Contains a collection of routines for determining if a given instruction is; /// guaranteed to execute if a given point in control flow is reached. The most; /// common example is an instruction within a loop being provably executed if we; /// branch to the header of it's containing loop.; ///; /// There are two interfaces available to determine if an instruction is; /// executed once a given point in the control flow is reached:; /// 1) A loop-centric one derived from LoopSafetyInfo.; /// 2) A ""must be executed context""-based one implemented in the; /// MustBeExecutedContextExplorer.; /// Please refer to the class comments for more information.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:439,Performance,cache,cached,439,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:18,Safety,safe,safety,18,"/// Captures loop safety information.; /// It keep information for loop blocks may throw exception or otherwise; /// exit abnormally on any iteration of the loop which might actually execute; /// at runtime. The primary way to consume this information is via; /// isGuaranteedToExecute below, but some callers bailout or fallback to; /// alternate reasoning if a loop contains any implicit control flow.; /// NOTE: LoopSafetyInfo contains cached information regarding loops and their; /// particular blocks. This information is only dropped on invocation of; /// computeLoopSafetyInfo. If the loop or any of its block is deleted, or if; /// any thrower instructions have been added or removed from them, or if the; /// control flow has changed, or in case of other meaningful modifications, the; /// LoopSafetyInfo needs to be recomputed. If a meaningful modifications to the; /// loop were made and the info wasn't recomputed properly, the behavior of all; /// methods except for computeLoopSafetyInfo is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Deployability,update,update,11,// Used to update funclet bundle operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:45,Deployability,update,update,45,/// Returns block colors map that is used to update funclet operand bundles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:125,Safety,avoid,avoid,125,/// Returns true iff the block \p BB potentially may throw exception. It can; /// be false-positive in cases when we want to avoid complex analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:169,Deployability,Update,Updates,169,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:13,Safety,safe,safety,13,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:177,Safety,safe,safety,177,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:254,Usability,clear,clear,254,"/// Computes safety information for a loop checks loop body & header for; /// the possibility of may throw exception, it takes LoopSafetyInfo and loop; /// as argument. Updates safety information in LoopSafetyInfo argument.; /// Note: This is defined to clear and reinitialize an already initialized; /// LoopSafetyInfo. Some callers rely on this fact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:130,Safety,avoid,avoid,130,/// Simple and conservative implementation of LoopSafetyInfo that can give; /// false-positive answers to its queries in order to avoid complicated; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:4,Usability,Simpl,Simple,4,/// Simple and conservative implementation of LoopSafetyInfo that can give; /// false-positive answers to its queries in order to avoid complicated; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:152,Performance,cache,cache,152,"/// This implementation of LoopSafetyInfo use ImplicitControlFlowTracking to; /// give precise answers on ""may throw"" queries. This implementation uses cache; /// that should be invalidated by calling the methods insertInstructionTo and; /// removeInstruction whenever we modify a basic block's contents by adding or; /// removing instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:140,Deployability,update,updates,140,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:134,Performance,cache,cache,134,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:15,Safety,safe,safety,15,/// Inform the safety info that we are planning to insert a new instruction; /// \p Inst into the basic block \p BB. It will make all cache updates to keep; /// it correct after this insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:122,Deployability,update,updates,122,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:116,Performance,cache,cache,116,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Safety,safe,safety,11,/// Inform safety info that we are planning to remove the instruction \p Inst; /// from its block. It will make all cache updates to keep it correct after; /// this removal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2184,Availability,avail,available,2184,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2167,Integrability,depend,depending,2167,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:2268,Integrability,depend,depending,2268,"or), there are two possible; /// outcomes. If we start the iterator at A, B, or E, we will visit only A, B,; /// and E. If we start at C or D, we will visit all instructions A-E.; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// \endcode; ///; ///; /// Below is the example extneded with instructions F and G. Now we assume F; /// might not transfer execution to it's successor G. As a result we get the; /// following visit sets:; ///; /// Start Instruction | Visit Set; /// A | A, B, E, F; /// B | A, B, E, F; /// C | A, B, C, D, E, F; /// D | A, B, C, D, E, F; /// E | A, B, E, F; /// F | A, B, E, F; /// G | A, B, E, F, G; ///; ///; /// \code; /// A;; /// B;; /// if (...) {; /// C;; /// D;; /// }; /// E;; /// F; // Might not transfer execution to its successor G.; /// G;; /// \endcode; ///; ///; /// A more complex example involving conditionals, loops, break, and continue; /// is shown below. We again assume all instructions will transmit control to; /// the successor and we assume we can prove the inner loop to be finite. We; /// omit non-trivial branch conditions as the exploration is oblivious to them.; /// Constant branches are assumed to be unconditional in the CFG. The resulting; /// visist sets are shown in the table below.; ///; /// \code; /// A;; /// while (true) {; /// B;; /// if (...); /// C;; /// if (...); /// continue;; /// D;; /// if (...); /// break;; /// do {; /// if (...); /// continue;; /// E;; /// } while (...);; /// F;; /// }; /// G;; /// \endcode; ///; /// Start Instruction | Visit Set; /// A | A, B; /// B | A, B; /// C | A, B, C; /// D | A, B, D; /// E | A, B, D, E, F; /// F | A, B, D, F; /// G | A, B, D, G; ///; ///; /// Note that the examples show optimal visist sets but not necessarily the ones; /// derived by the explorer depending on the available CFG analyses (see; /// MustBeExecutedContextExplorer). Also note that we, depending on the options,; /// the visit set can contain instructions from other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:46,Performance,cache,cached,46,"/// Reset the iterator to point at \p I, keep cached state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:215,Integrability,interface,interface,215,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:352,Security,expose,exposes,352,"/// A ""must be executed context"" for a given program point PP is the set of; /// instructions, potentially before and after PP, that are executed always when; /// PP is reached. The MustBeExecutedContextExplorer an interface to explore; /// ""must be executed contexts"" in a module through the use of; /// MustBeExecutedIterator.; ///; /// The explorer exposes ""must be executed iterators"" that traverse the must be; /// executed context. There is little information sharing between iterators as; /// the expected use case involves few iterators for ""far apart"" instructions.; /// If that changes, we should consider caching more intermediate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:19,Integrability,interface,interface,19,/// Iterator-based interface. \see MustBeExecutedIterator.; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:38,Performance,cache,cached,38,/// Return an iterator to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:44,Performance,cache,cached,44,/// Return an iterator range to explore the cached context around \p PP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:29,Performance,perform,performed,29,/// Parameter that limit the performed exploration. See the constructor for; /// their meaning.; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:17,Performance,cache,cache,17,///}; /// Map to cache isGuaranteedToTransferExecutionToSuccessor results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h:11,Performance,cache,cache,11,/// Map to cache containsIrreducibleCFG results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/MustExecute.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h:82,Testability,log,logs,82,"/// A pseudo model runner. We use it to store feature values when collecting; /// logs for the default policy, in 'development' mode, but never ask it to; /// 'run'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/NoInferenceModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:490,Modifiability,enhance,enhance,490,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:504,Performance,optimiz,optimization,504,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:412,Usability,simpl,simple,412,"//===- ObjCARCAliasAnalysis.h - ObjC ARC Alias Analysis ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a simple ARC-aware AliasAnalysis using special knowledge; /// of Objective C to enhance other optimization passes which rely on the Alias; /// Analysis infrastructure.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h:14,Usability,simpl,simple,14,/// This is a simple alias analysis implementation that uses knowledge; /// of ARC constructs to answer queries.; ///; /// TODO: This class could be generalized to know about other ObjC-specific; /// tricks. Such as knowing that ivars in the non-fragile ABI are non-aliasing; /// even though their offsets are dynamic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:456,Performance,Optimiz,Optimizer,456,"//===- ObjCARCAnalysisUtils.h - ObjC ARC Analysis Utilities -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file defines common analysis utilities used by the ObjC ARC Optimizer.; /// ARC stands for Automatic Reference Counting and is a system for managing; /// reference counts for objects in Objective C.; ///; /// WARNING: This file knows about certain library functions. It recognizes them; /// by name, and hardwires knowledge of their semantics.; ///; /// WARNING: This file knows about how certain Objective-C library functions are; /// used. Naive LLVM IR transformations which would otherwise be; /// behavior-preserving may break these assumptions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:45,Performance,Optimiz,Optimizations,45,/// A handy option to enable/disable all ARC Optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:58,Performance,optimiz,optimization,58,/// Test if the given module looks interesting to run ARC optimization; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:4,Testability,Test,Test,4,/// Test if the given module looks interesting to run ARC optimization; /// on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:14,Integrability,wrap,wrapper,14,"/// This is a wrapper around getUnderlyingObject which also knows how to; /// look through objc_retain and objc_autorelease calls, which we know to return; /// their argument verbatim.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,Integrability,wrap,wrapper,6,/// A wrapper for GetUnderlyingObjCPtr used for results memoization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:266,Performance,optimiz,optimizer,266,"/// The RCIdentity root of a value \p V is a dominating value U for which; /// retaining or releasing U is equivalent to retaining or releasing V. In other; /// words, ARC operations on \p V are equivalent to ARC operations on \p U.; ///; /// We use this in the ARC optimizer to make it easier to match up ARC; /// operations by always mapping ARC operations to RCIdentityRoots instead of; /// pointers themselves.; ///; /// The two ways that we see RCIdentical values in ObjC are via:; ///; /// 1. PointerCasts; /// 2. Forwarding Calls that return their argument verbatim.; ///; /// Thus this function strips off pointer casts and forwarding calls. *NOTE*; /// This implies that two RCIdentical values must alias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:4,Testability,Test,Test,4,/// Test whether the given value is possible a retainable object pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:62,Usability,intuit,intuitive,62,"// Only consider values with pointer types.; //; // It seemes intuitive to exclude function pointer types as well, since; // functions are never retainable object pointers, however clang occasionally; // bitcasts retainable object pointers to function-pointer type temporarily.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:17,Modifiability,variab,variables,17,// These special variables are known to hold values which are not; // reference-counted pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:6,Performance,cache,cache,6,/// A cache of MDKinds used by various ARC optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h:43,Performance,optimiz,optimizations,43,/// A cache of MDKinds used by various ARC optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCAnalysisUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is a kind of user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is objc_retain or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class is objc_autorelease or equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which return their; /// argument verbatim.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a null pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:93,Modifiability,variab,variable,93,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which do nothing if; /// passed a global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,Safety,safe,safe,69,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are always safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:68,Safety,safe,safe,68,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,"/// Test if the given class represents instructions which are never safe; /// to mark with the ""tail"" keyword.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:69,Safety,safe,safe,69,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test if the given class represents instructions which are always safe; /// to mark with the nounwind attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:4,Testability,Test,Test,4,/// Test whether the given instruction can autorelease any pointer or cause an; /// autoreleasepool pop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h:134,Safety,detect,detects,134,/// Determine which objc runtime call instruction class V belongs to.; ///; /// This is similar to GetARCInstKind except that it only detects objc; /// runtime calls. This allows it to be faster.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCInstKind.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:56,Performance,optimiz,optimization,56,"// Ignore the bundle if the return type is void. Global optimization passes; // can turn the called function's return type to void. That should happen only; // if the call doesn't return and the call to @llvm.objc.clang.arc.noop.use; // no longer consumes the function return or is deleted. In that case, it's; // not necessary to emit the marker instruction or calls to the ARC runtime; // functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:43,Safety,unsafe,unsafeClaimRV,43,/// Check whether the function is retainRV/unsafeClaimRV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h:256,Safety,Unsafe,UnsafeClaimRV,256,/// This function returns the ARCInstKind of the function attached to operand; /// bundle clang_arc_attachedcall. It returns std::nullopt if the call doesn't; /// have the operand bundle or the operand is null. Otherwise it returns either; /// RetainRV or UnsafeClaimRV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ObjCARCUtil.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:407,Integrability,interface,interfaces,407,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:501,Integrability,depend,dependent,501,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:586,Integrability,message,message,586,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:7,Performance,Optimiz,OptimizationRemarkEmitter,7,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:37,Performance,Optimiz,Optimization,37,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:383,Performance,Optimiz,Optimization,383,"//===- OptimizationRemarkEmitter.h - Optimization Diagnostic ----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Optimization diagnostic interfaces. It's packaged as an analysis pass so; // that by using this service passes become dependent on BFI as well. BFI is; // used to compute the ""hotness"" of the diagnostic message.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:32,Integrability,interface,interface,32,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:8,Performance,optimiz,optimization,8,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:78,Performance,optimiz,optimizations,78,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:96,Performance,perform,performed,96,/// The optimization diagnostic interface.; ///; /// It allows reporting when optimizations are performed and when they are not; /// along with the reasons for it. Hotness information of the corresponding; /// code region can be included in the remark if DiagnosticsHotnessRequested is; /// enabled in the LLVM context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:145,Integrability,depend,depending,145,"/// This variant can be used to generate ORE on demand (without the; /// analysis pass).; ///; /// Note that this ctor has a very different cost depending on whether; /// F->getContext().getDiagnosticsHotnessRequested() is on or not. If it's off; /// the operation is free.; ///; /// Whereas if DiagnosticsHotnessRequested is on, it is fairly expensive; /// operation since BFI and all its required analyses are computed. This is; /// for example useful for CGSCC passes that can't use function analyses; /// passes in the old PM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:65,Performance,optimiz,optimization,65,/// Output the remark via the diagnostic handler and to the; /// optimization record file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:3,Safety,Avoid,Avoid,3,// Avoid building the remark unless we know there are at least *some*; // remarks enabled. We can't currently check whether remarks are requested; // for the calling pass since that requires actually building the remark.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:54,Performance,perform,perform,54,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:162,Performance,optimiz,optimizations,162,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:355,Safety,detect,detected,355,/// Whether we allow for extra compile-time budget to perform more; /// analysis to produce fewer false positives.; ///; /// This is useful when reporting missed optimizations. In this case we can; /// use the extra analysis (1) to filter trivial false positives or (2) to; /// provide more context so that non-trivial false positives can be quickly; /// detected by the user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:83,Availability,avail,available,83,/// Compute hotness from IR value (currently assumed to be a block) if PGO is; /// available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:46,Deployability,update,update,46,/// Similar but use value from \p OptDiag and update hotness there.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:23,Integrability,message,messages,23,/// Only allow verbose messages if we know we're filtering by hotness; /// (BFI is only set in this case).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:92,Integrability,interface,interface,92,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:29,Safety,avoid,avoid,29,/// Add a small namespace to avoid name clashes with the classes used in; /// the streaming interface. We want these to be short for better; /// write/readability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h:4,Performance,Optimiz,OptimizationRemarkEmitter,4,"/// OptimizationRemarkEmitter legacy analysis pass; ///; /// Note that this pass shouldn't generally be marked as preserved by other; /// passes. It's holding onto BFI, so if the pass does not preserve BFI, BFI; /// could be freed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OptimizationRemarkEmitter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:399,Integrability,rout,routines,399,"//===-- OverflowInstAnalysis.h - Utils to fold overflow insts ----*- C++ -*-==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file holds routines to help analyse overflow instructions; // and fold them into constants or other overflow instructions; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:47,Testability,log,logic,47,"/// Match one of the patterns up to the select/logic op:; /// %Op0 = icmp ne i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %Op1 = extractvalue { i4, i1 } %Agg, 1; /// %ret = select i1 %Op0, i1 %Op1, i1 false / %ret = and i1 %Op0, %Op1; ///; /// %Op0 = icmp eq i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %NotOp1 = extractvalue { i4, i1 } %Agg, 1; /// %Op1 = xor i1 %NotOp1, true; /// %ret = select i1 %Op0, i1 true, i1 %Op1 / %ret = or i1 %Op0, %Op1; ///; /// Callers are expected to align that with the operands of the select/logic.; /// IsAnd is set to true if the Op0 and Op1 are used as the first pattern.; /// If Op0 and Op1 match one of the patterns above, return true and fill Y's; /// use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h:611,Testability,log,logic,611,"/// Match one of the patterns up to the select/logic op:; /// %Op0 = icmp ne i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %Op1 = extractvalue { i4, i1 } %Agg, 1; /// %ret = select i1 %Op0, i1 %Op1, i1 false / %ret = and i1 %Op0, %Op1; ///; /// %Op0 = icmp eq i4 %X, 0; /// %Agg = call { i4, i1 } @llvm.[us]mul.with.overflow.i4(i4 %X, i4 %Y); /// %NotOp1 = extractvalue { i4, i1 } %Agg, 1; /// %Op1 = xor i1 %NotOp1, true; /// %ret = select i1 %Op0, i1 true, i1 %Op1 / %ret = or i1 %Op0, %Op1; ///; /// Callers are expected to align that with the operands of the select/logic.; /// IsAnd is set to true if the Op0 and Op1 are used as the first pattern.; /// If Op0 and Op1 match one of the patterns above, return true and fill Y's; /// use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/OverflowInstAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:423,Security,access,accessor,423,"//===-- llvm/Analysis/Passes.h - Constructors for analyses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header file defines prototypes for accessor functions that expose passes; // in the analysis libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:447,Security,expose,expose,447,"//===-- llvm/Analysis/Passes.h - Constructors for analyses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header file defines prototypes for accessor functions that expose passes; // in the analysis libraries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h:161,Integrability,Depend,DependenceAnalysisWrapper,161,//===--------------------------------------------------------------------===//; //; // createDependenceAnalysisWrapperPass - This creates an instance of the; // DependenceAnalysisWrapper pass.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Passes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:6,Performance,cache,cache,6,/// A cache of \@llvm.assume calls used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:43,Usability,Simpl,SimplifyInstruction,43,/// A cache of \@llvm.assume calls used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:157,Safety,avoid,avoid,157,"/// isPotentiallyPHITranslatable - If this needs PHI translation, return true; /// if we have some hope of doing it. This should be used as a filter to; /// avoid calling PHITranslateValue in hopeless situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:260,Availability,failure,failure,260,"/// translateWithInsertion - PHI translate this value into the specified; /// predecessor block, inserting a computation of the value if it is; /// unavailable.; ///; /// All newly created instructions are added to the NewInsts list. This; /// returns null on failure.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:135,Availability,error,errors,135,"/// verify - Check internal consistency of this data structure. If the; /// structure is valid, it returns true. If invalid, it prints errors and; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h:248,Availability,failure,failure,248,/// insertTranslatedSubExpr - Insert a computation of the PHI translated; /// version of 'V' for the edge PredBB->CurBB into the end of the PredBB; /// block. All newly created instructions are added to the NewInsts list.; /// This returns null on failure.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PHITransAddr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:647,Performance,cache,cached,647,"//===- PhiValues.h - Phi Value Analysis -------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the PhiValues class, and associated passes, which can be; // used to find the underlying values of the phis in a function, i.e. the; // non-phi values that can be found by traversing the phi graph.; //; // This information is computed lazily and cached. If new phis are added to the; // function they are handled correctly, but if an existing phi has its operands; // modified PhiValues has to be notified by calling invalidateValue.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:67,Performance,cache,cached,67,"/// Get the underlying values of a phi.; ///; /// This returns the cached value if PN has previously been processed,; /// otherwise it processes it first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:30,Performance,cache,cached,30,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:131,Performance,cache,cached,131,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:363,Performance,cache,cached,363,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:344,Usability,clear,clear,344,"/// Notify PhiValues that the cached information using V is no longer valid; ///; /// Whenever a phi has its operands modified the cached values for that phi; /// (and the phis that use that phi) become invalid. A user of PhiValues has; /// to notify it of this by calling invalidateValue on either the operand or; /// the phi, which will then clear the relevant cached information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:42,Performance,cache,cache,42,/// Print out the values currently in the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:91,Performance,cache,cached,91,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:143,Safety,avoid,avoid,143,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:132,Usability,clear,cleared,132,"/// A CallbackVH to notify PhiValues when a value is deleted or replaced, so; /// that the cached information for that value can be cleared to avoid; /// dangling pointers to invalid values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper pass for the legacy pass manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PhiValues.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h:401,Integrability,interface,interfaces,401,"//=- llvm/Analysis/PostDominators.h - Post Dominator Calculation --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h:393,Security,expose,exposes,393,"//=- llvm/Analysis/PostDominators.h - Post Dominator Calculation --*- C++ -*-=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file exposes interfaces to post dominance information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PostDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:421,Security,access,access,421,"//===- llvm/Analysis/ProfileSummaryInfo.h - profile summary ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a pass that provides access to profile summary; // information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:529,Integrability,depend,depend,529,/// Analysis providing profile information.; ///; /// This is an immutable analysis pass that provides ability to query global; /// (program-level) profile information. The main APIs are isHotCount and; /// isColdCount that tells whether a given profile count is considered hot/cold; /// based on the profile summary. This also provides convenience methods to; /// check whether a function is hot or cold.; // FIXME: Provide convenience methods to determine hotness/coldness of other IR; // units. This would require making this depend on BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:16,Performance,cache,caches,16,// The map that caches the threshold values. The keys are the percentile; // cutoff values and the values are the corresponding threshold values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:39,Availability,avail,available,39,/// Returns true if profile summary is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:185,Availability,avail,available,185,"/// Returns true if \p F has hot function entry. If it returns false, it; /// either means it is not hot or it is unknown whether it is hot or not (for; /// example, no profile data is available).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h:165,Integrability,depend,dependency,165,"// Declare template specialization for llvm::MachineFunction. Do not implement; // here, because we cannot include MachineFunction header here, that would break; // dependency rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ProfileSummaryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:742,Modifiability,variab,variable,742,"//===- PtrUseVisitor.h - InstVisitors over a pointers uses ------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a collection of visitors which walk the (instruction); /// uses of a pointer. These visitors all provide the same essential behavior; /// as an InstVisitor with similar template-based flexibility and; /// implementation strategies.; ///; /// These can be used, for example, to quickly analyze the uses of an alloca,; /// global variable, or function argument.; ///; /// FIXME: Provide a variant which doesn't track offsets and is cheaper.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:26,Integrability,depend,dependent,26,/// Implementation of non-dependent functionality for \c PtrUseVisitor.; ///; /// See \c PtrUseVisitor for the public interface and detailed comments about; /// usage. This class is just a helper base class which is not templated and; /// contains all common code to be shared between different instantiations of; /// PtrUseVisitor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:118,Integrability,interface,interface,118,/// Implementation of non-dependent functionality for \c PtrUseVisitor.; ///; /// See \c PtrUseVisitor for the public interface and detailed comments about; /// usage. This class is just a helper base class which is not templated and; /// contains all common code to be shared between different instantiations of; /// PtrUseVisitor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:266,Safety,abort,aborted,266,"/// This class provides information about the result of a visit.; ///; /// After walking all the users (recursively) of a pointer, the basic; /// infrastructure records some commonly useful information such as escape; /// analysis and whether the visit completed or aborted early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:28,Usability,clear,clearing,28,"/// Reset the pointer info, clearing all state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:11,Safety,abort,abort,11,/// Did we abort the visit early?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,Availability,avail,available,128,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:45,Safety,abort,abort,45,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:107,Safety,abort,abort,107,/// Get the instruction causing the visit to abort.; /// \returns a pointer to the instruction causing the abort if one is; /// available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:139,Availability,avail,available,139,/// Get the instruction causing the pointer to escape.; /// \returns a pointer to the instruction which escapes the pointer if one; /// is available; otherwise returns null.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:132,Availability,avail,available,132,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:22,Safety,abort,aborted,22,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:122,Safety,abort,abort,122,"/// Mark the visit as aborted. Intended for use in a void return.; /// \param I The instruction which caused the visit to abort, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:128,Availability,avail,available,128,"/// Mark the pointer as escaped. Intended for use in a void return.; /// \param I The instruction which escapes the pointer, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:190,Availability,avail,available,190,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:50,Safety,abort,aborted,50,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:164,Safety,abort,aborts,164,"/// Mark the pointer as escaped, and the visit as aborted. Intended; /// for use in a void return.; /// \param I The instruction which both escapes the pointer and aborts the; /// visit, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:84,Integrability,rout,routine,84,/// Walk the operands of a GEP and adjust the offset as appropriate.; ///; /// This routine does the heavy lifting of the pointer walk by computing; /// offsets and looking through GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:440,Availability,avail,available,440,"// end namespace detail; /// A base class for visitors over the uses of a pointer value.; ///; /// Once constructed, a user can call \c visit on a pointer value, and this; /// will walk its uses and visit each instruction using an InstVisitor. It also; /// provides visit methods which will recurse through any pointer-to-pointer; /// transformations such as GEPs and bitcasts.; ///; /// During the visit, the current Use* being visited is available to the; /// subclass, as well as the current offset from the original base pointer if; /// known.; ///; /// The recursive visit of uses is accomplished with a worklist, so the only; /// ordering guarantee is that an instruction is visited before any uses of it; /// are visited. Note that this does *not* mean before any of its users are; /// visited! This is because users can be visited multiple times due to; /// multiple, different uses of pointers derived from the same base.; ///; /// A particular Use will only be visited once, but a User may be visited; /// multiple times, once per Use. This visits may notably have different; /// offsets.; ///; /// All visit methods on the underlying InstVisitor return a boolean. This; /// return short-circuits the visit, stopping it immediately.; ///; /// FIXME: Generalize this for all values rather than just instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:29,Usability,clear,clear,29,"// If we can't walk the GEP, clear the offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h:62,Testability,log,logic,62,// No-op intrinsics which we know don't escape the pointer to logic in; // some other function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/PtrUseVisitor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:577,Availability,Ping,Pingali,577,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:871,Availability,avail,available,871,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1784,Availability,avail,available,1784,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1000,Performance,perform,performing,1000,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1454,Performance,optimiz,optimization,1454,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1479,Safety,avoid,avoided,1479,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:955,Usability,simpl,simpler,955,"//===- RegionInfo.h - SESE region analysis ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Calculate a program structure tree built out of single entry single exit; // regions.; // The basic ideas are taken from ""The Program Structure Tree - Richard Johnson,; // David Pearson, Keshav Pingali - 1994"", however enriched with ideas from ""The; // Refined Process Structure Tree - Jussi Vanhatalo, Hagen Voelyer, Jana; // Koehler - 2009"".; // The algorithm to calculate these data structures however is completely; // different, as it takes advantage of existing information already available; // in (Post)dominace tree and dominance frontier passes. This leads to a simpler; // and in practice hopefully better performing algorithm. The runtime of the; // algorithms described in the papers above are both linear in graph size,; // O(V+E), whereas this algorithm is not, as the dominance frontier information; // itself is not, but in practice runtime seems to be in the order of magnitude; // of dominance tree calculation.; //; // WARNING: LLVM is generally very concerned about compile time such that; // the use of additional analysis passes in the default; // optimization sequence is avoided as much as possible.; // Specifically, if you do not need the RegionInfo, but dominance; // information could be sufficient please base your work only on; // the dominator tree. Most passes maintain it, such that using; // it has often near zero cost. In contrast RegionInfo is by; // default not available, is not maintained by existing; // transformations and there is no intention to do so.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:123,Safety,avoid,avoid,123,// Class to be specialized for different users of RegionInfo; // (i.e. BasicBlocks or MachineBasicBlocks). This is only to avoid needing to; // pass around an unreasonable number of template parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:506,Modifiability,extend,extended,506,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:284,Performance,optimiz,optimize,284,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:343,Usability,simpl,simple,343,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:593,Usability,simpl,simple,593,"//===----------------------------------------------------------------------===//; /// A single entry single exit Region.; ///; /// A Region is a connected subgraph of a control flow graph that has exactly; /// two connections to the remaining graph. It can be used to analyze or; /// optimize parts of the control flow graph.; ///; /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:1698,Usability,simpl,simple,1698," /// A <em> simple Region </em> is connected to the remaining graph by just two; /// edges. One edge entering the Region and another one leaving the Region.; ///; /// An <em> extended Region </em> (or just Region) is a subgraph that can be; /// transform into a simple Region. The transformation is done by adding; /// BasicBlocks that merge several entry or exit edges so that after the merge; /// just one entry and one exit edge exists.; ///; /// The \e Entry of a Region is the first BasicBlock that is passed after; /// entering the Region. It is an element of the Region. The entry BasicBlock; /// dominates all BasicBlocks in the Region.; ///; /// The \e Exit of a Region is the first BasicBlock that is passed after; /// leaving the Region. It is not an element of the Region. The exit BasicBlock,; /// postdominates all BasicBlocks in the Region.; ///; /// A <em> canonical Region </em> cannot be constructed by combining smaller; /// Regions.; ///; /// Region A is the \e parent of Region B, if B is completely contained in A.; ///; /// Two canonical Regions either do not intersect at all or one is; /// the parent of the other.; ///; /// The <em> Program Structure Tree</em> is a graph (V, E) where V is the set of; /// Regions in the control flow graph and E is the \e parent relation of these; /// Regions.; ///; /// Example:; ///; /// \verbatim; /// A simple control flow graph, that contains two regions.; ///; /// 1; /// / |; /// 2 |; /// / \ 3; /// 4 5 |; /// | | |; /// 6 7 8; /// \ | /; /// \ |/ Region A: 1 -> 9 {1,2,3,4,5,6,7,8}; /// 9 Region B: 2 -> 9 {2,4,5,6,7}; /// \endverbatim; ///; /// You can obtain more examples by either calling; ///; /// <tt> ""opt -passes='print<regions>' anyprogram.ll"" </tt>; /// or; /// <tt> ""opt -view-regions-only anyprogram.ll"" </tt>; ///; /// on any LLVM file you are interested in.; ///; /// The first call returns a textual representation of the program structure; /// tree, the second one creates a graphical representation using graphviz.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:153,Deployability,update,updates,153,/// Recursively replace the entry basic block of the region.; ///; /// This function replaces the entry basic block with a new basic block. It; /// also updates all child regions that have the same entry basic block as; /// this region.; ///; /// @param NewEntry The new entry basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:151,Deployability,update,updates,151,/// Recursively replace the exit basic block of the region.; ///; /// This function replaces the exit basic block with a new basic block. It; /// also updates all child regions that have the same exit basic block as; /// this region.; ///; /// @param NewExit The new exit basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:14,Usability,simpl,simple,14,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:51,Usability,simpl,simple,51,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:145,Usability,simpl,simple,145,/// Is this a simple region?; ///; /// A region is simple if it has exactly one exit and one entry edge.; ///; /// @return True if the Region is simple.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:143,Availability,avail,available,143,"/// Get the subregion that starts at a BasicBlock; ///; /// @param BB The BasicBlock the subregion should start.; /// @return The Subregion if available, otherwise NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:129,Availability,avail,available,129,"/// Get the RegionNode for a BasicBlock; ///; /// @param BB The BasicBlock at which the RegionNode should start.; /// @return If available, the RegionNode that represents the subregion; /// starting at BB. If no subregion starts at BB, the RegionNode; /// representing BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:14,Performance,cache,cache,14,/// Clear the cache for BB RegionNodes.; ///; /// After calling this function the BasicBlock RegionNodes will be stored at; /// different memory locations. RegionNodes obtained before this function is; /// called are therefore not comparable to RegionNodes abtained afterwords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Usability,Clear,Clear,4,/// Clear the cache for BB RegionNodes.; ///; /// After calling this function the BasicBlock RegionNodes will be stored at; /// different memory locations. RegionNodes obtained before this function is; /// called are therefore not comparable to RegionNodes abtained afterwords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:100,Safety,detect,detects,100,//===----------------------------------------------------------------------===//; /// Analysis that detects all canonical Regions.; ///; /// The RegionInfo pass detects all canonical regions in a function. The Regions; /// are connected using the parent relation. This builds a Program Structure; /// Tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:161,Safety,detect,detects,161,//===----------------------------------------------------------------------===//; /// Analysis that detects all canonical Regions.; ///; /// The RegionInfo pass detects all canonical regions in a function. The Regions; /// are connected using the parent relation. This builds a Program Structure; /// Tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Deployability,Update,Update,4,/// Update refences to a RegionInfoT held by the RegionT managed here; ///; /// This is a post-move helper. Regions hold references to the owning; /// RegionInfo object. After a move these need to be fixed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:97,Testability,assert,assertion,97,// Check whether the entries of BBtoRegion for the BBs of region; // SR are correct. Triggers an assertion if not. Calls itself recursively for; // subregions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:80,Modifiability,inherit,inherited,80,"// Returns true if BB is in the dominance frontier of; // entry, because it was inherited from exit. In the other case there is an; // edge going from entry to BB without passing exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:71,Modifiability,extend,extend,71,// Saves a shortcut pointing from entry to exit.; // This function may extend this shortcut if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detect,3,// Detect all regions starting with bb 'entry'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detects,3,// Detects regions in F.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:47,Safety,detect,detected,47,// Build the region hierarchy after all region detected.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Deployability,Update,Update,3,// Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Safety,Detect,Detect,3,// Detect all regions in function and build the region tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:19,Performance,Cache,Cache,19,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:4,Usability,Clear,Clear,4,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:65,Usability,clear,clearNodeCache,65,/// Clear the Node Cache for all Regions.; ///; /// @see Region::clearNodeCache(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:3,Deployability,update,updateStatistics,3,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:22,Deployability,Update,Update,22,// updateStatistics - Update statistic about created regions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,Integrability,interface,interface,23,/// @name FunctionPass interface; //@{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c RegionInfo for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:38,Safety,detect,detection,38,"//===- RegionInfoImpl.h - SESE region detection analysis --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:379,Safety,Detect,Detects,379,"//===- RegionInfoImpl.h - SESE region detection analysis --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Detects single entry single exit regions in the control flow graph.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:18,Performance,cache,cache,18,// Only clean the cache for this Region. Caches of child Regions will be; // cleaned when the child Regions are deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:41,Performance,Cache,Caches,41,// Only clean the cache for this Region. Caches of child Regions will be; // cleaned when the child Regions are deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:29,Availability,avail,available,29,// No further region at exit available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:153,Safety,detect,detected,153,"// Iterate over the dominance tree in post order to start with the small; // regions from the bottom of the dominance tree. If the small regions are; // detected first, detection of bigger regions is faster, as we can jump; // over the small regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:169,Safety,detect,detection,169,"// Iterate over the dominance tree in post order to start with the small; // regions from the bottom of the dominance tree. If the small regions are; // detected first, detection of bigger regions is faster, as we can jump; // over the small regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:135,Deployability,update,updated,135,// This basic block is a start block of a region. It is already in the; // BBtoRegion relation. Only the child basic blocks have to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:168,Performance,perform,performance,168,// ShortCut a function where for every BB the exit of the largest region; // starting with BB is stored. These regions can be threated as single BBS.; // This improves performance on linear CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h:126,Security,threat,threated,126,// ShortCut a function where for every BB the exit of the largest region; // starting with BB is stored. These regions can be threated as single BBS.; // This improves performance on linear CFGs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h:134,Testability,assert,assertion,134,"/// Create the iterator from a RegionNode.; ///; /// Note that the incoming node must be a bb node, otherwise it will trigger; /// an assertion when we try to get a BasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionIterator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:454,Performance,optimiz,optimization,454,"//===- RegionPass.h - RegionPass class --------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the RegionPass class. All region based analysis,; // optimization and transformation passes are derived from RegionPass.; // This class is implemented following the some ideas of the LoopPass.h class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:188,Security,Access,Accessing,188,//===--------------------------------------------------------------------===//; /// @name To be implemented by every RegionPass; ///; //@{; /// Run the pass on a specific Region; ///; /// Accessing regions not contained in the current region is not allowed.; ///; /// @param R The region this pass is run on.; /// @param RGM The RegionPassManager that manages this Pass.; ///; /// @return True if the pass modifies this Region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:111,Performance,optimiz,optimization,111,/// Optional passes call this function to check whether the pass should be; /// skipped. This is the case when optimization bisect is over the limit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:24,Energy Efficiency,schedul,schedule,24,/// The pass manager to schedule RegionPasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h:30,Energy Efficiency,schedul,scheduled,30,/// Execute all of the passes scheduled for execution.; ///; /// @return True if any of the passes modifies the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h:50,Integrability,interface,interface,50,"//===-- RegionPrinter.h - Region printer external interface -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines external functions that can be called to explicitly; // instantiate the region printer.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/RegionPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:7,Deployability,Release,ReleaseModeModelRunner,7,"//===- ReleaseModeModelRunner.h - Fast, precompiled model runner ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner wrapping an AOT compiled ML model.; // Only inference is supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:418,Integrability,wrap,wrapping,418,"//===- ReleaseModeModelRunner.h - Fast, precompiled model runner ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements a model runner wrapping an AOT compiled ML model.; // Only inference is supported.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:4,Deployability,Release,ReleaseModeModelRunner,4,/// ReleaseModeModelRunner - production mode implementation of the; /// MLModelRunner. It uses an AOT-compiled SavedModel for efficient execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:126,Energy Efficiency,efficient,efficient,126,/// ReleaseModeModelRunner - production mode implementation of the; /// MLModelRunner. It uses an AOT-compiled SavedModel for efficient execution.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:54,Deployability,Release,ReleaseModeModelRunner,54,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:32,Integrability,interface,interface,32,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:118,Safety,avoid,avoid,118,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h:6,Testability,mock,mock,6,"/// A mock class satisfying the interface expected by ReleaseModeModelRunner for; /// its `TGen` parameter. Useful to avoid conditional compilation complexity, as; /// a compile-time replacement for a real AOT-ed model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReleaseModeModelRunner.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:53,Integrability,interface,interface,53,"//===- ReplayInlineAdvisor.h - Replay Inline Advisor interface -*- C++ --*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:36,Performance,optimiz,optimization,36,/// Replay inline advisor that uses optimization remarks from inlining of; /// previous build to guide current inlining. This is useful for inliner tuning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h:97,Usability,guid,guide,97,/// Replay inline advisor that uses optimization remarks from inlining of; /// previous build to guide current inlining. This is useful for inliner tuning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ReplayInlineAdvisor.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:554,Modifiability,variab,variables,554,"//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The ScalarEvolution class is an LLVM pass which can be used to analyze and; // categorize scalar expressions in loops. It specializes in recognizing; // general induction variables, representing them with the abstract and opaque; // SCEV class. Given this analysis, trip counts of loops and other important; // properties can be obtained.; //; // This analysis is primarily useful for induction variable substitution and; // strength reduction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:778,Modifiability,variab,variable,778,"//===- llvm/Analysis/ScalarEvolution.h - Scalar Evolution -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The ScalarEvolution class is an LLVM pass which can be used to analyze and; // categorize scalar expressions in loops. It specializes in recognizing; // general induction variables, representing them with the abstract and opaque; // SCEV class. Given this analysis, trip counts of loops and other important; // properties can be obtained.; //; // This analysis is primarily useful for induction variable substitution and; // strength reduction.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:111,Integrability,wrap,wrap,111,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:140,Integrability,wrap,wrap,140,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:332,Integrability,wrap,wraparound,332,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:613,Integrability,wrap,wrapping,613,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:1582,Integrability,depend,dependence,1582,"/// NoWrapFlags are bitfield indices into SubclassData.; ///; /// Add and Mul expressions may have no-unsigned-wrap <NUW> or; /// no-signed-wrap <NSW> properties, which are derived from the IR; /// operator. NSW is a misnomer that we use to mean no signed overflow or; /// underflow.; ///; /// AddRec expressions may have a no-self-wraparound <NW> property if, in; /// the integer domain, abs(step) * max-iteration(loop) <=; /// unsigned-max(bitwidth). This means that the recurrence will never reach; /// its start value if the step is non-zero. Computing the same value on; /// each iteration is not considered wrapping, and recurrences with step = 0; /// are trivially <NW>. <NW> is independent of the sign of step and the; /// value the add recurrence starts with.; ///; /// Note that NUW and NSW are also valid properties of a recurrence, and; /// either implies NW. For convenience, NW will be set for a recurrence; /// whenever either NUW or NSW are set.; ///; /// We require that the flag on a SCEV apply to the entire scope in which; /// that SCEV is defined. A SCEV's scope is set of locations dominated by; /// a defining location, which is in turn described by the following rules:; /// * A SCEVUnknown is at the point of definition of the Value.; /// * A SCEVConstant is defined at all points.; /// * A SCEVAddRec is defined starting with the header of the associated; /// loop.; /// * All other SCEVs are defined at the earlest point all operands are; /// defined.; ///; /// The above rules describe a maximally hoisted form (without regards to; /// potential control dependence). A SCEV is defined anywhere a; /// corresponding instruction could be defined in said maximally hoisted; /// form. Note that SCEVUDivExpr (currently the only expression type which; /// can trap) can be defined per these rules in regions where it would trap; /// at runtime. A SCEV being defined does not require the existence of any; /// instruction within the defined scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:11,Integrability,wrap,wrap,11,// No self-wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:15,Integrability,wrap,wrap,15,// No unsigned wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:13,Integrability,wrap,wrap,13,// No signed wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:469,Performance,perform,performing,469,"// Returns estimated size of the mathematical expression represented by this; // SCEV. The rules of its calculation are following:; // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;; // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:; // (1 + Size(Op1) + ... + Size(OpN)).; // This value gives us an estimation of time we need to traverse through this; // SCEV and all its operands recursively. We may use it to avoid performing; // heavy transformations on SCEVs of excessive size for sake of saving the; // compilation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:463,Safety,avoid,avoid,463,"// Returns estimated size of the mathematical expression represented by this; // SCEV. The rules of its calculation are following:; // 1) Size of a SCEV without operands (like constants and SCEVUnknown) is 1;; // 2) Size SCEV with operands Op1, Op2, ..., OpN is calculated by formula:; // (1 + Size(Op1) + ... + Size(OpN)).; // This value gives us an estimation of time we need to traverse through this; // SCEV and all its operands recursively. We may use it to avoid performing; // heavy transformations on SCEVs of excessive size for sake of saving the; // compilation time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:42,Safety,avoid,avoid,42,// Specialize FoldingSetTrait for SCEV to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:51,Safety,avoid,avoid,51,// Specialize FoldingSetTrait for SCEVPredicate to avoid needing to compute; // temporary FoldingSetNodeID values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:593,Integrability,wrap,wrap,593,"/// This class represents an assumption made on an AddRec expression. Given an; /// affine AddRec expression {a,+,b}, we assume that it has the nssw or nusw; /// flags (defined below) in the first X iterations of the loop, where X is a; /// SCEV expression returned by getPredicatedBackedgeTakenCount).; ///; /// Note that this does not imply that X is equal to the backedge taken; /// count. This means that if we have a nusw predicate for i32 {0,+,1} with a; /// predicated backedge taken count of X, we only guarantee that {0,+,1} has; /// nusw in the first X iterations. {0,+,1} may still wrap in the loop if we; /// have more than X iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:192,Integrability,wrap,wrap,192,"/// Similar to SCEV::NoWrapFlags, but with slightly different semantics; /// for FlagNUSW. The increment is considered to be signed, and a + b; /// (where b is the increment) is considered to wrap if:; /// zext(a + b) != zext(a) + sext(b); ///; /// If Signed is a function that takes an n-bit tuple and maps to the; /// integer domain as the tuples value interpreted as twos complement,; /// and Unsigned a function that takes an n-bit tuple and maps to the; /// integer domain as the base two value of input tuple, then a + b; /// has IncrementNUSW iff:; ///; /// 0 <= Unsigned(a) + Signed(b) < 2^n; ///; /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.; ///; /// Note that the IncrementNUSW flag is not commutative: if base + inc; /// has IncrementNUSW, then inc + base doesn't neccessarily have this; /// property. The reason for this is that this is used for sign/zero; /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is; /// assumed. A {base,+,inc} expression is already non-commutative with; /// regards to base and inc, since it is interpreted as:; /// (((base + inc) + inc) + inc) ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:900,Modifiability,extend,extending,900,"/// Similar to SCEV::NoWrapFlags, but with slightly different semantics; /// for FlagNUSW. The increment is considered to be signed, and a + b; /// (where b is the increment) is considered to wrap if:; /// zext(a + b) != zext(a) + sext(b); ///; /// If Signed is a function that takes an n-bit tuple and maps to the; /// integer domain as the tuples value interpreted as twos complement,; /// and Unsigned a function that takes an n-bit tuple and maps to the; /// integer domain as the base two value of input tuple, then a + b; /// has IncrementNUSW iff:; ///; /// 0 <= Unsigned(a) + Signed(b) < 2^n; ///; /// The IncrementNSSW flag has identical semantics with SCEV::FlagNSW.; ///; /// Note that the IncrementNUSW flag is not commutative: if base + inc; /// has IncrementNUSW, then inc + base doesn't neccessarily have this; /// property. The reason for this is that this is used for sign/zero; /// extending affine AddRec SCEV expressions when a SCEVWrapPredicate is; /// assumed. A {base,+,inc} expression is already non-commutative with; /// regards to base and inc, since it is interpreted as:; /// (((base + inc) + inc) + inc) ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:37,Integrability,wrap,wrap,37,// No unsigned with signed increment wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:35,Integrability,wrap,wrap,35,// No signed with signed increment wrap; // (equivalent with SCEV::NSW),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:44,Integrability,wrap,wrap,44,/// Returns the set of SCEVWrapPredicate no wrap flags implied by a; /// SCEVAddRecExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:155,Testability,log,logical,155,"/// This class represents a composition of other SCEV predicates, and is the; /// class that most clients will interact with. This is equivalent to a; /// logical ""AND"" of all the predicates in the union.; ///; /// NB! Unlike other SCEVPredicate sub-classes this class does not live in the; /// ScalarEvolution::Preds folding set. This is why the \c add function is sound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:40,Integrability,interface,interface,40,/// Implementation of the SCEVPredicate interface,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:21,Safety,predict,predictably,21,///< The SCEV varies predictably with the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:205,Security,access,access,205,"/// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if values of the given type are analyzable within the SCEV; /// framework. This primarily includes integer types, and it can optionally; /// include pointer types if the ScalarEvolution class has access to; /// target-specific information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:399,Performance,load,load,399,"/// Return true if there exists a point in the program at which both; /// A and B could be operands to the same instruction.; /// SCEV expressions are generally assumed to correspond to instructions; /// which could exists in IR. In general, this requires that there exists; /// a use point in the program where all operands dominate the use.; ///; /// Example:; /// loop {; /// if; /// loop { v1 = load @global1; }; /// else; /// loop { v2 = load @global2; }; /// }; /// No SCEV with operand V1, and v2 can exist in this program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:443,Performance,load,load,443,"/// Return true if there exists a point in the program at which both; /// A and B could be operands to the same instruction.; /// SCEV expressions are generally assumed to correspond to instructions; /// which could exists in IR. In general, this requires that there exists; /// a use point in the program where all operands dominate the use.; ///; /// Example:; /// loop {; /// if; /// loop { v1 = load @global1; }; /// else; /// loop { v2 = load @global2; }; /// }; /// No SCEV with operand V1, and v2 can exist in this program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:99,Performance,cache,cached,99,/// Return true if the SCEV is a scAddRecExpr or it contains; /// scAddRecExpr. The result will be cached in HasRecMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:85,Integrability,wrap,wrap,85,"/// Parse NSW/NUW flags from add/sub/mul IR binary operation \p Op into; /// SCEV no-wrap flags, and deduce flag[s] that aren't known yet.; /// Does not mutate the original instruction. Returns std::nullopt if it could; /// not deduce more precise flags than the instruction already has, otherwise; /// returns proven flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:284,Modifiability,rewrite,rewrites,284,"/// Checks if \p SymbolicPHI can be rewritten as an AddRecExpr under some; /// Predicates. If successful return these <AddRecExpr, Predicates>;; /// The function is intended to be called from PSCEV (the caller will decide; /// whether to actually add the predicates and carry out the rewrites).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:38,Energy Efficiency,Power,Power,38,/// Return a SCEV for the constant \p Power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is zero extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Modifiability,extend,extended,136,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is sign extended. The; /// conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:115,Modifiability,extend,extended,115,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is extended with; /// unspecified bits. The conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:131,Modifiability,extend,extended,131,"/// Return a SCEV corresponding to a conversion of the input value to the; /// specified type. If the type must be extended, it is extended with; /// unspecified bits. The conversion must not be narrowing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umax operation with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Performance,perform,perform,87,"/// Promote the operands to the wider of the types using zero-extension, and; /// then perform a umin operation with them. N-ary function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:321,Modifiability,variab,variable,321,"/// Return a SCEV expression for the specified value at the specified scope; /// in the program. The L value specifies a loop nest to evaluate the; /// expression at, where null is the top-level or a specified loop is; /// immediately inside of the loop.; ///; /// This method can be used to compute the exit value for a variable defined; /// in a loop by querying what the value will hold in the parent loop.; ///; /// In the case that a relevant loop exit value cannot be computed, the; /// original value V is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:112,Safety,avoid,avoid,112,"/// Test whether entry to the loop is protected by a conditional between LHS; /// and RHS. This is used to help avoid max expressions in loop trip; /// counts, and to eliminate casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether entry to the loop is protected by a conditional between LHS; /// and RHS. This is used to help avoid max expressions in loop trip; /// counts, and to eliminate casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether entry to the basic block is protected by a conditional; /// between LHS and RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether the backedge of the loop is protected by a conditional; /// between LHS and RHS. This is used to eliminate casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:437,Integrability,wrap,wraps,437,"/// Convert from an ""exit count"" (i.e. ""backedge taken count"") to a ""trip; /// count"". A ""trip count"" is the number of times the header of the loop; /// will execute if an exit is taken after the specified number of backedges; /// have been taken. (e.g. TripCount = ExitCount + 1). Note that the; /// expression can overflow if ExitCount = UINT_MAX. If EvalTy is not wide; /// enough to hold the result without overflow, result unsigned wraps with; /// 2s-complement semantics. ex: EC = 255 (i8), TC = 0 (i8)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:203,Usability,simpl,simply,203,"/// Returns the exact trip count of the loop if we can compute it, and; /// the result is a small constant. '0' is used to represent an unknown; /// or non-constant trip count. Note that a trip count is simply one more; /// than the backedge taken count for the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:179,Usability,simpl,simply,179,"/// Return the exact trip count for this loop if we exit through ExitingBlock.; /// '0' is used to represent an unknown or non-constant trip count. Note; /// that a trip count is simply one more than the backedge taken count for; /// the same exit.; /// This ""trip count"" assumes that control exits via ExitingBlock. More; /// precisely, it is the number of times that control will reach ExitingBlock; /// before taking the branch. For loops with multiple exits, it may not be; /// the number times that the loop header executes if the loop exits; /// prematurely via another branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:32,Safety,predict,predictable,32,"/// If the specified loop has a predictable backedge-taken count, return it,; /// otherwise return a SCEVCouldNotCompute object. The backedge-taken count is; /// the number of times the loop header will be branched to from within the; /// loop, assuming there are no abnormal exists like exception throws. This is; /// one less than the trip count of the loop, since it doesn't count the first; /// iteration, when the header is branched to from outside the loop.; ///; /// Note that it is not valid to call this method on a loop without a; /// loop-invariant backedge-taken count (see; /// hasLoopInvariantBackedgeTakenCount).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:245,Performance,perform,perform,245,"/// Similar to getBackedgeTakenCount, except it will add a set of; /// SCEV predicates to Predicates that are required to be true in order for; /// the answer to be correct. Predicates can be checked with run-time; /// checks and can be used to perform loop versioning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:151,Usability,Clear,Clear,151,/// Called when the client has changed the disposition of values in; /// this loop.; ///; /// We don't have a way to invalidate per-loop dispositions. Clear and; /// recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:179,Usability,simpl,simpler,179,/// Called when the client has changed the disposition of values in; /// this loop.; ///; /// We don't have a way to invalidate per-loop dispositions. Clear and; /// recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:167,Usability,Clear,Clear,167,/// Called when the client has changed the disposition of values in; /// a loop or block.; ///; /// We don't have a way to invalidate per-loop/per-block dispositions. Clear; /// and recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:195,Usability,simpl,simpler,195,/// Called when the client has changed the disposition of values in; /// a loop or block.; ///; /// We don't have a way to invalidate per-loop/per-block dispositions. Clear; /// and recompute is simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-negative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-positive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to be non-zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:827,Availability,avail,available,827,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:234,Integrability,depend,depend,234,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:868,Testability,assert,assert,868,"/// We'd like to check the predicate on every iteration of the most dominated; /// loop between loops used in LHS and RHS.; /// To do this we use the following list of steps:; /// 1. Collect set S all loops on which either LHS or RHS depend.; /// 2. If S is non-empty; /// a. Let PD be the element of S which is dominated by all other elements.; /// b. Let E(LHS) be value of LHS on entry of PD.; /// To get E(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their entry values.; /// Define E(RHS) in the same way.; /// c. Let B(LHS) be value of L on backedge of PD.; /// To get B(LHS), we should just take LHS and replace all AddRecs that are; /// attached to PD on with their backedge values.; /// Define B(RHS) in the same way.; /// d. Note that E(LHS) and E(RHS) are automatically available on entry of PD,; /// so we can assert on that.; /// e. Return true if isLoopEntryGuardedByCond(Pred, E(LHS), E(RHS)) &&; /// isLoopBackedgeGuardedByCond(Pred, B(LHS), B(RHS))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the given expression is known to satisfy the condition described; /// by Pred, LHS, and RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the given expression is known to satisfy the condition described; /// by Pred, LHS, and RHS in the given Context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test if the condition described by Pred, LHS, RHS is known to be true on; /// every iteration of the loop of the recurrency LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:167,Testability,assert,asserts,167,"/// Construct either an exact exit limit from a constant, or an unknown; /// one from a SCEVCouldNotCompute. No other types of SCEVs are allowed; /// as arguments and asserts enforce that internally.; /*implicit*/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether this ExitLimit contains any computed information, or; /// whether it's all SCEVCouldNotCompute values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether this ExitLimit contains all information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:395,Integrability,wrap,wraparound,395,"/// Compute the number of times the backedge of the specified loop will; /// execute if its exit condition were a conditional branch of ExitCond.; ///; /// \p ControlsOnlyExit is true if ExitCond directly controls the only exit; /// branch. In this case, we can assume that the loop exits only if the; /// condition is true and can infer that failing to meet the condition prior; /// to integer wraparound results in undefined behavior.; ///; /// If \p AllowPredicates is set, this call will try to use a minimal set of; /// SCEV predicates in order to return an exact answer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:164,Availability,avail,available,164,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L, return a LoopInvariantPredicate with LHS and RHS being; /// invariants, available at L's entry. Otherwise, return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:227,Availability,avail,available,227,"/// If the result of the predicate LHS `Pred` RHS is loop invariant with; /// respect to L at given Context during at least first MaxIter iterations,; /// return a LoopInvariantPredicate with LHS and RHS being invariants,; /// available at L's entry. Otherwise, return std::nullopt. The predicate; /// should be the loop's exit condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Usability,Simpl,Simplify,4,"/// Simplify LHS and RHS in a comparison with predicate Pred. Return true; /// iff any changes were made. If the operands are provably equal or; /// unequal, LHS and RHS are set to the same value and Pred is set to either; /// ICMP_EQ or ICMP_NE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:90,Integrability,depend,depend,90,/// Determine if the SCEV can be evaluated at loop's entry. It is true if it; /// doesn't depend on a SCEVUnknown of an instruction which is dominated by; /// the header of loop L.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether the given SCEV has Op as a direct or indirect operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Deployability,Update,Update,4,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Integrability,wrap,wrap,14,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:57,Performance,cache,cached,57,/// Update no-wrap flags of an AddRec. This may drop the cached info about; /// this AddRec (such as range info) in case if new flags may potentially; /// sharpen it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:121,Performance,perform,performed,121,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:31,Safety,safe,safe,31,"/// Check whether it is poison-safe to represent the expression S using the; /// instruction I. If such a replacement is performed, the poison flags of; /// instructions in DropPoisonGeneratingInsts must be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:110,Safety,avoid,avoid,110,"/// Does the module have any calls to the llvm.experimental.guard intrinsic; /// at all? If this is false, we avoid doing work that will only help if; /// thare are guards present in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache to record whether a SCEV contains any scAddRecExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache of the values we have analyzed so far.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:14,Performance,cache,cache,14,/// This is a cache for expressions that got folded to a different existing; /// SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether this BackedgeTakenInfo contains any computed information,; /// or whether it's all SCEVCouldNotCompute values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test whether this BackedgeTakenInfo contains complete information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache the backedge-taken count of the loops for this function as they; /// are computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache the predicated backedge-taken count of the loops for this; /// function as they are computed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:137,Safety,avoid,avoid,137,/// This map contains entries for all of the PHI instructions that we; /// attempt to compute constant evolutions for. This allows us to avoid; /// potentially expensive recomputation of these properties. An instruction; /// maps to null if we are unable to compute its exit value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:136,Security,access,access,136,"/// Set to true if the loop contains no instruction that can have side; /// effects (i.e. via throwing an exception, volatile or atomic access).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,/// Cache for \c getLoopProperties.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:12,Modifiability,parameteriz,parameterize,12,/// Used to parameterize getRange,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:100,Performance,cache,cache,100,/// Determine the range for a particular SCEV.; /// NOTE: This returns a reference to an entry in a cache. It must be; /// copied if its needed for longer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:49,Integrability,wrap,wrapping,49,"/// Determines the range for the affine non-self-wrapping SCEVAddRecExpr {\p; /// Start,+,\p Step}<nw>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:49,Usability,simpl,simple,49,"/// If the unknown expression U corresponds to a simple recurrence, return; /// a constant range which represents the entire recurrence. Note that; /// *add* recurrences with loop invariant steps aren't represented by; /// SCEVUnknowns and thus don't use this mechanism.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:56,Usability,simpl,simple,56,/// A helper function for createAddRecFromPHI to handle simple cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:52,Safety,avoid,avoid,52,// Helper functions for computeExitLimitFromCond to avoid exponential time; // complexity.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:326,Testability,assert,assert,326,"// It may look like we need key on the whole (L, ExitIfTrue,; // ControlsOnlyExit, AllowPredicates) tuple, but recursive calls to; // computeExitLimitFromCondCached from computeExitLimitFromCondImpl only; // vary the in \c ExitCond and \c ControlsOnlyExit parameters. We remember; // the initial values of the other values to assert our assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:83,Modifiability,evolve,evolves,83,"/// If the loop is known to execute a constant number of times (the; /// condition evolves only from constants), try to evaluate a few iterations; /// of the loop until we get the exit condition gets a value of ExitWhen; /// (true or false). If we cannot evaluate the exit count of the loop,; /// return CouldNotCompute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the given FoundCondValue value evaluates to true in given; /// Context. If Context is nullptr, then the found predicate is true; /// everywhere. LHS and FoundLHS may have different type width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the given FoundCondValue value evaluates to true in given; /// Context. If Context is nullptr, then the found predicate is true; /// everywhere. LHS and FoundLHS must have same type width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by FoundPred, FoundLHS, FoundRHS is; /// true in given Context. If Context is nullptr, then the found predicate is; /// true everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true in given Context. If Context is nullptr, then the found predicate is; /// true everywhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true. Here LHS is an operation that includes FoundLHS as one of its; /// arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true.; /// Use only simple non-recursive types of checks, such as range analysis etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:86,Usability,simpl,simple,86,"/// Test whether the condition described by Pred, LHS, and RHS is true.; /// Use only simple non-recursive types of checks, such as range analysis etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true. Utility function used by isImpliedCondOperands. Tries to get; /// cases like ""X `sgt` 0 => X - 1 `sgt` -1"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to rule out certain kinds of integer overflow, and; /// then tries to reason about arithmetic properties of the predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to rule out certain kinds of integer overflow, and; /// then tries to reason about arithmetic properties of the predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to weaken the known condition basing on fact that; /// FoundLHS is an AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to weaken the known condition basing on fact that; /// FoundLHS is an AddRec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to figure out predicate for Phis which are SCEVUnknown; /// if it is true for every possible incoming value from their respective; /// basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to figure out predicate for Phis which are SCEVUnknown; /// if it is true for every possible incoming value from their respective; /// basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:170,Integrability,rout,routine,170,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to reason about shifts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,"/// Test whether the condition described by Pred, LHS, and RHS is true; /// whenever the condition described by Pred, FoundLHS, and FoundRHS is; /// true.; ///; /// This routine tries to reason about shifts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Testability,Test,Test,4,/// Test if the given expression is known to satisfy the condition described; /// by Pred and the known constant ranges of LHS and RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:35,Testability,log,logical,35,/// Try to split Pred LHS RHS into logical conjunctions (and's) and try to; /// prove them individually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:196,Integrability,wrap,wrap,196,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:20,Modifiability,Extend,ExtendOpTy,20,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:88,Modifiability,Extend,ExtendOpTy,88,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:112,Modifiability,Extend,ExtendOpTy,112,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:232,Modifiability,Extend,ExtendOpTy,232,"/// Return true if `ExtendOpTy`({`Start`,+,`Step`}) can be proved to be; /// equal to {`ExtendOpTy`(`Start`),+,`ExtendOpTy`(`Step`)}. This is; /// equivalent to proving no signed (resp. unsigned) wrap in; /// {`Start`,+,`Step`} if `ExtendOpTy` is `SCEVSignExtendExpr`; /// (resp. `SCEVZeroExtendExpr`).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:19,Integrability,wrap,wrap,19,/// Return SCEV no-wrap flags that can be proven based on reasoning about; /// how poison produced from no-wrap flags on this value (e.g. a nuw add); /// would trigger undefined behavior on overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:107,Integrability,wrap,wrap,107,/// Return SCEV no-wrap flags that can be proven based on reasoning about; /// how poison produced from no-wrap flags on this value (e.g. a nuw add); /// would trigger undefined behavior on overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper around the above for cases which don't care if the bound; /// is precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:425,Performance,cache,caches,425,"/// Similar to createAddRecFromPHI, but with the additional flexibility of; /// suggesting runtime overflow checks in case casts are encountered.; /// If successful, the analysis records that for this loop, \p SymbolicPHI,; /// which is the UnknownSCEV currently representing the PHI, can be rewritten; /// into an AddRec, assuming some predicates; The function then returns the; /// AddRec and the predicates as a pair, and caches this pair in; /// PredicatedSCEVRewrites.; /// If the analysis is not successful, a mapping from the \p SymbolicPHI to; /// itself (with no predicates) is recorded, and a nullptr with an empty; /// predicates vector is returned as a pair.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:218,Modifiability,variab,variable,218,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:273,Modifiability,variab,variable,273,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:404,Testability,assert,assert,404,"/// Compute the maximum backedge count based on the range of values; /// permitted by Start, End, and Stride. This is for loops of the form; /// {Start, +, Stride} LT End.; ///; /// Preconditions:; /// * the induction variable is known to be positive.; /// * the induction variable is assumed not to overflow (i.e. either it; /// actually doesn't, or we'd have to immediately execute UB); /// We *don't* assert these preconditions so please be careful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:4,Performance,Cache,Cache,4,"/// Cache tentative mappings from UnknownSCEVs in a Loop, to a SCEV expression; /// they can be rewritten into under certain predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:103,Deployability,release,releaseMemory,103,/// The head of a linked list of all SCEVUnknown values that have been; /// allocated. This is used by releaseMemory to locate them all and call; /// their destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:76,Energy Efficiency,allocate,allocated,76,/// The head of a linked list of all SCEVUnknown values that have been; /// allocated. This is used by releaseMemory to locate them all and call; /// their destructors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:23,Security,expose,exposes,23,/// Analysis pass that exposes the \c ScalarEvolution for a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:7,Integrability,interface,interface,7,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:259,Integrability,interface,interface,259,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:686,Modifiability,rewrite,rewrites,686,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:252,Usability,simpl,simple,252,"/// An interface layer with SCEV used to manage how we see SCEV expressions; /// for values in the context of existing predicates. We can add new; /// predicates, but we cannot remove them.; ///; /// This layer has multiple purposes:; /// - provides a simple interface for SCEV versioning.; /// - guarantees that the order of transformations applied on a SCEV; /// expression for a single Value is consistent across two different; /// getSCEV calls. This means that, for example, once we've obtained; /// an AddRec expression for a certain value through expression; /// rewriting, we will continue to get an AddRec expression for that; /// Value.; /// - lowers the number of expression rewrites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:48,Integrability,wrap,wrap,48,/// Returns true if we've proved that V doesn't wrap by means of a SCEV; /// predicate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:87,Modifiability,rewrite,rewrite,87,/// Holds a SCEV and the version number of the SCEV predicate used to; /// perform the rewrite of the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:75,Performance,perform,perform,75,/// Holds a SCEV and the version number of the SCEV predicate used to; /// perform the rewrite of the expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:23,Modifiability,rewrite,rewrite,23,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:164,Modifiability,rewrite,rewrite,164,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:227,Modifiability,rewrite,rewrites,227,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:245,Modifiability,rewrite,rewrite,245,"/// Maps a SCEV to the rewrite result of that SCEV at a certain version; /// number. If this number doesn't match the current Generation, we will; /// need to do a rewrite. To preserve the transformation order of previous; /// rewrites, we will rewrite the previous result instead of the original; /// SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:54,Modifiability,rewrite,rewrite,54,/// The SCEVPredicate that forms our context. We will rewrite all; /// expressions assuming that this predicate true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:208,Modifiability,rewrite,rewrite,208,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:266,Modifiability,rewrite,rewrite,266,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h:252,Performance,perform,perform,252,"/// Marks the version of the SCEV predicate used. When rewriting a SCEV; /// expression we mark it with the version of the predicate. We use this to; /// figure out if the predicate has changed from the last rewrite of the; /// SCEV. If so, we need to perform a new rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolution.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:403,Integrability,interface,interface,403,"//===- ScalarEvolutionAliasAnalysis.h - SCEV-based AA -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This is the interface for a SCEV-based alias analysis.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:6,Usability,simpl,simple,6,/// A simple alias analysis implementation that uses ScalarEvolution to answer; /// queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the SCEVAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:85,Usability,simpl,simpler,85,// These should be ordered in terms of increasing complexity to make the; // folders simpler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:90,Performance,scalab,scalable,90,"/// This class represents the value of vscale, as used when defining the length; /// of a scalable vector or returned by the llvm.vscale() intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:46,Energy Efficiency,allocate,allocates,46,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:216,Safety,avoid,avoids,216,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:126,Usability,simpl,simple,126,"// Since SCEVs are immutable, ScalarEvolution allocates operand; // arrays with its SCEVAllocator, so this class just needs a simple; // pointer rather than a more elaborate vector-like data structure.; // This also avoids the need for a non-trivial destructor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:43,Usability,clear,clearing,43,/// Set flags for a non-recurrence without clearing previously set flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:151,Integrability,depend,depend,151,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:224,Safety,avoid,avoid,224,"// In most cases the types of LHS and RHS will be the same, but in some; // crazy cases one or the other may be a pointer. ScalarEvolution doesn't; // depend on the type for correctness, but handling types carefully can; // avoid extra casts in the SCEVExpander. The LHS is more likely to be; // a pointer type than the RHS, so use the RHS' type here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:231,Integrability,wrap,wraparound,231,"/// Constructs and returns the recurrence indicating how much this; /// expression steps by. If this is a polynomial of degree N, it; /// returns a chrec of degree N-1. We cannot determine whether; /// the step recurrence has self-wraparound.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:39,Usability,clear,clearing,39,"/// Set flags for a recurrence without clearing any previously set flags.; /// For AddRec, either NUW or NSW implies NW. Keep track of this fact here; /// to make it easier to propagate flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:43,Usability,clear,clearing,43,/// Set flags for a non-recurrence without clearing previously set flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:54,Deployability,update,update,54,/// The parent ScalarEvolution value. This is used to update the; /// parent's maps when the value associated with a SCEVUnknown is; /// deleted or RAUW'd.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:25,Usability,simpl,simple,25,/// This class defines a simple visitor class that may be used for; /// various SCEV analysis purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:107,Performance,cache,cached,107,"/// This visitor recursively visits a SCEV expression and re-writes it.; /// The result from each visit is cached, so it will return the same; /// SCEV for the same input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:111,Availability,redundant,redundant,111,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:105,Safety,avoid,avoid,105,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:111,Safety,redund,redundant,111,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:331,Testability,test,tests,331,"// Memoize the result of each visit so that we only compute once for; // the same input SCEV. This is to avoid redundant computations when; // a SCEV is referenced by multiple SCEVs. Without memoization, this; // visit algorithm would have exponential time complexity in the worst; // case, causing the compiler to hang on certain tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h:70,Deployability,update,updates,70,/// The SCEVParameterRewriter takes a scalar evolution expression and updates; /// the SCEVUnknown components following the Map (Value -> SCEV).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionExpressions.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h:919,Modifiability,variab,variables,919,"//===- llvm/Analysis/ScalarEvolutionNormalization.h - See below -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines utilities for working with ""normalized"" ScalarEvolution; // expressions.; //; // The following example illustrates post-increment uses and how normalized; // expressions help.; //; // for (i=0; i!=n; ++i) {; // ...; // }; // use(i);; //; // While the expression for most uses of i inside the loop is {0,+,1}<%L>, the; // expression for the use of i outside the loop is {1,+,1}<%L>, since i is; // incremented at the end of the loop body. This is inconveient, since it; // suggests that we need two different induction variables, one that starts; // at 0 and one that starts at 1. We'd prefer to be able to think of these as; // the same induction variable, with uses inside the loop using the; // ""pre-incremented"" value, and uses after the loop using the; // ""post-incremented"" value.; //; // Expressions for post-incremented uses are represented as an expression; // paired with a set of loops for which the expression is in ""post-increment""; // mode (there may be multiple loops).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h:1048,Modifiability,variab,variable,1048,"//===- llvm/Analysis/ScalarEvolutionNormalization.h - See below -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines utilities for working with ""normalized"" ScalarEvolution; // expressions.; //; // The following example illustrates post-increment uses and how normalized; // expressions help.; //; // for (i=0; i!=n; ++i) {; // ...; // }; // use(i);; //; // While the expression for most uses of i inside the loop is {0,+,1}<%L>, the; // expression for the use of i outside the loop is {1,+,1}<%L>, since i is; // incremented at the end of the loop body. This is inconveient, since it; // suggests that we need two different induction variables, one that starts; // at 0 and one that starts at 1. We'd prefer to be able to think of these as; // the same induction variable, with uses inside the loop using the; // ""pre-incremented"" value, and uses after the loop using the; // ""post-incremented"" value.; //; // Expressions for post-incremented uses are represented as an expression; // paired with a set of loops for which the expression is in ""post-increment""; // mode (there may be multiple loops).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScalarEvolutionNormalization.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:407,Integrability,interface,interface,407,"//===- ScopedNoAliasAA.h - Scoped No-Alias Alias Analysis -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is the interface for a metadata-based scoped no-alias analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:6,Usability,simpl,simple,6,/// A simple AA result which uses scoped-noalias metadata to answer queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the ScopedNoAliasAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ScopedNoAliasAA.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:8,Usability,Simpl,SimplifyQuery,8,"//===-- SimplifyQuery.h - Context for simplifications -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:38,Usability,simpl,simplifications,38,"//===-- SimplifyQuery.h - Context for simplifications -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:31,Integrability,interface,interface,31,"/// InstrInfoQuery provides an interface to query additional information for; /// instructions like metadata or keywords like nsw, which provides conservative; /// results if the users specified it is safe to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:201,Safety,safe,safe,201,"/// InstrInfoQuery provides an interface to query additional information for; /// instructions like metadata or keywords like nsw, which provides conservative; /// results if the users specified it is safe to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:3,Integrability,Wrap,Wrapper,3,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:159,Safety,safe,safely,159,"// Wrapper to query additional information for instructions like metadata or; // keywords like nsw, which provides conservative results if those cannot; // be safely used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:21,Usability,simpl,simplifications,21,"/// Controls whether simplifications are allowed to constrain the range of; /// possible values for uses of undef. If it is false, simplifications are not; /// allowed to assume a particular value for a use of undef for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h:131,Usability,simpl,simplifications,131,"/// Controls whether simplifications are allowed to constrain the range of; /// possible values for uses of undef. If it is false, simplifications are not; /// allowed to assume a particular value for a use of undef for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SimplifyQuery.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:188,Energy Efficiency,power,power,188,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:362,Safety,avoid,avoid,362,"/// AbstractLatticeFunction - This class is implemented by the dataflow instance; /// to specify what the lattice values are and how they handle merges etc. This; /// gives the client the power to compute lattice values from instructions,; /// constants, etc. The current requirement is that lattice values must be; /// copyable. At the moment, nothing tries to avoid copying. Additionally,; /// lattice keys must be able to be used as keys of a mapping data structure.; /// Internally, the generic solver currently uses a DenseMap to map lattice keys; /// to lattice values. If the lattice key is a non-standard type, a; /// specialization of DenseMapInfo must be provided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:182,Safety,avoid,avoid,182,"/// IsUntrackedValue - If the specified LatticeKey is obviously uninteresting; /// to the analysis (i.e., it would always return UntrackedVal), this; /// function can return true to avoid pointless work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:128,Availability,down,down,128,/// MergeValues - Compute and return the merge of the two specified lattice; /// values. Merging should only move one direction down the lattice to; /// guarantee convergence (toward overdefined).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:10,Safety,safe,safe,10,"// always safe, never useful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:4,Deployability,Update,UpdateState,4,"/// UpdateState - When the state of some LatticeKey is potentially updated to; /// the given LatticeVal, this function notices and adds the LLVM value; /// corresponding the key to the work list, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:67,Deployability,update,updated,67,"/// UpdateState - When the state of some LatticeKey is potentially updated to; /// the given LatticeVal, this function notices and adds the LLVM value; /// corresponding the key to the work list, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:18,Deployability,Update,Update,18,// No change.; // Update the state of the given LatticeKey and add its corresponding LLVM; // value to the work list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:25,Modifiability,variab,variables,25,// Overdefined condition variables can branch either way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:22,Modifiability,variab,variables,22,// Constant condition variables mean the branch can only go a single way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:105,Availability,down,down,105,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be interesting,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:3,Deployability,Update,Update,3,"// Update the PHI with the compute value, which is the merge of the inputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h:39,Testability,log,logic,39,"// PHIs are handled by the propagation logic, they are never passed into the; // transfer functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/SparsePropagation.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:21,Availability,alive,alive,21,"// Controls what is ""alive"" if control flow may reach the instruction; // with a different liveness of the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:10,Availability,alive,alive,10,// May be alive on some path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:11,Availability,alive,alive,11,// Must be alive on every path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:34,Availability,alive,alive,34,/// Returns true if the alloca is alive after the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h:21,Testability,test,testing,21,/// Printer pass for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackLifetime.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:44,Safety,safe,safety,44,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:389,Safety,Safe,Safety,389,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:405,Safety,detect,detects,405,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:440,Safety,safe,safe,440,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:445,Security,access,access,445,"//===- StackSafetyAnalysis.h - Stack memory safety analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Stack Safety Analysis detects allocas and arguments with safe access.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:4,Integrability,Interface,Interface,4,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:30,Safety,safe,safety,30,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:17,Security,access,access,17,/// Interface to access stack safety analysis results for single function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:65,Security,access,access,65,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:155,Security,access,access,155,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:328,Security,access,access,328,"/// Parameters use for a FunctionSummary.; /// Function collects access information of all pointer parameters.; /// Information includes a range of direct access of parameters by the; /// functions and all call sites accepting the parameter.; /// StackSafety assumes that missing parameter information means possibility; /// of access to the parameter with any offset, so we can correctly link; /// code without StackSafety information, e.g. non-ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:33,Security,access,accesses,33,// Whether we can prove that all accesses to this Alloca are in-range and; // during its lifetime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:84,Security,access,accesses,84,// Returns true if the instruction can be proven to do only two types of; // memory accesses:; // (1) live stack locations in-bounds or; // (2) non-stack locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:20,Integrability,wrap,wrapper,20,/// StackSafetyInfo wrapper for the new pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:20,Integrability,wrap,wrapper,20,/// StackSafetyInfo wrapper for the legacy pass manager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,Performance,perform,performs,14,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,Safety,safe,safety,58,/// This pass performs the global (interprocedural) stack safety analysis (new; /// pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:14,Performance,perform,performs,14,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h:58,Safety,safe,safety,58,/// This pass performs the global (interprocedural) stack safety analysis; /// (legacy pass manager).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StackSafetyAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h:35,Security,Hash,Hash,35,"//=- StructuralHash.h - Structural Hash Printing --*- C++ -*-----------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/StructuralHash.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:536,Integrability,depend,dependent,536,"//====- TargetFolder.h - Constant folding helper ---------------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TargetFolder class, a helper for IRBuilder.; // It provides IRBuilder with a set of methods for creating constants with; // target dependent folding, in addition to the same target-independent; // folding that the ConstantFolder class provides. For general constant; // creation and folding, use ConstantExpr and the routines in; // llvm/Analysis/ConstantFolding.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:722,Integrability,rout,routines,722,"//====- TargetFolder.h - Constant folding helper ---------------*- C++ -*-====//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the TargetFolder class, a helper for IRBuilder.; // It provides IRBuilder with a set of methods for creating constants with; // target dependent folding, in addition to the same target-independent; // folding that the ConstantFolder class provides. For general constant; // creation and folding, use ConstantExpr and the routines in; // llvm/Analysis/ConstantFolding.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:48,Integrability,depend,dependent,48,/// TargetFolder - Create constants with target dependent folding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:175,Usability,simpl,simplified,175,//===--------------------------------------------------------------------===//; // Value-based folders.; //; // Return an existing value or a constant if the operation can be simplified.; // Otherwise return nullptr.; //===--------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h:3,Safety,avoid,avoid,3,// avoid calling Fold,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetFolder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:245,Availability,mask,mask,245,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:332,Availability,mask,mask,332,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:444,Availability,mask,mask,444,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:459,Availability,mask,masked,459,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:477,Availability,mask,mask,477,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:507,Performance,concurren,concurrent,507,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:623,Performance,scalab,scalable,623,"/// Provides info so a possible vectorization of a function can be; /// computed. Function 'VectorFnName' is equivalent to 'ScalarFnName'; /// vectorized by a factor 'VectorizationFactor'.; /// The VABIPrefix string holds information about isa, mask, vlen,; /// and vparams so a scalar-to-vector mapping of the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>); /// can be constructed where:; ///; /// <isa> = ""_LLVM_""; /// <mask> = ""M"" if masked, ""N"" if no mask.; /// <vlen> = Number of concurrent lanes, stored in the `VectorizationFactor`; /// field of the `VecDesc` struct. If the number of lanes is scalable; /// then 'x' is printed instead.; /// <vparams> = ""v"", as many as are the numArgs.; /// <scalarname> = the name of the scalar function.; /// <vectorname> = the name of the vector function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:77,Availability,mask,mask,77,/// Returns a vector function ABI variant string on the form:; /// _ZGV<isa><mask><vlen><vparams>_<scalarname>(<vectorname>),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:151,Availability,avail,available,151,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:221,Integrability,depend,depends,221,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:307,Integrability,wrap,wrapper,307,"/// Implementation of the target library information.; ///; /// This class constructs tables that hold the target library information and; /// make it available. However, it is somewhat expensive to compute and only; /// depends on the triple. So users typically interact with the \c; /// TargetLibraryInfo wrapper below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:121,Availability,avail,available,121,"/// Return true if the function type FTy is valid for the library function; /// F, regardless of whether the function is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:7,Performance,Perform,Performance,7,// Arm Performance Libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,Availability,avail,available,38,/// Forces a function to be marked as available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:38,Availability,avail,available,38,/// Forces a function to be marked as available and provide an alternate name; /// that must be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:58,Availability,avail,available,58,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:124,Performance,optimiz,optimizations,124,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:198,Performance,optimiz,optimizations,198,/// Provides information about what library functions are available for; /// the current target.; ///; /// This both allows optimizations to handle them specially and frontends to; /// disable such optimizations through -fno-builtin etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:121,Availability,avail,available,121,"/// Return true if the function type FTy is valid for the library function; /// F, regardless of whether the function is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:40,Availability,avail,available,40,/// Tests whether a library function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:4,Testability,Test,Tests,4,/// Tests whether a library function is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:34,Availability,avail,available,34,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:64,Performance,optimiz,optimized,64,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h:4,Testability,Test,Tests,4,/// Tests if the function is both available and a candidate for optimized code; /// generation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetLibraryInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:605,Integrability,interface,interface,605,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:775,Integrability,interface,interface,775,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:401,Security,expose,exposes,401,"//===- TargetTransformInfo.h ------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This pass exposes codegen information to IR-level passes. Every; /// transformation that uses codegen information is broken into three parts:; /// 1. The IR-level analysis pass.; /// 2. The IR-level transformation interface which provides the needed; /// information.; /// 3. Codegen-level implementation which uses target-specific hooks.; ///; /// This file defines #2, which is the interface that IR-level transformations; /// use for querying the codegen.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Performance,load,load,24,/// Information about a load/store intrinsic defined by the target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,Performance,load,loading,46,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:114,Performance,optimiz,optimization,114,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:202,Performance,load,load,202,"/// This is the pointer that the intrinsic is loading from or storing to.; /// If this is non-null, then analysis/optimization passes can assume that; /// this intrinsic is functionally equivalent to a load/store from this; /// pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,load,load,50,// Same Id is set by the target for corresponding load/store intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,Integrability,depend,dependent,27,/// Attributes of a target dependent hardware loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Deployability,update,updated,26,// Should loop counter be updated in; // the loop via a phi?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,perform,performs,37,// Generate the intrinsic which also performs; // icmp ne zero on the loop counter value and; // produces an i1 to guard the loop entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Availability,mask,mask,26,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:101,Energy Efficiency,power,power-of-,101,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:327,Energy Efficiency,power,power-of-,327,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:237,Modifiability,variab,variable,237,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:500,Modifiability,variab,variable,500,"/// Use predicate only to mask operations on data in the loop.; /// When the VL is not known to be a power-of-2, this method requires a; /// runtime overflow check for the i + VL in the loop because it compares the; /// scalar induction variable against the tripcount rounded up by VL which may; /// overflow. When the VL is a power-of-2, both the increment and uprounded; /// tripcount will overflow to 0, which does not require a runtime check; /// since the loop is exited when the loop induction variable equals the; /// uprounded trip-count, which are both 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:55,Availability,mask,mask,55,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:92,Availability,mask,mask,92,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:254,Availability,mask,mask,254,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Safety,avoid,avoids,22,"/// Same as Data, but avoids using the get.active.lane.mask intrinsic to; /// calculate the mask and instead implements this with a; /// splat/stepvector/cmp.; /// FIXME: Can this kind be removed now that SelectionDAGBuilder expands the; /// active.lane.mask intrinsic when it is not natively supported?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:222,Availability,mask,mask,222,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:244,Availability,mask,mask,244,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:310,Availability,mask,mask,310,"/// Use predicate to control both data and control flow.; /// This method always requires a runtime overflow check for the i + VL; /// increment inside the loop, because it uses the result direclty in the; /// active.lane.mask to calculate the mask for the next iteration. If the; /// increment overflows, the mask is no longer correct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:128,Safety,avoid,avoided,128,"/// Use predicate to control both data and control flow, but modify; /// the trip count so that a runtime overflow check can be avoided; /// and such that the scalar epilogue loop can always be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:45,Integrability,interface,interfaces,45,/// This pass provides access to the codegen interfaces that are needed; /// for IR-level transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:23,Security,access,access,23,/// This pass provides access to the codegen interfaces that are needed; /// for IR-level transformations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,Integrability,wrap,wrapping,137,/// Construct a TTI object using a type implementing the \c Concept; /// API below.; ///; /// This is used by targets to construct a TTI wrapping their target-specific; /// implementation that encodes appropriate costs for their target.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,Performance,throughput,throughput,16,///< Reciprocal throughput.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:9,Performance,latency,latency,9,///< The latency of instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:34,Performance,latency,latency,34,///< The weighted sum of size and latency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:51,Integrability,interface,interface,51,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:90,Integrability,interface,interface,90,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:703,Testability,test,test,703,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:534,Usability,simpl,simple,534,"/// Underlying constants for 'cost' values in this interface.; ///; /// Many APIs in this interface return a cost. This enum defines the; /// fundamental values that should be used to interpret (and produce) those; /// costs. The costs are returned as an int rather than a member of this; /// enumeration because it is expected that the cost of one IR instruction; /// may have a multiplicative factor to it or otherwise won't fit directly; /// into the enum. Moreover, it is common to sum or average costs which works; /// better as simple integral values. Thus this enum only provides constants.; /// Also note that the returned costs are signed integers to make it natural; /// to add, subtract, and test with zero (a common boundary condition). It is; /// not expected that 2^32 is a realistic cost to be modeling at any point.; ///; /// Note that these costs should usually reflect the intersection of code-size; /// cost and execution cost. A free instruction is typically one that folds; /// into another instruction. For example, reg-to-reg moves can often be; /// skipped by renaming the registers in the CPU, but they still are encoded; /// and thus wouldn't be considered 'free' here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:428,Performance,load,load,428,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:241,Security,Access,AccessType,241,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:297,Security,access,accessed,297,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:443,Security,Access,AccessType,443,"/// Estimate the cost of a GEP operation when lowered.; ///; /// \p PointeeType is the source element type of the GEP.; /// \p Ptr is the base pointer operand.; /// \p Operands is the list of indices following the base pointer.; ///; /// \p AccessType is a hint as to what type of memory might be accessed by; /// users of the GEP. getGEPCost will use it to determine if the GEP can be; /// folded into the addressing mode of a load/store. If AccessType is null,; /// then the resulting target type based off of PointeeType will be used as an; /// approximation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:92,Performance,load,loads,92,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:192,Performance,load,loads,192,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:164,Security,Access,AccessTy,164,/// Estimate the cost of a chain of pointers (typically pointer operands of a; /// chain of loads or stores within same block) operations set when lowered.; /// \p AccessTy is the type of the loads/stores that will ultimately use the; /// \p Ptrs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:370,Modifiability,evolve,evolved,370,/// \returns Vector bonus in percent.; ///; /// Vector bonuses: We want to more aggressively inline vector-dense kernels; /// and apply this bonus based on the percentage of vector instructions. A; /// bonus is applied if the vector instructions exceed 50% and half that; /// amount is applied if it exceeds 10%. Note that these bonuses are some what; /// arbitrary and evolved over time by accident as much as because they are; /// principled bonuses.; /// FIXME: It would be nice to base the bonus values on something more; /// scientific. A target may has no bonus on vector instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:60,Integrability,depend,depend,60,"/// \return the expected cost of a memcpy, which could e.g. depend on the; /// source/destination type and alignment and the number of bytes copied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Safety,predict,predicted,120,"/// If a branch or a select condition is skewed in one direction by more than; /// this factor, it is very likely to be predicted correctly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,Performance,perform,performance,116,"/// Return true if branch divergence exists.; ///; /// Branch divergence has a significantly negative impact on GPU performance; /// when threads in the same wavefront take different paths due to conditional; /// branches.; ///; /// If \p F is passed, provides a context function. If \p F is known to only; /// execute in a single threaded environment, the target may choose to skip; /// uniformity analysis and assume all values are uniform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:93,Integrability,depend,dependent,93,/// Returns whether V is a source of divergence.; ///; /// This function provides the target-dependent information for; /// the target-independent UniformityAnalysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:741,Performance,optimiz,optimizations,741,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:913,Performance,optimiz,optimize,913,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:268,Security,access,access,268,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:339,Security,Access,Access,339,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:491,Security,access,accessed,491,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:785,Security,access,access,785,"/// Returns the address space ID for a target's 'flat' address space. Note; /// this is not necessarily the same as addrspace(0), which LLVM sometimes; /// refers to as the generic address space. The flat address space is a; /// generic address space that can be used access multiple segments of memory; /// with different address spaces. Access of a memory location through a; /// pointer with this address space is expected to be legal but slower; /// compared to the same memory location accessed through a pointer with a; /// different address space.; //; /// This is for targets with different pointer representations which can; /// be converted with the addrspacecast instruction. If a pointer is converted; /// to this address space, optimizations should attempt to replace the access; /// with the source address space.; ///; /// \returns ~0u if the target does not have such a flat address space to; /// optimize away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite intrinsic call \p II such that \p OldV will be replaced with \p; /// NewV, which has a different address space. This should happen for every; /// operand index that collectFlatAddressOperands returned for the intrinsic.; /// \returns nullptr if the intrinsic was not handled. Otherwise, returns the; /// new value (which may be the original \p II with modified operands).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:423,Integrability,interface,interface,423,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Testability,Test,Test,4,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:107,Testability,test,test,107,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:256,Usability,clear,clear,256,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:341,Usability,simpl,simpler,341,"/// Test whether calls to a function lower to actual program function; /// calls.; ///; /// The idea is to test whether the program is likely to require a 'call'; /// instruction or equivalent in order to call the given function.; ///; /// FIXME: It's not clear that this is a good or useful query API. Client's; /// should probably move to simpler cost metrics using the above.; /// Alternatively, we could split the cost interface into distinct code-size; /// and execution-speed costs. This would allow modelling the core of this; /// query more accurately as a call is a single small instruction, but; /// incurs significant execution cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:213,Integrability,interface,interface,213,"/// The cost threshold for the unrolled loop. Should be relative to the; /// getInstructionCost values returned by this API, and the expectation is; /// that the unrolled loop's instructions when run through that interface; /// should not exceed this cost. However, this is only an estimate. Also,; /// specific loops may be unrolled even with a cost above this threshold if; /// deemed profitable. Set this to UINT_MAX to disable the loop body cost; /// restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,Energy Efficiency,reduce,reduce,31,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:425,Energy Efficiency,reduce,reduces,425,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:555,Energy Efficiency,reduce,reduce,555,"/// If complete unrolling will reduce the cost of the loop, we will boost; /// the Threshold by a certain percent to allow more aggressive complete; /// unrolling. This value provides the maximum boost percentage that we; /// can apply to Threshold (The value should be no less than 100).; /// BoostedThreshold = Threshold * min(RolledCost / UnrolledCost,; /// MaxPercentThresholdBoost / 100); /// E.g. if complete unrolling reduces the loop execution time by 50%; /// then we boost the threshold by the factor of 2x. If unrolling is not; /// expected to reduce the running time, then we do not increase the; /// threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,optimiz,optimizing,50,/// The cost threshold for the unrolled loop when optimizing for size (set; /// to UINT_MAX to disable).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:50,Performance,optimiz,optimizing,50,"/// The cost threshold for the unrolled loop when optimizing for size, like; /// OptSizeThreshold, but used for partial/runtime unrolling (set to; /// UINT_MAX to disable).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,optimiz,optimized,37,"// Represents number of instructions optimized when ""back edge""; // becomes ""fall through"" in unrolled loop.; // For now we count a conditional branch on a backedge and a comparison; // feeding it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:101,Safety,avoid,avoid,101,"/// Query the target whether it would be prefered to create a predicated; /// vector loop, which can avoid the need to emit a scalar epilogue loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:134,Deployability,update,update,134,"/// Query the target what the preferred style of tail folding is.; /// \param IVUpdateMayOverflow Tells whether it is known if the IV update; /// may (or will never) overflow for the suggested VF/UF in the given loop.; /// Targets can use this information to select a more optimal tail folding; /// style. The value conservatively defaults to true, such that no assumptions; /// are made on overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:216,Performance,perform,performance,216,"/// @}; /// \name Scalar Target Information; /// @{; /// Flags indicating the kind of support for population count.; ///; /// Compared to the SW implementation, HW support is supposed to; /// significantly boost the performance when the population is dense, and it; /// may or may not degrade performance if the population is sparse. A HW; /// support is considered as ""Fast"" if it can outperform, or is on a par; /// with, SW implementation when the population is sparse; otherwise, it is; /// considered as ""Slow"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:293,Performance,perform,performance,293,"/// @}; /// \name Scalar Target Information; /// @{; /// Flags indicating the kind of support for population count.; ///; /// Compared to the SW implementation, HW support is supposed to; /// significantly boost the performance when the population is dense, and it; /// may or may not degrade performance if the population is sparse. A HW; /// support is considered as ""Fast"" if it can outperform, or is on a par; /// with, SW implementation when the population is sparse; otherwise, it is; /// considered as ""Slow"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:94,Performance,load,load,94,"/// Return true if the addressing mode represented by AM is legal for; /// this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// If target returns true in LSRWithInstrQueries(), I may be valid.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:231,Performance,load,load,231,"/// Return true if the addressing mode represented by AM is legal for; /// this target, for a load/store of the specified type.; /// The type may be VoidTy, in which case only return true if the addressing; /// mode is legal for a load/store of any legal type.; /// If target returns true in LSRWithInstrQueries(), I may be valid.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:132,Availability,avail,available,132,"/// Return true if LSR should attempts to replace a use of an otherwise dead; /// primary IV in the latch condition with another IV available in the loop.; /// When successful, makes the primary IV dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,optimiz,optimize,36,/// \returns true if LSR should not optimize a chain that includes \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:46,Performance,load,load,46,/// Return true if the target supports masked load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:51,Performance,load,load,51,/// Return true if the target supports nontemporal load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,Performance,load,load,56,/// \Returns true if the target supports broadcasting a load to a vector of; /// type <NumElements x ElementTy>.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked scatter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked gather.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,Availability,mask,masked,57,/// Return true if the target forces scalarizing of llvm.masked.gather; /// intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:57,Availability,mask,masked,57,/// Return true if the target forces scalarizing of llvm.masked.scatter; /// intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked compress store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:39,Availability,mask,masked,39,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Performance,load,load,53,/// Return true if the target supports masked expand load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:336,Availability,mask,mask,336,/// Return true if this is an alternating opcode pattern that can be lowered; /// to a single instruction on the target. In X86 this is for the addsub; /// instruction which corrsponds to a Shuffle + Fadd + FSub pattern in IR.; /// This function expectes two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:344,Performance,throughput,throughput,344,"/// Return true if the target has a unified operation to calculate division; /// and remainder. If so, the additional implicit multiplication and; /// subtraction required to calculate a remainder from division are free. This; /// can enable more aggressive transformations for division and remainder than; /// would typically be allowed using throughput or size cost models.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:197,Performance,load,loads,197,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:311,Performance,load,loads,311,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Safety,avoid,avoid,145,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:65,Security,access,access,65,"/// Return true if the given instruction (assumed to be a memory access; /// instruction) has a volatile variant. If that's the case then we can avoid; /// addrspacecast to generic AS for volatile loads/stores. Default; /// implementation returns false, which prevents address space inference for; /// volatile loads/stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:116,Performance,load,load,116,"/// Return the cost of the scaling factor used in the addressing; /// mode represented by AM for this target, for a load/store; /// of the specified type.; /// If the AM is supported, the return value must be >= 0.; /// If the AM is not supported, it returns a negative value.; /// TODO: Handle pre/postinc as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Energy Efficiency,reduce,reduce,37,"/// Return true if the loop strength reduce pass should make; /// Instruction* based TTI queries to isLegalAddressingMode(). This is; /// needed on SystemZ, where e.g. a memcpy can only have a 12 bit unsigned; /// immediate offset and no index register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:18,Energy Efficiency,efficient,efficient,18,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,load,load,43,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:182,Performance,load,load,182,"/// If target has efficient vector element load/store instructions, it can; /// return true here so that insertion/extraction costs are not added to; /// the scalarization cost of a load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:21,Performance,load,load,21,// Maximum number of load operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Availability,avail,available,15,"// The list of available load sizes (in bytes), sorted in decreasing order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:25,Performance,load,load,25,"// The list of available load sizes (in bytes), sorted in decreasing order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Performance,load,load,120,"// For memcmp expansion when the memcmp result is only compared equal or; // not-equal to 0, allow up to this number of load pairs per block. As an; // example, this may allow 'memcmp(a, b, 3) == 0' in a single block:; // a0 = load2bytes &a[0]; // b0 = load2bytes &b[0]; // a2 = load1byte &a[2]; // b2 = load1byte &b[2]; // r = cmp eq (a0 ^ b0 | a2 ^ b2), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,loads,36,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:167,Performance,load,loads,167,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:176,Performance,Load,LoadSizes,176,"// Set to true to allow overlapping loads. For example, 7-byte compares can; // be done with two 4-byte compares instead of 4+2+1-byte compares. This; // requires all loads in LoadSizes to be doable in an unaligned way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:255,Energy Efficiency,efficient,efficiently,255,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:124,Performance,load,loaded,124,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Performance,load,load,145,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,load,loading,270,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:431,Performance,load,loads,431,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:456,Usability,simpl,simplifies,456,"// Sometimes, the amount of data that needs to be compared is smaller than; // the standard register size, but it cannot be loaded with just one load; // instruction. For example, if the size of the memory comparison is 6; // bytes, we can handle it more efficiently by loading all 6 bytes in a; // single block and generating an 8-byte number, instead of generating two; // separate blocks with conditional jumps for 4 and 2 byte loads. This; // approach simplifies the process and produces the comparison result as; // normal. This array lists the allowed sizes of memcmp tails that can be; // merged into one block",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,Optimiz,Optimization,22,/// Should the Select Optimization pass be enabled and ran.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,Optimiz,Optimization,22,"/// Should the Select Optimization pass treat the given instruction like a; /// select, potentially converting it to a conditional branch. This can; /// include select-like instructions like or(zext(c), x) that can be converted; /// to selects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,access,35,/// Enable matching of interleaved access groups.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:126,Availability,mask,masked,126,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:145,Performance,load,loads,145,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,access,35,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:78,Security,access,accesses,78,/// Enable matching of interleaved access groups that contain predicated; /// accesses or gaps and therefore vectorized using masked; /// vector loads/stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:276,Integrability,depend,depending,276,"/// Indicate that it is potentially unsafe to automatically vectorize; /// floating-point operations because the semantics of vector and scalar; /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math; /// does not support IEEE-754 denormal numbers, while depending on the; /// platform, scalar floating-point math does.; /// This applies to floating-point math operations and calls, not memory; /// operations, shuffles, or casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Safety,unsafe,unsafe,36,"/// Indicate that it is potentially unsafe to automatically vectorize; /// floating-point operations because the semantics of vector and scalar; /// floating-point semantics may differ. For example, ARM NEON v7 SIMD math; /// does not support IEEE-754 denormal numbers, while depending on the; /// platform, scalar floating-point math does.; /// This applies to floating-point math operations and calls, not memory; /// operations, shuffles, or casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:54,Security,access,accesses,54,/// Determine if the target supports unaligned memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:149,Integrability,wrap,wraps,149,"/// Return true if the cost of the instruction is too high to speculatively; /// execute and should be kept behind a branch.; /// This normally just wraps around a getInstructionCost() call, but some; /// targets might report a low TCK_SizeAndLatency value that is incompatible; /// with the fixed TCC_Expensive value.; /// NOTE: This assumes the instruction passes isSafeToSpeculativelyExecute().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:402,Usability,simpl,simpler,402,/// It can be advantageous to detach complex constants from their uses to make; /// their generation cheaper. This hook allows targets to report when such; /// transformations might negatively effect the code generation of the; /// underlying operation. The motivating example is divides whereby hoisting; /// constants prevents the code generator's ability to transform them into; /// combinations of simpler operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:76,Availability,mask,mask,76,///< Merge elements from two source vectors into one; ///< with any shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:69,Availability,mask,mask,69,///< Shuffle elements of single source vector with any; ///< shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:572,Performance,perform,performed,572,"/// \return the target-provided register class ID for the provided type,; /// accounting for type promotion and other type-legalization techniques that; /// the target might apply. However, it specifically does not account for the; /// scalarization or splitting of vector types. Should a vector type require; /// scalarization or splitting into multiple underlying vector registers, that; /// type should be mapped to a register class containing no registers.; /// Specifically, this is designed to provide a simple, high-level view of the; /// register allocation later performed by the backend. These register classes; /// don't necessarily map onto the register classes used by the backend.; /// FIXME: It's not currently possible to determine how many registers; /// are used by the provided type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:510,Usability,simpl,simple,510,"/// \return the target-provided register class ID for the provided type,; /// accounting for type promotion and other type-legalization techniques that; /// the target might apply. However, it specifically does not account for the; /// scalarization or splitting of vector types. Should a vector type require; /// scalarization or splitting into multiple underlying vector registers, that; /// type should be mapped to a register class containing no registers.; /// Specifically, this is designed to provide a simple, high-level view of the; /// register allocation later performed by the backend. These register classes; /// don't necessarily map onto the register classes used by the backend.; /// FIXME: It's not currently possible to determine how many registers; /// are used by the provided type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Performance,tune,tune,35,/// \return the value of vscale to tune the cost model for.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:44,Energy Efficiency,power,power,44,/// \return true if vscale is known to be a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,scalab,scalable,270,"/// \return The minimum vectorization factor for types of given element; /// bit width, or 0 if there is no minimum VF. The returned value only; /// applies when shouldMaximizeVectorBandwidth returns true.; /// If IsScalable is true, the returned ElementCount must be a scalable VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:26,Performance,cache,cache,26,/// \return The size of a cache line in bytes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:17,Performance,cache,cache,17,/// The possible cache levels,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Performance,cache,cache,15,// The L1 data cache,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:15,Performance,cache,cache,15,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:54,Performance,cache,caches,54,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:167,Performance,cache,cache,167,"// The L2 data cache; // We currently do not model L3 caches, as their sizes differ widely between; // microarchitectures. Also, we currently do not have a use for L3 cache; // size modeling yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Availability,avail,available,53,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,Performance,cache,cache,28,"/// \return The size of the cache level in bytes, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Availability,avail,available,53,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:37,Performance,cache,cache,37,"/// \return The associativity of the cache level, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:30,Performance,load,load,30,/// \return How much before a load we should place the prefetch; /// instruction. This is currently measured in number of; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:594,Performance,cache,cache,594,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:35,Security,access,accesses,35,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:311,Security,access,accesses,311,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:388,Security,access,accesses,388,"/// Some HW prefetchers can handle accesses up to a certain constant stride.; /// Sometimes prefetching is beneficial even below the HW prefetcher limit,; /// and the arguments provided are meant to serve as a basis for deciding this; /// for a particular loop.; ///; /// \param NumMemAccesses Number of memory accesses in the loop.; /// \param NumStridedMemAccesses Number of the memory accesses that; /// ScalarEvolution could find a known stride; /// for.; /// \param NumPrefetches Number of software prefetches that will be; /// emitted as determined by the addresses; /// involved and the cache line size.; /// \param HasCall True if the loop contains a call.; ///; /// \return This is the minimum stride in bytes where it makes sense to start; /// adding SW prefetches. The default is 1, i.e. prefetch with any; /// stride.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:155,Performance,perform,performed,155,"/// \return The maximum number of iterations to prefetch ahead. If; /// the required number of iterations is more than this number, no; /// prefetching is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Integrability,depend,depends,117,/// \return The maximum interleave factor that any transform should try to; /// perform for this target. This number depends on the level of parallelism; /// and the number of execution units in the CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:80,Performance,perform,perform,80,/// \return The maximum interleave factor that any transform should try to; /// perform for this target. This number depends on the level of parallelism; /// and the number of execution units in the CPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:295,Integrability,depend,dependency,295,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,throughput,throughput,43,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Performance,throughput,throughput,117,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:170,Performance,throughput,throughput,170,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:880,Performance,optimiz,optimizations,880,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:64,Testability,log,logic,64,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:151,Usability,guid,guides,151,"/// This is an approximation of reciprocal throughput of a math/logic op.; /// A higher cost indicates less expected throughput.; /// From Agner Fog's guides, reciprocal throughput is ""the average number of; /// clock cycles per instruction when the instructions are not part of a; /// limiting dependency chain.""; /// Therefore, costs should be scaled to account for multiple execution units; /// on the target that can process this type of instruction. For example, if; /// there are 5 scalar integer units and 2 vector integer units that can; /// calculate an 'add' in a single cycle, this model should indicate that the; /// cost of the vector add instruction is 2.5 times the cost of the scalar; /// add instruction.; /// \p Args is an optional argument which holds the instruction operands; /// values so the TTI can analyze those values searching for special; /// cases or optimizations based on those values.; /// \p CxtI is the optional original context instruction, if one exists, to; /// provide even more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:341,Availability,mask,mask,341,/// Returns the cost estimation for alternating opcode pattern that can be; /// lowered to a single instruction on the target. In X86 this is for the; /// addsub instruction which corrsponds to a Shuffle + Fadd + FSub pattern in; /// IR. This function expects two opcodes: \p Opcode1 and \p Opcode2 being; /// selected by \p OpcodeMask. The mask contains one bit per lane and is a `0`; /// when \p Opcode0 is selected and `1` when Opcode1 is selected.; /// \p VecTy is the vector type of the instruction to be generated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:90,Availability,mask,mask,90,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:112,Availability,Mask,Mask,112,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:495,Performance,load,loads,495,"/// \return The cost of a shuffle instruction of kind Kind and of type Tp.; /// The exact mask may be passed as Mask, or else the array will be empty.; /// The index and subtype parameters are used by the subvector insertion and; /// extraction shuffle kinds to show the insert/extract point and the type of; /// the subvector being inserted/extracted. The operands of the shuffle can be; /// passed through \p Args, which helps improve the cost estimation in some; /// cases, like in broadcast loads.; /// NOTE: For subvector extractions Tp represents the source type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:151,Performance,load,load,151,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:468,Performance,load,load,468,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:518,Performance,load,load,518,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:816,Performance,load,load,816,"/// Represents a hint about the context in which a cast is used.; ///; /// For zext/sext, the context of the cast is the operand, which must be a; /// load of some kind. For trunc, the context is of the cast is the single; /// user of the instruction, which must be a store of some kind.; ///; /// This enum allows the vectorizer to give getCastInstrCost an idea of the; /// type of cast it's dealing with, as not every cast is equal. For instance,; /// the zext of a load may be free, but the zext of an interleaving load can; //// be (very) expensive!; ///; /// See \c getCastContextHint to compute a CastContextHint from a cast; /// Instruction*. Callers can use it if they don't need to override the; /// context and just want it to be calculated from the instruction.; ///; /// FIXME: This handles the types of load/store that the vectorizer can; /// produce, which are the cases where the context instruction is most; /// likely to be incorrect. There are other situations where that can happen; /// too, which might be handled here but in the long run a more general; /// solution of costing multiple instructions at the same times may be better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:33,Performance,load,load,33,///< The cast is not used with a load/store of any kind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,load,36,///< The cast is used with a normal load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Availability,mask,masked,29,///< The cast is used with a masked load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:36,Performance,load,load,36,///< The cast is used with a masked load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:42,Performance,load,load,42,///< The cast is used with an interleaved load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:38,Performance,load,load,38,///< The cast is used with a reversed load/store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:49,Modifiability,extend,extended,49,/// \return The expected cost of a sign- or zero-extended vector extract. Use; /// Index = -1 to indicate that there is no information about the index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:179,Availability,avail,available,179,/// \return The expected cost of vector Insert and Extract.; /// Use -1 to indicate that there is no information on the index value.; /// This is used when the instruction is not available; a typical use; /// case is to provision the cost of vectorization/scalarization in; /// vectorizer passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:98,Availability,avail,available,98,"/// \return The expected cost of vector Insert and Extract.; /// This is used when instruction is available, and implementation; /// asserts 'I' is not nullptr.; ///; /// A typical suitable use case is cost estimation when vector instruction; /// exists (e.g., from basic blocks during transformation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:133,Testability,assert,asserts,133,"/// \return The expected cost of vector Insert and Extract.; /// This is used when instruction is available, and implementation; /// asserts 'I' is not nullptr.; ///; /// A typical suitable use case is cost estimation when vector instruction; /// exists (e.g., from basic blocks during transformation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:137,Availability,mask,mask,137,"/// \return The cost of replication shuffle of \p VF elements typed \p EltTy; /// \p ReplicationFactor times.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Performance,Load,Load,24,/// \return The cost of Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:27,Performance,Load,Load,27,/// \return The cost of VP Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:24,Availability,mask,masked,24,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:31,Performance,Load,Load,31,/// \return The cost of masked Load and Store instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:318,Availability,mask,mask,318,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:254,Modifiability,Variab,VariableMask,254,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:96,Performance,Load,Load,96,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:159,Performance,load,loaded,159,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:496,Performance,load,load,496,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:89,Security,access,access,89,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:290,Security,access,access,290,"/// \return The cost of Gather or Scatter operation; /// \p Opcode - is a type of memory access Load or Store; /// \p DataTy - a vector type of the data to be loaded or stored; /// \p Ptr - pointer [or vector of pointers] - address[es] in memory; /// \p VariableMask - true when the memory access is predicated with a mask; /// that is not a compile-time constant; /// \p Alignment - alignment of single element; /// \p I - the optional original context instruction, if one exists, e.g. the; /// load/store to transform or the call to the gather/scatter intrinsic",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:534,Availability,mask,masked,534,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:249,Performance,load,load,249,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:283,Performance,load,load,283,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:154,Security,access,access,154,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:461,Security,access,access,461,/// \return The cost of the interleaved memory operation.; /// \p Opcode is the memory operation code; /// \p VecTy is the vector type of the interleaved access.; /// \p Factor is the interleave factor; /// \p Indices is the indices for interleaved load members (as interleaved; /// load allows gaps); /// \p Alignment is the alignment of the memory operation; /// \p AddressSpace is address space of the pointer.; /// \p UseMaskForCond indicates if the memory access is predicated.; /// \p UseMaskForGaps indicates if gaps should be masked.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:270,Performance,perform,performing,270,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:338,Performance,perform,performed,338,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:834,Performance,perform,performing,834,"/// Calculate the cost of vector reduction intrinsics.; ///; /// This is the cost of reducing the vector value of type \p Ty to a scalar; /// value using the operation denoted by \p Opcode. The FastMathFlags; /// parameter \p FMF indicates what type of reduction we are performing:; /// 1. Tree-wise. This is the typical 'fast' reduction performed that; /// involves successively splitting a vector into half and doing the; /// operation on the pair of halves until you have a scalar value. For; /// example:; /// (v0, v1, v2, v3); /// ((v0+v2), (v1+v3), undef, undef); /// ((v0+v2+v1+v3), undef, undef, undef); /// This is the default behaviour for integer operations, whereas for; /// floating point we only do this if \p FMF indicates that; /// reassociation is allowed.; /// 2. Ordered. For a vector with N elements this involves performing N; /// operations in lane order, starting with an initial scalar value, i.e.; /// result = InitVal + v0; /// result = result + v1; /// result = result + v2; /// result = result + v3; /// This is only the case for FP operations and when reassociation is not; /// allowed.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Modifiability,extend,extended,29,"/// Calculate the cost of an extended reduction pattern, similar to; /// getArithmeticReductionCost of an Add reduction with multiply and optional; /// extensions. This is the cost of as:; /// ResTy vecreduce.add(mul (A, B)).; /// ResTy vecreduce.add(mul(ext(Ty A), ext(Ty B)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:29,Modifiability,extend,extended,29,"/// Calculate the cost of an extended reduction pattern, similar to; /// getArithmeticReductionCost of a reduction with an extension.; /// This is the cost of as:; /// ResTy vecreduce.opcode(ext(Ty A)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:499,Security,access,access,499,/// \returns The cost of the address computation. For most targets this can be; /// merged into the instruction indexing mode. Some targets might want to; /// distinguish between address computation for memory operations on vector; /// types and scalar types. Such targets should override this function.; /// The 'SE' parameter holds pointer for the scalar evolution object which; /// is used in order to get the Ptr step value in case of constant stride.; /// The 'Ptr' parameter holds SCEV of the access pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:68,Availability,alive,alive,68,"/// \returns The cost, if any, of keeping values of the given types alive; /// over a callsite.; ///; /// Some types may require the use of register classes that do not have; /// any callee-saved registers, so would require a spill and fill.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:16,Performance,load,load,16,/// The type of load/store indexing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Performance,load,load,43,/// \returns True if the specified indexed load for the given type is legal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:81,Performance,load,load,81,/// \returns The bitwidth of the largest vector type that should be used to; /// load/store in the given address space.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:25,Performance,load,load,25,/// \returns True if the load instruction is legal to vectorize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:56,Performance,load,load,56,/// \returns True if it is legal to vectorize the given load chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:53,Performance,scalab,scalable,53,/// \returns True if the given type is supported for scalable vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:91,Performance,load,loads,91,/// \returns The new vector factor value if the target doesn't support \p; /// SizeInBytes loads or has a better vector factor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:172,Availability,mask,mask,172,"/// \returns True if the target prefers reductions select kept in the loop; /// when tail folding. i.e.; /// loop:; /// p = phi (0, s); /// a = add (p, x); /// s = select (mask, a, p); /// vecreduce.add(s); ///; /// As opposed to the normal scheme of p = phi (0, a) which allows the select; /// to be pulled out of the loop. If the select(.., add, ..) can be predicated; /// by the target, this can lead to cleaner code generation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:41,Performance,scalab,scalable,41,/// \returns True if the target supports scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:22,Performance,scalab,scalable,22,/// \return true when scalable vectorization is preferred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:117,Energy Efficiency,efficient,efficiently,117,"/// \name Vector Predication Information; /// @{; /// Whether the target supports the %evl parameter of VP intrinsic efficiently; /// in hardware, for the given opcode and type/alignment. (see LLVM Language; /// Reference - ""Vector Predication Intrinsics"").; /// Use of %evl is discouraged when that is not the case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:183,Availability,mask,mask,183,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:133,Safety,safe,safe,133,// How to transform the EVL parameter.; // Legal: keep the EVL parameter as it is.; // Discard: Ignore the EVL parameter where it is safe to do so.; // Convert: Fold the EVL into the mask parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:60,Availability,avail,available,60,"/// @}; /// \returns Whether a 32-bit branch instruction is available in Arm or Thumb; /// state.; ///; /// Used by the LowerTypeTests pass, which constructs an IR inline assembler; /// node containing a jump table in a format suitable for the target, so it; /// needs to know what format of jump table it can legally use.; ///; /// For non-Arm targets, this function isn't used. It defaults to returning; /// false, but it shouldn't matter what it returns anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:48,Integrability,wrap,wraps,48,/// The template model for the base class which wraps a concrete; /// implementation in a type erased interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:102,Integrability,interface,interface,102,/// The template model for the base class which wraps a concrete; /// implementation in a type erased interface.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:30,Performance,load,load,30,/// \return How much before a load we should place the prefetch; /// instruction. This is currently measured in number of; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:43,Security,access,accesses,43,"/// \return Some HW prefetchers can handle accesses up to a certain; /// constant stride. This is the minimum stride in bytes where it; /// makes sense to start adding SW prefetches. The default is 1,; /// i.e. prefetch with any stride. Sometimes prefetching is beneficial; /// even below the HW prefetcher limit, and the arguments provided are; /// meant to serve as a basis for deciding this for a particular loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:155,Performance,perform,performed,155,"/// \return The maximum number of iterations to prefetch ahead. If; /// the required number of iterations is more than this number, no; /// prefetching is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:120,Integrability,interface,interface,120,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:110,Security,expose,expose,110,/// Analysis pass providing the \c TargetTransformInfo.; ///; /// The core idea of the TargetIRAnalysis is to expose an interface through; /// which LLVM targets can analyze and provide information about the middle; /// end's target-independent IR. This supports use cases such as target-aware; /// cost modeling of IR constructs.; ///; /// This is a function analysis because much of the cost modeling for targets; /// is done in a subtarget specific way and LLVM supports compiling different; /// functions targeting different subtargets in order to support runtime; /// dispatch according to the observed subtarget.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:462,Availability,error,error,462,"/// The callback used to produce a result.; ///; /// We use a completely opaque callback so that targets can provide whatever; /// mechanism they desire for constructing the TTI for a given function.; ///; /// FIXME: Should we really use std::function? It's relatively inefficient.; /// It might be possible to arrange for even stateful callbacks to outlive; /// the analysis and thus use a function_ref which would be lighter weight.; /// This may also be less error prone as the callback is likely to reference; /// the external TargetMachine, and that reference needs to never dangle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper pass for TargetTransformInfo.; ///; /// This pass can be constructed from a TTI object which it stores internally; /// and is queried by passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:153,Integrability,rout,routines,153,/// We must provide a default constructor for the pass but it should; /// never be used.; ///; /// Use the constructor below or call one of the creation routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:127,Availability,avail,available,127,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h:28,Integrability,wrap,wrapper,28,/// Create an analysis pass wrapper around a TTI object.; ///; /// This analysis pass just holds the TTI instance and makes it available to; /// clients.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:208,Modifiability,refactor,refactorings,208,"// FIXME: These should almost certainly not be handled here, and instead; // handled with the help of TLI or the target itself. This was largely; // ported from existing analysis heuristics here so that such refactorings; // can take place in the future.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:30,Performance,optimiz,optimized,30,// These are all likely to be optimized into something smaller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:52,Availability,avail,available,52,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:120,Energy Efficiency,power,power,120,"// By default, assume nontemporal memory stores are available for stores; // that are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:51,Availability,avail,available,51,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:118,Energy Efficiency,power,power,118,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:41,Performance,load,loads,41,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:65,Performance,load,loads,65,"// By default, assume nontemporal memory loads are available for loads that; // are aligned and have a size that is a power of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:22,Testability,log,logical-and,22,// If the select is a logical-and/logical-or then it is better treated as a; // and/or by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:34,Testability,log,logical-or,34,// If the select is a logical-and/logical-or then it is better treated as a; // and/or by the backend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:113,Performance,optimiz,optimized,113,"// Widenable conditions will eventually lower into constants, so some; // operations with them will be trivially optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:37,Testability,test,tests,37,// FIXME: A number of transformation tests seem to require these values; // which seems a little odd for how arbitary there are.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:16,Performance,latency,latency,16,// Assume a 3cy latency for fp arithmetic ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:49,Performance,throughput,throughput,49,"// A phi would be free, unless we're costing the throughput because it; // will require a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:103,Energy Efficiency,power,power-of-,103,"// Note for overrides: You must ensure for all element unordered-atomic; // memory intrinsics that all power-of-2 element sizes up to, and; // including, the return value of this method have a corresponding; // runtime lib call. These runtime lib call definitions can be found; // in RuntimeLibcalls.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:24,Performance,scalab,scalable,24,"// If this operand is a scalable type, bail out early.; // TODO: Make isLegalAddressingMode TypeSize aware.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:275,Performance,load,load,275,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:369,Performance,load,load,369,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:229,Security,access,access,229,"// If we haven't been provided a hint, use the target type for now.; //; // TODO: Take a look at potentially removing this: This is *slightly* wrong; // as it's possible to have a GEP with a foldable target type but a memory; // access that isn't foldable. For example, this load isn't foldable on; // RISC-V:; //; // %p = getelementptr i32, ptr %base, i32 42; // %x = load <2 x i32>, ptr %p",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:80,Security,access,access,80,"// If the final address of the GEP is a legal addressing mode for the given; // access type, then we can fold it into its users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:563,Integrability,depend,dependecies,563,"// In the basic model we take into account GEP instructions only; // (although here can come alloca instruction, a value, constants and/or; // constant expressions, PHIs, bitcasts ... whatever allowed to be used as a; // pointer). Typically, if Base is a not a GEP-instruction and all the; // pointers are relative to the same base address, all the rest are; // either GEP instructions, PHIs, bitcasts or constants. When we have same; // base, we just calculate cost of each non-Base GEP as an ADD operation if; // any their index is a non-const.; // If no known dependecies between the pointers cost is calculated as a sum; // of costs of GEP instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:29,Security,Access,AccessType,29,"// For now, only provide the AccessType in the simple case where the GEP; // only has one user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:47,Usability,simpl,simple,47,"// For now, only provide the AccessType in the simple case where the GEP; // only has one user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:110,Performance,load,load,110,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:186,Performance,load,load,186,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:319,Performance,load,load,319,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:416,Performance,load,load,416,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:465,Performance,load,load,465,"// If there is a non-register sized type, the cost estimation may expand; // it to be several instructions to load into multiple registers on the; // target. But, if the only use of the load is a trunc instruction to a; // register sized type, the instruction selector can combine these; // instructions to be a single load. So, in this case, we use the; // destination type of the trunc instruction rather than the load to; // accurately estimate the cost of this load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h:94,Performance,throughput,throughput,94,"// By default, just classify everything as 'basic' or -1 to represent that; // don't know the throughput cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TargetTransformInfoImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h:246,Usability,Learn,Learning,246,"/// TensorSpec encapsulates the specification of a tensor: its dimensions, or; /// ""shape"" (row-major), its type (see TensorSpec::getDataType specializations; /// for supported types), its name and port (see ""TensorFlow: Large-Scale; /// Machine Learning on Heterogeneous Distributed Systems"", section 4.2, para 2:; /// https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/45166.pdf); ///; /// Note that the design is motivated by Tensorflow, but it is not intended to; /// be Tensorflow-specific.; ///; /// Known tensor types. The left part is the C type, the; /// right is a name we can use to identify the type (to implement TensorSpec; /// equality checks), and to use, if needed, when mapping to an underlying; /// evaluator's type system. The main requirement is that the C type we use has; /// the same size and encoding (e.g. endian-ness) as the one used by the; /// evaluator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TensorSpec.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:538,Performance,optimiz,optimizations,538,"//===- llvm/Analysis/Trace.h - Represent one trace of LLVM code -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:666,Performance,optimiz,optimizations,666,"//===- llvm/Analysis/Trace.h - Represent one trace of LLVM code -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This class represents a single trace of LLVM basic blocks. A trace is a; // single entry, multiple exit, region of code that is often hot. Trace-based; // optimizations treat traces almost like they are a large, strange, basic; // block: because the trace path is assumed to be hot, optimizations for the; // fall-through path are made at the expense of the non-fall-through paths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h:65,Availability,error,error,65,/// dump - Debugger convenience method; writes trace to standard error; /// output stream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Trace.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:407,Integrability,interface,interface,407,"//===- TypeBasedAliasAnalysis.h - Type-Based Alias Analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This is the interface for a metadata-based TBAA. See the source file for; /// details on the algorithm.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:6,Usability,simpl,simple,6,/// A simple AA result that uses TBAA metadata to answer queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h:11,Integrability,wrap,wrapper,11,/// Legacy wrapper pass to provide the TypeBasedAAResult object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeBasedAliasAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h:46,Testability,test,test,46,"/// Given a call to the intrinsic \@llvm.type.test, find all devirtualizable; /// call sites based on the call and return them in DevirtCalls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h:54,Performance,load,load,54,"/// Given a call to the intrinsic \@llvm.type.checked.load, find all; /// devirtualizable call sites based on the call and return them in DevirtCalls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/TypeMetadataUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:46,Modifiability,extend,extended,46,/// Number of times a constant range has been extended with widening enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:22,Modifiability,extend,extending,22,/// Handle repeatedly extending a range by going to overdefined after a; /// number of steps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:42,Modifiability,extend,extended,42,"// Simple form of widening. If a range is extended multiple times, go to; // overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:3,Usability,Simpl,Simple,3,"// Simple form of widening. If a range is extended multiple times, go to; // overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h:4,Deployability,Update,Updates,4,/// Updates this object to approximate both this object and RHS. Returns; /// true if this object has been changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLattice.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:430,Performance,perform,performing,430,"//===-- ValueLatticeUtils.h - Utils for solving lattices --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares common functions useful for performing data-flow analyses; // that propagate values across function boundaries.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:58,Modifiability,variab,variable,58,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:143,Modifiability,variab,variable,143,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h:208,Performance,load,loads,208,/// Determine if the value maintained in the given global variable can be; /// tracked interprocedurally. A value can be tracked if the global variable; /// has local linkage and is only used by non-volatile loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueLatticeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:402,Integrability,rout,routines,402,"//===- llvm/Analysis/ValueTracking.h - Walk computations --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains routines that help analyze properties that chains of; // computations have.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:34,Integrability,depend,dependent,34,/// Merge bits known from context-dependent facts into Known.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:55,Testability,log,logic,55,/// Using KnownBits LHS/RHS produce the known bits for logic op (and/xor/or).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:149,Energy Efficiency,power,power,149,"/// Return true if the given value is known to have exactly one bit set when; /// defined. For vectors return true if every element is known to be a power; /// of two when defined. Supports values with integer or pointer type and; /// vectors of integers. If 'OrZero' is set, then return true if the given; /// value is either a power of two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:329,Energy Efficiency,power,power,329,"/// Return true if the given value is known to have exactly one bit set when; /// defined. For vectors return true if every element is known to be a power; /// of two when defined. Supports values with integer or pointer type and; /// vectors of integers. If 'OrZero' is set, then return true if the given; /// value is either a power of two or zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:243,Performance,perform,perform,243,"/// Return true if the given value is known to be non-zero when defined. For; /// vectors, return true if every element is known to be non-zero when; /// defined. For pointers, if the context instruction and dominator tree are; /// specified, perform context-sensitive analysis and return true if the; /// pointer couldn't possibly be null at the specified instruction.; /// Supports values with integer or pointer type and vectors of integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:24,Availability,Mask,Mask,24,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:101,Availability,down,downstream,101,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:113,Availability,Mask,Mask,113,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:334,Availability,mask,mask,334,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:81,Usability,simpl,simplify,81,"/// Return true if 'V & Mask' is known to be zero. We use this predicate to; /// simplify operations downstream. Mask is known to be zero for bits that V; /// cannot have.; ///; /// This function is defined on values with integer type, values with pointer; /// type, and vectors of integers. In the case; /// where V is a vector, the mask, known zero, and known one values are the; /// same width as the vector element, and the bit is set only if it is true; /// for all of the elements in the vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:220,Availability,mask,mask,220,"/// Returns a pair of values, which if passed to llvm.is.fpclass, returns the; /// same result as an fcmp with the given operands.; ///; /// If \p LookThroughSrc is true, consider the input value when computing the; /// mask.; ///; /// If \p LookThroughSrc is false, ignore the source value (i.e. the first pair; /// element will always be LHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:59,Availability,mask,mask,59,/// Return true if it's known this can never be one of the mask entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:80,Modifiability,extend,extends,80,/// Return true if it's know this can never be interpreted as a zero. This; /// extends isKnownNeverZero to cover the case where the assumed; /// floating-point mode for the function interprets denormals as zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:43,Availability,mask,mask,43,// Clear sign bits based on the input sign mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:3,Usability,Clear,Clear,3,// Clear sign bits based on the input sign mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:440,Availability,reliab,reliable,440,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:304,Performance,optimiz,optimization,304,"/// Determine which floating-point classes are valid for \p V, and return them; /// in KnownFPClass bit sets.; ///; /// This function is defined on values with floating-point type, values vectors; /// of floating-point type, and arrays of floating-point type.; /// \p InterestedClasses is a compile time optimization hint for which floating; /// point classes should be queried. Queries not specified in \p; /// InterestedClasses should be reliable if they are determined during the; /// query.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:4,Integrability,Wrap,Wrapper,4,/// Wrapper to account for known fast math flags at the use instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:107,Integrability,depend,depending,107,/// Return true if we can prove that the specified FP value's sign bit is 0.; ///; /// NaN --> true/false (depending on the NaN's sign bit); /// +0 --> true; /// -0 --> false; /// x > +0 --> true; /// x < -0 --> false,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:173,Integrability,wrap,wrapper,173,/// Analyze the specified pointer to see if it can be expressed as a base; /// pointer plus a constant offset. Return the base and offset to the caller.; ///; /// This is a wrapper around Value::stripAndAccumulateConstantOffsets that; /// creates and later unpacks the required APInt.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:136,Integrability,interface,interface,136,"/// ConstantDataArray pointer. nullptr indicates a zeroinitializer (a valid; /// initializer, it just doesn't fit the ConstantDataArray interface).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:16,Security,access,accessor,16,/// Convenience accessor for elements in the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:18,Safety,avoid,avoid,18,// Force const to avoid infinite recursion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:463,Performance,Load,Load-PRE,463,"/// This method is similar to getUnderlyingObject except that it can; /// look through phi and select instructions and return multiple objects.; ///; /// If LoopInfo is passed, loop phis are further analyzed. If a pointer; /// accesses different objects in each iteration, we don't look through the; /// phi node. E.g. consider this loop nest:; ///; /// int **A;; /// for (i); /// for (j) {; /// A[i][j] = A[i-1][j] * B[j]; /// }; ///; /// This is transformed by Load-PRE to stash away A[i] for the next iteration; /// of the outer loop:; ///; /// Curr = A[0]; // Prev_0; /// for (i: 1..N) {; /// Prev = Curr; // Prev = PHI (Prev_0, Curr); /// Curr = A[i];; /// for (j: 0..N) {; /// Curr[j] = Prev[j] * B[j]; /// }; /// }; ///; /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects; /// should not assume that Curr and Prev share the same underlying object thus; /// it shouldn't look through the phi above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:227,Security,access,accesses,227,"/// This method is similar to getUnderlyingObject except that it can; /// look through phi and select instructions and return multiple objects.; ///; /// If LoopInfo is passed, loop phis are further analyzed. If a pointer; /// accesses different objects in each iteration, we don't look through the; /// phi node. E.g. consider this loop nest:; ///; /// int **A;; /// for (i); /// for (j) {; /// A[i][j] = A[i-1][j] * B[j]; /// }; ///; /// This is transformed by Load-PRE to stash away A[i] for the next iteration; /// of the outer loop:; ///; /// Curr = A[0]; // Prev_0; /// for (i: 1..N) {; /// Prev = Curr; // Prev = PHI (Prev_0, Curr); /// Curr = A[i];; /// for (j: 0..N) {; /// Curr[j] = Prev[j] * B[j]; /// }; /// }; ///; /// Since A[i] and A[i-1] are independent pointers, getUnderlyingObjects; /// should not assume that Curr and Prev share the same underlying object thus; /// it shouldn't look through the phi above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getUnderlyingObjects and adds support for basic; /// ptrtoint+arithmetic+inttoptr sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:281,Integrability,interface,interface,281,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:44,Performance,load,load,44,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:71,Safety,avoid,avoid,71,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:121,Security,sanitiz,sanitizer,121,"/// Return true if speculation of the given load must be suppressed to avoid; /// ordering or interfering with an active sanitizer. If not suppressed,; /// dereferenceability and alignment must be proven separately. Note: This; /// is only needed for raw reasoning; if you use the interface below; /// (isSafeToSpeculativelyExecute), this is handled internally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:373,Performance,load,loading,373,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:775,Performance,perform,performs,775,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:842,Safety,safe,safe,842,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:1057,Safety,safe,safe,1057,"/// Return true if the instruction does not have any effects besides; /// calculating the result and does not have undefined behavior.; ///; /// This method never returns true for an instruction that returns true for; /// mayHaveSideEffects; however, this method also does some other checks in; /// addition. It checks for undefined behavior, like dividing by zero or; /// loading from an invalid pointer (but not for undefined results, like a; /// shift with a shift amount larger than the width of the result). It checks; /// for malloc and alloca because speculatively executing them might cause a; /// memory leak. It also returns false for instructions related to control; /// flow, specifically terminators and PHI nodes.; ///; /// If the CtxI is specified this method performs context-sensitive analysis; /// and returns true if it is safe to execute the instruction immediately; /// before the CtxI.; ///; /// If the CtxI is NOT specified this method only looks at the instruction; /// itself and its operands, so if this method returns true, it is safe to; /// move the instruction as long as the correct dominance relationships for; /// the operands and users hold.; ///; /// This method can return true for instructions that read memory;; /// for such instructions, moving them may change the resulting value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:456,Availability,fault,fault,456,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:78,Integrability,depend,depend,78,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:147,Integrability,depend,dependence,147,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:273,Integrability,depend,dependent,273,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:364,Integrability,depend,dependent,364,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:403,Integrability,depend,dependence,403,/// Returns true if the result or effects of the given instructions \p I; /// depend values not reachable through the def use graph.; /// * Memory dependence arises for example if the instruction reads from; /// memory or may produce effects or undefined behaviour. Memory dependent; /// instructions generally cannot be reorderd with respect to other memory; /// dependent instructions.; /// * Control dependence arises for example if the instruction may fault; /// if lifted above a throwing call or infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:315,Performance,optimiz,optimize,315,"/// Return true if it is valid to use the assumptions provided by an; /// assume intrinsic, I, at the point in the control-flow identified by the; /// context instruction, CxtI. By default, ephemeral values of the assumption; /// are treated as an invalid context, to prevent the assumption from being used; /// to optimize away its argument. If the caller can ensure that this won't; /// happen, it can call with AllowEphemerals set to true to get more valid; /// assumptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:105,Integrability,depend,dependent,105,"/// Returns true if the arithmetic part of the \p WO 's result is; /// used only along the paths control dependent on the computation; /// not overflowing, \p WO being an <op>.with.overflow intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:168,Safety,avoid,avoid,168,"/// Return true if every instruction in the range (Begin, End) is; /// guaranteed to transfer execution to its static successor. \p ScanLimit; /// bounds the search to avoid scanning huge blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:395,Performance,perform,performs,395,"/// Return true if this function can prove that V does not have undef bits; /// and is never poison. If V is an aggregate value or vector, check whether; /// all elements (except padding) are not undef or poison.; /// Note that this is different from canCreateUndefOrPoison because the; /// function assumes Op's operands are not poison/undef.; ///; /// If CtxI and DT are specified this method performs flow-sensitive analysis; /// and returns true if it is guaranteed to be never undef or poison; /// immediately before the CtxI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:477,Modifiability,variab,variable,477,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:536,Modifiability,variab,variable,536,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:23,Usability,simpl,simple,23,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h:1120,Usability,simpl,simple,1120,"/// Attempt to match a simple first order recurrence cycle of the form:; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %iv, %step; /// OR; /// %iv = phi Ty [%Start, %Entry], [%Inc, %backedge]; /// %inc = binop %step, %iv; ///; /// A first order recurrence is a formula with the form: X_n = f(X_(n-1)); ///; /// A couple of notes on subtleties in that definition:; /// * The Step does not have to be loop invariant. In math terms, it can; /// be a free variable. We allow recurrences with both constant and; /// variable coefficients. Callers may wish to filter cases where Step; /// does not dominate P.; /// * For non-commutative operators, we will match both forms. This; /// results in some odd recurrence structures. Callers may wish to filter; /// out recurrences where the phi is not the LHS of the returned operator.; /// * Because of the structure matched, the caller can assume as a post; /// condition of the match the presence of a Loop with P's parent as it's; /// header *except* in unreachable code. (Dominance decays in unreachable; /// code.); ///; /// NOTE: This is intentional simple. If you want the ability to analyze; /// non-trivial loop conditons, see ScalarEvolution instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/ValueTracking.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:38,Availability,mask,masked,38,"// Check whether we have at least one masked vector version of a scalar; // function. If no VF is specified then we check for any masked variant,; // otherwise we look for one that matches the supplied VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:130,Availability,mask,masked,130,"// Check whether we have at least one masked vector version of a scalar; // function. If no VF is specified then we check for any masked variant,; // otherwise we look for one that matches the supplied VF.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Integrability,interface,interface,31,/// \defgroup VFDatabase query interface.; ///; /// @{; /// Retrieve the Function with VFShape \p Shape.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:27,Availability,Mask,Mask,27,"/// If all non-negative \p Mask elements are the same value, return that value.; /// If all elements are negative (undefined) or \p Mask contains different; /// non-negative values, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:132,Availability,Mask,Mask,132,"/// If all non-negative \p Mask elements are the same value, return that value.; /// If all elements are negative (undefined) or \p Mask contains different; /// non-negative values, return -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:325,Energy Efficiency,power,powerful,325,"/// Return true if each element of the vector value \p V is poisoned or equal to; /// every other non-poisoned element. If an index element is specified, either; /// every element of the vector is poisoned or the element at that index is not; /// poisoned and equal to every other non-poisoned element.; /// This may be more powerful than the related getSplatValue() because it is; /// not limited by finding a scalar source value to a splatted vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:24,Availability,mask,mask,24,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:55,Availability,mask,mask,55,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:87,Availability,mask,masks,87,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:134,Availability,mask,mask,134,"/// Transform a shuffle mask's output demanded element mask into demanded; /// element masks for the 2 operands, returns false if the mask isn't valid.; /// Both \p DemandedLHS and \p DemandedRHS are initialised to [SrcWidth].; /// \p AllowUndefElts permits ""-1"" indices to be treated as undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Availability,mask,mask,25,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:94,Availability,mask,mask,94,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:121,Availability,Mask,Mask,121,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:206,Availability,mask,mask,206,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:411,Availability,mask,mask,411,"/// Replace each shuffle mask index with the scaled sequential indices for an; /// equivalent mask of narrowed elements. Mask elements that are less than 0; /// (sentinel values) are repeated in the output mask.; ///; /// Example with Scale = 4:; /// <4 x i32> <3, 2, 0, -1> -->; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1>; ///; /// This is the reverse process of widening shuffle mask elements, but it always; /// succeeds because the indexes can always be multiplied (scaled up) to map to; /// narrower vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Availability,mask,mask,31,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:103,Availability,mask,mask,103,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:136,Availability,mask,mask,136,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:200,Availability,mask,mask,200,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:281,Availability,mask,mask,281,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:693,Availability,mask,mask,693,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:816,Availability,down,down,816,"/// Try to transform a shuffle mask by replacing elements with the scaled index; /// for an equivalent mask of widened elements. If all mask elements that would; /// map to a wider element of the new mask are the same negative number; /// (sentinel value), that element of the new mask is the same value. If any; /// element in a given slice is negative and some other element in that slice is; /// not the same value, return false (partial matches with sentinel values are; /// not allowed).; ///; /// Example with Scale = 4:; /// <16 x i8> <12, 13, 14, 15, 8, 9, 10, 11, 0, 1, 2, 3, -1, -1, -1, -1> -->; /// <4 x i32> <3, 2, 0, -1>; ///; /// This is the reverse process of narrowing shuffle mask elements if it; /// succeeds. This transform is not always possible because indexes may not; /// divide evenly (scale down) to map to wider vector elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:100,Availability,mask,mask,100,"/// Repetitively apply `widenShuffleMaskElts()` for as long as it succeeds,; /// to get the shuffle mask with widest possible elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Availability,mask,mask,33,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:208,Availability,mask,mask,208,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:327,Availability,mask,mask,327,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:579,Availability,mask,masks,579,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:598,Availability,Mask,Mask,598,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:620,Availability,mask,mask,620,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:38,Integrability,depend,depending,38,"/// Splits and processes shuffle mask depending on the number of input and; /// output registers. The function does 2 main things: 1) splits the; /// source/destination vectors into real registers; 2) do the mask analysis to; /// identify which real registers are permuted. Then the function processes; /// resulting registers mask using provided action items. If no input register; /// is defined, \p NoInputAction action is used. If only 1 input register is; /// used, \p SingleInputAction is used, otherwise \p ManyInputsAction is used to; /// process > 2 input registers and masks.; /// \param Mask Original shuffle mask.; /// \param NumOfSrcRegs Number of source registers.; /// \param NumOfDestRegs Number of destination registers.; /// \param NumOfUsedRegs Number of actually used destination registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:342,Availability,down,down,342,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:211,Performance,perform,performed,211,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:1037,Performance,load,load,1037,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:1083,Performance,load,load,1083,"/// Compute a map of integer instructions to their minimum legal type; /// size.; ///; /// C semantics force sub-int-sized values (e.g. i8, i16) to be promoted to int; /// type (e.g. i32) whenever arithmetic is performed on them.; ///; /// For targets with native i8 or i16 operations, usually InstCombine can shrink; /// the arithmetic type down again. However InstCombine refuses to create; /// illegal types, so for targets without i8 or i16 registers, the lengthening; /// and shrinking remains.; ///; /// Most SIMD ISAs (e.g. NEON) however support vectors of i8 or i16 even when; /// their scalar equivalents do not, so during vectorization it is important to; /// remove these lengthens and truncates when deciding the profitability of; /// vectorization.; ///; /// This function analyzes the given range of instructions and determines the; /// minimum type size each can be converted to. It attempts to remove or; /// minimize type size changes across each def-use chain, so for example in the; /// following code:; ///; /// %1 = load i8, i8*; /// %2 = add i8 %1, 2; /// %3 = load i16, i16*; /// %4 = zext i8 %2 to i32; /// %5 = zext i16 %3 to i32; /// %6 = add i32 %4, %5; /// %7 = trunc i32 %6 to i16; ///; /// Instruction %6 must be done at least in i16, so computeMinimumValueSizes; /// will return: {%1: 16, %2: 16, %3: 16, %4: 16, %5: 16, %6: 16, %7: 16}.; ///; /// If the optional TargetTransformInfo is provided, this function tries harder; /// to do less work by only looking at illegal types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,Security,access,access-group,29,"/// Compute the union of two access-group lists.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Security,access,access,89,"/// Compute the union of two access-group lists.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,Security,access,access-group,16,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:37,Security,access,access,37,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:127,Security,access,access,127,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:232,Security,access,access,232,"/// Compute the access-group list of access groups that @p Inst1 and @p Inst2; /// are both in. If either instruction does not access memory at all, it is; /// considered to be in every list.; ///; /// If the list contains just one access group, it is returned directly. If the; /// list is empty, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,Availability,mask,mask,13,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:120,Availability,mask,mask,120,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:292,Availability,mask,mask,292,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:351,Availability,Mask,Mask,351,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:391,Availability,mask,mask,391,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:397,Availability,mask,mask,397,"/// Create a mask that filters the members of an interleave group where there; /// are gaps.; ///; /// For example, the mask for \p Group with interleave-factor 3; /// and \p VF 4, that has only its first member present is:; ///; /// <1,0,0,1,0,0,1,0,0,1,0,0>; ///; /// Note: The result is a mask of 0's and 1's, as opposed to the other; /// create[*]Mask() utilities which create a shuffle mask (mask that; /// consists of indices).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:13,Availability,mask,mask,13,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:86,Availability,mask,mask,86,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:214,Availability,mask,mask,214,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:244,Availability,mask,mask,244,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:437,Availability,mask,mask,437,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:342,Performance,load,loads,342,"/// Create a mask with replicated elements.; ///; /// This function creates a shuffle mask for replicating each of the \p VF; /// elements in a vector \p ReplicationFactor times. It can be used to; /// transform a mask of \p VF elements into a mask of; /// \p VF * \p ReplicationFactor elements used by a predicated; /// interleaved-group of loads/stores whose Interleaved-factor ==; /// \p ReplicationFactor.; ///; /// For example, the mask for \p ReplicationFactor=3 and \p VF=4 is:; ///; /// <0,0,0,1,1,1,2,2,2,3,3,3>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Availability,mask,mask,33,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:81,Availability,mask,mask,81,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:188,Availability,mask,mask,188,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:320,Availability,mask,mask,320,"/// Create an interleave shuffle mask.; ///; /// This function creates a shuffle mask for interleaving \p NumVecs vectors of; /// vectorization factor \p VF into a single wide vector. The mask is of the; /// form:; ///; /// <0, VF, VF * 2, ..., VF * (NumVecs - 1), 1, VF + 1, VF * 2 + 1, ...>; ///; /// For example, the mask for VF = 4 and NumVecs = 2 is:; ///; /// <0, 4, 1, 5, 2, 6, 3, 7>.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,Availability,mask,mask,28,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:76,Availability,mask,mask,76,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:157,Availability,mask,mask,157,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:279,Availability,mask,mask,279,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:393,Availability,mask,mask,393,"/// Create a stride shuffle mask.; ///; /// This function creates a shuffle mask whose elements begin at \p Start and; /// are incremented by \p Stride. The mask can be used to deinterleave an; /// interleaved vector into separate vectors of vectorization factor \p VF. The; /// mask is of the form:; ///; /// <Start, Start + Stride, ..., Start + Stride * (VF - 1)>; ///; /// For example, the mask for Start = 0, Stride = 2, and VF = 4 is:; ///; /// <0, 2, 4, 6>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:32,Availability,mask,mask,32,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:78,Availability,mask,mask,78,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:145,Availability,mask,mask,145,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:234,Availability,mask,mask,234,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:366,Availability,mask,mask,366,"/// Create a sequential shuffle mask.; ///; /// This function creates shuffle mask whose elements are sequential and begin; /// at \p Start. The mask contains \p NumInts integers and is padded with \p; /// NumUndefs undef values. The mask is of the form:; ///; /// <Start, Start + 1, ... Start + NumInts - 1, undef_1, ... undef_NumUndefs>; ///; /// For example, the mask for Start = 0, NumInsts = 4, and NumUndefs = 4 is:; ///; /// <0, 1, 2, 3, undef, undef, undef, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,Availability,mask,mask,20,"/// Given a shuffle mask for a binary shuffle, create the equivalent shuffle; /// mask assuming both operands are identical. This assumes that the unary; /// shuffle will use elements from operand 0 (operand 1 will be unused).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:82,Availability,mask,mask,82,"/// Given a shuffle mask for a binary shuffle, create the equivalent shuffle; /// mask assuming both operands are identical. This assumes that the unary; /// shuffle will use elements from operand 0 (operand 1 will be unused).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be false or undef. That is, return true if all; /// lanes can be assumed inactive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be false or undef. That is, return true if all; /// lanes can be assumed inactive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be true or undef. That is, return true if all; /// lanes can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if all of the elements of this; /// predicate mask are known to be true or undef. That is, return true if all; /// lanes can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of i1, Return true if any of the elements of this; /// predicate mask are known to be true or undef. That is, return true if at; /// least one lane can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Availability,mask,mask,89,"/// Given a mask vector of i1, Return true if any of the elements of this; /// predicate mask are known to be true or undef. That is, return true if at; /// least one lane can be assumed active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:12,Availability,mask,mask,12,"/// Given a mask vector of the form <Y x i1>, return an APInt (of bitwidth Y); /// for each lane which may be active.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:29,Performance,load,loads,29,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:325,Performance,load,load,325,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:813,Performance,load,load,813,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:278,Security,access,access,278,"/// The group of interleaved loads/stores sharing the same stride and; /// close to each other.; ///; /// Each member in this group has an index starting from 0, and the largest; /// index should be less than interleaved factor, which is equal to the absolute; /// value of the access's stride.; ///; /// E.g. An interleaved load group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// a = A[i]; // Member of index 0; /// b = A[i+1]; // Member of index 1; /// d = A[i+3]; // Member of index 3; /// ...; /// }; ///; /// An interleaved store group of factor 4:; /// for (unsigned i = 0; i < 1024; i+=4) {; /// ...; /// A[i] = a; // Member of index 0; /// A[i+1] = b; // Member of index 1; /// A[i+2] = c; // Member of index 2; /// A[i+3] = d; // Member of index 3; /// }; ///; /// Note: the interleaved load group could have gaps (missing members), but; /// the interleaved store group doesn't allow gaps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:15,Safety,safe,safe,15,// It's always safe to select the minimum alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:63,Security,access,access,63,"// We have a group with gaps. It therefore can't be a reversed access,; // because such groups get invalidated (TODO).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:22,Performance,load,loads,22,"// This is a group of loads, with gaps, and without a last-member",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:21,Integrability,depend,dependences,21,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:124,Performance,load,load,124,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:190,Performance,load,load,190,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:270,Performance,load,load,270,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Safety,avoid,avoid,6,"// To avoid breaking dependences, vectorized instructions of an interleave; // group should be inserted at either the first load or the last store in; // program order.; //; // E.g. %even = load i32 // Insert Position; // %add = add i32 %even // Use of %even; // %odd = load i32; //; // store i32 %even; // %odd = add i32 // Def of %odd; // store i32 %odd // Insert Position",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:259,Safety,unsafe,unsafe,259,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:45,Security,access,accesses,45,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:115,Security,access,accesses,115,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:247,Security,access,accesses,247,/// Drive the analysis of interleaved memory accesses in the loop.; ///; /// Use this class to analyze interleaved accesses only when we can vectorize; /// a loop. Otherwise it's meaningless to do analysis as the vectorization; /// on interleaved accesses is unsafe.; ///; /// The analysis collects interleave groups and records the relationships; /// between the member and the group in a map.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:157,Performance,load,loads,157,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:28,Security,access,accesses,28,/// Analyze the interleaved accesses and collect them in interleave; /// groups. Substitute symbolic strides using \p Strides.; /// Consider also predicated loads/stores in the analysis if; /// \p EnableMaskedInterleavedGroup is true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:179,Security,access,accesses,179,"/// Invalidate groups, e.g., in case all blocks in loop will be predicated; /// contrary to original assumption. Although we currently prevent group; /// formation for predicated accesses, we may be able to relax this limitation; /// in the future once we handle more complicated blocks. Returns true if any; /// groups were invalidated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:50,Security,access,access,50,/// Returns true if an interleaved group that may access memory; /// out-of-bounds requires a scalar epilogue iteration for correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:180,Availability,mask,masking,180,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:94,Performance,optimiz,optimizing,94,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:192,Performance,load,load,192,"/// Invalidate groups that require a scalar epilogue (due to gaps). This can; /// happen when optimizing for size forbids a scalar epilogue, and the gap; /// cannot be filtered by masking the load/store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Integrability,wrap,wrapper,6,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:170,Security,access,access,170,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:76,Usability,Simpl,Simplifies,76,"/// A wrapper around ScalarEvolution, used to add runtime SCEV checks.; /// Simplifies SCEV expressions in the context of existing SCEV assumptions.; /// The interleaved access analysis can also add new predicates (for example; /// by versioning strides of pointers).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:89,Security,access,accesses,89,/// True if the loop may contain non-reversed interleaved groups with; /// out-of-bounds accesses. We ensure we don't speculatively access memory; /// out-of-bounds by executing at least one scalar epilogue iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:132,Security,access,access,132,/// True if the loop may contain non-reversed interleaved groups with; /// out-of-bounds accesses. We ensure we don't speculatively access memory; /// out-of-bounds by executing at least one scalar epilogue iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:10,Integrability,depend,dependences,10,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:102,Integrability,depend,dependent,102,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:39,Security,access,accesses,39,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:83,Security,access,access,83,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:117,Security,access,accesses,117,/// Holds dependences among the memory accesses in the loop. It maps a source; /// access to a set of dependent sink accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:40,Security,access,access,40,/// The descriptor for a strided memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:7,Security,access,access,7,// The access's stride. It is negative for a reverse access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:53,Security,access,access,53,// The access's stride. It is negative for a reverse access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:33,Security,access,access,33,// The scalar expression of this access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Security,access,access,25,// The alignment of this access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:4,Deployability,Release,Release,4,/// Release the group and remove all the relationships.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:20,Security,access,accesses,20,/// Collect all the accesses with a constant stride in program order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:51,Integrability,depend,dependence,51,/// Returns true if LoopAccessInfo can be used for dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:273,Integrability,depend,dependent,273,"/// Returns true if memory accesses \p A and \p B can be reordered, if; /// necessary, when constructing interleaved groups.; ///; /// \p A must precede \p B in program order. We return false if reordering is; /// not necessary or is prevented because \p A and \p B may be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:27,Security,access,accesses,27,"/// Returns true if memory accesses \p A and \p B can be reordered, if; /// necessary, when constructing interleaved groups.; ///; /// \p A must precede \p B in program order. We return false if reordering is; /// not necessary or is prevented because \p A and \p B may be dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:433,Integrability,depend,dependence,433,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:521,Integrability,depend,dependences,521,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:609,Integrability,depend,dependence,609,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:70,Performance,load,loads,70,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:217,Performance,load,load,217,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:331,Performance,load,load,331,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:564,Safety,safe,safely,564,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Security,access,accesses,31,"// Code motion for interleaved accesses can potentially hoist strided loads; // and sink strided stores. The code below checks the legality of the; // following two conditions:; //; // 1. Potentially moving a strided load (B) before any store (A) that; // precedes B, or; //; // 2. Potentially moving a strided store (A) after any load or store (B); // that A precedes.; //; // It's legal to reorder A and B if we know there isn't a dependence from A; // to B. Note that this determination is conservative since some; // dependences could potentially be reordered safely.; // A is potentially the source of a dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:34,Integrability,depend,dependence,34,// B is potentially the sink of a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:58,Integrability,depend,dependences,58,"// Code motion for interleaved accesses can't violate WAR dependences.; // Thus, reordering is legal if the source isn't a write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:31,Security,access,accesses,31,"// Code motion for interleaved accesses can't violate WAR dependences.; // Thus, reordering is legal if the source isn't a write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:23,Security,access,accesses,23,// At least one of the accesses must be strided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:36,Availability,avail,available,36,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:6,Integrability,depend,dependence,6,"// If dependence information is not available from LoopAccessInfo,; // conservatively assume the instructions can't be reordered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:25,Integrability,depend,dependence,25,"// If we know there is a dependence from source to sink, assume the; // instructions can't be reordered. Otherwise, reordering is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:16,Integrability,depend,dependences,16,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:74,Integrability,depend,dependences,74,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:159,Integrability,depend,dependence,159,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h:114,Security,access,access,114,/// Collect the dependences from LoopAccessInfo.; ///; /// We process the dependences once during the interleaved access analysis to; /// enable constant-time dependence queries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/VectorUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h:45,Performance,cache,cache,45,"//===- llvm/Analysis/WithCache.h - KnownBits cache for pointers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Store a pointer to any type along with the KnownBits information for it; // that is computed lazily (if required).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/WithCache.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:385,Performance,perform,performed,385,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:887,Performance,perform,performed,887,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:1137,Performance,perform,performed,1137,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h:1172,Performance,perform,performed,1172,"/// Calculate and dump ThinLTO specific inliner stats.; /// The main statistics are:; /// (1) Number of inlined imported functions,; /// (2) Number of imported functions inlined into importing module (indirect),; /// (3) Number of non imported functions inlined into importing module; /// (indirect).; /// The difference between first and the second is that first stat counts; /// all performed inlines on imported functions, but the second one only the; /// functions that have been eventually inlined to a function in the importing; /// module (by a chain of inlines). Because llvm uses bottom-up inliner, it is; /// possible to e.g. import function `A`, `B` and then inline `B` to `A`,; /// and after this `A` might be too big to be inlined into some other function; /// that calls it. It calculates this statistic by building graph, where; /// the nodes are functions, and edges are performed inlines and then by marking; /// the edges starting from not imported function.; ///; /// If `Verbose` is set to true, then it also dumps statistics; /// per each inlined function, sorted by the greatest inlines count like; /// - number of performed inlines; /// - number of performed inlines to importing module",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/ImportedFunctionsInliningStatistics.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h:30,Performance,perform,perform,30,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h:408,Performance,perform,perform,408,"//===- Local.h - Functions to perform local transformations -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/Local.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:4,Performance,Load,Load,4,"/// Load a SavedModel, find the given inputs and outputs, and setup storage; /// for input tensors. The user is responsible for correctly dimensioning the; /// input tensors and setting their values before calling evaluate().; /// To initialize:; /// - construct the object; /// - initialize the input tensors using initInput. Indices must correspond to; /// indices in the InputNames used at construction.; /// To use:; /// - set input values by using getInput to get each input tensor, and then; /// setting internal scalars, for all dimensions (tensors are row-major:; /// https://github.com/tensorflow/tensorflow/blob/r1.5/tensorflow/c/c_api.h#L205); /// - call evaluate. The input tensors' values are not consumed after this, and; /// may still be read.; /// - use the outputs in the output vector",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:13,Security,access,access,13,/// Provides access to the input vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:34,Performance,load,loaded,34,"/// Returns true if the model was loaded successfully, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h:12,Security,access,access,12,/// Untyped access to input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TFUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:2041,Availability,avail,available,2041,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:427,Integrability,depend,dependencies,427,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:991,Performance,optimiz,optimizations,991,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:691,Safety,avoid,avoiding,691,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:46,Testability,log,logging,46,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:406,Testability,log,logger,406,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:776,Testability,log,logger,776,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:1649,Testability,log,log,1649,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:2032,Testability,test,test,2032,"dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; // An example reader, used for test, is available at; // Analysis/models/log_reader.py; //; // Example:; // {""features"":[list of TensorSpecs], ""score"":<a tensor spec>}; // {""context"": ""aFunction""}; // {""observation"": 0}; // <bytes>; // {""outcome"": 0}; // <bytes for the tensor corresponding to the ""score"" spec in the header>; // {""observation"": 1}; // ...; // {""context"": ""anotherFunction""}; // {""observation"": 0}; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:769,Usability,simpl,simple,769,"//===- TrainingLogger.h - mlgo feature/reward logging ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The design goals of the logger are:; // - no dependencies that llvm doesn't already have.; // - support streaming, so that we don't need to buffer data during compilation; // - 0-decoding tensor values. Tensor values are potentially very large buffers; // of scalars. Because of their potentially large size, avoiding; // serialization/deserialization overhead is preferred.; //; // The simple logger produces an output of the form (each line item on its line); // - header: a json object describing the data that will follow.; // - context: e.g. function name, for regalloc, or ""default"" for module-wide; // optimizations like the inliner. This is the context to which the subsequent; // data corresponds.; // - observation number.; // - tensor values - raw bytes of the tensors, in the order given in the header.; // The values are in succession, i.e. no separator is found between successive; // tensor values. At the end, there is a new line character.; // - [score] - this is optional, and is present if it was present in the header.; // Currently, for final rewards, we output ""0"" scores after each observation,; // except for the last one.; // <repeat>; // The file should be read as binary, but the reason we use newlines is mostly; // ease of debugging: the log can be opened in a text editor and, while tensor; // values are inscrutable, at least the sequence of data can be easily observed.; // Of course, the buffer of tensor values could contain '\n' bytes. A reader; // should use the header information to know how much data to read for the; // tensor values, and not use line information for that.; //; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:4,Testability,Log,Logging,4,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:107,Testability,log,logging,107,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:191,Testability,log,logged,191,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:267,Testability,log,log,267,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:548,Testability,log,logFloatValue,548,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:611,Testability,log,logFloatReward,611,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:650,Testability,log,logFloatValue,650,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:713,Testability,log,logFloatReward,713,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:782,Testability,log,log,782,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:818,Testability,log,logReward,818,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:864,Testability,log,log,864,"/// Logging utility - given an ordered specification of features, and assuming; /// a scalar reward, allow logging feature values and rewards.; /// The assumption is that, for an event to be logged (i.e. a set of feature; /// values and a reward), the user calls the log* API for each feature exactly; /// once, providing the index matching the position in the feature spec list; /// provided at construction. The example assumes the first feature's element; /// type is float, the second is int64, and the reward is float:; ///; /// event 0:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); /// event 1:; /// logFloatValue(0, ...); /// logInt64Value(1, ...); /// ...; /// logFloatReward(...); ///; /// At the end, call print to generate the log.; /// Alternatively, don't call logReward at the end of each event, just; /// log{Float|Int32|Int64}FinalReward at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:16,Testability,Log,Logger,16,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:56,Testability,log,logReward,56,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:74,Testability,log,logFinalReward,74,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h:349,Testability,log,logged,349,"/// Construct a Logger. If IncludeReward is false, then logReward or; /// logFinalReward shouldn't be called, and the reward feature won't be; /// printed out.; /// NOTE: the FeatureSpecs are expected to be in the same order (i.e. have; /// corresponding indices) with any MLModelRunner implementations; /// corresponding to the model being trained/logged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Analysis/Utils/TrainingLogger.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:168,Integrability,depend,depend,168,/// ValID - Represents a reference of a definition of some sort with no type.; /// There are several cases where we have to parse the value but where the; /// type can depend on later context. This may either be a numeric reference; /// or a symbolic (%var) reference. This is just a discriminated union.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:63,Deployability,Upgrade,UpgradeDebuginfo,63,/// Only the llvm-as tool may set this to false to bypass; /// UpgradeDebuginfo so it can generate broken bitcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:10,Integrability,Rout,Routines,10,// Helper Routines.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:94,Deployability,install,installs,94,"/// setInstName - After an instruction is parsed and inserted into its; /// basic block, this installs its name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:103,Availability,error,error,103,"/// DefineBB - Define the specified basic block, which is either named or; /// unnamed. If there is an error, this returns null otherwise it returns; /// the block being defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:97,Availability,error,error,97,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h:49,Integrability,rout,routine,49,"// Instruction Parsing. Each instruction parsing routine can return with a; // normal result, an error result, or return having eaten an extra comma.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLParser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h:122,Safety,detect,detection,122,"// GV's where the clang++ frontend (when ASan is used) notes that this is; // dynamically initialized, and thus needs ODR detection.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/LLToken.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:492,Availability,Error,Error,492,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:551,Energy Efficiency,allocate,allocate,551,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:502,Availability,Error,Error,502,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:561,Energy Efficiency,allocate,allocate,561,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Integrability,interface,interface,32,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code. It returns a; /// Module (intermediate representation) with the corresponding features. Note; /// that this does not verify that the generated Module is valid, so you should; /// run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:60,Integrability,interface,interfaces,60,/// Holds the Module and ModuleSummaryIndex returned by the interfaces; /// that parse both.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:563,Availability,Error,Error,563,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:622,Energy Efficiency,allocate,allocate,622,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code, including; /// a module summary. It returns a Module (intermediate representation) and; /// a ModuleSummaryIndex with the corresponding features. Note that this does; /// not verify that the generated Module or Index are valid, so you should; /// run the verifier after parsing the file to check that they are okay.; /// Parse LLVM Assembly from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.; /// \param Context Context in which to allocate globals info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Testability,test,testing,32,/// Only for use in llvm-as for testing; this does not produce a valid module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:500,Availability,Error,Error,500,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly Index from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:28,Integrability,interface,interface,28,"/// This function is a main interface to the LLVM Assembly Parser. It parses; /// an ASCII file that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly Index from a file; /// \param Filename The name of the file to parse; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:506,Availability,Error,Error,506,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:32,Integrability,interface,interface,32,"/// The function is a secondary interface to the LLVM Assembly Parser. It parses; /// an ASCII string that (presumably) contains LLVM Assembly code for a module; /// summary. It returns a a ModuleSummaryIndex with the corresponding features.; /// Note that this does not verify that the generated Index is valid, so you; /// should run the verifier after parsing the file to check that it is okay.; /// Parse LLVM Assembly from a string; /// \param AsmString The string containing assembly; /// \param Err Error result info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:194,Availability,Error,Error,194,/// parseAssemblyFile and parseAssemblyString are wrappers around this function.; /// Parse LLVM Assembly from a MemoryBuffer.; /// \param F The MemoryBuffer containing assembly; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:50,Integrability,wrap,wrappers,50,/// parseAssemblyFile and parseAssemblyString are wrappers around this function.; /// Parse LLVM Assembly from a MemoryBuffer.; /// \param F The MemoryBuffer containing assembly; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:158,Availability,Error,Error,158,/// Parse LLVM Assembly including the summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; ///; /// parseAssemblyFileWithIndex is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:309,Integrability,wrap,wrapper,309,/// Parse LLVM Assembly including the summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; ///; /// parseAssemblyFileWithIndex is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:148,Availability,Error,Error,148,/// Parse LLVM Assembly for summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; ///; /// parseSummaryIndexAssemblyFile is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:212,Integrability,wrap,wrapper,212,/// Parse LLVM Assembly for summary index from a MemoryBuffer.; ///; /// \param F The MemoryBuffer containing assembly with summary; /// \param Err Error result info.; ///; /// parseSummaryIndexAssemblyFile is a wrapper around this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:432,Availability,Error,Error,432,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:562,Availability,error,error,562,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:35,Integrability,interface,interface,35,/// This function is the low-level interface to the LLVM Assembly Parser.; /// This is kept as an independent function instead of being inlined into; /// parseAssembly for the convenience of interactive users that want to add; /// recently parsed bits to an existing module.; ///; /// \param F The MemoryBuffer containing assembly; /// \param M The module to add data to.; /// \param Index The index to add data to.; /// \param Err Error result info.; /// \param Slots The optional slot mapping that will be initialized during; /// parsing.; /// \return true on error.; /// \param DataLayoutCallback Override datalayout in the llvm assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:278,Availability,error,error,278,"/// Parse a type and a constant value in the given string.; ///; /// The constant value can be any LLVM constant, including a constant; /// expression.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:164,Availability,error,error,164,/// Parse a type in the given string.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h:280,Availability,error,error,280,/// Parse a string \p Asm that starts with a type.; /// \p Read[out] gives the number of characters that have been read to parse; /// the type in \p Asm.; ///; /// \param Slots The optional slot mapping that will restore the parsing state; /// of the module.; /// \return null on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/AsmParser/Parser.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:561,Availability,avail,available,561,"//===-- llvm/BinaryFormat/COFF.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an definitions used in Windows COFF Files.; //; // Structures and enums defined within this file where created using; // information from Microsoft's publicly available PE/COFF format document:; //; // Microsoft Portable Executable and Common Object File Format Specification; // Revision 8.1 - February 15, 2008; //; // As of 5/2/2010, hosted by Microsoft at:; // http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:614,Modifiability,Portab,Portable,614,"//===-- llvm/BinaryFormat/COFF.h --------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an definitions used in Windows COFF Files.; //; // Structures and enums defined within this file where created using; // information from Microsoft's publicly available PE/COFF format document:; //; // Microsoft Portable Executable and Common Object File Format Specification; // Revision 8.1 - February 15, 2008; //; // As of 5/2/2010, hosted by Microsoft at:; // http://www.microsoft.com/whdc/system/platform/firmware/pecoff.mspx; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:47,Testability,stub,stub,47,// The PE signature bytes that follows the DOS stub header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:134,Availability,error,error,134,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:59,Performance,load,loaded,59,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:122,Performance,load,loader,122,"/// The file does not contain base relocations and must be loaded at its; /// preferred base. If this cannot be done, the loader will error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:46,Performance,load,load,46,"/// If the image is on removable media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:44,Performance,load,load,44,"/// If the image is on network media, fully load it and copy it to swap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Modifiability,variab,variable,11,///< Stack variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:14,Modifiability,variab,variable,14,///< Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:36,Modifiability,variab,variable,36,///< No complex type; simple scalar variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:22,Usability,simpl,simple,22,///< No complex type; simple scalar variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:28,Performance,load,load,28,/// DLL can be relocated at load time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:9,Security,integrity,integrity,9,/// Code integrity checks are enforced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Performance,perform,performs,11,/// Module performs control flow integrity checks using system-supplied; /// support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:33,Security,integrity,integrity,33,/// Module performs control flow integrity checks using system-supplied; /// support.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:11,Performance,perform,performs,11,/// Module performs control flow and write integrity checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:43,Security,integrity,integrity,43,/// Module performs control flow and write integrity checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:40,Security,secur,security,40,/// Module does not make use of the /GS security cookie.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:36,Performance,load,load,36,/// Module supports read only delay load IAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:134,Modifiability,config,config,134,/// Module contains suppressed export information. This also infers that the; /// address taken IAT table is also present in the load config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:129,Performance,load,load,129,/// Module contains suppressed export information. This also infers that the; /// address taken IAT table is also present in the load config.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:4,Availability,Mask,Mask,4,"/// Mask for the subfield that contains the stride of Control Flow Guard; /// function table entries (that is, the additional count of bytes per table; /// entry).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h:30,Safety,safe,safeseh,30,// Object is compatible with /safeseh.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/COFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:667,Deployability,release,released,667,"//===-- llvm/BinaryFormat/Dwarf.h ---Dwarf Constants-------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file contains constants used for implementing Dwarf; /// debug support.; ///; /// For details on the Dwarf specfication see the latest DWARF Debugging; /// Information Format standard document on http://www.dwarfstd.org. This; /// file often includes support for non-released standard features.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:9,Testability,mock,mock,9,/// LLVM mock tags (see also llvm/BinaryFormat/Dwarf.def).; /// \{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:3,Security,Access,Accessibility,3,// Accessibility codes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:16,Modifiability,Extend,Extended,16,/// Line Number Extended Opcode Encodings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:22,Security,hash,hash,22,"// Dsymutil qualified hash extension.; // DW_ATOM_type_flags values.; // Always set for C++, only set for ObjC if this is the @implementation for a; // class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:3,Security,Hash,Hash,3,// Hash functions.; // Daniel J. Bernstein hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:43,Security,hash,hash,43,// Hash functions.; // Daniel J. Bernstein hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:103,Integrability,depend,depending,103,"/// A helper struct providing information about the byte size of DW_FORM; /// values that vary in size depending on the DWARF version, address byte; /// size, or DWARF32/DWARF64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:56,Integrability,depend,depends,56,"/// The definition of the size of form DW_FORM_ref_addr depends on the; /// version. In DWARF v2 it's the size of an address; after that, it's the; /// size of a reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:47,Integrability,depend,depending,47,/// Get the byte size of the unit length field depending on the DWARF format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h:182,Modifiability,variab,variable,182,"/// Get the fixed byte size for a given form.; ///; /// If the form has a fixed byte size, then an Optional with a value will be; /// returned. If the form is always encoded using a variable length storage; /// format (ULEB or SLEB numbers or blocks) then std::nullopt will be returned.; ///; /// \param Form DWARF form to get the fixed byte size for.; /// \param Params DWARF parameters to help interpret forms.; /// \returns std::optional<uint8_t> value with the fixed byte size or; /// std::nullopt if \p Form doesn't have a fixed byte size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Dwarf.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:39,Security,hash,hash,39,// This flag indicates that the shader hash was computed; // taking into account source information (-Zss),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:9,Security,Hash,HashFlags,9,// dxbc::HashFlags,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:3,Availability,Mask,Mask,3,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:136,Availability,mask,masked,136,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h:231,Availability,mask,masked,231,"// Mask (column allocation); // The ExclusiveMask has a different meaning for input and output signatures.; // For an output signature, masked components of the output register are never; // written to.; // For an input signature, masked components of the input register are always; // read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/DXContainer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:579,Integrability,Interface,Interface,579,"//===- llvm/BinaryFormat/ELF.h - ELF constants and structures ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header contains common, non-processor-specific data structures and; // constants for the ELF file format.; //; // The details of the ELF32 bits in this file are largely based on the Tool; // Interface Standard (TIS) Executable and Linking Format (ELF) Specification; // Version 1.2, May 1995. The ELF64 stuff is based on ELF-64 Object File Format; // Version 1.5, Draft 2, May 1998 as well as OpenBSD header files.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:97,Usability,ux,uxsglobal,97,// Machine architectures; // See current registered ELF machine architectures at:; // http://www.uxsglobal.com/developers/gabi/latest/ch4.eheader.html,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Enhance,Enhanced,3,// Enhanced instruction set SPARC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Energy Efficiency,Power,PowerPC,3,// PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:12,Testability,Log,Logic,12,// Advanced Logic Corp. TinyJ embedded processor family,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:7,Testability,Log,Logic,7,// LSI Logic 16-bit DSP Processor,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:24,Modifiability,config,configurable,24,// eXcess: 16/32/64-bit configurable embedded CPU,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:39,Modifiability,config,configurable,39,// STMicroelectronics STxP7x family of configurable; // and extensible RISC processors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Modifiability,Extend,Extended,13,// Freescale Extended Time Processing Unit,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Performance,Optimiz,Optimized,13,// Nanoradio Optimized RISC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:6,Usability,UX,UX,6,// HP-UX operating system,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:29,Availability,mask,mask,29,// EF_AVR_ARCH_xxx selection mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:11,Modifiability,extend,extended,11,// O32 ABI extended for 64-bit architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for selecting EF_MIPS_ABI_ variant.; // MIPS machine variant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:30,Availability,mask,mask,30,// EF_MIPS_MACH_xxx selection mask; // ARCH_ASE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for EF_MIPS_ARCH_ASE_xxx flags; // ARCH,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Availability,Mask,Mask,3,// Mask for applying EF_MIPS_ARCH_ variant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:40,Energy Efficiency,allocate,allocated,40,// Common symbols which are defined and allocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:12,Deployability,patch,patches,12,// Hardware patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:16,Deployability,patch,patches,16,// Hardware AND patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:15,Deployability,patch,patches,15,// Hardware OR patches applied,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:9,Security,access,access,9,// Other access sizes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:14,Security,access,access,14,// Byte-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:19,Security,access,access,19,// Half-word-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:14,Security,access,access,14,// Word-sized access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:20,Security,access,access,20,// Double-word-size access,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,Availability,mask,mask,23,// Processor selection mask for EF_AMDGPU_MACH_* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:19,Availability,mask,mask,19,// XNACK selection mask for EF_AMDGPU_FEATURE_XNACK_* values.; //; // Only valid for ELFOSABI_AMDGPU_HSA and ELFABIVERSION_AMDGPU_HSA_V4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:21,Availability,mask,mask,21,// SRAMECC selection mask for EF_AMDGPU_FEATURE_SRAMECC_* values.; //; // Only valid for ELFOSABI_AMDGPU_HSA and ELFABIVERSION_AMDGPU_HSA_V4.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:23,Availability,mask,mask,23,// Processor selection mask for EF_CUDA_SM* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Usability,Undo,Undocumented,3,// Undocumented software feature.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:31,Availability,mask,mask,31,// Virtual processor selection mask for EF_CUDA_VIRTUAL_SM* values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:126,Security,hash,hash,126,// Definitions from LoongArch ELF psABI v2.01.; // Reference: https://github.com/loongson/LoongArch-Documentation; // (commit hash 296de4def055c871809068e0816325a4ac04eb12); // Base ABI Modifiers,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,Availability,mask,mask,32,// Four-bit Xtensa machine type mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:34,Performance,load,loaded,34,// Address where section is to be loaded,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:39,Modifiability,variab,variables,39,// FORTRAN COMMON or C external global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:10,Security,hash,hash,10,// Symbol hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:47,Safety,safe,safe,47,// List of address-significant symbols; // for safe ICF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:8,Integrability,Depend,Dependent,8,// LLVM Dependent Library Specifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:18,Performance,load,loadable,18,// ELF header for loadable partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Performance,load,loadable,13,// Phdrs for loadable partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:13,Security,hash,hash,13,// GNU-style hash table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:59,Safety,avoid,avoid,59,// This section requires special OS-specific processing to avoid incorrect; // behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:87,Security,access,accesses,87,// All sections with the GPREL flag are grouped into a global data area; // for faster accesses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Which section (header table index) it's defined in; // These accessors and mutators correspond to the ELF32_ST_BIND,; // ELF32_ST_TYPE, and ELF32_ST_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:32,Security,access,accessors,32,// Size of the symbol; // These accessors and mutators are identical to those defined for ELF32; // symbol table entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:28,Modifiability,variab,variable,28,"// Symbol is a data object (variable, array, etc.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Symbol table index and type of relocation to apply; // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:64,Security,access,accessors,64,"// Compute value for relocatable field by adding this; // These accessors and mutators correspond to the ELF32_R_SYM, ELF32_R_TYPE,; // and ELF32_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:65,Security,access,accessors,65,"// Symbol table index and type of relocation to apply.; // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:65,Security,access,accessors,65,"// Compute value for relocatable field by adding this.; // These accessors and mutators correspond to the ELF64_R_SYM, ELF64_R_TYPE,; // and ELF64_R_INFO macros defined in the ELF specification:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Performance,Load,Loadable,3,// Loadable segment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:30,Performance,load,load,30,// Process all relocations on load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:22,Performance,load,load,22,// Reject attempts to load dynamically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:18,Performance,load,loading,18,// Trigger filtee loading at runtime.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Deployability,Configurat,Configuration,3,// Configuration alternative created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Config,Configuration,3,// Configuration alternative created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:10,Security,audit,auditing,10,// Global auditing required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:22,Energy Efficiency,power,power,22,// Hash size is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Security,Hash,Hash,3,// Hash size is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:9,Performance,load,load,9,// Delay-load DSO by default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:24,Safety,safe,safe,24,// Symbol table is in a safe order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:17,Availability,mask,mask,17,// Version Index mask,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:171,Deployability,upgrade,upgrade,171,"// Enumeration to determine the tagging mode. In Android-land, 'SYNC' means; // running all threads in MTE Synchronous mode, and 'ASYNC' means to use the; // kernels auto-upgrade feature to allow for either MTE Asynchronous,; // Asymmetric, or Synchronous mode. This allows silicon vendors to specify, on; // a per-cpu basis what 'ASYNC' should mean. Generally, the expectation is; // ""pick the most precise mode that's very fast"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:31,Performance,load,loader,31,// Bits indicating whether the loader should prepare for MTE to be enabled on; // the heap and/or stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h:3,Modifiability,Variab,Variable,3,// Variable in LDS; symbol encoded like SHN_COMMON,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/ELF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:22,Performance,load,loader,22,// Enums from <mach-o/loader.h>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags"" field in llvm::MachO::section and; // llvm::MachO::section_64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[7:0]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_TYPE); /// S_REGULAR - Regular section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:102,Availability,mask,mask,102,"// Constant masks for the ""flags[7:0]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_TYPE); /// S_REGULAR - Regular section.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:41,Testability,stub,stubs,41,"/// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in; /// the Reserved2 field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:61,Testability,stub,stub,61,"/// S_SYMBOL_STUBS - Section with symbol stubs, byte size of stub in; /// the Reserved2 field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:82,Performance,load,loaded,82,/// S_LAZY_DYLIB_SYMBOL_POINTERS - Section with lazy symbol pointers to; /// lazy loaded dylibs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:57,Modifiability,variab,variable,57,/// S_THREAD_LOCAL_VARIABLES - Section with thread local variable; /// structure data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:75,Modifiability,variab,variable,75,/// S_THREAD_LOCAL_INIT_FUNCTION_POINTERS - Section with thread local; /// variable initialization pointers to functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[31:24]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_USR); /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:104,Availability,mask,mask,104,"// Constant masks for the ""flags[31:24]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_USR); /// S_ATTR_PURE_INSTRUCTIONS - Section contains only true machine; /// instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:53,Testability,stub,stubs,53,/// S_ATTR_SELF_MODIFYING_CODE - Used with i386 code stubs written on by; /// dyld.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""flags[23:8]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_SYS); /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:103,Availability,mask,mask,103,"// Constant masks for the ""flags[23:8]"" field in llvm::MachO::section and; // llvm::MachO::section_64 (mask ""flags"" with SECTION_ATTRIBUTES_SYS); /// S_ATTR_SOME_INSTRUCTIONS - Section contains some machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,// Constant masks for the value of an indirect symbol in an indirect; // symbol table,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""n_type"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:12,Availability,mask,masks,12,"// Constant masks for the ""n_desc"" field in llvm::MachO::nlist and; // llvm::MachO::nlist_64; // The low 3 bits are the for the REFERENCE_TYPE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:45,Energy Efficiency,Power,PowerPC,45,// Constant values for the r_type field in a PowerPC architecture; // llvm::MachO::relocation_info or llvm::MachO::scattered_relocation_info; // structure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:6,Security,authenticat,authenticated,6,// An authenticated pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:24,Performance,load,loader,24,// Structs from <mach-o/loader.h>,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:123,Performance,load,load,123,/// Structs for dyld chained fixups.; /// dyld_chained_fixups_header is the data pointed to by LC_DYLD_CHAINED_FIXUPS; /// load command.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:3,Availability,Mask,Mask,3,// Mask for architecture bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Energy Efficiency,Power,PowerPC,16,// Old Motorola PowerPC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:3,Availability,Mask,Mask,3,// Mask for architecture bits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:25,Performance,load,load,25,// Define a union of all load command structs,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:36,Modifiability,variab,variable-length,36,// getStructOrErr() cannot copy the variable-length seg_info_offset array.; // Its elements must be byte swapped manually.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:7,Deployability,install,installer,7,/* has installer entitlement */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:11,Security,Validat,Validation,11,/* Library Validation required by Hardened System Policy */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:9,Performance,load,load,9,/* don't load invalid pages */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,validat,validation,19,/* require library validation */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:43,Modifiability,variab,variables,43,/* has com.apple.rootless.restricted-nvram-variables.heritable; entitlement */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Performance,load,load,16,/* dyld used to load this is a platform binary */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:33,Performance,load,loaded,33,"/* code is dev signed, cannot be loaded into prod signed code; (will go away with rdar://problem/28322552) */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:26,Security,validat,validation,26,/* OBSOLETE: skip library validation */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,hash,hashes,19,/* always - larger hashes are truncated */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:85,Modifiability,plugin,plugins,85,"/* max size of the hash we'll support */; /*; * Currently only to support Legacy VPN plugins, and Mac App Store; * but intended to replace all the various platform code, dev code etc. bits.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:19,Security,hash,hash,19,"/* max size of the hash we'll support */; /*; * Currently only to support Legacy VPN plugins, and Mac App Store; * but intended to replace all the various platform code, dev code etc. bits.; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:13,Security,hash,hash,13,/* offset of hash slot element at index zero */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:21,Security,hash,hash,21,/* number of special hash slots */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:29,Security,hash,hash,29,/* number of ordinary (code) hash slots */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:16,Security,hash,hash,16,/* size of each hash in bytes */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h:11,Security,hash,hash,11,/* type of hash (cdHashType* constants) */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MachO.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h:23,Testability,stub,stub,23,///< Mach-O Shared lib stub,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h:32,Testability,Stub,Stub,32,///< Text-based Dynamic Library Stub file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Magic.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h:113,Integrability,depend,depends,113,/// Detailed information about the processor of the system that generated this; /// minidump. Its interpretation depends on the ProcessorArchitecture enum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Minidump.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:20,Integrability,Message,MessagePack,20,"//===-- MsgPack.h - MessagePack Constants -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains constants used for implementing MessagePack support.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:447,Integrability,Message,MessagePack,447,"//===-- MsgPack.h - MessagePack Constants -----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains constants used for implementing MessagePack support.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:55,Integrability,Message,MessagePack,55,/// The endianness of all multi-byte encoded values in MessagePack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:34,Integrability,Message,MessagePack,34,/// The first byte identifiers of MessagePack object formats.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:343,Availability,mask,mask,343,"/// Most significant bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBits::String contains 0b10100000.; ///; /// A corresponding mask of the bit pattern is found in \c FixBitsMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:61,Integrability,Message,MessagePack,61,"/// Most significant bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBits::String contains 0b10100000.; ///; /// A corresponding mask of the bit pattern is found in \c FixBitsMask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:4,Availability,Mask,Mask,4,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:360,Availability,mask,mask,360,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h:52,Integrability,Message,MessagePack,52,"/// Mask of bits used to identify ""Fix"" variants in MessagePack.; ///; /// For example, FixStr objects encode their size in the five least significant; /// bits of their first byte, which is identified by the bit pattern ""101"" in; /// the three most significant bits. So FixBitsMask::String contains; /// 0b11100000.; ///; /// The corresponding bit pattern to mask for is found in FixBits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPack.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:423,Security,expose,exposes,423,"//===-- MsgPackDocument.h - MsgPack Document --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:433,Usability,simpl,simple,433,"//===-- MsgPackDocument.h - MsgPack Document --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This file declares a class that exposes a simple in-memory representation; /// of a document of MsgPack objects, that can be read from MsgPack, written to; /// MsgPack, and inspected and modified in memory. This is intended to be a; /// lighter-weight (in terms of memory allocations) replacement for; /// MsgPackTypes.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:44,Usability,simpl,simple,44,/// A node in a MsgPack Document. This is a simple copyable and; /// passable-by-value type that does not own any memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:3,Security,Access,Accessors,3,"// Accessors. isEmpty() returns true for both a default-constructed DocNode; // that has no associated Document, and the result of getEmptyNode(), which; // does have an associated document.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:297,Safety,avoid,avoid,297,"/// Convenience assignment operators. This only works if the destination; /// DocNode has an associated Document, i.e. it was not constructed using the; /// default constructor. The string one does not copy, so the string must; /// remain valid for the lifetime of the Document. Use fromString to avoid; /// that restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:7,Security,access,access,7,// Map access methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:11,Security,access,access,11,/// Member access. The string data must remain valid for the lifetime of the; /// Document.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:11,Security,access,access,11,"/// Member access, with convenience versions for an integer key.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:9,Security,access,access,9,// Array access methods.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:25,Modifiability,extend,extends,25,"/// Element access. This extends the array if necessary, with empty nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:12,Security,access,access,12,"/// Element access. This extends the array if necessary, with empty nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:4,Usability,Simpl,Simple,4,/// Simple in-memory representation of a document of msgpack objects with; /// ability to find and create array and map elements. Does not currently cope; /// with any extension types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:513,Availability,error,error,513,"/// Read a document from a binary msgpack blob, merging into anything already; /// in the Document. The blob data must remain valid for the lifetime of this; /// Document (because a string object in the document contains a StringRef; /// into the original blob). If Multi, then this sets root to an array and; /// adds top-level objects to it. If !Multi, then it only reads a single; /// top-level object, even if there are more, and sets root to that. Returns; /// false if failed due to illegal format or merge error.; ///; /// The Merger arg is a callback function that is called when the merge has a; /// conflict, that is, it is trying to set an item that is already set. If the; /// conflict cannot be resolved, the callback function returns -1. If the; /// conflict can be resolved, the callback returns a non-negative number and; /// sets *DestNode to the resolved node. The returned non-negative number is; /// significant only for an array node; it is then the array index to start; /// populating at. That allows Merger to choose whether to merge array; /// elements (returns 0) or append new elements (returns existing size).; ///; /// If SrcNode is an array or map, the resolution must be that *DestNode is an; /// array or map respectively, although it could be the array or map; /// (respectively) that was already there. MapKey is the key if *DestNode is a; /// map entry, a nil node otherwise.; ///; /// The default for Merger is to disallow any conflict.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h:63,Availability,failure,failure,63,/// Read YAML text into the MsgPack document. Returns false on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackDocument.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:768,Availability,error,error,768,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:406,Integrability,Message,MessagePack,406,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:25,Usability,Simpl,Simple,25,"//===- MsgPackReader.h - Simple MsgPack reader ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This is a MessagePack reader.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// standard.; ///; /// Typical usage:; /// \code; /// StringRef input = GetInput();; /// msgpack::Reader MPReader(input);; /// msgpack::Object Obj;; ///; /// while (true) {; /// Expected<bool> ReadObj = MPReader.read(&Obj);; /// if (!ReadObj); /// // Handle error...; /// if (!ReadObj.get()); /// break; // Reached end of input; /// switch (Obj.Kind) {; /// case msgpack::Type::Int:; // // Use Obj.Int; /// break;; /// // ...; /// }; /// }; /// \endcode; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:4,Integrability,Message,MessagePack,4,"/// MessagePack types as defined in the standard, with the exception of Integer; /// being divided into a signed Int and unsigned UInt variant in order to map; /// directly to C++ types.; ///; /// The types map onto corresponding union members of the \c Object struct.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:4,Integrability,Message,MessagePack,4,"/// MessagePack object, represented as a tagged union of C++ types.; ///; /// All types except \c Type::Nil (which has only one value, and so is; /// completely represented by the \c Kind itself) map to a exactly one union; /// member.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:10,Integrability,Message,MessagePack,10,"/// Reads MessagePack objects from memory, one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:629,Availability,error,error,629,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:86,Deployability,update,updated,86,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:171,Deployability,update,updated,171,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h:606,Deployability,update,updated,606,"/// Read one object from the input buffer, advancing past it.; ///; /// The \p Obj is updated with the kind of the object read, and the; /// corresponding union member is updated.; ///; /// For the collection objects (Array and Map), only the length is read, and; /// the caller must make and additional \c N calls (in the case of Array) or; /// \c N*2 calls (in the case of Map) to \c Read to retrieve the collection; /// elements.; ///; /// \param [out] Obj filled with next object on success.; ///; /// \returns true when object successfully read, false when at end of; /// input (and so \p Obj was not updated), otherwise an error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:417,Integrability,Message,MessagePack,417,"//===- MsgPackWriter.h - Simple MsgPack writer ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a MessagePack writer.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// specification.; ///; /// Typical usage:; /// \code; /// raw_ostream output = GetOutputStream();; /// msgpack::Writer MPWriter(output);; /// MPWriter.writeNil();; /// MPWriter.write(false);; /// MPWriter.write(""string"");; /// // ...; /// \endcode; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:25,Usability,Simpl,Simple,25,"//===- MsgPackWriter.h - Simple MsgPack writer ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains a MessagePack writer.; ///; /// See https://github.com/msgpack/msgpack/blob/master/spec.md for the full; /// specification.; ///; /// Typical usage:; /// \code; /// raw_ostream output = GetOutputStream();; /// msgpack::Writer MPWriter(output);; /// MPWriter.writeNil();; /// MPWriter.write(false);; /// MPWriter.write(""string"");; /// // ...; /// \endcode; ///; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:11,Integrability,Message,MessagePack,11,"/// Writes MessagePack objects to an output stream, one at a time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:88,Integrability,Message,MessagePack,88,"/// Construct a writer, optionally enabling ""Compatibility Mode"" as defined; /// in the MessagePack specification.; ///; /// When in \p Compatible mode, the writer will write \c Str16 formats; /// instead of \c Str8 formats, and will refuse to write any \c Bin formats.; ///; /// \param OS stream to output MessagePack objects to.; /// \param Compatible when set, write in ""Compatibility Mode"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h:307,Integrability,Message,MessagePack,307,"/// Construct a writer, optionally enabling ""Compatibility Mode"" as defined; /// in the MessagePack specification.; ///; /// When in \p Compatible mode, the writer will write \c Str16 formats; /// instead of \c Str8 formats, and will refuse to write any \c Bin formats.; ///; /// \param OS stream to output MessagePack objects to.; /// \param Compatible when set, write in ""Compatibility Mode"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/MsgPackWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h:18,Integrability,depend,dependencies,18,// Shared library dependencies,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h:22,Modifiability,extend,extended,22,// Set to non-zero if extended const is used (i.e. more than; // one instruction),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/Wasm.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Availability,Mask,Masks,3,// Masks for packing/unpacking the r_rsize field of relocations.; // The msb is used to indicate if the bits being relocated are signed or; // unsigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:46,Performance,load,loader,46,"///< file is executable (i.e., it; ///< has a loader section)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:31,Modifiability,variab,variable,31,///< executable requests using variable size pages,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:25,Performance,load,loadable,25,///< file is dynamically loadable and; ///< executable (equivalent to F_EXEC on AIX),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:17,Performance,load,loaded,17,"///< file can be loaded by the system loader, but it is; ///< ignored by the linker if it is a member of an archive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:38,Performance,load,loader,38,"///< file can be loaded by the system loader, but it is; ///< ignored by the linker if it is a member of an archive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:31,Integrability,Interface,Interface,31,///< Global Linkage (Interfile Interface Code),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Modifiability,Extend,Extended,5,///< Extended Operation (Pseudo Machine Instruction),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:30,Modifiability,variab,variable,30,///< Initialized thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:32,Modifiability,variab,variable,32,///< Uninitialized thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:40,Availability,Mask,Masks,40,"// Flags for defining the section type. Masks for use with the (signed, 32-bit); // s_flags field of the section header structure, selecting for values in the; // lower 16 bits. Defined in the system header `scnhdr.h`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:10,Modifiability,variab,variable,10,// Global variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Energy Efficiency,allocate,allocated,14,// Statically allocated symbol,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Modifiability,variab,variable,23,// Global thread-local variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Modifiability,variab,variable,23,// Static thread-local variable; // Storage classes used for DWARF symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:22,Energy Efficiency,allocate,allocated,22,// Automatic variable allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:13,Modifiability,variab,variable,13,// Automatic variable allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:26,Energy Efficiency,allocate,allocated,26,// Argument to subroutine allocated on stack,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:12,Modifiability,variab,variable,12,// Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:63,Usability,Undo,Undocumented,63,// Declaration of object (type); // Storage classes - Obsolete/Undocumented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:13,Modifiability,variab,variable,13,// Automatic variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:12,Modifiability,variab,variable,12,// Register variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:23,Performance,load,load,23,///< Positive indirect load relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Performance,load,load,14,///< Positive load address relocation. Modifiable instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:27,Performance,load,load,27,"///< TOC relative indirect load relocation. Similar to R_TOC,; ///< but not modifiable instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:256,Performance,load,load,256,///< Relative to the TOC or to the thread-local storage base; ///< relocation. Compilers are not permitted to generate this; ///< relocation type. It is the result of a reversible; ///< transformation by the linker of an R_TOC relation that turned a; ///< load instruction into an add-immediate instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:219,Integrability,depend,dependency,219,///< A non-relocating relocation. Used to prevent the binder; ///< from garbage collecting a csect (such as code used for; ///< dynamic initialization of non-local statics) for which; ///< another csect has an implicit dependency.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Energy Efficiency,Power,PowerPC,5,///< PowerPC common architecture 64-bit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:5,Energy Efficiency,POWER,POWER,5,///< POWER and PowerPC architecture common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:15,Energy Efficiency,Power,PowerPC,15,///< POWER and PowerPC architecture common.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:14,Energy Efficiency,Power,PowerPC,14,///< PPC970 - PowerPC 64-bit architecture.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Availability,Mask,Masks,3,// Masks to select leftmost bits for decoding parameter type information.; // Bit to use when vector info is not presented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:3,Modifiability,Extend,Extended,3,// Extended Traceback table flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h:19,Deployability,canary,canary,19,///< stack smasher canary present on stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/BinaryFormat/XCOFF.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeAnalyzer.h - Bitcode analyzer --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to analyze LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h:56,Availability,avail,available,56,/// Don't emit numeric info in dump if symbolic info is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeAnalyzer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:55,Integrability,Wrap,Wrappers,55,"//===- llvm/Bitcode/BitcodeConvenience.h - Convenience Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Convenience wrappers for the LLVM bitcode format and bitstream APIs.; ///; /// This allows you to use a sort of DSL to declare and use bitcode; /// abbreviations and records. Example:; ///; /// \code; /// using Metadata = BCRecordLayout<; /// METADATA_ID, // ID; /// BCFixed<16>, // Module format major version; /// BCFixed<16>, // Module format minor version; /// BCBlob // misc. version information; /// >;; /// Metadata metadata(Out);; /// metadata.emit(ScratchRecord, VERSION_MAJOR, VERSION_MINOR, Data);; /// \endcode; ///; /// For details on the bitcode format, see; /// http://llvm.org/docs/BitCodeFormat.html; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:403,Integrability,wrap,wrappers,403,"//===- llvm/Bitcode/BitcodeConvenience.h - Convenience Wrappers -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file Convenience wrappers for the LLVM bitcode format and bitstream APIs.; ///; /// This allows you to use a sort of DSL to declare and use bitcode; /// abbreviations and records. Example:; ///; /// \code; /// using Metadata = BCRecordLayout<; /// METADATA_ID, // ID; /// BCFixed<16>, // Module format major version; /// BCFixed<16>, // Module format minor version; /// BCBlob // misc. version information; /// >;; /// Metadata metadata(Out);; /// metadata.emit(ScratchRecord, VERSION_MAJOR, VERSION_MINOR, Data);; /// \endcode; ///; /// For details on the bitcode format, see; /// http://llvm.org/docs/BitCodeFormat.html; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:4,Testability,Assert,Asserts,4,/// Asserts that the given data is a valid value for this field.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:365,Availability,down,down,365,"// namespace detail; /// Represents a literal operand in a bitcode record.; ///; /// The value of a literal operand is the same for all instances of the record,; /// so it is only emitted in the abbreviation definition.; ///; /// Note that because this uses a compile-time template, you cannot have a; /// literal operand that is fixed at run-time without dropping down to the; /// raw LLVM APIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:17,Modifiability,variab,variable-width,17,/// Represents a variable-width value in a bitcode record.; ///; /// The \p Width parameter should include the continuation bit.; ///; /// Note that the LLVM bitcode format only supports unsigned values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:9,Security,validat,validate,9,// TODO: validate array data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h:76,Security,access,accessor,76,/// Blob data is not stored in the buffer if you are using the correct; /// accessor; this method should not be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeConvenience.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeReader.h - Bitcode reader ------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to read LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:47,Availability,Error,Error,47,// These functions are for converting Expected/Error values to; // ErrorOr/std::error_code for compatibility with legacy clients. FIXME:; // Remove these functions once no longer needed by the C and libLTO APIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:67,Availability,Error,ErrorOr,67,// These functions are for converting Expected/Error values to; // ErrorOr/std::error_code for compatibility with legacy clients. FIXME:; // Remove these functions once no longer needed by the C and libLTO APIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:201,Deployability,upgrade,upgrade,201,"/// The ValueType callback is called for every function definition or; /// declaration and allows accessing the type information, also behind; /// pointers. This can be useful, when the opaque pointer upgrade cleans all; /// type information behind pointers.; /// The second argument to ValueTypeCallback is the type ID of the; /// function, the two passed functions can be used to extract type; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:98,Security,access,accessing,98,"/// The ValueType callback is called for every function definition or; /// declaration and allows accessing the type information, also behind; /// pointers. This can be useful, when the opaque pointer upgrade cleans all; /// type information behind pointers.; /// The second argument to ValueTypeCallback is the type ID of the; /// function, the two passed functions can be used to extract type; /// information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:132,Performance,load,load,132,"/// Read the bitcode module and prepare for lazy deserialization of function; /// bodies. If ShouldLazyLoadMetadata is true, lazily load metadata as well.; /// If IsImporting is true, this module is being parsed for ThinLTO; /// importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:161,Performance,load,load,161,"/// Read the header of the specified bitcode buffer and prepare for lazy; /// deserialization of function bodies. If ShouldLazyLoadMetadata is true,; /// lazily load metadata as well. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,Availability,error,error,153,"/// Like getLazyBitcodeModule, except that the module takes ownership of; /// the memory buffer if successful. If successful, this moves Buffer. On; /// error, this *does not* move Buffer. If IsImporting is true, this module is; /// being parsed for ThinLTO importing into another module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:139,Availability,error,error,139,"/// Read the header of the specified bitcode buffer and extract just the; /// triple information. If successful, this returns a string. On error, this; /// returns """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:153,Availability,error,error,153,"/// Read the header of the specified bitcode buffer and extract just the; /// producer string information. If successful, this returns a string. On; /// error, this returns """".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:102,Integrability,wrap,wrapper,102,/// isBitcodeWrapper - Return true if the given bytes are the magic bytes; /// for an LLVM IR bitcode wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:34,Integrability,message,message,34,// See if you can find the hidden message in the magic bytes :-).; // (Hint: it's a little-endian encoding.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:110,Integrability,wrap,wrapper,110,/// isRawBitcode - Return true if the given bytes are the magic bytes for; /// raw LLVM IR bitcode (without a wrapper).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,Availability,redundant,redundant,109,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:37,Integrability,message,message,37,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:109,Safety,redund,redundant,109,"// These bytes sort of have a hidden message, but it's not in; // little-endian this time, and it's a little redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:118,Integrability,wrap,wrapper,118,"/// isBitcode - Return true if the given bytes are the magic bytes for; /// LLVM IR bitcode, either with or without a wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:548,Availability,down,down,548,"/// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special; /// header for padding or other reasons. The format of this header is:; ///; /// struct bc_header {; /// uint32_t Magic; // 0x0B17C0DE; /// uint32_t Version; // Version, currently always 0.; /// uint32_t BitcodeOffset; // Offset to traditional bitcode file.; /// uint32_t BitcodeSize; // Size of traditional bitcode file.; /// ... potentially other gunk ...; /// };; ///; /// This function is called when we find a file with a matching magic number.; /// In this case, skip down to the subsection of the file that is actually a; /// BC file.; /// If 'VerifyBufferSize' is true, check that the buffer is large enough to; /// contain the whole bitcode file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h:44,Integrability,wrap,wrap,44,"/// SkipBitcodeWrapperHeader - Some systems wrap bc files with a special; /// header for padding or other reasons. The format of this header is:; ///; /// struct bc_header {; /// uint32_t Magic; // 0x0B17C0DE; /// uint32_t Version; // Version, currently always 0.; /// uint32_t BitcodeOffset; // Offset to traditional bitcode file.; /// uint32_t BitcodeSize; // Size of traditional bitcode file.; /// ... potentially other gunk ...; /// };; ///; /// This function is called when we find a file with a matching magic number.; /// In this case, skip down to the subsection of the file that is actually a; /// BC file.; /// If 'VerifyBufferSize' is true, check that the buffer is large enough to; /// contain the whole bitcode file.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:403,Integrability,interface,interfaces,403,"//===- llvm/Bitcode/BitcodeWriter.h - Bitcode writers -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines interfaces to write LLVM bitcode files/streams.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:270,Performance,perform,performance,270,"/// Attempt to write a symbol table to the bitcode file. This must be called; /// at most once after all modules have been written.; ///; /// A reader does not require a symbol table to interpret a bitcode file;; /// the symbol table is needed only to improve link-time performance. So; /// this function may decide not to write a symbol table. It may so decide; /// if, for example, the target is unregistered or the IR is malformed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:360,Performance,optimiz,optimization,360,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:409,Security,hash,hashing,409,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:446,Security,hash,hash,446,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:604,Security,hash,hash,604,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:693,Security,hash,hash,693,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:791,Security,hash,hash,791,"/// Write the specified module to the buffer specified at construction time.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:440,Performance,optimiz,optimization,440,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:489,Security,hash,hashing,489,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:526,Security,hash,hash,526,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:684,Security,hash,hash,684,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:773,Security,hash,hash,773,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:871,Security,hash,hash,871,"/// Write the specified module to the specified raw output stream.; ///; /// For streams where it matters, the given stream should be in ""binary""; /// mode.; ///; /// If \c ShouldPreserveUseListOrder, encode the use-list order for each \a; /// Value in \c M. These will be reconstructed exactly when \a M is; /// deserialized.; ///; /// If \c Index is supplied, the bitcode will contain the summary index; /// (currently for use in ThinLTO optimization).; ///; /// \p GenerateHash enables hashing the Module and including the hash in the; /// bitcode (currently for use in ThinLTO incremental build).; ///; /// If \p ModHash is non-null, when GenerateHash is true, the resulting; /// hash is written into ModHash. When GenerateHash is false, that value; /// is used as the hash instead of computing from the generated bitcode.; /// Can be used to produce the same module hash for a minimized bitcode; /// used just for the thin link as in the regular full bitcode that will; /// be used in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h:132,Availability,avail,available,132,"/// If EmbedBitcode is set, save a copy of the llvm IR as data in the; /// __LLVM,__bitcode section (.llvmbc on non-MacOS).; /// If available, pass the serialized module via the Buf parameter. If not,; /// pass an empty (default-initialized) MemoryBufferRef, and the serialization; /// will be handled by this API. The same behavior happens if the provided Buf; /// is not bitcode (i.e. if it's invalid data or even textual LLVM assembly).; /// If EmbedCmdline is set, the command line is also exported in; /// the corresponding section (__LLVM,_cmdline / .llvmcmd) - even if CmdArgs; /// were empty.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h:277,Performance,optimiz,optimization,277,"/// Construct a bitcode writer pass around a particular output stream.; ///; /// If \c ShouldPreserveUseListOrder, encode use-list order so it can be; /// reproduced when deserialized.; ///; /// If \c EmitSummaryIndex, emit the summary index (currently; /// for use in ThinLTO optimization).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/BitcodeWriterPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:103,Availability,error,error,103,// Block intended to contains information on the bitcode versioning.; // Can be used to provide better error messages when we fail to parse a; // bitcode file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:109,Integrability,message,messages,109,// Block intended to contains information on the bitcode versioning.; // Can be used to provide better error messages when we fail to parse a; // bitcode file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:120,Deployability,upgrade,upgrade,120,"/// Identification block contains a string that describes the producer details,; /// and an epoch that defines the auto-upgrade capability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:36,Deployability,upgrade,upgrade,36,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:112,Deployability,release,release,112,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:133,Deployability,release,release,133,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:191,Deployability,release,releases,191,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:308,Deployability,release,release,308,"/// The epoch that defines the auto-upgrade compatibility for the bitcode.; ///; /// LLVM guarantees in a major release that a minor release can read bitcode; /// generated by previous minor releases. We translate this by making the reader; /// accepting only bitcode with the same epoch, except for the X.0 release which; /// also accepts N-1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Security,HASH,HASH,3,// HASH: [5*i32],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:25,Testability,test,test,25,// The list of llvm.type.test type identifiers used by the following function; // that are used other than by an llvm.assume.; // [n x typeid],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:83,Testability,test,test,83,"// The list of virtual calls made by this function using; // llvm.assume(llvm.type.test) intrinsics that do not have all constant; // integer arguments.; // [n x (typeid, offset)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:79,Performance,load,load,79,"// The list of virtual calls made by this function using; // llvm.type.checked.load intrinsics that do not have all constant integer; // arguments.; // [n x (typeid, offset)]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:86,Testability,test,test,86,"// Identifies a virtual call made by this function using an; // llvm.assume(llvm.type.test) intrinsic with all constant integer arguments.; // [typeid, offset, n x arg]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:82,Performance,load,load,82,"// Identifies a virtual call made by this function using an; // llvm.type.checked.load intrinsic with all constant integer arguments.; // [typeid, offset, n x arg]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:13,Usability,GUID,GUID,13,"// Assigns a GUID to a value ID. This normally appears only in combined; // summaries, but it can also appear in per-module summaries for PGO data.; // [valueid, guid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:162,Usability,guid,guid,162,"// Assigns a GUID to a value ID. This normally appears only in combined; // summaries, but it can also appear in per-module summaries for PGO data.; // [valueid, guid]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:25,Security,access,accessed,25,"// Range information for accessed offsets for every argument.; // [n x (paramno, range, numcalls, numcalls x (callee_guid, paramno, range))]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:35,Security,checksum,checksumkind,35,"// [distinct, filename, directory, checksumkind, checksum]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:49,Security,checksum,checksum,49,"// [distinct, filename, directory, checksumkind, checksum]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:27,Modifiability,variab,variable,27,"// [distinct, scope, name, variable,...]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol]; // 21 is unused.; // 22 is unused.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:142,Availability,avail,available,142,"// VAARG: [valistty, valist, instty]; // This store code encodes the pointer type, rather than the value type; // this is so information only available in the pointer type (e.g. address; // spaces) is retained.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Usability,RESUME,RESUME,3,// RESUME: [opval],MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h:3,Performance,LOAD,LOAD,3,"// LOAD: [opty, op, align, vol,; // ordering, synchscope]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitcode/LLVMBitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h:46,Integrability,wrap,wrapper,46,/// Offsets of the 32-bit fields of bitstream wrapper header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h:111,Availability,avail,available,111,"/// BLOCKINFO_BLOCK is used to define metadata about blocks, for example,; /// standard abbrevs that should be available to all blocks of a specified; /// ID.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodeEnums.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:3,Security,Access,Accessors,3,// Accessors for literals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:3,Security,Access,Accessors,3,// Accessors for encoding info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h:120,Safety,redund,redundancy,120,"/// BitCodeAbbrev - This class represents an abbreviation record. An; /// abbreviation allows a complex record that has redundancy to be stored in a; /// specialized format instead of the fully-general, fully-vbr, format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitCodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:54,Integrability,interface,interface,54,"//===- BitstreamReader.h - Low-level bitstream reader interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the BitstreamReader class. This class can be used to; // read an arbitrary bitstream, regardless of its contents.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:135,Modifiability,inherit,inherit,135,/// This contains information emitted to BLOCKINFO_BLOCK blocks. These; /// describe abbreviations that all blocks of the specified ID inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:9,Availability,mask,mask,9,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:17,Safety,avoid,avoid,17,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:26,Safety,abort,abort,26,"// If we run out of data, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:9,Availability,mask,mask,9,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:17,Safety,avoid,avoid,17,// Use a mask to avoid undefined behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:83,Usability,Simpl,SimpleBitstreamCursor,83,"/// This represents a position within a bitcode file, implemented on top of a; /// SimpleBitstreamCursor.; ///; /// Unlike iterators, BitstreamCursors are heavy-weight objects that should not; /// be passed by value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:12,Deployability,install,installed,12,/// Abbrevs installed at in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h:65,Availability,error,error,65,"/// Read and return a block info block from the bitstream. If an error was; /// encountered, return std::nullopt.; ///; /// \param ReadBlockInfoNames Whether to read block/record name information in; /// the BlockInfo block. Only llvm-bcanalyzer uses this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:54,Integrability,interface,interface,54,"//===- BitstreamWriter.h - Low-level bitstream writer interface -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This header defines the BitstreamWriter class. This class can be used to; // write an arbitrary bitstream, regardless of its contents.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:25,Deployability,install,installed,25,/// CurAbbrevs - Abbrevs installed at in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:147,Modifiability,inherit,inherit,147,/// BlockInfo - This contains information emitted to BLOCKINFO_BLOCK blocks.; /// These describe abbreviations that all blocks of the specified ID inherit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:16,Deployability,update,update,16,// Copy data to update into Bytes from the file FS and the buffer Out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:107,Deployability,update,updated,107,"// When unaligned, copy existing data into Bytes from the file FS and the; // buffer Out so that it can be updated before writing. For debug builds; // read bytes unconditionally in order to check that the existing value is 0; // as expected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:3,Deployability,Update,Update,3,// Update Bytes in terms of bit offset and value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:8,Deployability,update,updated,8,// Copy updated data back to the file FS and the buffer Out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:3,Deployability,Update,Update,3,// Update the block size field in the header of this sub-block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:39,Testability,assert,assertion,39,// Know that blob data is consumed for assertion below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h:245,Integrability,rout,routine,245,"/// EmitRecordWithBlob - Emit the specified record to the stream, using an; /// abbrev that includes a blob at the end. The blob data to emit is; /// specified by the pointer and length specified at the end. In contrast to; /// EmitRecord, this routine expects that the first entry in Vals is the code; /// of the record.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/Bitstream/BitstreamWriter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:2338,Modifiability,parameteriz,parameterized,2338,"/ section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notion of an on-disk; /// layout. This class is parameterized by an entry type, which should derive; /// from AccelTableData. This is the type of individual entries in the table,; /// and it should store the data necessary to emit them. AppleAccelTableData is; /// the base class for Apple Accelerator Table entries, which have a uniform; /// structure based on a sequence of Atoms. There are different sub-classes; /// derived from AppleAccelTable, which differ in the set of Atoms and how they; /// obtain their values.; ///; /// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:81,Performance,optimiz,optimized,81,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:70,Security,hash,hash,70,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:124,Security,access,access,124,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:505,Security,HASH,HASHES,505,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:686,Security,hash,hash,686,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:745,Security,hash,hashes,745,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:884,Security,hash,hashes,884,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:902,Security,hash,hashes,902,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:949,Security,hash,hash,949,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1061,Security,hash,hash,1061,"/// \file; /// The DWARF and Apple accelerator tables are an indirect hash table optimized; /// for null lookup rather than access to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1108,Security,hash,hash,1108,"to known data. The Apple accelerator; /// tables are a precursor of the newer DWARF v5 accelerator tables. Both; /// formats share common design ideas.; ///; /// The Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DW",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1259,Security,hash,hashes,1259,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1300,Security,hash,hash,1300,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1325,Security,hash,hash,1325,"e Apple accelerator table are output into an on-disk format that looks; /// like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | BUCKETS |; /// |------------------|; /// | HASHES |; /// |------------------|; /// | OFFSETS |; /// |------------------|; /// | DATA |; /// `------------------'; ///; /// The header contains a magic number, version, type of hash function,; /// the number of buckets, total number of hashes, and room for a special struct; /// of data and the length of that struct.; ///; /// The buckets contain an index (e.g. 6) into the hashes array. The hashes; /// section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notio",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:1893,Security,HASH,HASH,1893,"/ section contains all of the 32-bit hash values in contiguous memory, and the; /// offsets contain the offset into the data area for the particular hash.; ///; /// For a lookup example, we could hash a function name and take it modulo the; /// number of buckets giving us our bucket. From there we take the bucket value; /// as an index into the hashes table and look at each successive hash as long; /// as the hash value is still the same modulo result (bucket value) as earlier.; /// If we have a match we look at that same entry in the offsets table and grab; /// the offset in the data for our final match.; ///; /// The DWARF v5 accelerator table consists of zero or more name indices that; /// are output into an on-disk format that looks like this:; ///; /// .------------------.; /// | HEADER |; /// |------------------|; /// | CU LIST |; /// |------------------|; /// | LOCAL TU LIST |; /// |------------------|; /// | FOREIGN TU LIST |; /// |------------------|; /// | HASH TABLE |; /// |------------------|; /// | NAME TABLE |; /// |------------------|; /// | ABBREV TABLE |; /// |------------------|; /// | ENTRY POOL |; /// `------------------'; ///; /// For the full documentation please refer to the DWARF 5 standard.; ///; ///; /// This file defines the class template AccelTable, which is represents an; /// abstract view of an Accelerator table, without any notion of an on-disk; /// layout. This class is parameterized by an entry type, which should derive; /// from AccelTableData. This is the type of individual entries in the table,; /// and it should store the data necessary to emit them. AppleAccelTableData is; /// the base class for Apple Accelerator Table entries, which have a uniform; /// structure based on a sequence of Atoms. There are different sub-classes; /// derived from AppleAccelTable, which differ in the set of Atoms and how they; /// obtain their values.; ///; /// An Apple Accelerator Table can be serialized by calling emitAppleAccelTable; /// function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:4,Integrability,Interface,Interface,4,/// Interface which the different types of accelerator table data have to; /// conform. It serves as a base class for different values of the template; /// argument of the AccelTable class template.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:52,Security,hash,hash,52,// Subclasses should implement:; // static uint32_t hash(StringRef Name);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:38,Integrability,depend,dependant,38,/// A base class holding non-template-dependant functionality of the AccelTable; /// class. Clients should not use this class directly but rather instantiate; /// AccelTable with a type derived from AccelTableData.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:66,Security,hash,hash,66,"/// Represents a group of entries with identical name (and hence, hash value).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:18,Security,Hash,HashData,18,/// Allocator for HashData and Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:188,Modifiability,parameteriz,parameterized,188,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:157,Security,Hash,HashData,157,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:285,Security,hash,hash,285,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:315,Security,hash,hashing,315,"/// This class holds an abstract representation of an Accelerator Table,; /// consisting of a sequence of buckets, each bucket containint a sequence of; /// HashData entries. The class is parameterized by the type of entries it; /// holds. The type template parameter also defines the hash function to use for; /// hashing names.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:160,Modifiability,variab,variable,160,/// A base class for different implementations of Data classes for Apple; /// Accelerator Tables. The columns in the table are defined by the static Atoms; /// variable defined on the subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:127,Integrability,wrap,wrapper,127,"/// The Data class implementation for DWARF v5 accelerator table. Unlike the; /// Apple Data classes, this class is just a DIE wrapper, and does not know to; /// serialize itself. The complete serialization logic is in the; /// emitDWARF5AccelTable function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:207,Testability,log,logic,207,"/// The Data class implementation for DWARF v5 accelerator table. Unlike the; /// Apple Data classes, this class is just a DIE wrapper, and does not know to; /// serialize itself. The complete serialization logic is in the; /// emitDWARF5AccelTable function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:46,Usability,simpl,simple,46,/// Accelerator table data implementation for simple Apple accelerator tables; /// with just a DIE reference.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h:46,Usability,simpl,simple,46,/// Accelerator table data implementation for simple Apple accelerator tables; /// with a DIE offset but no actual DIE pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AccelTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:186,Energy Efficiency,schedul,scheduled,186,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:57,Performance,optimiz,optimized,57,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:257,Testability,test,tests,257,/// Test if the given instruction is in a position to be optimized; /// with a tail-call. This roughly means that it's in a block with; /// a return and there's nothing that needs to be scheduled; /// between it and the return.; ///; /// This function only tests target-independent requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:181,Performance,optimiz,optimizations,181,"/// Test if given that the input instruction is in the tail call position, if; /// there is an attribute mismatch between the caller and the callee that will; /// inhibit tail call optimizations.; /// \p AllowDifferingSizes is an output parameter which, if forming a tail call; /// is permitted, determines whether it's permitted only if the size of the; /// caller's and callee's return types match exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,"/// Test if given that the input instruction is in the tail call position, if; /// there is an attribute mismatch between the caller and the callee that will; /// inhibit tail call optimizations.; /// \p AllowDifferingSizes is an output parameter which, if forming a tail call; /// is permitted, determines whether it's permitted only if the size of the; /// caller's and callee's return types match exactly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:160,Performance,optimiz,optimization,160,/// Test if given that the input instruction is in the tail call position if the; /// return type or any attributes of the function will inhibit tail call; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h:4,Testability,Test,Test,4,/// Test if given that the input instruction is in the tail call position if the; /// return type or any attributes of the function will inhibit tail call; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/Analysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:516,Energy Efficiency,schedul,scheduling,516,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:44,Integrability,Depend,Dependence,44,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:456,Integrability,depend,dependence,456,"//===- llvm/CodeGen/AntiDepBreaker.h - Anti-Dependence Breaking -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the AntiDepBreaker class, which implements; // anti-dependence breaking heuristics for post-register-allocation scheduling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:53,Energy Efficiency,schedul,scheduler,53,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:111,Integrability,depend,dependencies,111,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:129,Safety,hazard,hazards,129,/// This class works in conjunction with the post-RA scheduler to rename; /// registers to break register anti-dependencies (WAR hazards).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:19,Integrability,depend,dependencies,19,/// Identifiy anti-dependencies within a basic-block region and break them by; /// renaming registers. Return the number of anti-dependencies broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:129,Integrability,depend,dependencies,129,/// Identifiy anti-dependencies within a basic-block region and break them by; /// renaming registers. Return the number of anti-dependencies broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:95,Energy Efficiency,schedul,scheduled,95,"/// Update liveness information to account for the current; /// instruction, which will not be scheduled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,/// Update DBG_VALUE or DBG_PHI if dependency breaker is updating; /// other machine instruction to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:35,Integrability,depend,dependency,35,/// Update DBG_VALUE or DBG_PHI if dependency breaker is updating; /// other machine instruction to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:4,Deployability,Update,Update,4,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:92,Deployability,update,update,92,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:66,Integrability,depend,dependency,66,/// Update all DBG_VALUE instructions that may be affected by the dependency; /// breaker's update of ParentMI to use NewReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:94,Energy Efficiency,Schedul,ScheduleDAGInstrs,94,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h:25,Integrability,depend,dependent,25,// The following code is dependent on the order in which the DbgValues are; // constructed in ScheduleDAGInstrs::buildSchedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AntiDepBreaker.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:4,Performance,Optimiz,Optimization,4,/// Optimization remark emitter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:59,Modifiability,extend,extended,59,/// struct HandlerInfo and Handlers permit users or target extended; /// AsmPrinter to add their own handlers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:161,Security,access,accessed,161,/// Return the symbol to be used for the specified basic block when its; /// address is taken. This cannot be its normal LBB label because the block; /// may be accessed outside its containing function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:276,Integrability,depend,depending,276,"// The table will contain these structs that point to the sled, the function; // containing the sled, and what kind of sled (and whether they should always; // be instrumented). We also use a version identifier that the runtime can use; // to decide what to do with the sled, depending on the version of the sled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:9,Availability,down,down,9,"/// Shut down the asmprinter. If you override this in your pass, you must make; /// sure to call it explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:108,Integrability,rout,routines,108,//===------------------------------------------------------------------===//; // Coarse grained IR lowering routines.; //===------------------------------------------------------------------===//; /// This should be called when a new MachineFunction is being processed from; /// runOnMachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:193,Security,sanitiz,sanitizers,193,"/// Since emitting CFI unwind information is entangled with supporting the; /// exceptions, this returns true for platforms which use CFI unwind; /// information for other purposes (debugging, sanitizers, ...) when; /// `MCAsmInfo::ExceptionsType == ExceptionHandling::None`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:30,Modifiability,variab,variable,30,/// Emit the specified global variable to the .s file.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:49,Energy Efficiency,power,power,49,"/// Emit an alignment directive to the specified power of two boundary. If a; /// global value is specified, and if that global has an explicit alignment; /// requested, it will override the alignment request if required for; /// correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:113,Modifiability,variab,variable,113,"/// Print a general LLVM constant to the .s file.; /// On AIX, when an alias refers to a sub-element of a global variable, the; /// label of that alias needs to be emitted before the corresponding element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:28,Modifiability,variab,variables,28,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:89,Modifiability,variab,variable,89,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:116,Modifiability,variab,variable,116,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:411,Modifiability,variab,variables,411,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:224,Performance,optimiz,optimization,224,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:422,Safety,avoid,avoid,422,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:251,Security,access,accesses,251,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:520,Security,access,accesses,520,"/// Unnamed constant global variables solely contaning a pointer to; /// another globals variable act like a global variable ""proxy"", or GOT; /// equivalents, i.e., it's only used to hold the address of the latter. One; /// optimization is to replace accesses to these proxies by using the GOT; /// entry for the final global instead. Hence, we select GOT equivalent; /// candidates among all the module global variables, avoid emitting them; /// unnecessarily and finally replace references to them by pc relative; /// accesses to GOT entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,//===------------------------------------------------------------------===//; // Symbol Lowering Routines.; //===------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,//===------------------------------------------------------------------===//; // Emission Helper Routines.; //===------------------------------------------------------------------===//; /// This is just convenient handler for printing offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:175,Availability,avail,available,175,"/// Emit something like "".long Hi-Lo"" where the size in bytes of the directive; /// is specified by Size and Hi/Lo specify the labels. This implicitly uses; /// .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:183,Availability,avail,available,183,"/// Emit something like "".long Label+Offset"" where the size in bytes of the; /// directive is specified by Size and Label specifies the label. This; /// implicitly uses .set if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:103,Integrability,Rout,Routines,103,"//===------------------------------------------------------------------===//; // Dwarf Emission Helper Routines; //===------------------------------------------------------------------===//; /// Emit a .byte 42 directive that corresponds to an encoding. If verbose; /// assembly output is enabled, we output comments describing the encoding.; /// Desc is a string saying what the encoding is specifying (e.g. ""LSDA"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:298,Integrability,depend,depends,298,"/// Emit the 4- or 8-byte offset of a string from the start of its section.; ///; /// When possible, emit a DwarfStringPool section offset without any; /// relocations, and without using the symbol. Otherwise, defers to \a; /// emitDwarfSymbolReference().; ///; /// The length of the emitted value depends on the DWARF format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:78,Integrability,depend,depending,78,"/// Emit something like "".long Label + Offset"" or "".quad Label + Offset""; /// depending on the DWARF format.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:29,Integrability,depend,depending,29,/// Emit 32- or 64-bit value depending on the DWARF format.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:96,Integrability,Rout,Routines,96,//===------------------------------------------------------------------===//; // Dwarf Lowering Routines; //===------------------------------------------------------------------===//; /// Emit frame instruction to describe the layout of the frame.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:97,Integrability,Rout,Routines,97,"//===------------------------------------------------------------------===//; // CodeView Helper Routines; //===------------------------------------------------------------------===//; /// Gets information required to create a CodeView debug symbol for a jump; /// table.; /// Return value is <Base Address, Base Offset, Branch Address, Entry Size>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h:494,Modifiability,portab,portably,494,"//===------------------------------------------------------------------===//; // Inline Asm Support; //===------------------------------------------------------------------===//; // These are hooks that targets can override to implement inline asm; // support. These should probably be moved out of AsmPrinter someday.; /// Print information related to the specified machine instr that is; /// independent of the operand, and may be independent of the instr itself.; /// This can be useful for portably encoding the comment character or other; /// bits of target-specific knowledge into the asmstrings. The syntax used is; /// ${:comment}. Targets can override this to add support for their own; /// strange codes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h:412,Integrability,interface,interface,412,"//===-- llvm/CodeGen/AsmPrinterHandler.h -----------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains a generic interface for AsmPrinter handlers,; // like debug and EH info emitters.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AsmPrinterHandler.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:9,Integrability,wrap,wrapper,9,/// Type wrapper for integer ID for Variables. 0 is reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:36,Modifiability,Variab,Variables,36,/// Type wrapper for integer ID for Variables. 0 is reserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:4,Modifiability,Variab,Variable,4,/// Variable location definition used by FunctionVarLocs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:34,Modifiability,variab,variable,34,/// Data structure describing the variable locations in a function. Used as the; /// result of the AssignmentTrackingAnalysis pass. Essentially read-only; /// outside of AssignmentTrackingAnalysis where it is built.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:20,Modifiability,Variab,VariableID,20,/// Maps VarLocInfo.VariableID to a DebugVariable for VarLocRecords.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:12,Modifiability,variab,variable,12,/// List of variable location changes grouped by the instruction the; /// change occurs before (see VarLocsBeforeInst). The elements from; /// zero to SingleVarLocEnd represent variables with a single location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:177,Modifiability,variab,variables,177,/// List of variable location changes grouped by the instruction the; /// change occurs before (see VarLocsBeforeInst). The elements from; /// zero to SingleVarLocEnd represent variables with a single location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:49,Modifiability,variab,variables,49,/// End of range of VarLocRecords that represent variables with a single; /// location that is valid for the entire scope. Range starts at 0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:38,Modifiability,variab,variable,38,/// Return the DILocalVariable of the variable represented by \p ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:53,Modifiability,variab,variable,53,///@name iterators; ///@{; /// First single-location variable location definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:38,Modifiability,variab,variable,38,/// One past the last single-location variable location definition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:10,Modifiability,variab,variable,10,/// First variable location definition that comes before \p Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h:22,Modifiability,variab,variable,22,/// One past the last variable location definition that comes before \p; /// Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AssignmentTrackingAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:77,Performance,load,loaded,77,"/// Parameters (see the expansion example below):; /// (the builder, %addr, %loaded, %new_val, ordering,; /// /* OUT */ %success, /* OUT */ %new_loaded)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:227,Availability,avail,available,227,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:333,Modifiability,rewrite,rewrite,333,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:714,Modifiability,Rewrite,RewriteAtomics,714,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:278,Performance,load,loads,278,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:879,Performance,load,load,879,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:938,Performance,load,loaded,938,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:1027,Performance,load,loaded,1027,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:1167,Performance,load,loaded,1167,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:587,Safety,avoid,avoid,587,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h:623,Safety,avoid,avoiding,623,"/// Expand an atomic RMW instruction into a loop utilizing; /// cmpxchg. You'll want to make sure your target machine likes cmpxchg; /// instructions in the first place and that there isn't another, better,; /// transformation available (for example AArch32/AArch64 have linked loads).; ///; /// This is useful in passes which can't rewrite the more exotic RMW; /// instructions directly into a platform specific intrinsics (because, say,; /// those intrinsics don't exist). If such a pass is able to expand cmpxchg; /// instructions directly however, then, with this function, it could avoid two; /// extra module passes (avoiding passes by `-atomic-expand` and itself). A; /// specific example would be PNaCl's `RewriteAtomics` pass.; ///; /// Given: atomicrmw some_op iN* %addr, iN %incr ordering; ///; /// The standard expansion we produce is:; /// [...]; /// %init_loaded = load atomic iN* %addr; /// br label %loop; /// loop:; /// %loaded = phi iN [ %init_loaded, %entry ], [ %new_loaded, %loop ]; /// %new = some_op iN %loaded, %incr; /// ; This is what -atomic-expand will produce using this function on i686; /// targets:; /// %pair = cmpxchg iN* %addr, iN %loaded, iN %new_val; /// %new_loaded = extractvalue { iN, i1 } %pair, 0; /// %success = extractvalue { iN, i1 } %pair, 1; /// ; End callback produced IR; /// br i1 %success, label %atomicrmw.end, label %loop; /// atomicrmw.end:; /// [...]; ///; /// Returns true if the containing function was modified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/AtomicExpandUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:29,Availability,error,error,29,// Returns a profile parsing error for the current line.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h:113,Availability,avail,available,113,// Map from every function name in the module to its debug info filename or; // empty string if no debug info is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionsProfileReader.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:339,Performance,optimiz,optimized,339,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:167,Safety,detect,detect,167,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:220,Security,hash,hash,220,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h:258,Security,hash,hash,258,"/// This checks if the source of this function has drifted since this binary was; /// profiled previously.; /// For now, we are piggy backing on what PGO does to; /// detect this with instrumented profiles. PGO emits an hash of the IR and; /// checks if the hash has changed. Advanced basic block layout is usually done; /// on top of PGO optimized binaries and hence this check works well in; /// practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicBlockSectionUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:455,Integrability,interface,interface,455,"//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a helper that implements much of the TTI interface in; /// terms of the target-independent code generator and TargetLowering; /// interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:544,Integrability,interface,interfaces,544,"//===- BasicTTIImpl.h -------------------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file provides a helper that implements much of the TTI interface in; /// terms of the target-independent code generator and TargetLowering; /// interfaces.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:133,Integrability,interface,interface,133,"/// Base class which can be used to help build a TTI implementation.; ///; /// This class provides as much implementation of the TTI interface as is; /// possible using the target independent parts of the code generator.; ///; /// In order to subclass it, your class must implement a getST() method to; /// return the subtarget, and a getTLI() method to return the target lowering.; /// We need these methods implemented in the derived class so that this class; /// doesn't have to duplicate storage for them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Security,access,access,23,/// Helper function to access this as a T.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:164,Availability,mask,mask,164,"// Shuffle cost is equal to the cost of extracting element from its argument; // plus the cost of inserting them onto the result vector.; // e.g. <4 x float> has a mask of <0,5,2,7> i.e we need to extract from; // index 0 of first vector, index 1 of second vector,index 2 of first; // vector and finally index 3 of second vector and insert them at index; // <0,1,2,3> of result vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:87,Availability,mask,masks,87,"// Compute the cost of conditionally executing the memory operations with; // variable masks. This includes extracting the individual conditions, a; // branches and PHIs to combine the results.; // NOTE: Estimating the cost of conditionally executing the memory; // operations accurately is quite difficult and the current solution; // provides a very rough estimate only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:78,Modifiability,variab,variable,78,"// Compute the cost of conditionally executing the memory operations with; // variable masks. This includes extracting the individual conditions, a; // branches and PHIs to combine the results.; // NOTE: Estimating the cost of conditionally executing the memory; // operations accurately is quite difficult and the current solution; // provides a very rough estimate only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:266,Testability,test,test,266,"/// Try to find the estimated number of clusters. Note that the number of; /// clusters identified in this function could be different from the actual; /// numbers found in lowering. This function ignore switches that are; /// lowered with a mix of jump table / bit test / BTree. This function was; /// initially intended to be used when estimating the cost of switch in; /// inline cost heuristic, but it's a generic cost model to be used in other; /// places (e.g., in loop unrolling).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:43,Testability,test,test,43,// Early exit if both a jump table and bit test are not allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Testability,test,test,31,// Check if suitable for a bit test,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:25,Availability,avail,available,25,"// Check whether FADD is available, as a proxy for floating-point in; // general.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:175,Performance,Optimiz,Optimization,175,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:290,Performance,queue,queue,290,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:593,Performance,Optimiz,Optimization,593,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:257,Safety,detect,detector,257,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:698,Safety,predict,predictor,698,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:1003,Testability,benchmark,benchmarking,1003,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:606,Usability,Guid,Guide,606,"// This unrolling functionality is target independent, but to provide some; // motivation for its intended use, for x86:; // According to the Intel 64 and IA-32 Architectures Optimization Reference; // Manual, Intel Core models and later have a loop stream detector (and; // associated uop queue) that can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have no more than 4 (8 for Nehalem and later) branches; // taken, and none of them may be calls.; // - The loop can have no more than 18 (28 for Nehalem and later) uops.; // According to the Software Optimization Guide for AMD Family 15h; // Processors, models 30h-4fh (Steamroller and later) have a loop predictor; // and loop buffer which can benefit from partial unrolling.; // The relevant requirements are:; // - The loop must have fewer than 16 branches; // - The loop must have less than 40 uops in all executed loop branches; // The number of taken branches in a loop is hard to estimate here, and; // benchmarking has revealed that it is better not to be conservative when; // estimating the branch count. As a result, we'll ignore the branch limits; // until someone finds a case where it matters in practice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:24,Performance,optimiz,optimizing,24,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Safety,Avoid,Avoid,3,// Avoid unrolling when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,optimiz,optimized,30,"// Set number of instructions optimized when ""back edge""; // becomes ""fall through"" to default value of 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:110,Performance,scalab,scalable,110,/// FIXME: a bitfield is not a reasonable abstraction for talking about; /// which elements are needed from a scalable vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:11,Integrability,wrap,wrapper,11,/// Helper wrapper for the DemandedElts variant of getScalarizationOverhead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Usability,simpl,simple,31,"// Ensure we return a sensible simple VT here, since many callers of; // this function require it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:71,Modifiability,extend,extending,71,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:31,Performance,load,load,31,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:81,Performance,load,load,81,"// If this is a zext/sext of a load, return 0 if the corresponding; // extending load exists on target and the result type is legal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:66,Usability,simpl,simple,66,"// If the cast is between same-sized registers, then the check is simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:44,Performance,load,loading,44,// Illegal bitcasts are done by storing and loading from a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:7,Availability,Mask,Mask,7,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:62,Availability,Mask,Mask,62,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:184,Availability,mask,mask,184,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:240,Availability,mask,mask,240,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:271,Availability,mask,mask,271,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:399,Availability,mask,mask,399,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:429,Availability,mask,mask,429,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:500,Availability,mask,mask,500,"// The Mask shuffling cost is extract all the elements of the Mask; // and insert each of them Factor times into the wide vector:; //; // E.g. an interleaved group with factor 3:; // %mask = icmp ult <8 x i32> %vec1, %vec2; // %interleaved.mask = shufflevector <8 x i1> %mask, <8 x i1> undef,; // <24 x i32> <0,0,0,1,1,1,2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7>; // The cost is estimated as extract all mask elements from the <8xi1> mask; // vector and insert them factor times into the <24xi1> shuffled mask; // vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:21,Performance,load,loads,21,// Assuming that all loads of legal types cost 1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:83,Modifiability,extend,extending,83,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:93,Performance,load,loads,93,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:159,Performance,scalab,scalable,159,// In practice it's not currently possible to have a change in lane; // length for extending loads or truncating stores so both types should; // have the same scalable property.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:110,Modifiability,extend,extending,110,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:20,Performance,load,load,20,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:120,Performance,load,load,120,"// This is a vector load that legalizes to a larger type than the vector; // itself. Unless the corresponding extending load or truncating store is; // legal, then this will scalarize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:20,Performance,load,load,20,// This is a vector load/store for some illegal type that is scalarized.; // We must account for the cost of building or decomposing the vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:23,Performance,scalab,scalable,23,"// We cannot scalarize scalable vectors, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:24,Performance,load,load,24,"// Firstly, the cost of load/store operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:582,Availability,mask,masked,582,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:232,Performance,load,load,232,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:261,Performance,load,load,261,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:385,Performance,load,loads,385,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:406,Performance,load,loads,406,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:518,Performance,load,loads,518,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:589,Performance,load,loads,589,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:632,Performance,load,loads,632,"// Scale the cost of the memory operation by the fraction of legalized; // instructions that will actually be used. We shouldn't account for the; // cost of dead instructions since they will be removed.; //; // E.g., An interleaved load of factor 8:; // %vec = load <16 x i64>, <16 x i64>* %ptr; // %v0 = shufflevector %vec, undef, <0, 8>; //; // If <16 x i64> is legalized to 8 v2i64 loads, only 2 of the loads will be; // used (those corresponding to elements [0:1] and [8:9] of the unlegalized; // type). The other loads are unused.; //; // TODO: Note that legalization can turn masked loads/stores into unmasked; // (legalized) loads/stores. This can be reflected in the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:17,Performance,load,loads,17,// The number of loads of a legal type it will take to represent a load; // of the unlegalized vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:67,Performance,load,load,67,// The number of loads of a legal type it will take to represent a load; // of the unlegalized vector type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:25,Performance,load,load,25,// Scale the cost of the load by the fraction of legal instructions that; // will be used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:155,Performance,load,load,155,"// The interleave cost is similar to extract sub vectors' elements; // from the wide vector, and insert them into sub vectors.; //; // E.g. An interleaved load of factor 2 (with one member of index 0):; // %vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle %vec, undef, <0, 2, 4, 6> ; Index 0; // The cost is estimated as extract elements at 0, 2, 4, 6 from the; // <8 x i32> vector and insert them into a <4 x i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:213,Performance,load,load,213,"// The interleave cost is similar to extract sub vectors' elements; // from the wide vector, and insert them into sub vectors.; //; // E.g. An interleaved load of factor 2 (with one member of index 0):; // %vec = load <8 x i32>, <8 x i32>* %ptr; // %v0 = shuffle %vec, undef, <0, 2, 4, 6> ; Index 0; // The cost is estimated as extract elements at 0, 2, 4, 6 from the; // <8 x i32> vector and insert them into a <4 x i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:281,Availability,mask,mask,281,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:383,Availability,mask,masked,383,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:464,Availability,mask,mask,464,"// The interleave cost is extract elements from sub vectors, and; // insert them into the wide vector.; //; // E.g. An interleaved store of factor 3 with 2 members at indices 0,1:; // (using VF=4):; // %v0_v1 = shuffle %v0, %v1, <0,4,undef,1,5,undef,2,6,undef,3,7,undef>; // %gaps.mask = <true, true, false, true, true, false,; // true, true, false, true, true, false>; // call llvm.masked.store <12 x i32> %v0_v1, <12 x i32>* %ptr,; // i32 Align, <12 x i1> %gaps.mask; // The cost is estimated as extract all elements (of actual members,; // excluding gaps) from both <4 x i32> vectors and insert into the <12 x; // i32> vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:12,Availability,mask,mask,12,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:155,Availability,Mask,MaskForGaps,155,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:182,Availability,mask,mask,182,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:290,Availability,mask,masks,290,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:231,Security,access,access,231,"// The Gaps mask is invariant and created outside the loop, therefore the; // cost of creating it is not accounted for here. However if we have both; // a MaskForGaps and some other mask that guards the execution of the; // memory access, we need to account for the cost of And-ing the two masks; // inside the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:40,Performance,perform,performed,40,// The cost is modeled on the expansion performed by ExpandPowI in; // SelectionDAGBuilder.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,scalab,scalable,30,// FIXME: Handle case where a scalable vector is extracted from a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:66,Performance,scalab,scalable,66,// FIXME: Handle case where a scalable vector is extracted from a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:30,Performance,scalab,scalable,30,// FIXME: Handle case where a scalable vector is inserted into a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:65,Performance,scalab,scalable,65,// FIXME: Handle case where a scalable vector is inserted into a scalable; // vector,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:49,Availability,mask,mask,49,// Non-vp version will have same Args/Tys except mask and vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:3,Performance,Scalab,Scalable,3,"// Scalable vectors cannot be scalarized, so return Invalid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:1187,Energy Efficiency,reduce,reduced,1187,"/// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.; /// We're assuming that reduction operation are performing the following way:; ///; /// %val1 = shufflevector<n x t> %val, <n x t> %undef,; /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/2 elements n/2 elements; /// %red1 = op <n x t> %val, <n x t> val1; /// After this operation we have a vector %red1 where only the first n/2; /// elements are meaningful, the second n/2 elements are undefined and can be; /// dropped. All other operations are actually working with the vector of; /// length n/2, not n, though the real vector length is still n.; /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,; /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/4 elements 3*n/4 elements; /// %red2 = op <n x t> %red1, <n x t> val2 - working with the vector of; /// length n/2, the resulting vector has length n/4 etc.; ///; /// The cost model should take into account that the actual length of the; /// vector is reduced on each iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:128,Performance,perform,performing,128,"/// Try to calculate arithmetic and shuffle op costs for reduction intrinsics.; /// We're assuming that reduction operation are performing the following way:; ///; /// %val1 = shufflevector<n x t> %val, <n x t> %undef,; /// <n x i32> <i32 n/2, i32 n/2 + 1, ..., i32 n, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/2 elements n/2 elements; /// %red1 = op <n x t> %val, <n x t> val1; /// After this operation we have a vector %red1 where only the first n/2; /// elements are meaningful, the second n/2 elements are undefined and can be; /// dropped. All other operations are actually working with the vector of; /// length n/2, not n, though the real vector length is still n.; /// %val2 = shufflevector<n x t> %red1, <n x t> %undef,; /// <n x i32> <i32 n/4, i32 n/4 + 1, ..., i32 n/2, i32 undef, ..., i32 undef>; /// \----------------v-------------/ \----------v------------/; /// n/4 elements 3*n/4 elements; /// %red2 = op <n x t> %red1, <n x t> val2 - working with the vector of; /// length n/2, the resulting vector has length n/4 etc.; ///; /// The cost model should take into account that the actual length of the; /// vector is reduced on each iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:236,Integrability,depend,dependent,236,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:91,Performance,perform,performed,91,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:180,Performance,perform,performed,180,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction operations are performed on the vectors with the same; // architecture-dependent length.; // By default reductions need one shuffle per reduction level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:33,Performance,perform,performing,33,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:669,Performance,scalab,scalable,669,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:486,Usability,simpl,simple,486,"/// Try to calculate the cost of performing strict (in-order) reductions,; /// which involves doing a sequence of floating point additions in lane; /// order, starting with an initial value. For example, consider a scalar; /// initial value 'InitVal' of type float and a vector of type <4 x float>:; ///; /// Vector = <float %v0, float %v1, float %v2, float %v3>; ///; /// %add1 = %InitVal + %v0; /// %add2 = %add1 + %v1; /// %add3 = %add2 + %v2; /// %add4 = %add3 + %v3; ///; /// As a simple estimate we can say the cost of such a reduction is 4 times; /// the cost of a scalar FP addition. We can only estimate the costs for; /// fixed-width vectors here because for scalable vectors we do not know the; /// runtime number of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:50,Performance,scalab,scalable,50,"// Targets must implement a default value for the scalable case, since; // we don't know how many lanes the vector has.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:234,Integrability,depend,dependent,234,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction opertions are perfomed on the vectors with the same; // architecture-dependent length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h:91,Performance,perform,performed,91,// The minimal length of the vector is limited by the real length of vector; // operations performed on the current platform. That's why several final; // reduction opertions are perfomed on the vectors with the same; // architecture-dependent length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/BasicTTIImpl.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:50,Integrability,depend,depending,50,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h:44,Safety,avoid,avoid,44,"// The constant 25 instructions is added to avoid depending too much on; // accidental SlotIndex gaps for small intervals. The effect is that small; // intervals have a spill weight that is mostly proportional to the number; // of uses, while large intervals get a spill weight that is closer to a use; // density.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CalcSpillWeights.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Modifiability,extend,extended,21,// The value is sign extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Modifiability,extend,extended,21,// The value is zero extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:16,Modifiability,extend,extended,16,// The value is extended with undefined upper bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:73,Modifiability,extend,extended,73,// The value is in the upper bits of the location and should be; // sign extended when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:73,Modifiability,extend,extended,73,// The value is in the upper bits of the location and should be; // zero extended when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:68,Modifiability,extend,extended,68,// The value is in the upper bits of the location and should be; // extended with undefined upper bits when retrieved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:34,Modifiability,extend,extended,34,// The floating-point value is fp-extended in the location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:223,Integrability,depend,dependent,223,// Holds one of:; // - the register that the value is assigned to;; // - the memory offset at which the value resides;; // - additional information about pending location; the exact interpretation; // of the data is target-dependent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:210,Energy Efficiency,allocate,allocate,210,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:197,Security,access,accessors,197,/// CCState - This class holds information needed while lowering arguments and; /// return values. It captures which registers are already assigned and which; /// stack slots are used. It provides accessors to allocate these values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:31,Energy Efficiency,allocate,allocated,31,// True if arguments should be allocated at negative offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:18,Energy Efficiency,allocate,allocated,18,// First register allocated for current parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocated,29,// First after last register allocated for current parameter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:38,Energy Efficiency,allocate,allocated,38,/// Returns the size of the currently allocated portion of the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:78,Energy Efficiency,allocate,allocated,78,/// isAllocated - Return true if the specified register (or an alias) is; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:100,Performance,perform,performed,100,"/// CheckReturn - Analyze the return values of a function, returning; /// true if the return can be performed without sret-demotion, and; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:13,Energy Efficiency,allocate,allocated,13,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:55,Energy Efficiency,allocate,allocated,55,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:155,Energy Efficiency,allocate,allocated,155,/// A shadow allocated register is a register that was allocated; /// but wasn't added to the location list (Locs).; /// \returns true if the register was allocated as shadow or false otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:125,Energy Efficiency,allocate,allocated,125,"/// getFirstUnallocated - Return the index of the first unallocated register; /// in the set, or Regs.size() if they are all allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Availability,avail,available,65,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateReg,4,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocate,29,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:161,Energy Efficiency,allocate,allocated,161,"/// AllocateReg - Attempt to allocate one register. If it is not available,; /// return zero. Otherwise, return the register, marking it and any aliases; /// as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateReg,15,/// Version of AllocateReg with extra register to be shadowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:87,Availability,avail,available,87,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:143,Availability,avail,available,143,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateReg,4,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:29,Energy Efficiency,allocate,allocate,29,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:189,Energy Efficiency,allocate,allocated,189,"/// AllocateReg - Attempt to allocate one of the specified registers. If none; /// are available, return zero. Otherwise, return the first one available,; /// marking it and any aliases as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Energy Efficiency,allocate,allocated,65,// Didn't find the reg.; // Mark the register and any aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateRegBlock,4,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:34,Energy Efficiency,allocate,allocate,34,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:198,Energy Efficiency,allocate,allocated,198,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:237,Energy Efficiency,allocate,allocated,237,"/// AllocateRegBlock - Attempt to allocate a block of RegsRequired consecutive; /// registers. If this is not possible, return zero. Otherwise, return the first; /// register of the block that were allocated, marking the entire block as allocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:21,Energy Efficiency,allocate,allocated,21,// Check for already-allocated regs in this block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:28,Energy Efficiency,allocate,allocated,28,// Mark the entire block as allocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:16,Availability,avail,available,16,// No block was available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateReg,15,/// Version of AllocateReg with list of registers to be shadowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:65,Energy Efficiency,allocate,allocated,65,// Didn't find the reg.; // Mark the register and any aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:4,Energy Efficiency,Allocate,AllocateStack,4,/// AllocateStack - Allocate a chunk of stack space with the specified size; /// and alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:20,Energy Efficiency,Allocate,Allocate,20,/// AllocateStack - Allocate a chunk of stack space with the specified size; /// and alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:15,Energy Efficiency,Allocate,AllocateStack,15,"/// Version of AllocateStack with list of extra registers to be shadowed.; /// Note that, unlike AllocateReg, this shadows ALL of the shadow registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:97,Energy Efficiency,Allocate,AllocateReg,97,"/// Version of AllocateStack with list of extra registers to be shadowed.; /// Note that, unlike AllocateReg, this shadows ALL of the shadow registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:17,Energy Efficiency,Allocate,Allocate,17,// HandleByVal - Allocate a stack slot large enough to pass an argument by; // value. The size and alignment information of the argument is encoded in its; // parameter attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:3,Usability,Clear,Clear,3,// Clear byval registers tracking info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h:62,Energy Efficiency,allocate,allocated,62,/// MarkAllocated - Mark a register and all of its aliases as allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CallingConvLower.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:604,Availability,failure,failure,604,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1899,Availability,avail,available,1899,"n the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a tim",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4625,Availability,failure,failure,4625," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4683,Availability,failure,failure,4683," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4825,Availability,failure,failure,4825," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:753,Performance,optimiz,optimization,753,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:794,Performance,optimiz,optimization,794,"/// Encapsulates all of the information needed to generate a stack protector; /// check, and signals to isel when initialized that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point wer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:973,Performance,optimiz,optimization,973,"d that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowerin",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1201,Performance,optimiz,optimization,1201,"d that one needs to be generated.; ///; /// *NOTE* The following is a high level documentation of SelectionDAG Stack; /// Protector Generation. This is now also ported be shared with GlobalISel,; /// but without any significant changes.; ///; /// High Level Overview of ISel Stack Protector Generation:; ///; /// Previously, the ""stack protector"" IR pass handled stack protector; /// generation. This necessitated splitting basic blocks at the IR level to; /// create the success/failure basic blocks in the tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowerin",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1781,Performance,perform,perform,1781,"n the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a tim",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2045,Performance,perform,perform,2045,"ack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2442,Performance,optimiz,optimization,2442,"hitecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical t",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4557,Performance,load,loads,4557," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:4085,Security,validat,validation,4085," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:2967,Testability,test,tests,2967,"//; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG only processes one IR level basic block at a; /// time implying one could not create a DAG Combine to move the callinst.; ///; /// To get around this problem:; ///; /// 1. SelectionDAG can only process one block at a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:3991,Testability,log,logic,3991," a time, we can generate; /// multiple machine basic blocks for one IR level basic block.; /// This is how we handle bit tests and switches.; ///; /// 2. At the MI level, tail calls are represented via a special return; /// MIInst called ""tcreturn"". Thus if we know the basic block in which we; /// wish to insert the stack protector check, we get the correct behavior; /// by always inserting the stack protector check right before the return; /// statement. This is a ""magical transformation"" since no matter where; /// the stack protector check intrinsic is, we always insert the stack; /// protector check code at the end of the BB.; ///; /// Given the aforementioned constraints, the following solution was devised:; ///; /// 1. On platforms that do not support ISel stack protector check; /// generation, allow for the normal IR level stack protector check; /// generation to continue.; ///; /// 2. On platforms that do support ISel stack protector check; /// generation:; ///; /// a. Use the IR level stack protector pass to decide if a stack; /// protector is required/which BB we insert the stack protector check; /// in by reusing the logic already therein.; ///; /// b. After we finish selecting the basic block, we produce the validation; /// code with one of these techniques:; /// 1) with a call to a guard check function; /// 2) with inlined instrumentation; ///; /// 1) We insert a call to the check function before the terminator.; ///; /// 2) We first find a splice point in the parent basic block; /// before the terminator and then splice the terminator of said basic; /// block into the success basic block. Then we code-gen a new tail for; /// the parent basic block consisting of the two loads, the comparison,; /// and finally two branches to the success/failure basic blocks. We; /// conclude by code-gening the failure basic block if we have not; /// code-gened it already (all stack protector checks we generate in; /// the same function, use the same failure basic block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:1580,Usability,guid,guided,1580," tail of the basic block in; /// question. As a result of this, calls that would have qualified for the; /// sibling call optimization were no longer eligible for optimization since; /// said calls were no longer right in the ""tail position"" (i.e. the immediate; /// predecessor of a ReturnInst instruction).; ///; /// Since the sibling call optimization causes the callee to reuse the caller's; /// stack, if we could delay the generation of the stack protector check until; /// later in CodeGen after the sibling call decision was made, we get both the; /// tail call optimization and the stack protector check!; ///; /// A few goals in solving this problem were:; ///; /// 1. Preserve the architecture independence of stack protector generation.; ///; /// 2. Preserve the normal IR level stack protector check for platforms like; /// OpenBSD for which we support platform-specific stack protector; /// generation.; ///; /// The main problem that guided the present solution is that one can not; /// solve this problem in an architecture independent manner at the IR level; /// only. This is because:; ///; /// 1. The decision on whether or not to perform a sibling call on certain; /// platforms (for instance i386) requires lower level information; /// related to available registers that can not be known at the IR level.; ///; /// 2. Even if the previous point were not true, the decision on whether to; /// perform a tail call is done in LowerCallTo in SelectionDAG (or; /// CallLowering in GlobalISel) which occurs after the Stack Protector; /// Pass. As a result, one would need to put the relevant callinst into the; /// stack protector check success basic block (where the return inst is; /// placed) and then move it back later at ISel/MI time before the; /// stack protector check if the tail call optimization failed. The MI; /// level option was nixed immediately since it would require; /// platform-specific pattern matching. The ISel level option was; /// nixed because SelectionDAG ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:108,Availability,Failure,FailureMBB,108,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:138,Availability,failure,failure,138,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:249,Modifiability,variab,variable,249,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:274,Modifiability,variab,variable,274,/// Reset state that only changes when we switch functions.; ///; /// This currently includes:; ///; /// 1. FailureMBB since we reuse the failure code path for all stack; /// protector checks created in an individual function.; ///; /// 2.The guard variable since the guard variable we are checking against is; /// always the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:292,Availability,Failure,FailureMBB,292,"/// The basic block for which we are generating the stack protector.; ///; /// As a result of stack protector generation, we will splice the; /// terminators of this basic block into the successor mbb SuccessMBB and; /// replace it with a compare/branch to the successor mbbs; /// SuccessMBB/FailureMBB depending on whether or not the stack protector; /// was violated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:303,Integrability,depend,depending,303,"/// The basic block for which we are generating the stack protector.; ///; /// As a result of stack protector generation, we will splice the; /// terminators of this basic block into the successor mbb SuccessMBB and; /// replace it with a compare/branch to the successor mbbs; /// SuccessMBB/FailureMBB depending on whether or not the stack protector; /// was violated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:54,Availability,failure,failure,54,/// This basic block visited on stack protector check failure that will; /// contain a call to __stack_chk_fail().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:55,Performance,perform,performed,55,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:40,Testability,test,test,40,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:166,Testability,test,test,166,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:244,Testability,Test,Test,244,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:253,Testability,test,test,253,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:336,Testability,test,test,336,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:398,Testability,test,test,398,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h:390,Usability,simpl,simpler,390,"/// Evaluates if the specified FP class test is better performed as the inverse; /// (i.e. fewer instructions should be required to lower it). An example is the; /// test ""inf|normal|subnormal|zero"", which is an inversion of ""nan"".; /// \param Test The test as specified in 'is_fpclass' intrinsic invocation.; /// \returns The inverted test, or fcNone, if inversion does not produce a; /// simpler test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenCommonISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:36,Deployability,pipeline,pipelines,36,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:475,Deployability,configurat,configurations,475,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:511,Deployability,pipeline,pipelines,511,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:396,Integrability,Interface,Interfaces,396,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:475,Modifiability,config,configurations,475,"//===- Construction of codegen pass pipelines ------------------*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// Interfaces for registering analysis passes, producing common pass manager; /// configurations, and parsing of pass pipelines.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:107,Availability,avail,available,107,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c MachinePassRegistry.def file specifies how to construct; /// all of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:24,Security,access,access,24,"/// This class provides access to building LLVM's passes.; ///; /// Its members provide the baseline state available to passes during their; /// construction. The \c MachinePassRegistry.def file specifies how to construct; /// all of the built-in passes, and those may reference these members during; /// construction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:52,Availability,error,error,52,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:139,Availability,error,erroring,139,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Safety,abort,abort,43,"/// Check whether or not GlobalISel should abort on error.; /// When this is disabled, GlobalISel will fall back on SDISel instead of; /// erroring out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:41,Deployability,install,install,41,"/// addInstSelector - This method should install an instruction selector pass,; /// which converts from LLVM code to machine instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,"/// Add passes that optimize instruction level parallelism for out-of-order; /// targets. These passes are run while the machine code is still in SSA; /// form, so they can use MachineTraceMetrics to control their heuristics.; ///; /// All passes added here should preserve the MachineDominatorTree,; /// MachineLoopInfo, and MachineTraceMetrics analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:68,Deployability,pipeline,pipeline,68,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:38,Performance,optimiz,optimized,38,"/// addPreRewrite - Add passes to the optimized register allocation pipeline; /// after register allocation is complete, but before virtual registers are; /// rewritten to physical registers.; ///; /// These passes must preserve VirtRegMap and LiveIntervals, and when running; /// after RABasic or RAGreedy, they should take advantage of LiveRegMatrix.; /// When these passes run, VirtRegMap contains legal physreg assignments for; /// all virtual registers.; ///; /// Note if the target overloads addRegAssignAndRewriteOptimized, this may not; /// be honored. This is also not generally used for the fast variant,; /// where the allocation and rewriting are done in one pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:106,Deployability,pipeline,pipeline,106,/// This method may be implemented by targets that want to run passes after; /// register allocation pass pipeline but before prolog-epilog insertion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:139,Energy Efficiency,schedul,scheduling,139,/// This method may be implemented by targets that want to run passes after; /// prolog-epilog insertion and before the second instruction scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install an IR translator pass, which converts from; /// LLVM code to machine instructions with possibly generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a legalize pass, which converts the instruction; /// sequence into one that can be selected by the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a register bank selector pass, which; /// assigns register banks to virtual registers without a register; /// class or register banks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:23,Deployability,install,install,23,"/// This method should install a (global) instruction selector pass, which; /// converts possibly generic instructions to fully target-specific; /// instructions, thereby constraining all generic virtual registers to; /// register classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:177,Performance,optimiz,optimization,177,/// @}}; /// High level function that adds all passes necessary to go from llvm IR; /// representation to the MI representation.; /// Adds IR based lowering and target specific optimization passes and finally; /// the core instruction selection passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR; /// transforms following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:94,Deployability,pipeline,pipeline,94,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:442,Performance,optimiz,optimize,442,"/// Methods with trivial inline returns are convenient points in the common; /// codegen pass pipeline where targets may insert passes. Methods with; /// out-of-line standard implementations are major CodeGen stages called by; /// addMachinePasses. Some targets may override major stages when inserting; /// passes is insufficient, but maintaining overriden stages is more work.; ///; /// addMachineSSAOptimization - Add standard passes that optimize machine; /// instructions in SSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:174,Performance,optimiz,optimization,174,/// Utilities for targets to add passes to the pass manager.; ///; /// createTargetRegisterAllocator - Create the register allocator pass for; /// this target at the current optimization level.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:11,Modifiability,variab,variable,11,/// Helper variable for `-start-before/-start-after/-stop-before/-stop-after`,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:22,Modifiability,config,configurable,22,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Performance,perform,perform,47,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:115,Performance,optimiz,optimization,115,/// Add common target configurable passes that perform LLVM IR to IR transforms; /// following machine independent optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Performance,optimiz,optimizer,110,"// Before running any passes, run the verifier to determine if the input; // coming from the front-end and/or optimizer is valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:80,Performance,load,loads,80,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:175,Performance,load,loads,175,// The MergeICmpsPass tries to create memcmp calls by grouping sequences of; // loads and compares. ExpandMemCmpPass then tries to expand those calls; // into optimally-sized loads and compares. The transforms are enabled by a; // target lowering hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:48,Testability,log,log,48,"// Replace calls to LLVM intrinsics (e.g., exp, log) operating on vector; // operands with calls to the corresponding functions in a vector library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:45,Availability,mask,masked,45,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:213,Availability,mask,mask,213,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:169,Performance,load,loads,169,"// Add scalarization of target's unsupported masked memory intrinsics pass.; // the unsupported intrinsic will be replaced with a chain of basic blocks,; // that stores/loads element one-by-one if the appropriate mask bit is set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:24,Modifiability,Rewrite,RewriteSymbolPass,24,// TODO: Default ctor'd RewriteSymbolPass is no-op.; // addPass(RewriteSymbolPass());,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:64,Modifiability,Rewrite,RewriteSymbolPass,64,// TODO: Default ctor'd RewriteSymbolPass is no-op.; // addPass(RewriteSymbolPass());,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:27,Performance,perform,perform,27,/// Add common passes that perform LLVM IR to IR transforms in preparation for; /// instruction selection.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:16,Safety,safe,safe,16,// Add both the safe stack and the stack protection passes: each of them will; // only protect functions that have corresponding attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:50,Safety,abort,abort,50,// Provide a fallback path when we do not want to abort on; // not-yet-supported input.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:186,Deployability,configurat,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:258,Integrability,rout,routines,258,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:317,Integrability,rout,routine,317,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:431,Integrability,inject,injecting,431,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:638,Integrability,rout,routines,638,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:866,Integrability,depend,dependencies,866,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:186,Modifiability,config,configuration,186,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:678,Modifiability,maintainab,maintainability,678,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:431,Security,inject,injecting,431,"/// Add the complete set of target-independent postISel code generator passes.; ///; /// This can be read as the standard order of major LLVM CodeGen stages. Stages; /// with nontrivial configuration or multiple passes are broken out below in; /// add%Stage routines.; ///; /// Any CodeGenPassBuilder<Derived>::addXX routine may be overriden by the; /// Target. The addPre/Post methods with empty header implementations allow; /// injecting target-specific fixups just before or after major stages.; /// Additionally, targets have the flexibility to change pass order within a; /// stage by overriding default implementation of add%Stage routines below. Each; /// technique has maintainability tradeoffs because alternate pass orders are; /// not well supported. addPre/Post works better if the target pass is easily; /// tied to a common pass. But if it has subtle dependencies on multiple passes,; /// the target should override the stage instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:19,Performance,optimiz,optimize,19,// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:106,Energy Efficiency,schedul,scheduling,106,"// Run register allocation and passes that are tightly coupled with it,; // including phi elimination and scheduling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:44,Energy Efficiency,schedul,scheduling,44,// Expand pseudo instructions before second scheduling pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,Energy Efficiency,schedul,scheduler,15,// Second pass scheduler.; // Let Target optionally insert this pass by itself at some other; // point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:61,Availability,mask,mask,61,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:108,Performance,optimiz,optimize,108,"// Collect register usage information and produce a register mask of; // clobbered registers, to be used to optimize call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:20,Performance,optimiz,optimize,20,/// Add passes that optimize machine instructions in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:3,Performance,Optimiz,Optimize,3,// Optimize PHIs before DCE: removing dead PHI cycles may make more; // instructions dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:43,Modifiability,variab,variables,43,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:100,Usability,simpl,simplify,100,"// If the target requests it, assign local variables to stack slots relative; // to one another and simplify frame index references where possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:8,Performance,optimiz,optimization,8,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:250,Testability,test,test,250,"// With optimization, dead code should already be eliminated. However; // there is one known exception: lowered code for arguments that are only; // used by tail calls, where the tail calls reuse the incoming stack; // arguments directly (see t11 in test/CodeGen/X86/sibcall.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Deployability,Configurat,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:110,Modifiability,Config,Configuration,110,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:294,Performance,optimiz,optimized,294,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:459,Performance,optimiz,optimized,459,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:549,Performance,optimiz,optimized,549,//===---------------------------------------------------------------------===//; /// Register Allocation Pass Configuration; //===---------------------------------------------------------------------===//; /// Instantiate the default register allocator pass for this target for either; /// the optimized or unoptimized allocation path. This will be added to the pass; /// manager by addFastRegAlloc in the unoptimized case or addOptimizedRegAlloc; /// in the optimized case.; ///; /// A target that uses the standard regalloc pass order for fast or optimized; /// allocation may still override this for per-target regalloc; /// selection. But -regalloc=... always takes precedence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:99,Performance,optimiz,optimization,99,/// Find and instantiate the register allocation pass requested by this target; /// at the current optimization level. Different register allocators are; /// defined as separate passes because they may require different analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:11,Modifiability,rewrite,rewrite,11,// Finally rewrite virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:3,Performance,Perform,Perform,3,// Perform stack slot coloring and post-ra machine LICM.; //; // FIXME: Re-enable coloring with register when it's capable of adding; // kill markers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:118,Energy Efficiency,schedul,scheduling,118,/// Add the minimum set of target-independent passes that are required for; /// register allocation. No coalescing or scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:156,Energy Efficiency,schedul,scheduling,156,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:78,Performance,optimiz,optimized,78,"/// Add standard target-independent passes that are tightly coupled with; /// optimized register allocation, including coalescing, machine instruction; /// scheduling, and register allocation itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:15,Energy Efficiency,schedul,scheduler,15,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:121,Safety,avoid,avoid,121,"// The machine scheduler may accidentally create disconnected components; // when moving subregister definitions around, avoid this by splitting them to; // separate vregs before. Splitting can also improve reg. allocation quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:21,Energy Efficiency,schedul,scheduling,21,// PreRA instruction scheduling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:47,Integrability,depend,depending,47,// Allow targets to expand pseudo instructions depending on the choice of; // registers before MachineCopyPropagation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:104,Deployability,Configurat,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:104,Modifiability,Config,Configuration,104,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:220,Performance,optimiz,optimize,220,//===---------------------------------------------------------------------===//; /// Post RegAlloc Pass Configuration; //===---------------------------------------------------------------------===//; /// Add passes that optimize machine instructions after register allocation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:94,Performance,perform,performance,94,// Tail duplication.; // Note that duplicating tail just increases code size and degrades; // performance for targets that require Structured Control Flow.; // In addition it can also make CFG irreducible. Thus we disable it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,Availability,redundant,redundant,14,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:54,Performance,load,loads,54,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h:14,Safety,redund,redundant,14,// Cleanup of redundant (identical) address/immediate loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CodeGenPassBuilder.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:44,Integrability,Interface,Interface,44,"//===-- CommandFlags.h - Command Line Flags Interface -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains codegen-specific flags that are shared between different; // command line tools. The tools ""llc"" and ""opt"" both use this file to prevent; // flag duplication.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:275,Integrability,depend,dependant,275,"/// Common utility function tightly tied to the options listed here. Initializes; /// a TargetOptions object with CodeGen flags and returns it.; /// \p TheTriple is used to determine the default value for options if; /// options are not explicitly specified. If those triple dependant options; /// value do not have effect for your component, a default Triple() could be; /// passed in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h:26,Modifiability,variab,variable,26,/// Should value-tracking variable locations / instruction referencing be; /// enabled by default for this triple?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CommandFlags.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:412,Usability,simpl,simple,412,"//===-- CostTable.h - Instruction Cost Table handling -----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Cost tables and simple lookup functions; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:46,Availability,failure,failures,46,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:3,Integrability,Wrap,Wrapper,3,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:46,Availability,failure,failures,46,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h:3,Integrability,Wrap,Wrapper,3,// Wrapper to fix template argument deduction failures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CostTable.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:37,Integrability,interface,interface,37,"//===- CSEConfigBase.h - A CSEConfig interface ------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:27,Deployability,configurat,configuration,27,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:149,Integrability,depend,depend,149,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:213,Integrability,interface,interface,213,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h:27,Modifiability,config,configuration,27,"// Class representing some configuration that can be done during GlobalISel's; // CSEInfo analysis. We define it here because TargetPassConfig can't depend on; // the GlobalISel library, and so we use this in the interface between them; // so that the derived classes in GISel can reference generic opcodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/CSEConfigBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:18,Modifiability,variab,variable,18,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:78,Modifiability,variab,variable,78,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:106,Modifiability,variab,variables,106,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:90,Security,access,accessible,90,"/// For each user variable, keep a list of instruction ranges where this; /// variable is accessible. The variables are listed in order of appearance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:28,Modifiability,variab,variable,28,"/// Specifies a change in a variable's debug value history.; ///; /// There exist two types of entries:; ///; /// * Debug value entry:; ///; /// A new debug value becomes live. If the entry's \p EndIndex is \p NoEntry,; /// the value is valid until the end of the function. For other values, the; /// index points to the entry in the entry vector that ends this debug; /// value. The ending entry can either be an overlapping debug value, or; /// an instruction that clobbers the value.; ///; /// * Clobbering entry:; ///; /// This entry's instruction clobbers one or more preceding; /// register-described debug values that have their end index; /// set to this entry's position in the entry vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:4,Testability,Test,Test,4,"/// Test whether a vector of entries features any non-empty locations. It; /// could have no entries, or only DBG_VALUE $noreg entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h:59,Modifiability,variab,variable,59,/// Drop location ranges which exist entirely outside each variable's scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DbgEntityHistoryCalculator.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:39,Modifiability,variab,variable,39,/// Represents the location at which a variable is stored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:23,Performance,load,loads,23,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:42,Performance,load,load,42,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:91,Performance,load,load,91,/// Chain of offsetted loads necessary to load the value if it lives in; /// memory. Every load except for the last is pointer-sized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:48,Modifiability,variab,variable,48,/// Present if the location is part of a larger variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:14,Modifiability,Variab,VariableLocation,14,"/// Extract a VariableLocation from a MachineInstr.; /// This will only work if Instruction is a debug value instruction; /// and the associated DIExpression is in one of the supported forms.; /// If these requirements are not met, the returned Optional will not; /// have a value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:124,Availability,alive,alive,124,/// Base class for debug information backends. Common functionality related to; /// tracking which variables and scopes are alive at a given PC live here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:99,Modifiability,variab,variables,99,/// Base class for debug information backends. Common functionality related to; /// tracking which variables and scopes are alive at a given PC live here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:69,Modifiability,variab,variable,69,/// History of DBG_VALUE and clobber instructions for each user; /// variable. Variables are listed in order of appearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:79,Modifiability,Variab,Variables,79,/// History of DBG_VALUE and clobber instructions for each user; /// variable. Variables are listed in order of appearance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h:129,Security,access,accessors,129,"/// Maps instruction with label emitted before instruction.; /// FIXME: Make this private from DwarfDebug, we have the necessary accessors; /// for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DebugHandlerBase.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:7,Safety,Detect,DetectDeadLanes,7,"//===- DetectDeadLanes.h - SubRegister Lane Usage Analysis --*- C++ -*-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:610,Safety,detect,detect,610,"//===- DetectDeadLanes.h - SubRegister Lane Usage Analysis --*- C++ -*-----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// Analysis that tracks defined/used subregister lanes across COPY instructions; /// and instructions that get lowered to a COPY (PHI, REG_SEQUENCE,; /// INSERT_SUBREG, EXTRACT_SUBREG).; /// The information is used to detect dead definitions and the usage of; /// (completely) undefined values and mark the operands as such.; /// This pass is necessary because the dead/undef status is not obvious anymore; /// when subregisters are involved.; ///; /// Example:; /// %0 = some definition; /// %1 = IMPLICIT_DEF; /// %2 = REG_SEQUENCE %0, sub0, %1, sub1; /// %3 = EXTRACT_SUBREG %2, sub1; /// = use %3; /// The %0 definition is dead and %3 contains an undefined value.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:4,Deployability,Update,Update,4,/// Update the \p DefinedLanes and the \p UsedLanes for all virtual registers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:45,Availability,mask,mask,45,"/// Given a use regiser operand \p Use and a mask of defined lanes, check; /// if the operand belongs to a lowersToCopies() instruction, transfer the; /// mask to the def and put the instruction into the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:155,Availability,mask,mask,155,"/// Given a use regiser operand \p Use and a mask of defined lanes, check; /// if the operand belongs to a lowersToCopies() instruction, transfer the; /// mask to the def and put the instruction into the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,Availability,mask,mask,12,"/// Given a mask \p DefinedLanes of lanes defined at operand \p OpNum; /// of COPY-like instruction, determine which lanes are defined at the output; /// operand \p Def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h:12,Availability,mask,mask,12,/// Given a mask \p UsedLanes used from the output of instruction \p MI; /// determine which lanes are used from operand \p MO of this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DetectDeadLanes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:679,Energy Efficiency,Schedul,Schedule,679,"//===- llvm/CodeGen/DFAPacketizer.h - DFA Packetizer for VLIW ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:937,Energy Efficiency,consumption,consumption,937,"//===- llvm/CodeGen/DFAPacketizer.h - DFA Packetizer for VLIW ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // This class implements a deterministic finite automaton (DFA) based; // packetizing mechanism for VLIW architectures. It provides APIs to; // determine whether there exists a legal mapping of instructions to; // functional unit assignments in a packet. The DFA is auto-generated from; // the target's Schedule.td file.; //; // A DFA consists of 3 major elements: states, inputs, and transitions. For; // the packetizing mechanism, the input is the set of instruction classes for; // a target. The state models all possible combinations of functional unit; // consumption for a given set of instructions in a packet. A transition; // models the addition of an instruction to a packet. In the DFA constructed; // by this class, if an instruction can be added to a packet, then a valid; // transition exists from the corresponding state. Invalid transitions; // indicate that the instruction cannot be added to the current packet.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:22,Energy Efficiency,Schedul,ScheduleDAGInstrs,22,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:58,Energy Efficiency,schedul,schedule,58,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:91,Integrability,depend,dependence,91,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:14,Modifiability,extend,extends,14,// This class extends ScheduleDAGInstrs and overrides the schedule method; // to build the dependence graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:10,Energy Efficiency,schedul,scheduling,10,// Actual scheduling work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:86,Safety,redund,redundancy,86,"/// For every itinerary, an ""action"" to apply to the automaton. This removes; /// the redundancy in actions between itinerary classes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:49,Availability,avail,available,49,// Reset the current state to make all resources available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:56,Availability,avail,available,56,// Check if the resources occupied by a MCInstrDesc are available in; // the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:64,Availability,avail,available,64,// Check if the resources occupied by a machine instruction are available; // in the current state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:217,Availability,avail,available,217,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:279,Integrability,depend,depends,279,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:339,Integrability,depend,dependency,339,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:445,Integrability,depend,dependency,445,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:509,Integrability,depend,dependence,509,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:35,Usability,simpl,simple,35,"// VLIWPacketizerList implements a simple VLIW packetizer using DFA. The; // packetizer works on machine basic blocks. For each instruction I in BB,; // the packetizer consults the DFA to see if machine resources are available; // to execute I. If so, the packetizer checks if I depends on any instruction; // in the current packet. If no dependency is found, I is added to current; // packet and the machine resource is marked as taken. If any dependency is; // found, a target API call is made to prune the dependence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:12,Energy Efficiency,Schedul,Scheduler,12,// The VLIW Scheduler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:139,Performance,perform,perform,139,// End the current packet and reset the state of the packetizer.; // Overriding this function allows the target-specific packetizer; // to perform custom finalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:121,Integrability,depend,dependent,121,// Perform initialization before packetizing an instruction. This; // function is supposed to be overrided by the target dependent packetizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:3,Performance,Perform,Perform,3,// Perform initialization before packetizing an instruction. This; // function is supposed to be overrided by the target dependent packetizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h:33,Integrability,depend,dependece,33,// Check if it is legal to prune dependece between SUI and SUJ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DFAPacketizer.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:86,Usability,simpl,simple,86,//===--------------------------------------------------------------------===//; /// A simple label difference DIE.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:70,Availability,down,down,70,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:60,Performance,optimiz,optimized,60,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:134,Testability,assert,assert,134,"/// Destroy the underlying value.; ///; /// This should get optimized down to a no-op. We could skip it if we could; /// add a static assert on \a std::is_trivially_copyable(), but we currently; /// support versions of GCC that don't understand that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:67,Availability,down,down,67,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:57,Performance,optimiz,optimized,57,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:77,Usability,simpl,simple,77,"/// Copy the underlying value.; ///; /// This should get optimized down to a simple copy. We need to actually; /// construct the value, rather than calling memcpy, to satisfy strict; /// aliasing rules.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:4,Security,Access,Accessors,4,/// Accessors.; /// @{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:607,Energy Efficiency,allocate,allocated,607,"/// A list of DIE values.; ///; /// This is a singly-linked list, but instead of reversing the order of; /// insertion, we keep a pointer to the back of the list so we can push in; /// order.; ///; /// There are two main reasons to choose a linked list over a customized; /// vector-like data structure.; ///; /// 1. For teardown efficiency, we want DIEs to be BumpPtrAllocated. Using a; /// linked list here makes this way easier to accomplish.; /// 2. Carrying an extra pointer per \a DIEValue isn't expensive. 45% of DIEs; /// have 2 or fewer values, and 90% have 5 or fewer. A vector would be; /// over-allocated by 50% on average anyway, the same cost as the; /// linked-list node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:130,Testability,test,testing,130,/// Set to true to force a DIE to emit an abbreviation that says it has; /// children even when it doesn't. This is used for unit testing purposes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:44,Modifiability,variab,variable,44,"/// The compile unit or type unit DIE. This variable must be an instance of; /// DIE so that we can calculate the DIEUnit from any DIE by traversing the; /// parent backchain and getting the Unit DIE, and then casting itself to a; /// DIEUnit. This allows us to be able to find the DIEUnit for any DIE without; /// having to store a pointer to the DIEUnit in each DIE instance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:97,Integrability,depend,depending,97,/// The section this unit will be emitted in. This may or may not be set to; /// a valid section depending on the client that is emitting DWARF.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h:182,Modifiability,variab,variable,182,/// Set the section that this DIEUnit will be emitted into.; ///; /// This function is used by some clients to set the section. Not all clients; /// that emit DWARF use this section variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DIE.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h:437,Energy Efficiency,adapt,adapted,437,"//===------------------- llvm/CodeGen/DwarfEHPrepare.h ----------*- C++-*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h:437,Modifiability,adapt,adapted,437,"//===------------------- llvm/CodeGen/DwarfEHPrepare.h ----------*- C++-*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass mulches exception handling code into a form adapted to code; // generation. Required if using dwarf exception handling.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/DwarfEHPrepare.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:480,Availability,avail,available,480,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:802,Deployability,pipeline,pipelines,802,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:763,Modifiability,config,configured,763,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:639,Performance,latency,latency,639,"//==-- llvm/CodeGen/ExecutionDomainFix.h - Execution Domain Fix -*- C++ -*--==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Execution Domain Fix pass.; ///; /// Some X86 SSE instructions like mov, and, or, xor are available in different; /// variants for different operand types. These variant instructions are; /// equivalent, but on Nehalem and newer cpus there is extra latency; /// transferring data between integer and floating point domains. ARM cores; /// have similar issues when they are configured with both VFP and NEON; /// pipelines.; ///; /// This pass changes the variant instructions to minimize domain crossings.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:782,Availability,avail,available,782,"/// A DomainValue is a bit like LiveIntervals' ValNo, but it also keeps track; /// of execution domains.; ///; /// An open DomainValue represents a set of instructions that can still switch; /// execution domain. Multiple registers may refer to the same open; /// DomainValue - they will eventually be collapsed to the same execution; /// domain.; ///; /// A collapsed DomainValue represents a single register that has been forced; /// into one of more execution domains. There is a separate collapsed; /// DomainValue for each register, but it may contain multiple execution; /// domains. A register value is initially created in a single execution; /// domain, but if we were forced to pay the penalty of a domain crossing, we; /// keep track of the fact that the register is now available in multiple; /// domains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:15,Availability,avail,available,15,"/// Bitmask of available domains. For an open DomainValue, it is the still; /// possible domains for collapsing. For a collapsed DomainValue it is the; /// domains where the register is available for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:186,Availability,avail,available,186,"/// Bitmask of available domains. For an open DomainValue, it is the still; /// possible domains for collapsing. For a collapsed DomainValue it is the; /// domains where the register is available for free.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:168,Deployability,update,updated,168,"/// Pointer to the next DomainValue in a chain. When two DomainValues are; /// merged, Victim.Next is set to point to Victor, so old DomainValue; /// references can be updated by following the chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:135,Availability,avail,available,135,/// A collapsed DomainValue has no instructions to twiddle - it simply keeps; /// track of the domains where the registers are already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:64,Usability,simpl,simply,64,/// A collapsed DomainValue has no instructions to twiddle - it simply keeps; /// track of the domains where the registers are already available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:14,Availability,avail,available,14,/// Is domain available?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:19,Availability,avail,available,19,/// Mark domain as available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:31,Availability,avail,available,31,// Restrict to a single domain available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:39,Availability,avail,available,39,/// Return bitmask of domains that are available and in mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:56,Availability,mask,mask,56,/// Return bitmask of domains that are available and in mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:17,Availability,avail,available,17,/// First domain available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Usability,Clear,Clear,4,/// Clear this DomainValue and point to next which has all its data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Release,Release,4,"/// Release a reference to DV. When the last reference is released,; /// collapse if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:58,Deployability,release,released,58,"/// Release a reference to DV. When the last reference is released,; /// collapse if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:84,Deployability,Update,Update,84,/// Follow the chain of dead DomainValues until a live DomainValue is reached.; /// Update the referenced pointer when necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:65,Deployability,release,released,65,"/// All instructions and registers in B are moved to A, and B is released.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Update,Update,4,/// Update live-out values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:4,Deployability,Update,Update,4,"/// Update def-ages for registers defined by MI.; /// If Kill is set, also kill off DomainValues clobbered by the defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h:72,Availability,mask,mask,72,/// A soft instruction can be changed to work in other domains given by mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExecutionDomainFix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h:45,Performance,load,load,45,"//===--- ExpandMemCmp.h - Expand memcmp() to load/stores --------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ExpandMemCmp.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:78,Performance,perform,perform,78,// IsTailCall Should be modified by implementations of FastLowerCall; // that perform tail call conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:195,Safety,avoid,avoid,195,"/// The position of the last instruction for materializing constants; /// for use in the current block. It resets to EmitStartPt when it makes sense; /// (for example, it's usually profitable to avoid function calls between the; /// definition and the use)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:90,Modifiability,variab,variables,90,"/// The top most instruction in the current block that is allowed for; /// emitting local variables. LastLocalValue resets to EmitStartPt when it; /// makes sense (for example, on function calls)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Deployability,Update,Update,4,/// Update the position of the last instruction emitted for; /// materializing constants for use in the current block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:53,Performance,cache,cached,53,/// Look up the value to see if its value is already cached in a; /// register. It may be defined by instructions across blocks or defined; /// locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:14,Integrability,wrap,wrapper,14,/// This is a wrapper around getRegForValue that also takes care of; /// truncating or sign-extending the given getelementptr index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:92,Modifiability,extend,extending,92,/// This is a wrapper around getRegForValue that also takes care of; /// truncating or sign-extending the given getelementptr index value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:229,Performance,load,load,229,"/// We're checking to see if we can fold \p LI into \p FoldInst. Note; /// that we could have a sequence where multiple LLVM IR instructions are; /// folded into the same machineinstr. For example we could have:; ///; /// A: x = load i32 *P; /// B: y = icmp A, 42; /// C: br y, ...; ///; /// In this scenario, \p LI is ""A"", and \p FoldInst is ""C"". We know about ""B""; /// (and any other folded instructions) because it is between A and C.; ///; /// If we succeed folding, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:105,Performance,load,load,105,"/// The specified machine instr operand is a vreg, and that vreg is; /// being provided by the specified load instruction. If possible, try to; /// fold the load as an operand to the instruction, returning true if; /// possible.; ///; /// This method should be implemented by targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:157,Performance,load,load,157,"/// The specified machine instr operand is a vreg, and that vreg is; /// being provided by the specified load instruction. If possible, try to; /// fold the load as an operand to the instruction, returning true if; /// possible.; ///; /// This method should be implemented by targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:21,Integrability,wrap,wrapper,21,"/// This method is a wrapper of fastEmit_ri.; ///; /// It first tries to emit an instruction with an immediate operand using; /// fastEmit_ri. If that fails, it materializes the immediate into a register; /// and try fastEmit_rr instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:115,Deployability,update,update,115,"/// Emit an unconditional branch to the given block, unless it is the; /// immediate (fall-through) successor, and update the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Deployability,Update,Update,4,"/// Update the value map to include the new mapping for this; /// instruction, or insert an extra copy to get the result in a previous; /// determined register.; ///; /// NOTE: This is only necessary because we might select a block that uses a; /// value before we select the block that defines the value. It might be; /// possible to fix this by selecting blocks in reverse postorder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:38,Usability,usab,usable,38,"/// Try to constrain Op so that it is usable by argument OpNum of the; /// provided MCInstrDesc. If this fails, create a new virtual register in the; /// correct class and COPY the value there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:90,Performance,load,loads,90,"/// Emit a constant in a register using target-specific logic, such as; /// constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:56,Testability,log,logic,56,"/// Emit a constant in a register using target-specific logic, such as; /// constant pool loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:63,Testability,log,logic,63,/// Emit an alloca address in a register using target-specific logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:84,Testability,log,logic,84,/// Emit the floating-point constant +0.0 in a register using target-; /// specific logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:42,Safety,safe,safely,42,"/// Check if \c Add is an add that can be safely folded into \c GEP.; ///; /// \c Add can be folded into \c GEP if:; /// - \c Add is an add,; /// - \c Add's size matches \c GEP's,; /// - \c Add is in the same basic block as \c GEP, and; /// - \c Add has a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:88,Availability,avail,available,88,/// Helper for getRegForVale. This function is called when the value; /// isn't already available in a register and must be materialized with new; /// instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:62,Modifiability,variab,variables,62,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:142,Modifiability,variab,variables,142,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:135,Performance,cache,cached,135,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:120,Safety,avoid,avoid,120,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:4,Usability,Clear,Clears,4,/// Clears LocalValueMap and moves the area for the new local variables; /// to the beginning of the block. It helps to avoid spilling cached variables; /// across heavy instructions like calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:22,Deployability,patch,patchpoint,22,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:95,Deployability,patch,patchpoint,95,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h:55,Modifiability,variab,variable,55,/// Add a stackmap or patchpoint intrinsic call's live variable; /// operands to a stackmap or patchpoint machine instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FastISel.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:7,Availability,Fault,FaultMaps,7,"//===- FaultMaps.h - The ""FaultMaps"" section --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:26,Availability,Fault,FaultMaps,26,"//===- FaultMaps.h - The ""FaultMaps"" section --------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h:92,Testability,test,testing,92,// We'd like to keep a stable iteration order for FunctionInfos to help; // FileCheck based testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FaultMaps.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:399,Integrability,rout,routines,399,"//===- FunctionLoweringInfo.h - Lower functions from LLVM IR ---*- C++ -*--===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This implements routines for translating functions from LLVM IR into; // Machine IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:79,Energy Efficiency,allocate,allocated,79,"/// DemoteRegister - if CanLowerReturn is false, DemoteRegister is a vreg; /// allocated to hold a pointer to the hidden sret parameter.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:129,Energy Efficiency,efficient,efficiently,129,/// StaticAllocaMap - Keep track of frame indices for fixed sized allocas in; /// the entry block. This allows the allocas to be efficiently referenced; /// anywhere in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:124,Energy Efficiency,schedul,scheduling,124,/// ArgDbgValues - A list of DBG_VALUE instructions created during isel for; /// function arguments that are inserted after scheduling is completed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:25,Modifiability,extend,extend,25,/// Record the preferred extend type (ISD::SIGN_EXTEND or ISD::ZERO_EXTEND); /// for a value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:82,Deployability,update,updated,82,"/// PHINodesToUpdate - A list of phi instructions whose operand list will; /// be updated after processing the current basic block.; /// TODO: This isn't per-function state, it's per-basic-block state. But; /// there's no other convenient place for it to live right now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:4,Usability,clear,clear,4,"/// clear - Clear out all the function-specific state. This returns this; /// FunctionLoweringInfo to an empty state, ready to be used for a; /// different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:12,Usability,Clear,Clear,12,"/// clear - Clear out all the function-specific state. This returns this; /// FunctionLoweringInfo to an empty state, ready to be used for a; /// different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:223,Modifiability,extend,extended,223,"/// GetLiveOutRegInfo - Gets LiveOutInfo for a register, returning NULL if the; /// register is a PHI destination and the PHI's LiveOutInfo is not valid. If; /// the register's LiveOutInfo is for a smaller bit width, it is extended to; /// the larger bit width by zero extension. The bit width must be no smaller; /// than the LiveOutInfo's existing bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h:8,Deployability,install,install,8,// Only install this information if it tells us something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/FunctionLoweringInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:567,Integrability,interface,interface,567,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1062,Performance,perform,performed,1062,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:793,Safety,Safe,Safe,793,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1015,Safety,safe,safe,1015,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:691,Testability,log,logs,691,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:1151,Usability,simpl,simply,1151,"//===- GCMetadata.h - Garbage collector metadata ----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the GCFunctionInfo and GCModuleInfo classes, which are; // used as a communication channel from the target code generator to the target; // garbage collectors. This interface allows code generators and garbage; // collectors to be developed independently.; //; // The GCFunctionInfo class logs the data necessary to build a type accurate; // stack map. The code generator outputs:; //; // - Safe points as specified by the GCStrategy's NeededSafePoints.; // - Stack offsets for GC roots, as specified by calls to llvm.gcroot; //; // As a refinement, liveness analysis calculates the set of live roots at each; // safe point. Liveness analysis is not presently performed by the code; // generator, so all roots are assumed live.; //; // GCModuleInfo simply collects GCFunctionInfo instances for each Function as; // they are compiled. This accretion is necessary for collectors which must emit; // a stack map for the compilation unit as a whole. Therefore, GCFunctionInfo; // outlives the MachineFunction from which it is derived and must not refer to; // any code generator data structures.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:39,Safety,safe,safe,39,/// GCPoint - Metadata for a collector-safe point in machine code.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:137,Safety,Safe,SafePoints,137,"// FIXME: Liveness. A 2D BitVector, perhaps?; //; // BitVector Liveness;; //; // bool islive(int point, int root) =; // Liveness[point * SafePoints.size() + root]; //; // The bit vector is the more compact representation where >3.2% of roots; // are live per safe point (1.5% on 64-bit hosts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:259,Safety,safe,safe,259,"// FIXME: Liveness. A 2D BitVector, perhaps?; //; // BitVector Liveness;; //; // bool islive(int point, int root) =; // Liveness[point * SafePoints.size() + root]; //; // The bit vector is the more compact representation where >3.2% of roots; // are live per safe point (1.5% on 64-bit hosts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:44,Safety,safe,safe,44,/// addSafePoint - Notes the existence of a safe point. Num is the ID of the; /// label just prior to the safe point (if the code generator is using; /// MachineModuleInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:106,Safety,safe,safe,106,/// addSafePoint - Notes the existence of a safe point. Num is the ID of the; /// label just prior to the safe point (if the code generator is using; /// MachineModuleInfo).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:30,Safety,safe,safe,30,/// begin/end - Iterators for safe points.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:62,Safety,safe,safe,62,/// live_begin/live_end - Iterators for live roots at a given safe point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the entire Module.; /// Records a cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:86,Performance,cache,cache,86,/// An analysis pass which caches information about the entire Module.; /// Records a cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:142,Integrability,depend,depends,142,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the Function.; /// Records the function level information used by GCRoots.; /// This pass depends on `CollectorMetadataAnalysis`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:32,Modifiability,rewrite,rewrites,32,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:126,Performance,load,loads,126,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:187,Performance,perform,performs,187,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:119,Usability,simpl,simple,119,"/// LowerIntrinsics - This pass rewrites calls to the llvm.gcread or; /// llvm.gcwrite intrinsics, replacing them with simple loads and stores as; /// directed by the GCStrategy. It also performs automatic root initialization; /// and custom intrinsic lowering.; ///; /// This pass requires `CollectorMetadataAnalysis`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:27,Performance,cache,caches,27,/// An analysis pass which caches information about the entire Module.; /// Records both the function level information used by GCRoots and a; /// cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:147,Performance,cache,cache,147,/// An analysis pass which caches information about the entire Module.; /// Records both the function level information used by GCRoots and a; /// cache of the 'active' gc strategy objects for the current Module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h:4,Usability,clear,clear,4,"/// clear - Resets the pass. Any pass, which uses GCModuleInfo, should; /// call it in doFinalization().; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadata.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:792,Modifiability,plugin,plugins,792,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:571,Safety,avoid,avoid,571,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h:782,Testability,log,logically,782,"//===- llvm/CodeGen/GCMetadataPrinter.h - Prints asm GC tables --*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The abstract base class GCMetadataPrinter supports writing GC metadata tables; // as assembly code. This is a separate class from GCStrategy in order to allow; // users of the LLVM JIT to avoid linking with the AsmWriter.; //; // Subclasses of GCMetadataPrinter must be registered using the; // GCMetadataPrinterRegistry. This is separate from the GCStrategy itself; // because these subclasses are logically plugins for the AsmWriter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GCMetadataPrinter.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:44,Integrability,depend,depending,44,"// FIXME: Infer the maximum possible offset depending on the actual users; // (these max offsets are different for the users inside Thumb or ARM; // functions), see the code that passes in the offset in the ARM backend; // for more information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:35,Modifiability,variab,variables,35,/// Whether we should merge global variables that have external linkage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:29,Performance,optimiz,optimize,29,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:89,Usability,simpl,simple,89,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h:196,Usability,learn,learn,196,"/// Whether we should try to optimize for size only.; /// Currently, this applies a dead simple heuristic: only consider globals; /// used in minsize functions for merging.; /// FIXME: This could learn about optsize, and be used in the cost model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/GlobalMerge.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:434,Integrability,inject,inject,434,"//===---- IndirectThunks.h - Indirect Thunk Base Class ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Contains a base class for Passes that inject an MI thunk.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:434,Security,inject,inject,434,"//===---- IndirectThunks.h - Indirect Thunk Base Class ----------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Contains a base class for Passes that inject an MI thunk.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:5,Modifiability,variab,variable,5,"// A variable used to track whether (and possible which) thunks have been; // inserted so far. InsertedThunksTy is usually a bool, but can be other types; // to represent more than one type of thunk. Requires an |= operator to; // accumulate results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:182,Testability,assert,asserts,182,// A MachineBasicBlock must not be created for the Entry block; code; // generation from an empty naked function in C source code also does not; // generate one. At least GlobalISel asserts if this invariant isn't; // respected.; // Set MF properties. We never use vregs...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h:181,Safety,detect,detect,181,"// Only add a thunk if one of the functions has the corresponding feature; // enabled in its subtarget, and doesn't enable external thunks. The target; // can use InsertedThunks to detect whether relevant thunks have already; // been inserted.; // FIXME: Conditionalize on indirect calls so we don't emit a thunk when; // nothing will end up calling it.; // FIXME: It's a little silly to look at every function just to enumerate; // the subtargets, but eventually we'll want to look at them for indirect; // calls, so maybe this is OK.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IndirectThunks.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h:516,Security,access,access,516,"//===---- llvm/CodeGen/InterleavedAccess.h ----------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// This file contains the declaration of the InterleavedAccessPass class,; /// its corresponding pass name is `interleaved-access`.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/InterleavedAccess.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:423,Integrability,interface,interface,423,"//===-- IntrinsicLowering.h - Intrinsic Function Lowering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the IntrinsicLowering interface. This interface allows; // addition of domain-specific or front-end specific intrinsics to LLVM without; // having to modify all of the C backend or interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:439,Integrability,interface,interface,439,"//===-- IntrinsicLowering.h - Intrinsic Function Lowering -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the IntrinsicLowering interface. This interface allows; // addition of domain-specific or front-end specific intrinsics to LLVM without; // having to modify all of the C backend or interpreter.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:182,Integrability,message,message,182,"/// Replace a call to the specified intrinsic function.; /// If an intrinsic function must be implemented by the code generator; /// (such as va_start), this function should print a message and abort.; ///; /// Otherwise, if an intrinsic function call can be lowered, the code to; /// implement it (often a call to a non-intrinsic function) is inserted; /// _after_ the call instruction and the call is deleted. The caller must; /// be capable of handling this kind of change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:194,Safety,abort,abort,194,"/// Replace a call to the specified intrinsic function.; /// If an intrinsic function must be implemented by the code generator; /// (such as va_start), this function should print a message and abort.; ///; /// Otherwise, if an intrinsic function call can be lowered, the code to; /// implement it (often a call to a non-intrinsic function) is inserted; /// _after_ the call instruction and the call is deleted. The caller must; /// be capable of handling this kind of change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h:111,Usability,simpl,simple,111,/// Try to replace a call instruction with a call to a bswap intrinsic. Return; /// false if the call is not a simple integer bswap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/IntrinsicLowering.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:222,Integrability,depend,dependent,222,"//===--------------------------------------------------------------------===//; /// ISD::NodeType enum - This enum defines the target-independent operators; /// for a SelectionDAG.; ///; /// Targets may also define target-dependent operator codes for SDNodes. For; /// example, on x86, these are the enum values in the X86ISD namespace.; /// Targets should aim to use target-independent operators to model their; /// instruction sets as much as possible, and only use target-dependent; /// operators when they have special requirements.; ///; /// Finally, during and after selection proper, SNodes may use special; /// operator codes that correspond directly with MachineInstr opcodes. These; /// are used to represent selected instructions. See the isMachineOpcode(); /// and getMachineOpcode() member functions of SDNode.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:475,Integrability,depend,dependent,475,"//===--------------------------------------------------------------------===//; /// ISD::NodeType enum - This enum defines the target-independent operators; /// for a SelectionDAG.; ///; /// Targets may also define target-dependent operator codes for SDNodes. For; /// example, on x86, these are the enum values in the X86ISD namespace.; /// Targets should aim to use target-independent operators to model their; /// instruction sets as much as possible, and only use target-dependent; /// operators when they have special requirements.; ///; /// Finally, during and after selection proper, SNodes may use special; /// operator codes that correspond directly with MachineInstr opcodes. These; /// are used to represent selected instructions. See the isMachineOpcode(); /// and getMachineOpcode() member functions of SDNode.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:71,Availability,error,errors,71,/// DELETED_NODE - This is an illegal value that is used to catch; /// errors. This opcode is not a legal opcode for any node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:119,Modifiability,extend,extended,119,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:235,Modifiability,extend,extended,235,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Testability,Assert,AssertSext,4,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:16,Testability,Assert,AssertZext,16,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:415,Testability,assert,assertion,415,"/// AssertSext, AssertZext - These nodes record if a register contains a; /// value that has already been zero or sign extended from a narrower type.; /// These nodes take two operands. The first is the node that has already; /// been extended, and the second is a value type node indicating the width; /// of the extension.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Testability,Assert,AssertAlign,4,/// AssertAlign - These nodes record if a register contains a value that; /// has a known alignment and the trailing bits are known to be zero.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:234,Testability,assert,assertion,234,/// AssertAlign - These nodes record if a register contains a value that; /// has a known alignment and the trailing bits are known to be zero.; /// NOTE: In case of the source value (or any vector element value) is; /// poisoned the assertion will not be true for that value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:131,Modifiability,variab,variables,131,"/// READ_REGISTER, WRITE_REGISTER - This node represents llvm.register on; /// the DAG, which implements the named register global variables extension.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:80,Usability,simpl,simplification,80,"/// TargetConstant* - Like Constant*, but the DAG does not do any folding,; /// simplification, or lowering of the constant. They are used for constants; /// which are known to fit in the immediate fields of their users, or for; /// carrying magic numbers which are not values which need to be; /// materialized in registers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:78,Integrability,depend,dependent,78,"/// TargetIndex - Like a constant pool entry, but with completely; /// target-dependent semantics. Holds target flags, a 32-bit index, and a; /// 64-bit index. Targets can use this however they like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:178,Availability,avail,available,178,/// CopyFromReg - This node indicates that the input value is a virtual or; /// physical register that is defined outside of the scope of this; /// SelectionDAG. The register is available from the RegisterSDNode object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Usability,Simpl,Simple,4,/// Simple integer binary arithmetic operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:541,Testability,log,logic,541,"/// Carry-using nodes for multiple precision addition and subtraction.; /// These nodes take three operands: The first two are the normal lhs and; /// rhs to the add or sub, and the third is a boolean value that is 1 if and; /// only if there is an incoming carry/borrow. These nodes produce two; /// results: the normal result of the add or sub, and a boolean value that is; /// 1 if and only if there is an outgoing carry/borrow.; ///; /// Care must be taken if these opcodes are lowered to hardware instructions; /// that use the inverse logic -- 0 if and only if there is an; /// incoming/outgoing carry/borrow. In such cases, you must preserve the; /// semantics of these opcodes by inverting the incoming carry/borrow, feeding; /// it to the add/sub hardware instruction, and then inverting the outgoing; /// carry/borrow.; ///; /// The use of these opcodes is preferable to adde/sube if the target supports; /// it, as the carry is a regular value rather than a glue, which allows; /// further optimisation.; ///; /// These opcodes are different from [US]{ADD,SUB}O in that; /// U{ADD,SUB}O_CARRY consume and produce a carry/borrow, whereas; /// [US]{ADD,SUB}O produce an overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]ADDSAT(LHS, RHS) - Perform saturation addition on 2; /// integers with the same bit width (W). If the true value of LHS + RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]SUBSAT(LHS, RHS) - Perform saturation subtraction on 2; /// integers with the same bit width (W). If the true value of LHS - RHS; /// exceeds the largest value that can be represented by W bits, the; /// resulting value is this maximum value. Otherwise, if this value is less; /// than the smallest value that can be represented by W bits, the; /// resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:36,Performance,Perform,Perform,36,"/// RESULT = [US]SHLSAT(LHS, RHS) - Perform saturation left shift. The first; /// operand is the value to be shifted, and the second argument is the amount; /// to shift by. Both must be integers of the same bit width (W). If the true; /// value of LHS << RHS exceeds the largest value that can be represented by; /// W bits, the resulting value is this maximum value, Otherwise, if this; /// value is less than the smallest value that can be represented by W bits,; /// the resulting value is this minimum value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Performance,Perform,Perform,43,"/// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication; /// on 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer. A scale of zero is effectively performing; /// multiplication on 2 integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:286,Performance,perform,performing,286,"/// RESULT = [US]MULFIX(LHS, RHS, SCALE) - Perform fixed point multiplication; /// on 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer. A scale of zero is effectively performing; /// multiplication on 2 integers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:43,Performance,Perform,Perform,43,"/// RESULT = [US]DIVFIX(LHS, RHS, SCALE) - Perform fixed point division on; /// 2 integers with the same width and scale. SCALE represents the scale; /// of both operands as fixed point numbers. This SCALE parameter must be a; /// constant integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Usability,Simpl,Simple,4,/// Simple binary floating point operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:168,Performance,optimiz,optimizations,168,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:210,Performance,optimiz,optimized,210,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:99,Usability,simpl,simple,99,/// Constrained versions of the binary floating point operators.; /// These will be lowered to the simple operators before final selection.; /// They are used to limit optimizations while the DAG is being; /// optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:244,Performance,optimiz,optimizations,244,/// Constrained versions of libm-equivalent floating point intrinsics.; /// These will be lowered to the equivalent non-constrained pseudo-op; /// (or expanded to the equivalent library call) before final selection.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:281,Performance,optimiz,optimized,281,/// Constrained versions of libm-equivalent floating point intrinsics.; /// These will be lowered to the equivalent non-constrained pseudo-op; /// (or expanded to the equivalent library call) before final selection.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,Performance,optimiz,optimizations,187,/// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or; /// unsigned integer. These have the same semantics as fptosi and fptoui; /// in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:224,Performance,optimiz,optimized,224,/// STRICT_FP_TO_[US]INT - Convert a floating point value to a signed or; /// unsigned integer. These have the same semantics as fptosi and fptoui; /// in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:187,Performance,optimiz,optimizations,187,/// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to; /// a floating point value. These have the same semantics as sitofp and; /// uitofp in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:224,Performance,optimiz,optimized,224,/// STRICT_[US]INT_TO_FP - Convert a signed or unsigned integer to; /// a floating point value. These have the same semantics as sitofp and; /// uitofp in IR.; /// They are used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:88,Availability,down,down,88,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:731,Performance,optimiz,optimizations,731,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:768,Performance,optimiz,optimized,768,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:609,Safety,safe,safe,609,"/// X = STRICT_FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating; /// point type down to the precision of the destination VT. TRUNC is a; /// flag, which is always an integer that is zero or one. If TRUNC is 0,; /// this is a normal rounding, if it is 1, this FP_ROUND is known to not; /// change the value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,1)) -> X which are not safe for; /// STRICT_FP_EXTEND(STRICT_FP_ROUND(X,0)) because the extra bits aren't; /// removed.; /// It is used to limit optimizations while the DAG is being optimized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:30,Modifiability,Extend,Extend,30,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,Performance,optimiz,optimizations,108,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:145,Performance,optimiz,optimized,145,/// X = STRICT_FP_EXTEND(Y) - Extend a smaller FP type into a larger FP; /// type.; /// It is used to limit optimizations while the DAG is being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:124,Performance,perform,performs,124,"/// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used; /// for floating-point operands only. STRICT_FSETCC performs a quiet; /// comparison operation, while STRICT_FSETCCS performs a signaling; /// comparison operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:189,Performance,perform,performs,189,"/// STRICT_FSETCC/STRICT_FSETCCS - Constrained versions of SETCC, used; /// for floating-point operands only. STRICT_FSETCC performs a quiet; /// comparison operation, while STRICT_FSETCCS performs a signaling; /// comparison operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:10,Performance,Perform,Perform,10,/// FMA - Perform a * b + c with no intermediate rounding step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:11,Performance,Perform,Perform,11,"/// FMAD - Perform a * b + c, while getting the same result as the; /// separately rounded operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,Perform,Performs,4,"/// Performs a check of floating point class property, defined by IEEE-754.; /// The first operand is the floating point value to check. The second operand; /// specifies the checked property and is a TargetConstant which specifies; /// test in the same way as intrinsic 'is_fpclass'.; /// Returns boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:237,Testability,test,test,237,"/// Performs a check of floating point class property, defined by IEEE-754.; /// The first operand is the floating point value to check. The second operand; /// specifies the checked property and is a TargetConstant which specifies; /// test in the same way as intrinsic 'is_fpclass'.; /// Returns boolean value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:109,Modifiability,variab,variable,109,"/// BUILD_VECTOR(ELT0, ELT1, ELT2, ELT3,...) - Return a fixed-width vector; /// with the specified, possibly variable, elements. The types of the; /// operands must match the vector element type, except that integer types; /// are allowed to be larger than the element type, in which case the; /// operands are implicitly truncated. The types of the operands must all; /// be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:235,Performance,scalab,scalable,235,"/// INSERT_VECTOR_ELT(VECTOR, VAL, IDX) - Returns VECTOR with the element; /// at IDX replaced with VAL. If the type of VAL is larger than the vector; /// element type then VAL is truncated before replacement.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:111,Modifiability,variab,variable,111,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:247,Modifiability,extend,extended,247,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:362,Performance,scalab,scalable,362,"/// EXTRACT_VECTOR_ELT(VECTOR, IDX) - Returns a single element from VECTOR; /// identified by the (potentially variable) element number IDX. If the return; /// type is an integer type larger than the element type of the vector, the; /// result is extended to the width of the return type. In that case, the high; /// bits are undefined.; ///; /// If VECTOR is a scalable vector, then IDX may be larger than the minimum; /// vector width. IDX is not first scaled by the runtime scaling factor of; /// VECTOR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:382,Performance,scalab,scalable,382,"/// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of; /// vector type with the same length and element type, this produces a; /// concatenated vector result value, with length equal to the sum of the; /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then; /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0; /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:433,Performance,scalab,scalable,433,"/// CONCAT_VECTORS(VECTOR0, VECTOR1, ...) - Given a number of values of; /// vector type with the same length and element type, this produces a; /// concatenated vector result value, with length equal to the sum of the; /// lengths of the input vectors. If VECTOR0 is a fixed-width vector, then; /// VECTOR1..VECTORN must all be fixed-width vectors. Similarly, if VECTOR0; /// is a scalable vector, then VECTOR1..VECTORN must all be scalable vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:310,Performance,scalab,scalable,310,"/// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2; /// inserted into VECTOR1. IDX represents the starting element number at which; /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known; /// minimum vector length. Let the type of VECTOR2 be T, then if T is a; /// scalable vector, IDX is first scaled by the runtime scaling factor of T.; /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.; /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1; /// indices. If this condition cannot be determined statically but is false at; /// runtime, then the result vector is undefined. The IDX parameter must be a; /// vector index constant type, which for most targets will be an integer; /// pointer type.; ///; /// This operation supports inserting a fixed-width vector into a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:859,Performance,scalab,scalable,859,"/// INSERT_SUBVECTOR(VECTOR1, VECTOR2, IDX) - Returns a vector with VECTOR2; /// inserted into VECTOR1. IDX represents the starting element number at which; /// VECTOR2 will be inserted. IDX must be a constant multiple of T's known; /// minimum vector length. Let the type of VECTOR2 be T, then if T is a; /// scalable vector, IDX is first scaled by the runtime scaling factor of T.; /// The elements of VECTOR1 starting at IDX are overwritten with VECTOR2.; /// Elements IDX through (IDX + num_elements(T) - 1) must be valid VECTOR1; /// indices. If this condition cannot be determined statically but is false at; /// runtime, then the result vector is undefined. The IDX parameter must be a; /// vector index constant type, which for most targets will be an integer; /// pointer type.; ///; /// This operation supports inserting a fixed-width vector into a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:284,Performance,scalab,scalable,284,"/// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.; /// Let the result type be T, then IDX represents the starting element number; /// from which a subvector of type T is extracted. IDX must be a constant; /// multiple of T's known minimum vector length. If T is a scalable vector,; /// IDX is first scaled by the runtime scaling factor of T. Elements IDX; /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this; /// condition cannot be determined statically but is false at runtime, then; /// the result vector is undefined. The IDX parameter must be a vector index; /// constant type, which for most targets will be an integer pointer type.; ///; /// This operation supports extracting a fixed-width vector from a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:758,Performance,scalab,scalable,758,"/// EXTRACT_SUBVECTOR(VECTOR, IDX) - Returns a subvector from VECTOR.; /// Let the result type be T, then IDX represents the starting element number; /// from which a subvector of type T is extracted. IDX must be a constant; /// multiple of T's known minimum vector length. If T is a scalable vector,; /// IDX is first scaled by the runtime scaling factor of T. Elements IDX; /// through (IDX + num_elements(T) - 1) must be valid VECTOR indices. If this; /// condition cannot be determined statically but is false at runtime, then; /// the result vector is undefined. The IDX parameter must be a vector index; /// constant type, which for most targets will be an integer pointer type.; ///; /// This operation supports extracting a fixed-width vector from a scalable; /// vector, but not the other way around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:256,Security,access,accessible,256,"/// VECTOR_SHUFFLE(VEC1, VEC2) - Returns a vector, of the same type as; /// VEC1/VEC2. A VECTOR_SHUFFLE node also contains an array of constant int; /// values that indicate which value (or undef) each result element will; /// get. These constant ints are accessible through the; /// ShuffleVectorSDNode class. This is quite similar to the Altivec; /// 'vperm' instruction, except that the indices must be constants and are; /// in terms of the element size of VEC1/VEC2, not in terms of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:61,Performance,load,loading,61,"/// SCALAR_TO_VECTOR(VAL) - This represents the operation of loading a; /// scalar value into element 0 of the resultant vector type. The top; /// elements 1 to N-1 of the N-element vector are undefined. The type; /// of the operand must match the vector element type, except when they; /// are integer types. In this case the operand is allowed to be wider; /// than the vector element type, and is implicitly truncated to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:33,Performance,scalab,scalable,33,"/// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised; /// of a linear sequence of unsigned values starting from 0 with a step of; /// IMM, where IMM must be a TargetConstant with type equal to the vector; /// element type. The arithmetic is performed modulo the bitwidth of the; /// element.; ///; /// The operation does not support returning fixed-width vectors or; /// non-constant operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:263,Performance,perform,performed,263,"/// STEP_VECTOR(IMM) - Returns a scalable vector whose lanes are comprised; /// of a linear sequence of unsigned values starting from 0 with a step of; /// IMM, where IMM must be a TargetConstant with type equal to the vector; /// element type. The arithmetic is performed modulo the bitwidth of the; /// element.; ///; /// The operation does not support returning fixed-width vectors or; /// non-constant operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:24,Testability,log,logical,24,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:37,Testability,log,logical,37,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:49,Testability,log,logical,49,"/// Bitwise operators - logical and, logical or, logical xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:186,Performance,perform,performed,186,"/// ABS - Determine the unsigned absolute value of a signed integer value of; /// the same bitwidth.; /// Note: A value of INT_MIN will return INT_MIN, no saturation or overflow; /// is performed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:159,Integrability,depend,depending,159,"/// Conversion operators. These are all single input single output; /// operations. For all of these, the result type must be strictly; /// wider or narrower (depending on the operation) than the source; /// type.; /// SIGN_EXTEND - Used for integer types, replicating the sign bit; /// into new bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:82,Integrability,depend,depends,82,/// [SU]INT_TO_FP - These operators convert integers (whose interpreted sign; /// depends on the first letter) to floating point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:86,Modifiability,extend,extend,86,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:151,Modifiability,extend,extending,151,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:49,Performance,perform,performs,49,"/// SIGN_EXTEND_INREG - This operator atomically performs a SHL/SRA pair to; /// sign extend a small value in a large integer register (e.g. sign; /// extending the low 8 bits of a 32-bit register to fill the top 24 bits; /// with the 7th bit). The size of the smaller type is indicated by the 1th; /// operand, a ValueType node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:407,Modifiability,extend,extended,407,"/// ANY_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register any-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is any-extended into the corresponding,; /// wider result elements with the high bits becoming undef.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:410,Modifiability,extend,extended,410,"/// SIGN_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register sign-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is sign-extended into the corresponding,; /// wider result elements.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:410,Modifiability,extend,extended,410,"/// ZERO_EXTEND_VECTOR_INREG(Vector) - This operator represents an; /// in-register zero-extension of the low lanes of an integer vector. The; /// result type must have fewer elements than the operand type, and those; /// elements must be larger integer types such that the total size of the; /// operand type is less than or equal to the size of the result type. Each; /// of the low operand elements is zero-extended into the corresponding,; /// wider result elements.; /// NOTE: The type legalizer prefers to make the operand and result size; /// the same to allow expansion to shuffle vector during op legalization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:740,Modifiability,extend,extended,740,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:787,Modifiability,extend,extends,787,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:824,Modifiability,extend,extends,824,"/// FP_TO_[US]INT_SAT - Convert floating point value in operand 0 to a; /// signed or unsigned scalar integer type given in operand 1 with the; /// following semantics:; ///; /// * If the value is NaN, zero is returned.; /// * If the value is larger/smaller than the largest/smallest integer,; /// the largest/smallest integer is returned (saturation).; /// * Otherwise the result of rounding the value towards zero is returned.; ///; /// The scalar width of the type given in operand 1 must be equal to, or; /// smaller than, the scalar result type width. It may end up being smaller; /// than the result width as a result of integer type legalization.; ///; /// After converting to the scalar integer type in operand 1, the value is; /// extended to the result VT. FP_TO_SINT_SAT sign extends and FP_TO_UINT_SAT; /// zero extends.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:81,Availability,down,down,81,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:588,Safety,safe,safe,588,"/// X = FP_ROUND(Y, TRUNC) - Rounding 'Y' from a larger floating point type; /// down to the precision of the destination VT. TRUNC is a flag, which is; /// always an integer that is zero or one. If TRUNC is 0, this is a; /// normal rounding, if it is 1, this FP_ROUND is known to not change the; /// value of Y.; ///; /// The TRUNC = 1 case is used in cases where we know that the value will; /// not be modified by the node, because Y is not using any of the extra; /// precision of source type. This allows certain transformations like; /// FP_EXTEND(FP_ROUND(X,1)) -> X which are not safe for; /// FP_EXTEND(FP_ROUND(X,0)) because the extra bits aren't removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:218,Integrability,depend,dependent,218,"/// Returns current rounding mode:; /// -1 Undefined; /// 0 Round to 0; /// 1 Round to nearest, ties to even; /// 2 Round to +inf; /// 3 Round to -inf; /// 4 Round to nearest, ties to zero; /// Other values are target dependent.; /// Result is rounding mode and chain. Input is a chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:23,Modifiability,Extend,Extend,23,/// X = FP_EXTEND(Y) - Extend a smaller FP type into a larger FP type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:711,Integrability,depend,depends,711,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:136,Performance,load,loaded,136,"/// BITCAST - This operator converts between integer, vector and FP; /// values, as if the value was stored to memory with one type and loaded; /// from the same address with the other type (or equivalently for vector; /// format conversions, etc). The source and result are required to have; /// the same bit size (e.g. f32 <-> i32). This can also be used for; /// int-to-int or fp-to-fp conversions, but that is a noop, deleted by; /// getNode().; ///; /// This operator is subtly different from the bitcast instruction from; /// LLVM-IR since this node may change the bits in the register. For; /// example, this occurs on big-endian NEON and big-endian MSA where the; /// layout of the bits in the register depends on the vector type and this; /// operator acts as a shuffle operation for some vector type combinations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:180,Integrability,interface,interface,180,"/// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions; /// and truncation for half-precision (16 bit) floating numbers. These nodes; /// form a semi-softened interface for dealing with f16 (as an i16), which; /// is often a storage-only type but has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,Performance,perform,perform,57,"/// FP16_TO_FP, FP_TO_FP16 - These operators are used to perform promotions; /// and truncation for half-precision (16 bit) floating numbers. These nodes; /// form a semi-softened interface for dealing with f16 (as an i16), which; /// is often a storage-only type but has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:143,Integrability,interface,interface,143,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:57,Performance,perform,perform,57,"/// BF16_TO_FP, FP_TO_BF16 - These operators are used to perform promotions; /// and truncation for bfloat16. These nodes form a semi-softened interface; /// for dealing with bf16 (as an i16), which is often a storage-only type but; /// has native conversions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,Perform,Perform,4,"/// Perform various unary floating-point operations inspired by libm. For; /// FPOWI, the result is undefined if the integer operand doesn't fit into; /// sizeof(int).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:22,Performance,Perform,Perform,22,"/// FMINNUM/FMAXNUM - Perform floating-point minimum or maximum on two; /// values.; //; /// In the case where a single input is a NaN (either signaling or quiet),; /// the non-NaN input is returned.; ///; /// The return value of (FMINNUM 0.0, -0.0) could be either 0.0 or -0.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:32,Performance,Perform,Perform,32,"/// FMINNUM_IEEE/FMAXNUM_IEEE - Perform floating-point minimum or maximum on; /// two values, following the IEEE-754 2008 definition. This differs from; /// FMINNUM/FMAXNUM in the handling of signaling NaNs. If one input is a; /// signaling NaN, returns a quiet NaN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:149,Performance,load,loaded,149,"/// Sets the current floating point environment. The first operand is a token; /// chain, the second is a pointer to memory, where FP environment is loaded; /// from. The result is a token chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:4,Performance,LOAD,LOAD,4,"/// LOAD and STORE have token chains as their first operand, then the same; /// operands as an LLVM load/store instruction, then an offset node that; /// is added / subtracted from the base pointer to form the address (for; /// indexed memory ops).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:100,Performance,load,load,100,"/// LOAD and STORE have token chains as their first operand, then the same; /// operands as an LLVM load/store instruction, then an offset node that; /// is added / subtracted from the base pointer to form the address (for; /// indexed memory ops).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:25,Energy Efficiency,Allocate,Allocate,25,"/// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned; /// to a specified boundary. This node always has two return values: a new; /// stack pointer value and a chain. The first operand is the token chain,; /// the second is the number of bytes to allocate, and the third is the; /// alignment boundary. The size is guaranteed to be a multiple of the; /// stack alignment, and the alignment is guaranteed to be bigger than the; /// stack alignment (if required) or 0 to get standard stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:270,Energy Efficiency,allocate,allocate,270,"/// DYNAMIC_STACKALLOC - Allocate some number of bytes on the stack aligned; /// to a specified boundary. This node always has two return values: a new; /// stack pointer value and a chain. The first operand is the token chain,; /// the second is the number of bytes to allocate, and the third is the; /// alignment boundary. The size is guaranteed to be a multiple of the; /// stack alignment, and the alignment is guaranteed to be bigger than the; /// stack alignment (if required) or 0 to get standard stack alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:464,Performance,optimiz,optimizations,464,"/// BRCOND - Conditional branch. The first operand is the chain, the; /// second is the condition, the third is the block to branch to if the; /// condition is true. If the type of the condition is not i1, then the; /// high bits must conform to getBooleanContents. If the condition is undef,; /// it nondeterministically jumps to the block.; /// TODO: Its semantics w.r.t undef requires further discussion; we need to; /// make it sure that it is consistent with optimizations in MIR & the; /// meaning of IMPLICIT_DEF. See https://reviews.llvm.org/D92015",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:657,Modifiability,variab,variable,657,"/// INLINEASM - Represents an inline asm block. This node always has two; /// return values: a chain and a flag result. The inputs are as follows:; /// Operand #0 : Input chain.; /// Operand #1 : a ExternalSymbolSDNode with a pointer to the asm string.; /// Operand #2 : a MDNodeSDNode with the !srcloc metadata.; /// Operand #3 : HasSideEffect, IsAlignStack bits.; /// After this, it is followed by a list of operands with this format:; /// ConstantSDNode: Flags that encode whether it is a mem or not, the; /// of operands that follow, etc. See InlineAsm.h.; /// ... however many operands ...; /// Operand #last: Optional, an incoming flag.; ///; /// The variable width operands are required to represent target addressing; /// modes as a single ""operand"", even though they may have multiple; /// SDOperands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:191,Performance,load,loads,191,"/// ANNOTATION_LABEL - Represents a mid basic block label used by; /// annotations. This should remain within the basic block and be ordered; /// with respect to other call instructions, but loads and stores may float; /// past it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:268,Performance,optimiz,optimizers,268,"/// CALLSEQ_START/CALLSEQ_END - These operators mark the beginning and end; /// of a call sequence, and carry arbitrary information that target might; /// want to know. The first operand is a chain, the rest are specified by; /// the target and not touched by the DAG optimizers.; /// Targets that may use stack to pass call arguments define additional; /// operands:; /// - size of the call frame part that must be set up within the; /// CALLSEQ_START..CALLSEQ_END pair,; /// - part of the call frame prepared prior to CALLSEQ_START.; /// Both these parameters must be constants, their sum is the total call; /// frame size.; /// CALLSEQ_START..CALLSEQ_END pairs may not be nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:415,Performance,latency,latency,415,"/// READCYCLECOUNTER - This corresponds to the readcyclecounter intrinsic.; /// It produces a chain and one i64 value. The only operand is a chain.; /// If i64 is not legal, the result will be expanded into smaller values.; /// Still, it returns an i64, so targets should set legality for i64.; /// The result is the content of the architecture-specific cycle; /// counter-like register (or other high accuracy low latency clock source).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:326,Security,access,access,326,"/// INIT_TRAMPOLINE - This corresponds to the init_trampoline intrinsic. It; /// takes as input a token chain, the pointer to the trampoline, the pointer; /// to the nested function, the pointer to pass for the 'nest' parameter, a; /// SRCVALUE for the trampoline and another for the nested function; /// (allowing targets to access the original Function*).; /// It produces a token chain as output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:77,Availability,failure,failure,77,/// UBSANTRAP - Trap with an immediate describing the kind of sanitizer; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:62,Security,sanitiz,sanitizer,62,/// UBSANTRAP - Trap with an immediate describing the kind of sanitizer; /// failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:213,Performance,cache,cache,213,"/// PREFETCH - This corresponds to a prefetch intrinsic. The first operand; /// is the chain. The other operands are the address to prefetch,; /// read / write specifier, locality specifier and instruction / data cache; /// specifier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:183,Integrability,Synchroniz,SynchronizationScope,183,"/// OUTCHAIN = ATOMIC_FENCE(INCHAIN, ordering, scope); /// This corresponds to the fence instruction. It takes an input chain, and; /// two integer constants: an AtomicOrdering and a SynchronizationScope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:72,Performance,load,load,72,"/// Val, OUTCHAIN = ATOMIC_LOAD(INCHAIN, ptr); /// This corresponds to ""load atomic"" instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Availability,Mask,Masked,3,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:92,Availability,mask,mask,92,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:146,Availability,mask,masked-off,146,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:203,Availability,Mask,Mask,203,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:257,Availability,Mask,Mask,257,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:10,Performance,load,load,10,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:46,Performance,load,load,46,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:126,Security,access,accesses,126,"// Masked load and store - consecutive vector load and store operations; // with additional mask operand that prevents memory accesses to the; // masked-off lanes.; //; // Val, OutChain = MLOAD(BasePtr, Mask, PassThru); // OutChain = MSTORE(Value, BasePtr, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:3,Availability,Mask,Masked,3,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:110,Availability,mask,mask,110,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:164,Availability,mask,masked-off,164,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:232,Availability,Mask,Mask,232,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:300,Availability,Mask,Mask,300,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:31,Performance,load,load,31,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:148,Security,access,accesses,148,"// Masked gather and scatter - load and store operations for a vector of; // random addresses with additional mask operand that prevents memory; // accesses to the masked-off lanes.; //; // Val, OutChain = GATHER(InChain, PassThru, Mask, BasePtr, Index, Scale); // OutChain = SCATTER(InChain, Value, Mask, BasePtr, Index, Scale); //; // The Index operand can have more vector elements than the other operands; // due to type legalization. The extra elements are ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:297,Performance,optimiz,optimizers,297,"/// GC_TRANSITION_START/GC_TRANSITION_END - These operators mark the; /// beginning and end of GC transition sequence, and carry arbitrary; /// information that target might need for lowering. The first operand is; /// a chain, the rest are specified by the target and not touched by the DAG; /// optimizers. GC_TRANSITION_START..GC_TRANSITION_END pairs may not be; /// nested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:176,Energy Efficiency,Power,PowerPC,176,"/// GET_DYNAMIC_AREA_OFFSET - get offset from native SP to the address of; /// the most recent dynamic alloca. For most targets that would be 0, but; /// for some others (e.g. PowerPC, PowerPC64) that would be compile-time; /// known nonzero constant. The only operand here is the chain.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:108,Performance,scalab,scalable,108,/// VSCALE(IMM) - Returns the runtime scaling factor used to calculate the; /// number of elements within a scalable vector. IMM is a constant integer; /// multiplier that is applied to the runtime value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:293,Energy Efficiency,reduce,reduce,293,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:145,Performance,perform,perform,145,"/// Generic reduction nodes. These nodes represent horizontal vector; /// reduction operations, producing a scalar result.; /// The SEQ variants perform reductions in sequential order. The first; /// operand is an initial scalar accumulator value, and the second operand; /// is the vector to reduce.; /// E.g. RES = VECREDUCE_SEQ_FADD f32 ACC, <4 x f32> SRC_VEC; /// ... is equivalent to; /// RES = (((ACC + SRC_VEC[0]) + SRC_VEC[1]) + SRC_VEC[2]) + SRC_VEC[3]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:512,Performance,perform,performing,512,"/// These reductions have relaxed evaluation order semantics, and have a; /// single vector operand. The order of evaluation is unspecified. For; /// pow-of-2 vectors, one valid legalizer expansion is to use a tree; /// reduction, i.e.:; /// For RES = VECREDUCE_FADD <8 x f16> SRC_VEC; /// PART_RDX = FADD SRC_VEC[0:3], SRC_VEC[4:7]; /// PART_RDX2 = FADD PART_RDX[0:1], PART_RDX[2:3]; /// RES = FADD PART_RDX2[0], PART_RDX2[1]; /// For non-pow-2 vectors, this can be computed by extracting each element; /// and performing the operation as if it were scalarized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:114,Performance,perform,performed,114,"/// Integer reductions may have a result type larger than the vector element; /// type. However, the reduction is performed using the vector element type; /// and the value in the top bits is unspecified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:90,Availability,mask,mask,90,"// The `llvm.experimental.patchpoint.*` intrinsic.; // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,; // <numArgs>, cc, ...; // Outputs: [rv], output chain, glue",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:26,Deployability,patch,patchpoint,26,"// The `llvm.experimental.patchpoint.*` intrinsic.; // Operands: input chain, [glue], reg-mask, <id>, <numShadowBytes>, callee,; // <numArgs>, cc, ...; // Outputs: [rv], output chain, glue",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:28,Testability,log,logic,28,/// Whether this is bitwise logic opcode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:39,Availability,mask,mask,39,/// The operand position of the vector mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:269,Availability,avail,available,269,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:128,Performance,load,load,128,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:201,Performance,load,load,201,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:397,Performance,load,load,397,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:441,Performance,load,load,441,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:701,Performance,load,load,701,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:739,Performance,load,load,739,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:797,Performance,perform,performing,797,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:927,Performance,load,load,927,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:972,Performance,load,load,972,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:1355,Performance,load,load,1355,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:1404,Performance,load,load,1404,"//===--------------------------------------------------------------------===//; /// MemIndexedMode enum - This enum defines the load / store indexed; /// addressing modes.; ///; /// UNINDEXED ""Normal"" load / store. The effective address is already; /// computed and is available in the base pointer. The offset; /// operand is always undefined. In addition to producing a; /// chain, an unindexed load produces one value (result of the; /// load); an unindexed store does not produce a value.; ///; /// PRE_INC Similar to the unindexed mode where the effective address is; /// PRE_DEC the value of the base pointer add / subtract the offset.; /// It considers the computation as being folded into the load /; /// store operation (i.e. the load / store does the address; /// computation as well as performing the memory transaction).; /// The base operand is always undefined. In addition to; /// producing a chain, pre-indexed load produces two values; /// (result of the load and the result of the address; /// computation); a pre-indexed store produces one value (result; /// of the address computation).; ///; /// POST_INC The effective address is the value of the base pointer. The; /// POST_DEC value of the offset operand is then added to / subtracted; /// from the base after memory transaction. In addition to; /// producing a chain, post-indexed load produces two values; /// (the result of the load and the result of the base +/- offset; /// computation); a post-indexed store produces one value (the; /// the result of the base +/- offset computation).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:233,Modifiability,extend,extends,233,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:331,Modifiability,extend,extends,331,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:432,Modifiability,extend,extending,432,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:465,Modifiability,extend,extending,465,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:84,Performance,Load,LoadExtType,84,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:143,Performance,LOAD,LOADEXT,143,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:157,Performance,load,load,157,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:198,Performance,load,loads,198,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:296,Performance,load,loads,296,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:442,Performance,load,loads,442,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:475,Performance,load,loads,475,//===--------------------------------------------------------------------===//; /// LoadExtType enum - This enum defines the three variants of LOADEXT; /// (load with extension).; ///; /// SEXTLOAD loads the integer operand and sign extends it to a larger; /// integer result type.; /// ZEXTLOAD loads the integer operand and zero extends it to a larger; /// integer result type.; /// EXTLOAD is used for two things: floating point extending loads and; /// integer extending loads [the top bits are undefined].,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:20,Usability,Intuit,Intuitive,20,// Opcode N U L G E Intuitive operation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs a signed; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an unsigned; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with integer operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:52,Performance,perform,performs,52,/// Return true if this is a setcc instruction that performs an equality; /// comparison when used with floating point operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:27,Testability,log,logical,27,/// Return the result of a logical OR between different comparisons of; /// identical values: ((X op1 Y) | (X op2 Y)). This function returns; /// SETCC_INVALID if it is not possible to represent the resultant comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h:27,Testability,log,logical,27,/// Return the result of a logical AND between different comparisons of; /// identical values: ((X op1 Y) & (X op2 Y)). This function returns; /// SETCC_INVALID if it is not possible to represent the resultant comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/ISDOpcodes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:449,Energy Efficiency,Schedul,SchedulingPriorityQueue,449,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:478,Energy Efficiency,schedul,schedules,478,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:521,Energy Efficiency,reduce,reduce,521,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:10,Performance,Latency,LatencyPriorityQueue,10,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:37,Performance,latency,latency-oriented,37,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:63,Performance,queue,queue,63,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:406,Performance,Latency,LatencyPriorityQueue,406,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:494,Performance,latency,latency,494,"//===---- LatencyPriorityQueue.h - A latency-oriented priority queue ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file declares the LatencyPriorityQueue class, which is a; // SchedulingPriorityQueue that schedules using latency information to; // reduce the length of the critical path through the basic block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:30,Availability,Avail,Available,30,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:40,Performance,queue,queue,40,/// Sorting functions for the Available queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:78,Performance,Queue,Queue,78,"/// NumNodesSolelyBlocking - This vector contains, for every node in the; /// Queue, the number of nodes that the node is the sole unscheduled; /// predecessor for. This is used as a tie-breaker heuristic for better; /// mobility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:4,Performance,Queue,Queue,4,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:16,Performance,queue,queue,16,/// Queue - The queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:240,Availability,avail,available,240,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:3,Energy Efficiency,schedul,scheduledNode,3,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:32,Energy Efficiency,schedul,scheduled,32,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h:203,Energy Efficiency,schedul,scheduling,203,"// scheduledNode - As nodes are scheduled, we look to see if there are any; // successor nodes that have a single unscheduled predecessor. If so, that; // single predecessor has a higher priority, since scheduling it will make; // the node available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LatencyPriorityQueue.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h:331,Availability,avail,available,331,"/// This is an alternative analysis pass to MachineBlockFrequencyInfo.; /// The difference is that with this pass, the block frequencies are not; /// computed when the analysis pass is executed but rather when the BFI result; /// is explicitly requested by the analysis client.; ///; /// This works by checking querying if MBFI is available and otherwise; /// generating MBFI on the fly. In this case the passes required for (LI, DT); /// are also queried before being computed on the fly.; ///; /// Note that it is expected that we wouldn't need this functionality for the; /// new PM since with the new PM, analyses are executed on demand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h:53,Availability,avail,available,53,/// Calculate MBFI and all other analyses that's not available and; /// required by BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LazyMachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:4,Modifiability,extend,extendInsnRange,4,/// extendInsnRange - Extend the current instruction range covered by; /// this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:22,Modifiability,Extend,Extend,22,/// extendInsnRange - Extend the current instruction range covered by; /// this scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:122,Integrability,interface,interface,122,//===----------------------------------------------------------------------===//; /// LexicalScopes - This class provides interface to collect and use lexical; /// scoping information from machine instruction.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:4,Deployability,release,releaseMemory,4,/// releaseMemory - release memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:20,Deployability,release,release,20,/// releaseMemory - release memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:66,Availability,avail,available,66,/// empty - Return true if there is any lexical scope information available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:85,Availability,avail,available,85,/// getOrCreateLexicalScope - Find lexical scope for the given Scope/IA. If; /// not available then create new lexical scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h:70,Performance,cache,cache,70,/// Map a location to the set of basic blocks it dominates. This is a cache; /// for \ref LexicalScopes::getMachineBasicBlocks results.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LexicalScopes.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h:25,Modifiability,plug-in,plug-ins,25,"// We must reference the plug-ins in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h:128,Performance,optimiz,optimization,128,"// We must reference the plug-ins in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllAsmWriterComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h:126,Performance,optimiz,optimization,126,"// We must reference the passes in such a way that compilers will not; // delete it all as dead code, even with whole program optimization,; // yet is effectively a NO-OP. As the compiler isn't smart enough; // to know that getenv() never returns -1, this will do the job.; // This is so that globals in the translation units where these functions; // are defined are forced to be initialized, populating various; // registries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LinkAllCodegenComponents.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:135,Integrability,interface,interface,135,"/// Result of a LiveRange query. This class hides the implementation details; /// of live ranges, and it should be used as the primary interface for; /// examining live ranges around instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:22,Availability,alive,alive,22,"/// Returns the value alive at the end of the instruction, if any. This can; /// be a live-through value, a live def or a dead def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:29,Deployability,continuous,continuous,29,"/// This represents a simple continuous liveness interval for a value.; /// The start point is inclusive, the end point exclusive. These intervals; /// are rendered as [start,end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:22,Usability,simpl,simple,22,"/// This represents a simple continuous liveness interval for a value.; /// The start point is inclusive, the end point exclusive. These intervals; /// are rendered as [start,end).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:117,Energy Efficiency,allocate,allocate,117,"/// createDeadDef - Make sure the range has a value defined at Def.; /// If one already exists, return it. Otherwise allocate a new value and; /// add liveness for a dead def.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:15,Modifiability,extend,extend,15,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:450,Modifiability,extend,extended,450,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:691,Modifiability,extend,extend,691,"/// Attempt to extend a value defined after @p StartIdx to include @p Use.; /// Both @p StartIdx and @p Use should be in the same basic block. In case; /// of subranges, an extension could be prevented by an explicit ""undef""; /// caused by a <def,read-undef> on a non-overlapping lane. The list of; /// location of such ""undefs"" should be provided in @p Undefs.; /// The return value is a pair: the first element is VNInfo of the value; /// that was extended (possibly nullptr), the second is a boolean value; /// indicating whether an ""undef"" was encountered.; /// If this range is live before @p Use in the basic block that starts at; /// @p StartIdx, and there is no intervening ""undef"", extend it to be live; /// up to @p Use, and return the pair {value, false}. If there is no; /// segment before @p Use and there is no ""undef"" between @p StartIdx and; /// @p Use, return {nullptr, false}. If there is an ""undef"" before @p Use,; /// return {nullptr, true}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:37,Modifiability,extend,extendInBlock,37,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:232,Modifiability,extend,extend,232,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:4,Usability,Simpl,Simplified,4,"/// Simplified version of the above ""extendInBlock"", which assumes that; /// no register lanes are undefined by <def,read-undef> operands.; /// If this range is live before @p Use in the basic block that starts; /// at @p StartIdx, extend it to be live up to @p Use, and return the; /// value. If there is no segment before @p Use, return nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:186,Safety,abort,aborts,186,"/// join - Join two live ranges (this, and other) together. This applies; /// mappings to the value numbers in the LHS/RHS ranges as specified. If; /// the ranges are not joinable, this aborts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:213,Modifiability,extend,extended,213,"/// True iff this segment is a single segment that lies between the; /// specified boundaries, exclusively. Vregs live across a backedge are not; /// considered local. The boundaries are expected to lie within an extended; /// basic block, so vregs that are not live out should contain no holes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:163,Security,access,access,163,/// Stores indexes from the input index sequence R at which this LiveRange; /// is live to the output O iterator.; /// R is a range of _ascending sorted_ _random_ access iterators; /// to the input indexes. Indexes stored at O are ascending sorted so it; /// can be used directly in the subsequent search (for example for; /// subranges). Returns true if found at least one index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:23,Testability,assert,assert,23,/// Walk the range and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:103,Testability,assert,asserts,103,/// Walk the range and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:56,Availability,avail,available,56,/// Returns true if subregister liveness information is available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,Availability,mask,mask,21,"/// For a given lane mask @p LaneMask, compute indexes at which the; /// lane is marked undefined by subregister <def,read-undef> definitions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:359,Availability,mask,mask,359,"/// Refines the subranges to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:642,Availability,mask,masks,642,"/// Refines the subranges to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how th",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:944,Deployability,update,update,944,"s to support \p LaneMask. This may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:1847,Deployability,update,update,1847,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:2035,Deployability,update,updated,2035,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:1710,Modifiability,rewrite,rewrite,1710,"s may only be called; /// for LI.hasSubrange()==true. Subregister ranges are split or created; /// until \p LaneMask can be matched exactly. \p Mod is executed on the; /// matching subranges.; ///; /// Example:; /// Given an interval with subranges with lanemasks L0F00, L00F0 and; /// L000F, refining for mask L0018. Will split the L00F0 lane into; /// L00E0 and L0010 and the L000F lane into L0007 and L0008. The Mod; /// function will be applied to the L0010 and L0008 subranges.; ///; /// \p Indexes and \p TRI are required to clean up the VNIs that; /// don't define the related lane masks after they get shrunk. E.g.,; /// when L000F gets split into L0007 and L0008 maybe only a subset; /// of the VNIs that defined L000F defines L0007.; ///; /// The clean up of the VNIs need to look at the actual instructions; /// to decide what is or is not live at a definition point. If the; /// update of the subranges occurs while the IR does not reflect these; /// changes, \p ComposeSubRegIdx can be used to specify how the; /// definition are going to be rewritten.; /// E.g., let say we want to merge:; /// V1.sub1:<2 x s32> = COPY V2.sub3:<4 x s32>; /// We do that by choosing a class where sub1:<2 x s32> and sub3:<4 x s32>; /// overlap, i.e., by choosing a class where we can find ""offset + 1 == 3"".; /// Put differently we align V2's sub3 with V1's sub1:; /// V2: sub0 sub1 sub2 sub3; /// V1: <offset> sub0 sub1; ///; /// This offset will look like a composed subregidx in the class:; /// V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; /// => V1.(composed sub2 with sub1):<4 x s32> = COPY V2.sub3:<4 x s32>; ///; /// Now if we didn't rewrite the uses and def of V1, all the checks for V1; /// need to account for this offset.; /// This happens during coalescing where we update the live-ranges while; /// still having the old IR around because updating the IR on-the-fly; /// would actually clobber some information on how the live-ranges that; /// are being updated look like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:27,Testability,assert,assert,27,/// Walks the interval and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:107,Testability,assert,asserts,107,/// Walks the interval and assert if any invariants fail to hold.; ///; /// Note that this is a no-op when asserts are disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:47,Deployability,update,updates,47,/// Helper class for performant LiveRange bulk updates.; ///; /// Calling LiveRange::addSegment() repeatedly can be expensive on large; /// live ranges because segments after the insertion point may need to be; /// shifted. The LiveRangeUpdater class can defer the shifting when adding; /// many segments in order.; ///; /// The LiveRange will be in an invalid state until flush() is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:21,Performance,perform,performant,21,/// Helper class for performant LiveRange bulk updates.; ///; /// Calling LiveRange::addSegment() repeatedly can be expensive on large; /// live ranges because segments after the insertion point may need to be; /// shifted. The LiveRangeUpdater class can defer the shifting when adding; /// many segments in order.; ///; /// The LiveRange will be in an invalid state until flush() is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:149,Performance,perform,performance,149,"/// Add a segment to LR and coalesce when possible, just like; /// LR.addSegment(). Segments should be added in increasing start order for; /// best performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:14,Deployability,update,updater,14,/// Flush the updater state to LR so it is valid and contains all added; /// segments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h:411,Energy Efficiency,allocate,allocate,411,"/// ConnectedVNInfoEqClasses - Helper class that can divide VNInfos in a; /// LiveInterval into equivalence clases of connected components. A; /// LiveInterval that has multiple connected components can be broken into; /// multiple LiveIntervals.; ///; /// Given a LiveInterval that may have multiple connected components, run:; ///; /// unsigned numComps = ConEQ.Classify(LI);; /// if (numComps > 1) {; /// // allocate numComps-1 new LiveIntervals into LIS[1..]; /// ConEQ.Distribute(LIS);; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveInterval.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:272,Availability,mask,mask,272,"/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// If @p LR is a main range, or if @p LI is null, then all uses must be; /// jointly dominated by the definitions from @p LR. If @p LR is a subrange; /// of the live interval @p LI, corresponding to lane mask @p LaneMask,; /// all uses must be jointly dominated by the definitions from @p LR; /// together with definitions of other lanes where @p LR becomes undefined; /// (via <def,read-undef> operands).; /// If @p LR is a main range, the @p LaneMask should be set to ~0, i.e.; /// LaneBitmask::getAll().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:4,Modifiability,Extend,Extend,4,"/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// If @p LR is a main range, or if @p LI is null, then all uses must be; /// jointly dominated by the definitions from @p LR. If @p LR is a subrange; /// of the live interval @p LI, corresponding to lane mask @p LaneMask,; /// all uses must be jointly dominated by the definitions from @p LR; /// together with definitions of other lanes where @p LR becomes undefined; /// (via <def,read-undef> operands).; /// If @p LR is a main range, the @p LaneMask should be set to ~0, i.e.; /// LaneBitmask::getAll().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h:4,Modifiability,Extend,Extend,4,/// Extend the live range of @p LR to reach all uses of Reg.; ///; /// All uses must be jointly dominated by existing liveness. PHI-defs are; /// inserted as needed to preserve SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,Availability,mask,mask,46,"/// Sorted list of instructions with register mask operands. Always use the; /// 'r' slot, RegMasks are normal clobbers, not early clobbers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:99,Availability,mask,mask,99,"/// This vector is parallel to RegMaskSlots, it holds a pointer to the; /// corresponding register mask. This pointer can be recomputed as:; ///; /// MI = Indexes->getInstructionFromIndex(RegMaskSlot[N]);; /// unsigned OpNum = findRegMaskOperand(MI);; /// RegMaskBits[N] = MI->getOperand(OpNum).getRegMask();; ///; /// This is kept in a separate vector partly because some standard; /// libraries don't support lower_bound() with mixed objects, partly to; /// improve locality when searching in RegMaskSlots.; /// Also see the comment in LiveInterval::find().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:246,Availability,mask,mask,246,"/// For each basic block number, keep (begin, size) pairs indexing into the; /// RegMaskSlots and RegMaskBits arrays.; /// Note that basic block numbers may not be layout contiguous, that's why; /// we can't just keep track of the first register mask in each basic; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:191,Availability,mask,mask,191,"/// Specialized version of; /// shrinkToUses(LiveInterval *li, SmallVectorImpl<MachineInstr*> *dead); /// that works on a subregister live range and only looks at uses matching; /// the lane mask of the subregister range.; /// This may leave the subrange empty which needs to be cleaned up with; /// LiveInterval::removeEmptySubranges() afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Modifiability,Extend,Extend,4,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:360,Modifiability,extend,extended,360,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:519,Modifiability,extend,extended,519,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:577,Modifiability,extend,extend,577,"/// Extend the live range \p LR to reach all points in \p Indices. The; /// points in the \p Indices array must be jointly dominated by the union; /// of the existing defs in \p LR and points in \p Undefs.; ///; /// PHI-defs are added as needed to maintain SSA form.; ///; /// If a SlotIndex in \p Indices is the end index of a basic block, \p LR; /// will be extended to be live out of the basic block.; /// If a SlotIndex in \p Indices is jointy dominated only by points in; /// \p Undefs, the live range will not be extended to that point.; ///; /// See also LiveRangeCalc::extend().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:168,Modifiability,extend,extendToIndices,168,"/// If \p LR has a live value at \p Kill, prune its live range by removing; /// any liveness reachable from Kill. Add live range end points to; /// EndPoints such that extendToIndices(LI, EndPoints) will reconstruct the; /// value's live range.; ///; /// Calling pruneValue() and extendToIndices() can be used to reconstruct; /// SSA form after adding defs to a virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:280,Modifiability,extend,extendToIndices,280,"/// If \p LR has a live value at \p Kill, prune its live range by removing; /// any liveness reachable from Kill. Add live range end points to; /// EndPoints such that extendToIndices(LI, EndPoints) will reconstruct the; /// value's live range.; ///; /// Calling pruneValue() and extendToIndices() can be used to reconstruct; /// SSA form after adding defs to a virtual register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:107,Safety,avoid,avoid,107,/// Returns true if VNI is killed by any PHI-def values in LI.; /// This may conservatively return true to avoid expensive computations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:120,Deployability,update,update,120,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:241,Deployability,Update,UpdateFlags,241,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:253,Deployability,Update,Update,253,/// Call this method to notify LiveIntervals that instruction \p MI has been; /// moved within a basic block. This will update the live intervals for all; /// operands of \p MI. Moves between basic blocks are not supported.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Deployability,Update,Update,4,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:132,Deployability,Update,UpdateFlags,132,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:144,Deployability,Update,Update,144,/// Update intervals of operands of all instructions in the newly; /// created bundle specified by \p BundleStart.; ///; /// \param UpdateFlags Update live intervals for nonallocatable physregs.; ///; /// Assumes existing liveness is accurate.; /// \pre BundleStart should be the first instruction in the Bundle.; /// \pre BundleStart should not have a have SlotIndex as one will be assigned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Deployability,Update,Update,4,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:172,Energy Efficiency,efficient,efficient,172,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:414,Usability,simpl,simple,414,"/// Update live intervals for instructions in a range of iterators. It is; /// intended for use after target hooks that may insert or remove; /// instructions, and is only efficient for a small number of instructions.; ///; /// OrigRegs is a vector of registers that were originally used by the; /// instructions in the range between the two iterators.; ///; /// Currently, the only changes that are supported are simple removal; /// and addition of uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:12,Availability,mask,mask,12,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:76,Availability,mask,mask,76,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:441,Availability,mask,mask,441,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:539,Availability,mask,mask,539,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:235,Performance,perform,performance,235,"// Register mask functions.; //; // Machine instructions may use a register mask operand to indicate that a; // large number of registers are clobbered by the instruction. This is; // typically used for calls.; //; // For compile time performance reasons, these clobbers are not recorded in; // the live intervals for individual physical registers. Instead,; // LiveIntervalAnalysis maintains a sorted list of instructions with; // register mask operands.; /// Returns a sorted array of slot indices of all instructions with; /// register mask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:82,Availability,mask,mask,82,/// Returns a sorted array of slot indices of all instructions with register; /// mask operands in the basic block numbered \p MBBNum.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:33,Availability,mask,mask,33,/// Returns an array of register mask pointers corresponding to; /// getRegMaskSlots().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,Availability,mask,mask,24,/// Returns an array of mask pointers corresponding to; /// getRegMaskSlotsInBlock(MBBNum).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:46,Availability,mask,mask,46,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:88,Availability,mask,mask,88,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:219,Availability,mask,mask,219,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:4,Testability,Test,Test,4,"/// Test if \p LI is live across any register mask instructions, and; /// compute a bit mask of physical registers that are not clobbered by any; /// of them.; ///; /// Returns false if \p LI doesn't cross any register mask instructions. In; /// that case, the bit vector is not filled in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:420,Energy Efficiency,efficient,efficiently,420,"// Register unit functions.; //; // Fixed interference occurs when MachineInstrs use physregs directly; // instead of virtual registers. This typically happens when passing; // arguments to a function call, or when instructions require operands in; // fixed registers.; //; // Each physreg has one or more register units, see MCRegisterInfo. We; // track liveness per register unit to handle aliasing registers more; // efficiently.; /// Return the live range for register unit \p Unit. It will be computed if; /// it doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h:24,Availability,repair,repairIntervalsInRange,24,"/// Helper function for repairIntervalsInRange(), walks backwards and; /// creates/modifies live segments in \p LR to match the operands found.; /// Only full operands or operands with subregisters matching \p LaneMask; /// are considered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervals.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:126,Integrability,depend,depending,126,"/// Union of live intervals that are strong candidates for coalescing into a; /// single register (either physical or virtual depending on the context). We; /// expect the constituent live intervals to be disjoint, although we may; /// eventually make exceptions to handle value-based interference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:18,Security,access,access,18,// Provide public access to the underlying map to allow overlap iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h:10,Performance,cache,cached,10,"// Retain cached results, e.g. firstInterference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveIntervalUnion.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:1181,Availability,alive,alive,1181,"//===- llvm/CodeGen/LivePhysRegs.h - Live Physical Register Set -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the LivePhysRegs utility for tracking liveness of; /// physical registers. This can be used for ad-hoc liveness tracking after; /// register allocation. You can start with the live-ins/live-outs at the; /// beginning/end of a block and update the information while walking the; /// instructions inside the block. This implementation tracks the liveness on a; /// sub-register granularity.; ///; /// We assume that the high bits of a physical super-register are not preserved; /// unless the instruction has an implicit-use operand reading the super-; /// register.; ///; /// X86 Example:; /// %ymm0 = ...; /// %xmm0 = ... (Kills %xmm0, all %xmm0s sub-registers, and %ymm0); ///; /// %ymm0 = ...; /// %xmm0 = ..., implicit %ymm0 (%ymm0 and all its sub-registers are alive); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:652,Deployability,update,update,652,"//===- llvm/CodeGen/LivePhysRegs.h - Live Physical Register Set -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file implements the LivePhysRegs utility for tracking liveness of; /// physical registers. This can be used for ad-hoc liveness tracking after; /// register allocation. You can start with the live-ins/live-outs at the; /// beginning/end of a block and update the information while walking the; /// instructions inside the block. This implementation tracks the liveness on a; /// sub-register granularity.; ///; /// We assume that the high bits of a physical super-register are not preserved; /// unless the instruction has an implicit-use operand reading the super-; /// register.; ///; /// X86 Example:; /// %ymm0 = ...; /// %xmm0 = ... (Kills %xmm0, all %xmm0s sub-registers, and %ymm0); ///; /// %ymm0 = ...; /// %xmm0 = ..., implicit %ymm0 (%ymm0 and all its sub-registers are alive); //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:25,Usability,clear,clears,25,/// (re-)initializes and clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:4,Usability,Clear,Clears,4,/// Clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:275,Availability,avail,available,275,"/// Returns true if register \p Reg is contained in the set. This also; /// works if only the super register of \p Reg has been defined, because; /// addReg() always adds all sub-registers to the set as well.; /// Note: Returns false if just some sub registers are live, use available(); /// when searching a free register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:158,Integrability,depend,depends,158,"/// Simulates liveness when stepping forward over an instruction(bundle).; /// Remove killed-uses, add defs. This is the not recommended way, because it; /// depends on accurate kill flags. If possible use stepBackward() instead of; /// this function. The clobbers set will be the list of registers either; /// defined or clobbered by a regmask. The operand will identify whether this; /// is a regmask or register operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h:80,Availability,mask,masks,80,"/// Adds live-in registers from basic block \p MBB, taking associated; /// lane masks into consideration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LivePhysRegs.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:755,Availability,avail,available,755,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:906,Availability,down,down,906,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:742,Integrability,interface,interface,742,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:1000,Integrability,interface,interface,1000,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:794,Modifiability,variab,variable,794,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:487,Performance,cache,caches,487,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:594,Performance,cache,cache,594,"//===- LiveRangeCalc.h - Calculate live ranges -----------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LiveRangeCalc class can be used to implement the computation of; // live ranges from scratch.; // It caches information about values in the CFG to speed up repeated; // operations on the same live range. The cache can be shared by; // non-overlapping live ranges. SplitKit uses that when computing the live; // range of split products.; //; // A low-level interface is available to clients that know where a variable is; // live, but don't know which value it has as every point. LiveRangeCalc will; // propagate values down the dominator tree, and even insert PHI-defs where; // needed. SplitKit uses this faster interface when possible.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,Availability,redundant,redundant,82,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:82,Safety,redund,redundant,82,"/// LiveOutPair - A value and the block that defined it. The domtree node is; /// redundant, it can be computed as: MDT[Indexes.getMBBFromIndex(VNI->def)].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:211,Usability,clear,cleared,211,"/// Bit vector of active entries in LiveOut, also used as a visited set by; /// findReachingDefs. One entry per basic block, indexed by block number.; /// This is kept as a separate bit vector because it can be cleared quickly; /// when switching live ranges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:117,Deployability,update,updated,117,// DomNode - Dominator tree node for the block.; // Cleared when the final value has been determined and LI has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:52,Usability,Clear,Cleared,52,// DomNode - Dominator tree node for the block.; // Cleared when the final value has been determined and LI has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:30,Deployability,update,updateSSA,30,// Live-in value filled in by updateSSA once it is known.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:174,Deployability,update,updateSSA,174,/// LiveIn - Work list of blocks where the live-in value has yet to be; /// determined. This list is typically computed by findReachingDefs() and; /// used as a work list by updateSSA(). The low-level interface may also be; /// used to add entries directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:201,Integrability,interface,interface,201,/// LiveIn - Work list of blocks where the live-in value has yet to be; /// determined. This list is typically computed by findReachingDefs() and; /// used as a work list by updateSSA(). The low-level interface may also be; /// used to add entries directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:4,Deployability,update,updateSSA,4,/// updateSSA - Compute the values that will be live in to all requested; /// blocks in LiveIn. Create PHI-def values as required to preserve SSA form.; ///; /// Every live-in block must be jointly dominated by the added live-out; /// blocks. No values are read from the live ranges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:71,Deployability,update,update,71,/// Transfer information from the LiveIn vector to the live ranges and update; /// the given @p LiveOuts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:20,Security,expose,expose,20,/// Some getters to expose in a read-only way some private fields to; /// subclasses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:94,Integrability,interface,interface,94,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:254,Performance,cache,caches,254,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:316,Performance,cache,caches,316,"//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Calculate live ranges from scratch.; //; /// reset - Prepare caches for a new set of non-overlapping live ranges. The; /// caches must be reset before attempting calculations with a live range; /// that may overlap a previously computed live range, and before the first; /// live range in a function. If live ranges are not known to be; /// non-overlapping, call reset before each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Mid-level interface.; //===--------------------------------------------------------------------===//; //; // Modify existing live ranges.; //; /// Extend the live range of @p LR to reach @p Use.; ///; /// The existing values in @p LR must be live so they jointly dominate @p Use.; /// If @p Use is not dominated by a single existing value, PHI-defs are; /// inserted as required to preserve SSA form.; ///; /// PhysReg, when set, is used to verify live-in lists on basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:230,Modifiability,Extend,Extend,230,"//===--------------------------------------------------------------------===//; // Mid-level interface.; //===--------------------------------------------------------------------===//; //; // Modify existing live ranges.; //; /// Extend the live range of @p LR to reach @p Use.; ///; /// The existing values in @p LR must be live so they jointly dominate @p Use.; /// If @p Use is not dominated by a single existing value, PHI-defs are; /// inserted as required to preserve SSA form.; ///; /// PhysReg, when set, is used to verify live-in lists on basic blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // These functions can be used to compute live ranges where the live-in and; // live-out blocks are already known, but the SSA value in each block is; // unknown.; //; // After calling reset(), add known live-out values and known live-in blocks.; // Then call calculateValues() to compute the actual value that is; // live-in to each block, and add liveness to the live ranges.; //; /// setLiveOutValue - Indicate that VNI is live out from MBB. The; /// calculateValues() function will not add liveness for MBB, the caller; /// should take care of that.; ///; /// VNI may be null only if MBB is a live-through block also passed to; /// addLiveInBlock().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeCalc.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:86,Performance,load,load,86,"/// foldAsLoad - If LI has a single use and a single def that can be folded as; /// a load, eliminate the register by folding the def into the use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:40,Availability,down,down,40,"/// Create a LiveRangeEdit for breaking down parent into smaller pieces.; /// @param parent The register being spilled or split.; /// @param newRegs List to receive any new registers created. This needn't be; /// empty initially, any existing registers are ignored.; /// @param MF The MachineFunction the live range edit is taking place in.; /// @param lis The collection of all live intervals in this function.; /// @param vrm Map of virtual registers to physical registers for this; /// function. If NULL, no virtual register map updates will; /// be done. This could be the case if called before Regalloc.; /// @param deadRemats The collection of all the instructions defining an; /// original reg and are dead after remat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:532,Deployability,update,updates,532,"/// Create a LiveRangeEdit for breaking down parent into smaller pieces.; /// @param parent The register being spilled or split.; /// @param newRegs List to receive any new registers created. This needn't be; /// empty initially, any existing registers are ignored.; /// @param MF The MachineFunction the live range edit is taking place in.; /// @param lis The collection of all live intervals in this function.; /// @param vrm Map of virtual registers to physical registers for this; /// function. If NULL, no virtual register map updates will; /// be done. This could be the case if called before Regalloc.; /// @param deadRemats The collection of all the instructions defining an; /// original reg and are dead after remat.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:17,Security,access,accessing,17,/// Iterator for accessing the new registers added by this edit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:445,Energy Efficiency,allocate,allocate,445,"/// pop_back - It allows LiveRangeEdit users to drop new registers.; /// The context is when an original def instruction of a register is; /// dead after rematerialization, we still want to keep it for following; /// rematerializations. We save the def instruction in DeadRemats,; /// and replace the original dst register with a new dummy register so; /// the live range of original dst register can be shrinked normally.; /// We don't want to allocate phys register for the dummy register, so; /// we want to drop it from the NewRegs set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:94,Availability,avail,available,94,/// allUsesAvailableAt - Return true if all registers used by OrigMI at; /// OrigIdx are also available with the same value at UseIdx.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h:171,Deployability,update,updated,171,"/// rematerializeAt - Rematerialize RM.ParentVNI into DestReg by inserting an; /// instruction into MBB before MI. The new instruction is mapped, but; /// liveness is not updated. If ReplaceIndexMI is not null it will be replaced; /// by new MI in the index map.; /// Return the SlotIndex of the new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRangeEdit.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Performance,Cache,Cached,3,// Cached queries per register unit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:19,Availability,mask,mask,19,// Cached register mask interference info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:3,Performance,Cache,Cached,3,// Cached register mask interference info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:94,Integrability,interface,interface,94,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:298,Performance,cache,cached,298,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:438,Performance,cache,caches,438,//===--------------------------------------------------------------------===//; // High-level interface.; //===--------------------------------------------------------------------===//; //; // Check for interference before assigning virtual registers to physical; // registers.; //; /// Invalidate cached interference queries after modifying virtual register; /// live ranges. Interference checks may return stale information unless; /// caches are invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:166,Availability,avail,available,166,/// Assign VirtReg to PhysReg.; /// This will mark VirtReg's live range as occupied in the LiveRegMatrix and; /// update VirtRegMap. The live range is expected to be available in PhysReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:114,Deployability,update,update,114,/// Assign VirtReg to PhysReg.; /// This will mark VirtReg's live range as occupied in the LiveRegMatrix and; /// update VirtRegMap. The live range is expected to be available in PhysReg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:140,Deployability,update,updates,140,"/// Unassign VirtReg from its PhysReg.; /// Assuming that VirtReg was previously assigned to a PhysReg, this undoes; /// the assignment and updates VirtRegMap accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:109,Usability,undo,undoes,109,"/// Unassign VirtReg from its PhysReg.; /// Assuming that VirtReg was previously assigned to a PhysReg, this undoes; /// the assignment and updates VirtRegMap accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:93,Integrability,interface,interface,93,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // Provide access to the underlying LiveIntervalUnions.; //; /// Check for regmask interference only.; /// Return true if VirtReg crosses a regmask operand that clobbers PhysReg.; /// If PhysReg is null, check if VirtReg crosses any regmask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:200,Security,access,access,200,"//===--------------------------------------------------------------------===//; // Low-level interface.; //===--------------------------------------------------------------------===//; //; // Provide access to the underlying LiveIntervalUnions.; //; /// Check for regmask interference only.; /// Return true if VirtReg crosses a regmask operand that clobbers PhysReg.; /// If PhysReg is null, check if VirtReg crosses any regmask operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h:13,Security,access,access,13,/// Directly access the live interval unions per regunit.; /// This returns an array indexed by the regunit number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegMatrix.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:19,Usability,clear,clear,19,/// Initialize and clear the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:4,Usability,Clear,Clears,4,/// Clears the set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:98,Availability,Mask,Mask,98,/// Adds register units covered by physical register \p Reg that are; /// part of the lanemask \p Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:4,Deployability,Update,Updates,4,/// Updates liveness when stepping backwards over the instruction \p MI.; /// This removes all register units defined or clobbered in \p MI and then; /// adds the units used (as in use operands) in \p MI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h:61,Availability,mask,mask,61,/// Returns an iterator range over all physical register and mask operands for; /// \p MI and bundled instructions. This also skips any debug operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveRegUnits.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1077,Energy Efficiency,efficient,efficiently,1077,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:44,Modifiability,Variab,Variable,44,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:818,Modifiability,variab,variables,818,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:923,Modifiability,variab,variable,923,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1106,Modifiability,variab,variables,1106,"//===-- llvm/CodeGen/LiveVariables.h - Live Variable Analysis ---*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the LiveVariables analysis pass. For each machine; // instruction in the function, this pass calculates the set of registers that; // are immediately dead after the instruction (i.e., the instruction calculates; // the value, but it is never used) and the set of registers that are used by; // the instruction, but are never used after the instruction (i.e., they are; // killed).; //; // This class computes live variables using a sparse implementation based on; // the machine code SSA form. This class computes live variable information for; // each virtual and _register allocatable_ physical register in a function. It; // uses the dominance properties of SSA form to efficiently compute live; // variables for virtual registers, and assumes that physical registers are only; // live within a single basic block (allowing it to do a single local analysis; // to resolve physical register lifetimes in each basic block). If a physical; // register is not register allocatable, it is not tracked. This is useful for; // things like the stack pointer and condition codes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:498,Availability,Alive,AliveBlocks,498,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:653,Availability,Alive,AliveBlocks,653,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:728,Availability,Alive,AliveBlocks,728,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1274,Availability,Alive,AliveBlocks,1274,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:1498,Availability,Alive,AliveBlocks,1498,"/// VarInfo - This represents the regions where a virtual register is live in; /// the program. We represent this with three different pieces of; /// information: the set of blocks in which the instruction is live; /// throughout, the set of blocks in which the instruction is actually used,; /// and the set of non-phi instructions that are the last users of the value.; ///; /// In the common case where a value is defined and killed in the same block,; /// There is one killing instruction, and AliveBlocks is empty.; ///; /// Otherwise, the value is live out of the block. If the value is live; /// throughout any blocks, these blocks are listed in AliveBlocks. Blocks; /// where the liveness range ends are not included in AliveBlocks, instead; /// being captured by the Kills set. In these blocks, the value is live into; /// the block (unless the value is defined and killed in the same block) and; /// lives until the specified instruction. Note that there cannot ever be a; /// value whose Kills set contains two instructions from the same basic block.; ///; /// PHI nodes complicate things a bit. If a PHI node is the last user of a; /// value in one of its predecessor blocks, it is not listed in the kills set,; /// but does include the predecessor block in the AliveBlocks set (unless that; /// block also defines the value). This leads to the (perfectly sensical); /// situation where a value is defined in a block, and the last use is a phi; /// node in the successor. In this case, AliveBlocks is empty (the value is; /// not live across any blocks) and Kills is empty (phi nodes are not; /// included). This is sensical because the value must be live to the end of; /// the block, but is not live in any successor blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:4,Availability,Alive,AliveBlocks,4,/// AliveBlocks - Set of blocks in which this value is alive completely; /// through. This is a bit set which uses the basic block number as an; /// index.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:55,Availability,alive,alive,55,/// AliveBlocks - Set of blocks in which this value is alive completely; /// through. This is a bit set which uses the basic block number as an; /// index.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:78,Modifiability,variab,variable,78,/// VirtRegInfo - This list is a mapping from virtual register number to; /// variable information.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:74,Availability,Mask,Mask,74,/// HandleRegMask - Call HandlePhysRegKill for all registers clobbered by Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:109,Modifiability,variab,variable,109,"/// analyzePHINodes - Gather information about the PHI nodes in here. In; /// particular, we want to map the variable information of a virtual; /// register which is used in a PHI node. We map that to the BB the vreg; /// is coming from.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:90,Deployability,update,update,90,//===--------------------------------------------------------------------===//; // API to update live variable information; /// Recompute liveness from scratch for a virtual register \p Reg that is; /// known to have a single def that dominates all uses. This can be useful; /// after removing some uses of \p Reg. It is not necessary for the whole; /// machine function to be in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:102,Modifiability,variab,variable,102,//===--------------------------------------------------------------------===//; // API to update live variable information; /// Recompute liveness from scratch for a virtual register \p Reg that is; /// known to have a single def that dominates all uses. This can be useful; /// after removing some uses of \p Reg. It is not necessary for the whole; /// machine function to be in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:29,Deployability,Update,Update,29,/// replaceKillInstruction - Update register kill info by replacing a kill; /// instruction with a new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:103,Modifiability,variab,variable,103,"/// removeVirtualRegisterKilled - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked as killed by the specified instruction,; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:150,Modifiability,variab,variable,150,"/// removeVirtualRegisterKilled - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked as killed by the specified instruction,; /// false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:101,Modifiability,variab,variable,101,"/// removeVirtualRegisterDead - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked dead at the specified instruction, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:148,Modifiability,variab,variable,148,"/// removeVirtualRegisterDead - Remove the specified kill of the virtual; /// register from the live variable information. Returns true if the; /// variable was marked dead at the specified instruction, false; /// otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h:78,Modifiability,variab,variables,78,/// addNewBlock - Add a new basic block BB between DomBB and SuccBB. All; /// variables that are live out of DomBB and live into SuccBB will be marked; /// as passing live through BB. This method assumes that the machine code is; /// still in SSA form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LiveVariables.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:647,Energy Efficiency,efficient,efficient,647,"//==------ llvm/CodeGen/LoopTraversal.h - Loop Traversal -*- C++ -*---------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Loop Traversal logic.; ///; /// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:405,Testability,log,logic,405,"//==------ llvm/CodeGen/LoopTraversal.h - Loop Traversal -*- C++ -*---------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Loop Traversal logic.; ///; /// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:353,Deployability,update,update,353,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:971,Deployability,update,update,971,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:229,Energy Efficiency,efficient,efficient,229,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:835,Performance,Optimiz,Optimized,835,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1777,Performance,optimiz,optimized,1777,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1799,Safety,avoid,avoid,1799,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:398,Usability,clear,clearance,398,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:443,Usability,clear,clearance,443,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:482,Usability,clear,clearances,482,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1347,Usability,clear,clearances,1347,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:1388,Usability,clear,clearance,1388,"/// This class provides the basic blocks traversal order used by passes like; /// ReachingDefAnalysis and ExecutionDomainFix.; /// It identifies basic blocks that are part of loops and should to be visited; /// twice and returns efficient traversal order for all the blocks.; ///; /// We want to visit every instruction in every basic block in order to update; /// it's execution domain or collect clearance information. However, for the; /// clearance calculation, we need to know clearances from all predecessors; /// (including any backedges), therfore we need to visit some blocks twice.; /// As an example, consider the following loop.; ///; ///; /// PH -> A -> B (xmm<Undef> -> xmm<Def>) -> C -> D -> EXIT; /// ^ |; /// +----------------------------------+; ///; /// The iteration order this pass will return is as follows:; /// Optimized: PH A B C A' B' C' D; ///; /// The basic block order is constructed as follows:; /// Once we finish processing some block, we update the counters in MBBInfos; /// and re-process any successors that are now 'done'.; /// We call a block that is ready for its final round of processing `done`; /// (isBlockDone), e.g. when all predecessor information is known.; ///; /// Note that a naive traversal order would be to do two complete passes over; /// all basic blocks/instructions, the first for recording clearances, the; /// second for updating clearance based on backedges.; /// However, for functions without backedges, or functions with a lot of; /// straight-line code, and a small loop, that would be a lot of unnecessary; /// work (since only the BBs that are part of the loop require two passes).; ///; /// E.g., the naive iteration order for the above exmple is as follows:; /// Naive: PH A B C D A' B' C' D'; ///; /// In the optimized approach we avoid processing D twice, because we; /// can entirely process the predecessors before getting to D.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h:99,Energy Efficiency,efficient,efficient,99,/// Identifies basic blocks that are part of loops and should to be; /// visited twice and returns efficient traversal order for all the blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LoopTraversal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h:414,Modifiability,variab,variables,414,"//==------ llvm/CodeGen/LowerEmuTLS.h -------------------------*- C++ -*----==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file Add Add __emutls_[vt].* variables.; ///; /// This file provide declaration of LowerEmuTLSPass.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowerEmuTLS.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:99,Usability,simpl,simple,99,/// Get a 16-bit IEEE half value.; /// TODO: Add IEEE semantics to type - This currently returns a simple `scalar(16)`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,Performance,scalab,scalable,20,/// Get a low-level scalable vector of some number of elements and element; /// width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:20,Performance,scalab,scalable,20,/// Get a low-level scalable vector of some number of elements and element; /// type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,Performance,scalab,scalable,33,/// Returns true if the LLT is a scalable vector. Must only be called on; /// vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:33,Performance,scalab,scalable,33,"/// Returns true if the LLT is a scalable vector. Returns false otherwise,; /// even if the LLT is not a vector type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:51,Energy Efficiency,Reduce,Reduces,51,"/// Return a type that is \p Factor times smaller. Reduces the number of; /// elements if this is a vector, or the bitwidth for scalar/pointers. Does; /// not attempt to handle cases that aren't evenly divisible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:219,Modifiability,portab,portable,219,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:357,Modifiability,variab,variables,357,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:382,Modifiability,variab,variables,382,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:212,Usability,simpl,simple,212,"/// LLT is packed into 64 bits as follows:; /// isScalar : 1; /// isPointer : 1; /// isVector : 1; /// with 61 bits remaining for Kind-specific data, packed in bitfields; /// as described below. As there isn't a simple portable way to pack bits; /// into bitfields, here the different fields in the packed structure is; /// described in static const *Field variables. Each of these variables; /// is a 2-element array, with the first element describing the bitfield size; /// and the second element describing the bitfield offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:114,Performance,Scalab,Scalable,114,/// * Vector-of-non-pointer (isPointer == 0 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 32;; /// Scalable: 1;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h:133,Performance,Scalab,Scalable,133,/// * Vector-of-pointer (isPointer == 1 && isVector == 1):; /// NumElements: 16;; /// SizeOfElement: 16;; /// AddressSpace: 24;; /// Scalable: 1;,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelType.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h:118,Testability,assert,assert,118,"/// Get a rough equivalent of an LLT for a given MVT. LLT does not yet support; /// scalarable vector types, and will assert if used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/LowLevelTypeUtils.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:39,Availability,mask,mask,39,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:62,Usability,simpl,simply,62,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:130,Usability,clear,clearly,130,/// Pair of physical register and lane mask.; /// This is not simply a std::pair typedef because the members should be named; /// clearly as they both have an integer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:154,Performance,optimiz,optimization,154,"/// Keep track of the probabilities to the successors. This vector has the; /// same order as Successors, or it is empty if we don't use it (disable; /// optimization).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:105,Performance,cache,cached,105,"/// since getSymbol is a relatively heavy-weight operation, the symbol; /// is only computed once and is cached.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Performance,Cache,Cached,4,/// Cached MCSymbol for this block (used if IsEHCatchRetTarget).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:26,Energy Efficiency,allocate,allocated,26,// MachineBasicBlocks are allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,"/// Test whether this block is used as something other than the target; /// of a terminator, exception-handling target, or jump table. This is; /// either the result of an IR-level ""blockaddress"", or some form; /// of target-specific branch lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:191,Performance,load,loaded,191,"/// Test whether this block is used as something other than the target of a; /// terminator, exception-handling target, jump table, or IR blockaddress.; /// For example, its address might be loaded into a register, or; /// stored in some branch table that isn't part of MachineJumpTableInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,"/// Test whether this block is used as something other than the target of a; /// terminator, exception-handling target, jump table, or IR blockaddress.; /// For example, its address might be loaded into a register, or; /// stored in some branch table that isn't part of MachineJumpTableInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,/// Test whether this block is the target of an IR BlockAddress. (There can; /// more than one MBB associated with an IR BB where the address is taken.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Testability,Test,Test,4,/// Test whether this block must have its label emitted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:96,Availability,error,error,96,// LiveIn management methods.; /// Adds the specified register as a live in. Note that it is an error to add; /// the same register to the same set more than once unless the intention is; /// to call sortUniqueLiveIns after all registers are added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Usability,Clear,Clear,4,/// Clear live in list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:176,Testability,assert,assert,176,"/// Unlike livein_begin, this method does not check that the liveness; /// information is accurate. Still for debug purposes it may be useful; /// to have iterators that won't assert if the liveness information; /// is not current.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,Availability,mask,mask,20,/// Get the clobber mask for the start of this basic block. Funclets use this; /// to prevent register allocation across funclet transitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:20,Availability,mask,mask,20,/// Get the clobber mask for the end of the basic block.; /// \see getBeginClobberMask(),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Deployability,Update,Update,4,"/// Update the terminator instructions in block to account for changes to; /// block layout which may have been made. PreviousLayoutSuccessor should be; /// set to the block which may have been used as fallthrough before the block; /// layout was modified. If the block previously fell through to that block,; /// it may now need a branch. If it previously branched to another block, it; /// may now be able to fallthrough to the current layout successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:132,Deployability,update,updated,132,"// Machine-CFG mutators; /// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. PROB parameter is stored in; /// Probabilities list. The default probability is set as unknown. Mixing; /// known and unknown probabilities in successor list is not allowed. When all; /// successors have unknown probabilities, 1 / N is returned as the; /// probability for each successor, where N is the number of successors.; ///; /// Note that duplicate Machine CFG edges are not allowed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:172,Availability,avail,available,172,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:107,Deployability,update,updated,107,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:266,Integrability,interface,interface,266,"/// Add Succ as a successor of this MachineBasicBlock. The Predecessors list; /// of Succ is automatically updated. The probability is not provided because; /// BPI is not available (e.g. -O0 is used), in which case edge probabilities; /// won't be used. Using this interface can save some space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:126,Deployability,update,update,126,"/// Normalize probabilities of all successors so that the sum of them becomes; /// one. This is usually done when the current update on this MBB is done, and; /// the sum of its successors' probabilities is not guaranteed to be one. The; /// user is responsible for the correct use of this function.; /// MBB::removeSuccessor() has an option to do this automatically.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Security,Validat,Validate,4,/// Validate successors' probabilities and check if the sum of them is; /// approximate one. This only works in DEBUG mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:125,Deployability,update,updated,125,"/// Remove successor from the successors list of this MachineBasicBlock. The; /// Predecessors list of Succ is automatically updated.; /// If NormalizeSuccProbs is true, then normalize successors' probabilities; /// after the successor is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:135,Deployability,update,updated,135,"/// Remove specified successor from the successors list of this; /// MachineBasicBlock. The Predecessors list of Succ is automatically updated.; /// If NormalizeSuccProbs is true, then normalize successors' probabilities; /// after the successor is removed.; /// Return the iterator to the element after the one removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:39,Deployability,update,update,39,/// Replace successor OLD with NEW and update probability info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:50,Deployability,update,updates,50,/// Split the old successor into old plus new and updates the probability; /// info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:64,Deployability,update,update,64,"/// Transfers all the successors, as in transferSuccessors, and update PHI; /// operands in the successor blocks which refer to FromMBB to refer to this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:424,Performance,optimiz,optimizing,424,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:547,Performance,optimiz,optimizations,547,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:591,Performance,optimiz,optimizations,591,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:810,Performance,optimiz,optimizations,810,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:898,Performance,optimiz,optimizations,898,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:343,Safety,avoid,avoid,343,"/// Returns an iterator to the first non-debug instruction in the basic block,; /// or end(). Skip any pseudo probe operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:417,Performance,optimiz,optimizing,417,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:540,Performance,optimiz,optimizations,540,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:584,Performance,optimiz,optimizations,584,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:803,Performance,optimiz,optimizations,803,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:891,Performance,optimiz,optimizations,891,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:336,Safety,avoid,avoid,336,"/// Returns an iterator to the last non-debug instruction in the basic block,; /// or end(). Skip any pseudo operation if \c SkipPseudoOp is true.; /// Pseudo probes are like debug instructions which do not turn into real; /// machine code. We try to use the function to skip both debug instructions; /// and pseudo probe operations to avoid API proliferation. This should work; /// most of the time when considering optimizing the rest of code in the; /// block, except for certain cases where pseudo probes are designed to block; /// the optimizations. For example, code merge like optimizations are supposed; /// to be blocked by pseudo probes for better AutoFDO profile quality.; /// Therefore, they should be considered as a valid instruction when this; /// function is called in a context of such optimizations. On the other hand,; /// \c SkipPseudoOp should be true when it's used in optimizations that; /// unlikely hurt profile quality, e.g., without block merging. The default; /// value of \c SkipPseudoOp is set to true to maximize code quality in; /// general, with an explict false value passed in in a few places like branch; /// folding and if-conversion to favor profile quality.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:275,Deployability,update,updated,275,"/// Split a basic block into 2 pieces at \p SplitPoint. A new block will be; /// inserted after this block, and all instructions after \p SplitInst moved; /// to it (\p SplitInst will be in the original block). If \p LIS is provided,; /// LiveIntervals will be appropriately updated. \return the newly inserted; /// block.; ///; /// If \p UpdateLiveIns is true, this will ensure the live ins list is; /// accurate, including for physreg uses/defs in the original block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:339,Deployability,Update,UpdateLiveIns,339,"/// Split a basic block into 2 pieces at \p SplitPoint. A new block will be; /// inserted after this block, and all instructions after \p SplitInst moved; /// to it (\p SplitInst will be in the original block). If \p LIS is provided,; /// LiveIntervals will be appropriately updated. \return the newly inserted; /// block.; ///; /// If \p UpdateLiveIns is true, this will ensure the live ins list is; /// accurate, including for physreg uses/defs in the original block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:177,Deployability,update,updates,177,"/// Split the critical edge from this block to the given successor block, and; /// return the newly created block, or null if splitting is not possible.; ///; /// This function updates LiveVariables, MachineDominatorTree, and; /// MachineLoopInfo, as applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:354,Availability,reliab,reliable,354,"/// Insert MI into the instruction list before I, possibly inside a bundle.; ///; /// If the insertion point is inside a bundle, MI will be added to the bundle,; /// otherwise MI will not be added to any bundle. That means this function; /// alone can't be used to prepend or append instructions to bundles. See; /// MIBundleBuilder::insert() for a more reliable way of doing that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:4,Deployability,Update,Update,4,/// Update all phi nodes in this basic block to refer to basic block \p New; /// instead of basic block \p Old.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:23,Availability,avail,available,23,///< Add IR name where available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:155,Deployability,update,update,155,"// Machine-CFG mutators; /// Add Pred as a predecessor of this MachineBasicBlock. Don't do this; /// unless you know what you're doing, because it doesn't update Pred's; /// successors list. Use Pred->addSuccessor instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:133,Deployability,update,update,133,"/// Remove Pred as a predecessor of this MachineBasicBlock. Don't do this; /// unless you know what you're doing, because it doesn't update Pred's; /// successors list. Use Pred->removeSuccessor instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:9,Security,access,accessors,9,// These accessors are handy for sharing templated code between IR and MIR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h:33,Integrability,interface,interface,33,"/// MachineInstrSpan provides an interface to get an iteration range; /// containing the instruction it was initialized with, along with all; /// those instructions inserted prior to or following that instruction; /// at some point after the MachineInstrSpan is constructed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBasicBlock.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:399,Usability,simpl,simplified,399,"//===- MachineBlockFrequencyInfo.h - MBB Frequency Analysis -----*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loops should be simplified before this analysis.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:281,Safety,avoid,avoid,281,"/// getblockFreq - Return block frequency. Return 0 if we don't have the; /// information. Please note that initial frequency is equal to 1024. It means; /// that we should not rely on the value itself, but only on the comparison to; /// the other block frequencies. We do this to avoid using of floating points.; /// For example, to get the frequency of a block relative to the entry block,; /// divide the integral value returned by this function (the; /// BlockFrequency::getFrequency() value) by getEntryFreq().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h:70,Safety,avoid,avoid,70,"/// incrementally calculate block frequencies when we split edges, to avoid; /// full CFG traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBlockFrequencyInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h:407,Modifiability,inherit,inherit,407,"// Default weight value. Used when we don't have information about the edge.; // TODO: DEFAULT_WEIGHT makes sense during static predication, when none of; // the successors have a weight yet. But it doesn't make sense when providing; // weight to an edge that may have siblings with non-zero weights. This can; // be handled various ways, but it's probably fine for an edge with unknown; // weight to just ""inherit"" the non-zero weight of an adjacent successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h:108,Availability,avail,available,108,"// Same as above, but using a const_succ_iterator from Src. This is faster; // when the iterator is already available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineBranchProbabilityInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Energy Efficiency,Power,PowerPC,37,// These are patterns matched by the PowerPC to reassociate FMA chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:37,Energy Efficiency,Power,PowerPC,37,// These are patterns matched by the PowerPC to reassociate FMA and FSUB to; // reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:80,Energy Efficiency,reduce,reduce,80,// These are patterns matched by the PowerPC to reassociate FMA and FSUB to; // reduce register pressure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:30,Energy Efficiency,reduce,reduce,30,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h:51,Integrability,depend,dependence,51,// These are patterns used to reduce the length of dependence chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCombinerPattern.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h:136,Integrability,wrap,wrapper,136,"/// isMachineConstantPoolEntry - Return true if the MachineConstantPoolEntry; /// is indeed a target specific constantpool entry, not a wrapper over a; /// Constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineConstantPool.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h:445,Integrability,wrap,wrapper,445,"//===- MachineCycleAnalysis.h - Cycle Info for Machine IR -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MachineCycleInfo class, which is a thin wrapper over; // the Machine IR instance of GenericCycleInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineCycleAnalysis.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:63,Deployability,update,updates,63,/// Apply all the recorded critical edges to the DT.; /// This updates the underlying DT information in a way that uses; /// the fast query path of DT as much as possible.; ///; /// \post CriticalEdgesToSplit.empty().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:50,Performance,perform,performs,50,// dominates - Return true if A dominates B. This performs the; // special checks necessary if A and B are in the same basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:54,Deployability,update,update,54,/// changeImmediateDominator - This method is used to update the dominator; /// tree information when a node's immediate dominator changes.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:59,Deployability,Update,Update,59,/// splitBlock - BB is split and now it has one successor. Update dominator; /// tree to reflect this change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:138,Deployability,update,update,138,"/// Record that the critical edge (FromBB, ToBB) has been; /// split with NewBB.; /// This is best to use this method instead of directly update the; /// underlying information, because this helps mitigating the; /// number of time the DT information is invalidated.; ///; /// \note Do not use this method with regular edges.; ///; /// \note To benefit from the compile time improvement incurred by this; /// method, the users of this method have to limit the queries to the DT; /// interface between two edges splitting. In other words, they have to; /// pack the splitting of critical edges as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h:483,Integrability,interface,interface,483,"/// Record that the critical edge (FromBB, ToBB) has been; /// split with NewBB.; /// This is best to use this method instead of directly update the; /// underlying information, because this helps mitigating the; /// number of time the DT information is invalidated.; ///; /// \note Do not use this method with regular edges.; ///; /// \note To benefit from the compile time improvement incurred by this; /// method, the users of this method have to limit the queries to the DT; /// interface between two edges splitting. In other words, they have to; /// pack the splitting of critical edges as much as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineDominators.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:326,Performance,load,loaded,326,"/// Flag indicating whether the register is actually restored in the epilog.; /// In most cases, if a register is saved, it is also restored. There are; /// some situations, though, when this is not the case. For example, the; /// LR register on ARM is usually saved, but on exit from the function its; /// saved value may be loaded directly into PC. Since liveness tracking of; /// physical registers treats callee-saved registers are live outside of; /// the function, LR would be treated as live-on-exit, even though in these; /// scenarios it is not. This flag is added to indicate that the saved; /// register described by this object is not restored in the epilog.; /// The long-term solution is to model the liveness of callee-saved registers; /// by implicit uses on the return instructions, however, the required; /// changes in the ARM backend would be quite extensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:3,Security,Access,Accessors,3,// Accessors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:879,Energy Efficiency,allocate,allocated,879,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:854,Modifiability,variab,variable,854,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1071,Modifiability,variab,variable,1071,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1145,Modifiability,variab,variable,1145,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1227,Modifiability,variab,variable,1227,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1346,Modifiability,variab,variable,1346,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:171,Performance,optimiz,optimizations,171,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:276,Performance,optimiz,optimizations,276,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1004,Performance,optimiz,optimization,1004,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1422,Performance,perform,performed,1422,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:1181,Safety,safe,safe,1181,"/// The MachineFrameInfo class represents an abstract stack frame until; /// prolog/epilog code is inserted. This class is key to allowing stack frame; /// representation optimizations, such as frame pointer elimination. It also; /// allows more mundane (but still important) optimizations, such as reordering; /// of abstract objects on the stack frame.; ///; /// To support this, the class assigns unique integer identifiers to stack; /// objects requested clients. These identifiers are negative integers for; /// fixed stack objects (such as arguments passed on the stack) or nonnegative; /// for objects that may be reordered. Instructions which refer to stack; /// objects use a special MO_FrameIndex operand to represent these frame; /// indexes.; ///; /// Because this class keeps track of all references to the stack frame, it; /// knows when a variable sized object is allocated on the stack. This is the; /// sole condition which prevents frame pointer elimination, which is an; /// important optimization on register-poor architectures. Because original; /// variable sized alloca's in the source program are the only source of; /// variable sized stack objects, it is safe to decide whether there will be; /// any variable sized objects before all stack objects are known (for; /// example, register allocator spill code never needs variable sized; /// objects).; ///; /// When prolog/epilog code emission is performed, the final stack frame is; /// built and the machine instructions are modified to refer to the actual; /// stack offsets of the object, eliminating all MO_FrameIndex operands from; /// the program.; ///; /// Abstract Stack Frame Information",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:39,Security,expose,exposed,39,///< The address of this allocation is exposed and; ///< triggered protection. 3rd closest to the protector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:29,Energy Efficiency,allocate,allocated,29,// Represent a single object allocated on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:114,Modifiability,variab,variable,114,// The offset of this object from the stack pointer on entry to; // the function. This field has no meaning for a variable sized element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:51,Modifiability,variab,variable,51,"// The size of this object on the stack. 0 means a variable sized object,; // ~0ULL means a dead object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:176,Energy Efficiency,Power,PowerPC,176,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:123,Security,access,accessible,123,"// If true, an LLVM IR value might point to this object.; // Normally, spill slots and fixed-offset objects don't alias IR-accessible; // objects, but there are exceptions (on PowerPC, for example, some byval; // arguments have ABI-prescribed offsets).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Modifiability,extend,extended,38,"/// If true, the object has been zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Modifiability,extend,extended,38,"/// If true, the object has been sign-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:590,Energy Efficiency,allocate,allocate,590,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:696,Performance,optimiz,optimization,696,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:653,Security,access,access,653,"/// Can the stack be realigned. This can be false if the target does not; /// support stack realignment, or if the user asks us not to realign the; /// stack. In this situation, overaligned allocas are all treated as dynamic; /// allocations and the target must handle them as part of DYNAMIC_STACKALLOC; /// lowering. All non-alloca stack objects have their alignment clamped to the; /// base ABI stack alignment.; /// FIXME: There is room for improvement in this case, in terms of; /// grouping overaligned allocas into a ""secondary stack frame"" and; /// then only use a single alloca to allocate this frame and only a; /// single virtual register to access it. Currently, without such an; /// optimization, each such alloca gets its own dynamic realignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:30,Energy Efficiency,allocate,allocated,30,/// The list of stack objects allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:82,Energy Efficiency,allocate,allocated,82,/// This boolean keeps track of whether any variable; /// sized objects have been allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:44,Modifiability,variab,variable,44,/// This boolean keeps track of whether any variable; /// sized objects have been allocated yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:92,Deployability,patch,patchpoint,92,/// This boolean keeps track of whether there is a call; /// to builtin \@llvm.experimental.patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:157,Deployability,update,updates,157,"/// The prolog/epilog code inserter calculates the final stack; /// offsets for all of the fixed size objects, updating the Objects list; /// above. It then updates StackSize to contain the number of bytes that need; /// to be allocated on entry to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:227,Energy Efficiency,allocate,allocated,227,"/// The prolog/epilog code inserter calculates the final stack; /// offsets for all of the fixed size objects, updating the Objects list; /// above. It then updates StackSize to contain the number of bytes that need; /// to be allocated on entry to the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:156,Integrability,depend,dependent,156,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:619,Performance,perform,performed,619,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:273,Security,access,accessed,273,"/// The amount that a frame offset needs to be adjusted to; /// have the actual offset from the stack/frame pointer. The exact usage of; /// this is target-dependent, but it is typically used to adjust between; /// SP-relative and FP-relative offsets. E.G., if objects are accessed via; /// SP then OffsetAdjustment is zero; if FP is used, OffsetAdjustment is set; /// to the distance between the initial SP and the value in FP. For many; /// targets, this value is only used when generating debug info (via; /// TargetRegisterInfo::getFrameIndexReference); when generating code, the; /// corresponding adjustments are performed directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:20,Energy Efficiency,allocate,allocated,20,/// Size of the pre-allocated local frame block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:46,Energy Efficiency,allocate,allocated,46,"/// Whether the local object blob needs to be allocated together. If not,; /// PEI should ignore the isPreAllocated flags on the stack objects and; /// just allocate them normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:157,Energy Efficiency,allocate,allocate,157,"/// Whether the local object blob needs to be allocated together. If not,; /// PEI should ignore the isPreAllocated flags on the stack objects and; /// just allocate them normally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,Availability,down,down,62,/// True if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:24,Integrability,wrap,wrapping,24,"/// Not null, if shrink-wrapping found a better place for the prologue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:24,Integrability,wrap,wrapping,24,"/// Not null, if shrink-wrapping found a better place for the epilogue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:16,Safety,Unsafe,UnsafeStack,16,/// Size of the UnsafeStack Frame,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:152,Modifiability,variab,variable,152,/// This method may be called any time after instruction; /// selection is complete to determine if the stack frame for this function; /// contains any variable sized objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:152,Deployability,patch,patchpoint,152,/// This method may be called any time after instruction; /// selection is complete to determine if there is a call to builtin; /// \@llvm.experimental.patchpoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:485,Availability,error,error,485,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:530,Availability,failure,failures,530,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:547,Availability,error,errors,547,"/// Return true if this function requires a split stack prolog, even if it; /// uses no stack space. This is only meaningful for functions where; /// MachineFunction::shouldSplitStack() returns true.; //; // For non-leaf functions we have to allow for the possibility that the call; // is to a non-split function, as in PR37807. This function could also take; // the address of a non-split function. When the linker tries to adjust its; // non-existent prologue, it would fail with an error. Mark the object file so; // that such failures are not errors. See this Go language bug-report; // https://go-review.googlesource.com/c/go/+/148819/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:33,Energy Efficiency,allocate,allocated,33,/// Return the number of objects allocated into the local object block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:52,Energy Efficiency,allocate,allocated,52,/// Get whether the local allocation blob should be allocated together or; /// let PEI allocate the locals in it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:87,Energy Efficiency,allocate,allocate,87,/// Get whether the local allocation blob should be allocated together or; /// let PEI allocate the locals in it directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:91,Energy Efficiency,allocate,allocated,91,/// setUseLocalStackAllocationBlock - Set whether the local allocation blob; /// should be allocated together or let PEI allocate the locals in it; /// directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:121,Energy Efficiency,allocate,allocate,121,/// setUseLocalStackAllocationBlock - Set whether the local allocation blob; /// should be allocated together or let PEI allocate the locals in it; /// directly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:38,Energy Efficiency,allocate,allocated,38,/// Return true if the object was pre-allocated into the local block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:49,Performance,scalab,scalable,49,// Only ensure max alignment for the default and scalable vector stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:44,Energy Efficiency,allocate,allocated,44,/// Return the number of bytes that must be allocated to hold; /// all of the fixed size frame objects. This is only valid after; /// Prolog/Epilog code insertion has finalized the stack frame layout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:70,Availability,down,down,70,/// Returns true if the function contains operations which will lower down to; /// instructions which manipulate the stack pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:116,Availability,avail,available,116,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:62,Energy Efficiency,allocate,allocated,62,"/// Return the maximum size of a call frame that must be; /// allocated for an outgoing function call. This is only available if; /// CallFrameSetup/Destroy pseudo instructions are used by the target, and; /// then only during or after prolog/epilog code insertion.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:21,Testability,assert,assert,21,"// TODO: Enable this assert when targets are fixed.; //assert(isMaxCallFrameSizeComputed() && ""MaxCallFrameSize not computed yet"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:55,Testability,assert,assert,55,"// TODO: Enable this assert when targets are fixed.; //assert(isMaxCallFrameSizeComputed() && ""MaxCallFrameSize not computed yet"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:104,Deployability,update,updated,104,"// If ID > 0, MaxAlignment may now be overly conservative.; // If ID == 0, MaxAlignment will need to be updated separately.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:57,Modifiability,variab,variable,57,/// Returns true if the specified index corresponds to a variable sized; /// object.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:46,Modifiability,variab,variable,46,"/// Notify the MachineFrameInfo object that a variable sized object has been; /// created. This must be created whenever a variable sized object is; /// created, whether or not the index returned is actually used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h:123,Modifiability,variab,variable,123,"/// Notify the MachineFrameInfo object that a variable sized object has been; /// created. This must be created whenever a variable sized object is; /// created, whether or not the index returned is actually used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFrameInfo.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:177,Security,access,accessed,177,/// MachineFunctionInfo - This class can be derived from and used by targets to; /// hold private target-specific information for each MachineFunction. Objects; /// of type are accessed/created with MF::getInfo and destroyed when the; /// MachineFunction is destroyed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,extend,extend,35,"// Possible TODO: Allow targets to extend this (perhaps by allowing the; // constructor to specify the size of the bit vector); // Possible TODO: Allow requiring the negative (e.g. VRegsAllocated could be; // stated as the negative of ""has vregs""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:969,Availability,reliab,reliable,969,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:2635,Deployability,pipeline,pipeline,2635,"y not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it; // means that tied-def have been rewritten to meet the RegConstraint.; // FailsVerification: Means that the function is not expected to pass machine; // verification. This can be set by passes that introduce known problems that; // have not been fixed yet.; // TracksDebugUserValues: Without this property enabled, debug instructions; // such as DBG_VALUE are allowed to reference virtual registers even if those; // registers do not have a definition. With the property enabled virtual; // registers must only be used if they have a definition. This property; // allows earlier passes in the pipeline to skip updates of `DBG_VALUE`; // instructions to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:2652,Deployability,update,updates,2652,"y not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddressinstruction pass will set this flag, it; // means that tied-def have been rewritten to meet the RegConstraint.; // FailsVerification: Means that the function is not expected to pass machine; // verification. This can be set by passes that introduce known problems that; // have not been fixed yet.; // TracksDebugUserValues: Without this property enabled, debug instructions; // such as DBG_VALUE are allowed to reference virtual registers even if those; // registers do not have a definition. With the property enabled virtual; // registers must only be used if they have a definition. This property; // allows earlier passes in the pipeline to skip updates of `DBG_VALUE`; // instructions to save compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:914,Usability,clear,cleared,914,"// The properties are stated in ""positive"" form; i.e. a pass could require; // that the property hold, but not that it does not hold.; // Property descriptions:; // IsSSA: True when the machine function is in SSA form and virtual registers; // have a single def.; // NoPHIs: The machine function does not contain any PHI instruction.; // TracksLiveness: True when tracking register liveness accurately.; // While this property is set, register liveness information in basic block; // live-in lists and machine instruction operands (e.g. implicit defs) is; // accurate, kill flags are conservatively accurate (kill flag correctly; // indicates the last use of a register, an operand without kill flag may or; // may not be the last use of a register). This means it can be used to; // change the code in ways that affect the values in registers, for example; // by the register scavenger.; // When this property is cleared at a very late time, liveness is no longer; // reliable.; // NoVRegs: The machine function does not use any virtual registers.; // Legalized: In GlobalISel: the MachineLegalizer ran and all pre-isel generic; // instructions have been legalized; i.e., all instructions are now one of:; // - generic and always legal (e.g., COPY); // - target-specific; // - legal pre-isel generic instructions.; // RegBankSelected: In GlobalISel: the RegBankSelect pass ran and all generic; // virtual registers have been assigned to a register bank.; // Selected: In GlobalISel: the InstructionSelect pass ran and all pre-isel; // generic instructions have been eliminated; i.e., all instructions are now; // target-specific or non-pre-isel generic instructions (e.g., COPY).; // Since only pre-isel generic instructions can have generic virtual register; // operands, this also means that all generic virtual registers have been; // constrained to virtual registers (assigned to register classes) and that; // all sizes attached to them have been eliminated.; // TiedOpsRewritten: The twoaddress",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Availability,recover,recover,24,/// Address of block to recover at. Null for a finally handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Safety,recover,recover,24,/// Address of block to recover at. Null for a finally handler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,Energy Efficiency,allocate,allocated,25,// Keep track of objects allocated on the stack.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:8,Energy Efficiency,allocate,allocate,8,// Pool-allocate MachineFunction-lifetime and IR objects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,Performance,optimiz,optimizations,189,"/// ExposesReturnsTwice - True if the function calls setjmp or related; /// functions with attribute ""returns twice"", but doesn't have; /// the attribute itself.; /// This is used to limit optimizations which cannot reason; /// about the control flow of such functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Security,Expose,ExposesReturnsTwice,4,"/// ExposesReturnsTwice - True if the function calls setjmp or related; /// functions with attribute ""returns twice"", but doesn't have; /// the attribute itself.; /// This is used to limit optimizations which cannot reason; /// about the control flow of such functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:117,Energy Efficiency,allocate,allocated,117,/// Current high-level properties of the IR of the function (e.g. is in SSA; /// form or whether registers have been allocated),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:184,Energy Efficiency,allocate,allocated,184,"/// \}; /// Clear all the members of this MachineFunction, but the ones used; /// to initialize again the MachineFunction.; /// More specifically, this deallocates all the dynamically allocated; /// objects and get rid of all the XXXInfo data structure, but keep; /// unchanged the references to Fn, Target, MMI, and FunctionNumber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:12,Usability,Clear,Clear,12,"/// \}; /// Clear all the members of this MachineFunction, but the ones used; /// to initialize again the MachineFunction.; /// More specifically, this deallocates all the dynamically allocated; /// objects and get rid of all the XXXInfo data structure, but keep; /// unchanged the references to Fn, Target, MMI, and FunctionNumber.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate and initialize the different members.; /// In particular, the XXXInfo data structure.; /// \pre Fn, Target, MMI, and FunctionNumber are properly set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:37,Modifiability,variab,variable,37,"/// Description of the location of a variable whose Address is valid and; /// unchanging during function execution. The Address may be:; /// * A stack index, which can be negative for fixed stack objects.; /// * A MCRegister, whose entry value contains the address of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:272,Modifiability,variab,variable,272,"/// Description of the location of a variable whose Address is valid and; /// unchanging during function execution. The Address may be:; /// * A stack index, which can be negative for fixed stack objects.; /// * A MCRegister, whose entry value contains the address of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Modifiability,variab,variable,24,/// Return true if this variable is in a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Modifiability,variab,variable,24,/// Return true if this variable is in the entry value of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Returns the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Returns the MCRegister of this variable, assuming; /// `inEntryValueRegister()` is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Deployability,Update,Updates,4,"/// Updates the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,"/// Updates the stack slot of this variable, assuming `inStackSlot()` is; /// true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:14,Security,access,accessed,14,// Need to be accessed from MachineInstr::setDesc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:49,Safety,Avoid,Avoid,49,/// Set value of DebugInstrNumberingCount field. Avoid using this unless; /// you're deserializing this data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,Availability,recover,recovery,217,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:234,Modifiability,variab,variable,234,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:217,Safety,recover,recovery,217,"/// Debug value substitutions: a collection of DebugSubstitution objects,; /// recording changes in where a value is defined. For example, when one; /// instruction is substituted for another. Keeping a record allows recovery; /// of variable locations after compilation finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:233,Availability,mainten,maintenance,233,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:60,Modifiability,variab,variable,60,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:122,Performance,Load,Loaded,122,"/// Location of a PHI instruction that is also a debug-info variable value,; /// for the duration of register allocation. Loaded by the PHI-elimination; /// pass, and emitted as DBG_PHI instructions during VirtRegRewriter, with; /// maintenance applied by intermediate passes that edit registers (such as; /// coalescing and the allocator passes).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:131,Performance,optimiz,optimization,131,"/// Create substitutions for any tracked values in \p Old, to point at; /// \p New. Needed when we re-create an instruction during optimization,; /// which has the same signature (i.e., def operands in the same place) but; /// a modified instruction type, flags, or otherwise. An example: X86 moves; /// are sometimes transformed into equivalent LEAs.; /// If the two instructions are not the same opcode, limit which operands to; /// examine for substitutions to the first N operands by setting; /// \p MaxOperand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:673,Performance,cache,cache,673,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:256,Safety,avoid,avoided,256,"/// Find the underlying defining instruction / operand for a COPY instruction; /// while in SSA form. Copies do not actually define values -- they move them; /// between registers. Labelling a COPY-like instruction with an instruction; /// number is to be avoided as it makes value numbers non-unique later in; /// compilation. This method follows the definition chain for any sequence of; /// COPY-like instructions to find whatever non-COPY-like instruction defines; /// the copied value; or for parameters, creates a DBG_PHI on entry.; /// May insert instructions into the entry block!; /// \p MI The copy-like instruction to salvage.; /// \p DbgPHICache A container to cache already-solved COPYs.; /// \returns An instruction/operand pair identifying the defining value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:46,Deployability,configurat,configuration,46,"/// Determine whether, in the current machine configuration, we should use; /// instruction referencing or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:46,Modifiability,config,configuration,46,"/// Determine whether, in the current machine configuration, we should use; /// instruction referencing or not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:35,Modifiability,variab,variable,35,/// Returns true if the function's variable locations are tracked with; /// instruction referencing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:56,Testability,assert,assert,56,/// Reset the currently registered delegate - otherwise assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:126,Energy Efficiency,allocate,allocated,126,/// getFrameInfo - Return the frame info object for the current function.; /// This object contains information about objects allocated on the stack; /// frame of the current function in an abstract way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:103,Energy Efficiency,allocate,allocate,103,"/// getOrCreateJumpTableInfo - Get the JumpTableInfo for this function, if it; /// does already exist, allocate one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Security,expose,exposesReturnsTwice,4,"/// exposesReturnsTwice - Returns true if the function calls setjmp or; /// any other similar functions with attribute ""returns twice"" without; /// having the attribute itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:51,Energy Efficiency,allocate,allocated,51,/// getNumBlockIDs - Return the number of MBB ID's allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:262,Integrability,depend,depends,262,"/// viewCFG - This function is meant for use from the debugger. You can just; /// say 'call F->viewCFG()' and a ghostview window should pop up from the; /// program, displaying the CFG of the current function with the code for each; /// basic block inside. This depends on there being a 'dot' and 'gv' program; /// in your path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:11,Security,access,accessors,11,// Provide accessors for the MachineBasicBlock list...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:94,Security,access,accessor,94,//===--------------------------------------------------------------------===//; // BasicBlock accessor functions.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:25,Energy Efficiency,Allocate,Allocate,25,/// CreateMachineInstr - Allocate a new MachineInstr. Use this instead; /// of `new MachineInstr'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:259,Performance,perform,perform,259,"/// Create a new MachineInstr which is a copy of \p Orig, identical in all; /// ways except the instruction has no parent, prev, or next. Bundling flags; /// are reset.; ///; /// Note: Clones a single instruction, not whole instruction bundles.; /// Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:140,Performance,perform,perform,140,/// Clones instruction or the whole instruction bundle \p Orig and insert; /// into \p MBB before \p InsertBefore.; ///; /// Note: Does not perform target specific adjustments; consider using; /// TargetInstrInfo::duplicate() intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Energy Efficiency,Allocate,Allocate,30,/// CreateMachineBasicBlock - Allocate a new MachineBasicBlock. Use this; /// instead of `new MachineBasicBlock'. Sets `MachineBasicBlock::BBID` if; /// basic-block-sections is enabled for the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,/// getMachineMemOperand - Allocate a new MachineMemOperand.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,"/// getMachineMemOperand - Allocate a new MachineMemOperand by copying; /// an existing one, adjusting by an offset and using the given size.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:27,Energy Efficiency,Allocate,Allocate,27,"/// getMachineMemOperand - Allocate a new MachineMemOperand by copying; /// an existing one, replacing only the MachinePointerInfo and size.; /// MachineMemOperands are owned by the MachineFunction and need not be; /// explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing only AliasAnalysis information. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,"/// Allocate a new MachineMemOperand by copying an existing one,; /// replacing the flags. MachineMemOperands are owned; /// by the MachineFunction and need not be explicitly deallocated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate an array of MachineOperands. This is only intended for use by; /// internal MachineInstr functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:189,Energy Efficiency,allocate,allocate,189,/// Dellocate an array of MachineOperands and recycle the memory. This is; /// only intended for use by internal MachineInstr functions.; /// Cap must be the same capacity that was used to allocate the array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:39,Availability,mask,mask,39,/// Allocate and initialize a register mask with @p NumRegister bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and initialize a register mask with @p NumRegister bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate and construct an extra info structure for a `MachineInstr`.; ///; /// This is allocated on the function's allocator and so lives the life of; /// the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:91,Energy Efficiency,allocate,allocated,91,/// Allocate and construct an extra info structure for a `MachineInstr`.; ///; /// This is allocated on the function's allocator and so lives the life of; /// the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:4,Energy Efficiency,Allocate,Allocate,4,/// Allocate a string and populate it with the given external symbol name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:72,Modifiability,variab,variable,72,/// \}; /// Collect information used to emit debugging information of a variable in a; /// stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:64,Modifiability,variab,variable,64,/// Collect information used to emit debugging information of a variable in; /// the entry value of a register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned a stack slot.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:30,Modifiability,variab,variables,30,/// Returns the collection of variables for which we have debug info and that; /// have been assigned an entry value register.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h:24,Deployability,update,update,24,"/// Following functions update call site info. They should be called before; /// removing, replacing or copying call instruction.; /// Erase the call site info for \p MI. It is used to remove a call; /// instruction from the instruction stream.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunction.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:37,Energy Efficiency,adapt,adapts,37,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:61,Integrability,interface,interface,61,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:37,Modifiability,adapt,adapts,37,"/// MachineFunctionPass - This class adapts the FunctionPass interface to; /// allow convenient creation of passes that operate on the MachineFunction; /// representation. Instead of overriding runOnFunction, subclasses; /// override runOnMachineFunction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:3,Performance,Cache,Cache,3,// Cache the properties info at module-init time so we don't have to; // construct them for every function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h:61,Performance,perform,perform,61,/// runOnMachineFunction - This method must be overloaded to perform the; /// desired machine code transformation or analysis.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineFunctionPass.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:498,Integrability,depend,dependent,498,"//===- llvm/CodeGen/MachineInstr.h - MachineInstr class ---------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains the declaration of the MachineInstr class, which is the; // basic representation for all target dependent machine instructions used by; // the back end.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:38,Integrability,contract,contraction,38,// Instruction supports Fast math; // contraction operations like fma.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:56,Integrability,wrap,wrap,56,// Instruction supports binary operator; // no unsigned wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:54,Integrability,wrap,wrap,54,// Instruction supports binary operator; // no signed wrap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:55,Energy Efficiency,allocate,allocated,55,// Pointer to the owning basic block.; // Operands are allocated by an ArrayRecycler.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:136,Performance,optimiz,optimized,136,"// Description of the extra info, used to interpret the actual optional; // data appended.; //; // Note that this is not terribly space optimized. This leaves a great deal; // of flexibility to fit more in here later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:94,Integrability,rout,routine,94,// Just a boring constructor to allow us to initialize the sizes. Always use; // the `create` routine above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:50,Availability,avail,available,50,/// Enumeration of the kinds of inline extra info available. It is important; /// that the `MachineMemOperand` inline kind has a tag value of zero to make; /// it accessible as an `ArrayRef`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:163,Security,access,accessible,163,/// Enumeration of the kinds of inline extra info available. It is important; /// that the `MachineMemOperand` inline kind has a tag value of zero to make; /// it accessible as an `ArrayRef`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:170,Performance,optimiz,optimize,170,"// We store extra information about the instruction here. The common case is; // expected to be nothing or a single pointer (typically a MMO or a symbol).; // We work to optimize this common case by storing it inline here rather than; // requiring a separate allocation, but we fall back to an allocation when; // multiple pointers are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:26,Energy Efficiency,allocate,allocated,26,// MachineInstrs are pool-allocated and owned by MachineFunction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear the AsmPrinter bitvector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,Clear,Clear,4,/// Clear specific AsmPrinter flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Usability,clear,clearFlag,4,/// clearFlag - Clear a MI flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:16,Usability,Clear,Clear,16,/// clearFlag - Clear a MI flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:37,Modifiability,variab,variable,37,/// Return the operand for the debug variable referenced by; /// this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:21,Modifiability,variab,variable,21,/// Return the debug variable referenced by; /// this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:49,Safety,Avoid,Avoid,49,/// Set instruction number of this MachineInstr. Avoid using unless you're; /// deserializing this information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:13,Modifiability,variab,variable,13,/// Drop any variable location debugging information associated with this; /// instruction. Use when an instruction is modified in such a way that it no; /// longer defines the value it used to. Variable locations using that value; /// will be dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:195,Modifiability,Variab,Variable,195,/// Drop any variable location debugging information associated with this; /// instruction. Use when an instruction is modified in such a way that it no; /// longer defines the value it used to. Variable locations using that value; /// will be dropped.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:12,Availability,error,error,12,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:172,Availability,error,errors,172,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:282,Availability,recover,recover,282,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:299,Availability,error,error,299,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:282,Safety,recover,recover,282,"/// Emit an error referring to the source location of this instruction.; /// This should only be used for inline assembly that is somehow; /// impossible to compile. Other errors should have been handled much; /// earlier.; ///; /// If this method returns, the caller should try to recover from the error.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:69,Modifiability,variab,variable,69,/// Returns a range over all operands that are used to determine the variable; /// location for this DBG_VALUE instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction. If there are none, that does; /// not imply anything about whether the function accesses memory. Instead,; /// the caller must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:130,Security,access,accesses,130,"/// Access to memory operands of the instruction. If there are none, that does; /// not imply anything about whether the function accesses memory. Instead,; /// the caller must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:168,Security,access,accesses,168,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:4,Security,Access,Access,4,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:168,Security,access,accesses,168,"/// Access to memory operands of the instruction.; ///; /// If `memoperands_begin() == memoperands_end()`, that does not imply; /// anything about whether the function accesses memory. Instead, the caller; /// must behave conservatively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:85,Security,access,access,85,"/// Return true if we don't have any memory operands which described the; /// memory access done by this instruction. If this is true, calling code; /// must be conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:33,Security,hash,hash,33,/// Helper to extract a CFI type hash if one has been added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:47,Modifiability,variab,variable,47,"/// Return true if this instruction can have a variable number of operands.; /// In this case, the variable operands will be after the normal; /// operands but before the implicit definitions and uses (if any are; /// present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:99,Modifiability,variab,variable,99,"/// Return true if this instruction can have a variable number of operands.; /// In this case, the variable operands will be after the normal; /// operands but before the implicit definitions and uses (if any are; /// present).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:190,Availability,error,errors,190,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:46,Safety,safe,safely,46,"/// Return true if this instruction cannot be safely duplicated.; /// For example, if the instruction has a unique labels attached; /// to it, duplicating it would cause multiple definition errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:104,Integrability,depend,dependent,104,/// Return true if this instruction is convergent.; /// Convergent instructions can not be made control-dependent on any; /// additional values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:165,Performance,load,loads,165,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:210,Performance,load,loaded,210,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:320,Performance,load,loads,320,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:158,Usability,simpl,simple,158,"/// Return true for instructions that can be folded as; /// memory operands in other instructions. The most common use for this; /// is instructions that are simple loads from memory that don't modify; /// the loaded value in any way, but it can also be used for instructions; /// that can be expressed as constant-pool loads, such as V_SETALLONES; /// on x86, to allow them to be folded when it is beneficial.; /// This should only be set on instructions that return a value in their; /// only virtual register definition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:243,Performance,optimiz,optimizers,243,"/// Return true if this instruction behaves; /// the same way as the generic REG_SEQUENCE instructions.; /// E.g., on ARM,; /// dX VMOVDRR rY, rZ; /// is equivalent to; /// dX = REG_SEQUENCE rY, ssub_0, rZ, ssub_1.; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getRegSequenceLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:290,Performance,optimiz,optimizers,290,"/// Return true if this instruction behaves; /// the same way as the generic EXTRACT_SUBREG instructions.; /// E.g., on ARM,; /// rX, rY VMOVRRD dZ; /// is equivalent to two EXTRACT_SUBREG:; /// rX = EXTRACT_SUBREG dZ, ssub_0; /// rY = EXTRACT_SUBREG dZ, ssub_1; ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getExtractSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:281,Performance,optimiz,optimizers,281,"/// Return true if this instruction behaves; /// the same way as the generic INSERT_SUBREG instructions.; /// E.g., on ARM,; /// dX = VSETLNi32 dY, rZ, Imm; /// is equivalent to a INSERT_SUBREG:; /// dX = INSERT_SUBREG dY, rZ, translateImmToSubIdx(Imm); ///; /// Note that for the optimizers to be able to take advantage of; /// this property, TargetInstrInfo::getInsertSubregLikeInputs has to be; /// override accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:313,Performance,load,load,313,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:346,Performance,load,load,346,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:306,Usability,simpl,simple,306,"//===--------------------------------------------------------------------===//; // Side Effect Analysis; //===--------------------------------------------------------------------===//; /// Return true if this instruction could possibly read memory.; /// Instructions with this flag set are not necessarily simple load; /// instructions, they may load a value and modify it, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:123,Usability,simpl,simple,123,"/// Return true if this instruction could possibly modify memory.; /// Instructions with this flag set are not necessarily simple store; /// instructions, they may store a modified value based on their operands, or; /// may not actually modify anything, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:303,Energy Efficiency,efficient,efficient,303,"/// Return true if this is a 2-address instruction; /// which can be changed into a 3-address instruction if needed. Doing this; /// transformation can be profitable in the register allocator, because it; /// means that the instruction can use a 2-address form if possible, but; /// degrade into a less efficient form if the source and dest register cannot; /// be assigned to the same register. For example, this allows the x86; /// backend to turn a ""shl reg, 3"" instruction into an LEA instruction, which; /// is the same speed as the shift but has bigger code size.; ///; /// If this returns true, then the target must implement the; /// TargetInstrInfo::convertToThreeAddress method for this instruction, which; /// is allowed to fail if the transformation isn't valid for this specific; /// instruction (e.g. shl reg, 4 on x86).; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h:88,Energy Efficiency,schedul,scheduler,88,"/// Return true if this instruction requires; /// custom insertion support when the DAG scheduler is inserting it into a; /// machine basic block. If this is true for the instruction, it basically; /// means that it is a pseudo instruction used at SelectionDAG time that is; /// expanded out into magic code by the target when MachineInstrs are formed.; ///; /// If this is true, the TargetLoweringInfo::InsertAtEndOfBasicBlock method; /// is used to insert this into the MachineBasicBlock.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/include/llvm/CodeGen/MachineInstr.h
