id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp:53,Energy Efficiency,adapt,adapter,53,"// we start from negative numbers since the Illumina adapter dimer usually have the first A skipped as A-tailing",MatchSource.CODE_COMMENT,src/adaptertrimmer.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp:53,Integrability,adapter,adapter,53,"// we start from negative numbers since the Illumina adapter dimer usually have the first A skipped as A-tailing",MatchSource.CODE_COMMENT,src/adaptertrimmer.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp:53,Modifiability,adapt,adapter,53,"// we start from negative numbers since the Illumina adapter dimer usually have the first A skipped as A-tailing",MatchSource.CODE_COMMENT,src/adaptertrimmer.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/adaptertrimmer.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/cmdline.h:1286,Integrability,CONTRACT,CONTRACT,1286,"/*; Copyright (c) 2009, Hideyuki Tanaka; All rights reserved. Redistribution and use in source and binary forms, with or without; modification, are permitted provided that the following conditions are met:; * Redistributions of source code must retain the above copyright; notice, this list of conditions and the following disclaimer.; * Redistributions in binary form must reproduce the above copyright; notice, this list of conditions and the following disclaimer in the; documentation and/or other materials provided with the distribution.; * Neither the name of the <organization> nor the; names of its contributors may be used to endorse or promote products; derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY <copyright holder> ''AS IS'' AND ANY; EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE; DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY; DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND; ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; */",MatchSource.CODE_COMMENT,src/cmdline.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/cmdline.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/common.h:49,Availability,error,error,49,"// the limit of the queue to store the packs; // error may happen if it generates more packs than this number",MatchSource.CODE_COMMENT,src/common.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/common.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/common.h:20,Performance,queue,queue,20,"// the limit of the queue to store the packs; // error may happen if it generates more packs than this number",MatchSource.CODE_COMMENT,src/common.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/common.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:14,Testability,test,test,14,"// output for test; /*for(iter = hotseqs.begin(); iter!=hotseqs.end(); iter++) {; cerr << iter->first << "": "" << iter->second << endl;; }*/",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:15,Deployability,update,update,15,"// by the way, update readNum so we don't need to evaluate it if splitting output is enabled",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:15,Deployability,update,update,15,"// by the way, update readNum so we don't need to evaluate it if splitting output is enabled",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:20,Energy Efficiency,adapt,adapter,20,"// find the longest adapter",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:20,Integrability,adapter,adapter,20,"// find the longest adapter",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:20,Modifiability,adapt,adapter,20,"// find the longest adapter",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp:15,Deployability,update,update,15,"// by the way, update readNum so we don't need to evaluate it if splitting output is enabled",MatchSource.CODE_COMMENT,src/evaluator.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/evaluator.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp:32,Integrability,synchroniz,synchronization,32,"// Set locale and disable stdio synchronization to improve iostream performance; // http://www.drdobbs.com/the-standard-librarian-iostreams-and-std/184401305; // http://stackoverflow.com/questions/5166263/how-to-get-iostream-to-perform-better",MatchSource.CODE_COMMENT,src/fastareader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp:68,Performance,perform,performance,68,"// Set locale and disable stdio synchronization to improve iostream performance; // http://www.drdobbs.com/the-standard-librarian-iostreams-and-std/184401305; // http://stackoverflow.com/questions/5166263/how-to-get-iostream-to-perform-better",MatchSource.CODE_COMMENT,src/fastareader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp:228,Performance,perform,perform-better,228,"// Set locale and disable stdio synchronization to improve iostream performance; // http://www.drdobbs.com/the-standard-librarian-iostreams-and-std/184401305; // http://stackoverflow.com/questions/5166263/how-to-get-iostream-to-perform-better",MatchSource.CODE_COMMENT,src/fastareader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastareader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp:104,Energy Efficiency,charge,charge,104,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/fastqreader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp:967,Integrability,CONTRACT,CONTRACT,967,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/fastqreader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp:43,Testability,log,logical,43,"// all data was processed - fail if not at logical end of zip file (truncated?)",MatchSource.CODE_COMMENT,src/fastqreader.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h:104,Energy Efficiency,charge,charge,104,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/fastqreader.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h:967,Integrability,CONTRACT,CONTRACT,967,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/fastqreader.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h:109,Performance,concurren,concurrently,109,"//this function is not thread-safe; //do not call read() of a same FastqReader object from different threads concurrently",MatchSource.CODE_COMMENT,src/fastqreader.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h:30,Safety,safe,safe,30,"//this function is not thread-safe; //do not call read() of a same FastqReader object from different threads concurrently",MatchSource.CODE_COMMENT,src/fastqreader.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/fastqreader.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:13,Deployability,rolling,rolling,13,"// preparing rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:3,Deployability,rolling,rolling,3,"// rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:13,Deployability,rolling,rolling,13,"// preparing rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:3,Deployability,rolling,rolling,3,"// rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:13,Deployability,rolling,rolling,13,"// preparing rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp:3,Deployability,rolling,rolling,3,"// rolling",MatchSource.CODE_COMMENT,src/filter.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filter.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:9,Energy Efficiency,adapt,adapter,9,"// merge adapter stats",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:9,Integrability,adapter,adapter,9,"// merge adapter stats",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:9,Modifiability,adapt,adapter,9,"// merge adapter stats",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:3,Deployability,update,update,3,"// update read counting",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:8,Energy Efficiency,adapt,adapters,8,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:25,Energy Efficiency,adapt,adapter,25,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:8,Integrability,adapter,adapters,8,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:25,Integrability,adapter,adapter,25,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:8,Modifiability,adapt,adapters,8,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp:25,Modifiability,adapt,adapter,25,"// sort adapters list by adapter length from short to long",MatchSource.CODE_COMMENT,src/filterresult.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Energy Efficiency,adapt,adapters,29,"// a part of JSON report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Integrability,adapter,adapters,29,"// a part of JSON report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Modifiability,adapt,adapters,29,"// a part of JSON report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Energy Efficiency,adapt,adapters,29,"// a part of HTML report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Integrability,adapter,adapters,29,"// a part of HTML report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h:29,Modifiability,adapt,adapters,29,"// a part of HTML report for adapters",MatchSource.CODE_COMMENT,src/filterresult.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/filterresult.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1396,Integrability,CONTRACT,CONTRACT,1396,"/**********************************************************************; Copyright(c) 2011-2016 Intel Corporation All rights reserved. Redistribution and use in source and binary forms, with or without; modification, are permitted provided that the following conditions; are met:; * Redistributions of source code must retain the above copyright; notice, this list of conditions and the following disclaimer.; * Redistributions in binary form must reproduce the above copyright; notice, this list of conditions and the following disclaimer in; the documentation and/or other materials provided with the; distribution.; * Neither the name of Intel Corporation nor the names of its; contributors may be used to endorse or promote products derived; from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR; A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; **********************************************************************/",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1194,Energy Efficiency,Power,Powers,1194,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:96,Integrability,interface,interface,96,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:149,Integrability,interface,interface,149,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:998,Modifiability,config,configurable,998,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1037,Modifiability,config,configurable,1037,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:117,Performance,perform,performance,117,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:442,Performance,perform,performed,442,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1349,Performance,perform,performance,1349,"/**; * @file igzip_lib.h; *; * @brief This file defines the igzip compression and decompression interface, a; * high performance deflate compression interface for storage applications.; *; * Deflate is a widely used compression standard that can be used standalone, it; * also forms the basis of gzip and zlib compression formats. Igzip supports the; * following flush features:; *; * - No Flush: The default method where no special flush is performed.; *; * - Sync flush: whereby isal_deflate() finishes the current deflate block at; * the end of each input buffer. The deflate block is byte aligned by; * appending an empty stored block.; *; * - Full flush: whereby isal_deflate() finishes and aligns the deflate block as; * in sync flush but also ensures that subsequent block's history does not; * look back beyond this point and new blocks are fully independent.; *; * Igzip also supports compression levels from ISAL_DEF_MIN_LEVEL to; * ISAL_DEF_MAX_LEVEL.; *; * Igzip contains some behavior configurable at compile time. These; * configurable options are:; *; * - IGZIP_HIST_SIZE - Defines the window size. The default value is 32K (note K; * represents 1024), but 8K is also supported. Powers of 2 which are at most; * 32K may also work.; *; * - LONGER_HUFFTABLES - Defines whether to use a larger hufftables structure; * which may increase performance with smaller IGZIP_HIST_SIZE values. By; * default this option is not defined. This define sets IGZIP_HIST_SIZE to be; * 8 if IGZIP_HIST_SIZE > 8K.; *; * As an example, to compile gzip with an 8K window size, in a terminal run; * @verbatim gmake D=""-D IGZIP_HIST_SIZE=8*1024"" @endverbatim on Linux and; * FreeBSD, or with @verbatim nmake -f Makefile.nmake D=""-D; * IGZIP_HIST_SIZE=8*1024"" @endverbatim on Windows.; *; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:245,Energy Efficiency,power,power,245,/******************************************************************************/; /* Deflate Implementation Specific Defines */; /******************************************************************************/; /* Note IGZIP_HIST_SIZE must be a power of two */,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:6,Availability,error,errors,6,/* No errors encountered while decompressing */,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:21,Integrability,wrap,wrapper,21,/* Invalid gzip/zlib wrapper found */,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:13,Integrability,wrap,wrapper,13,/* Gzip/zlib wrapper specifies unsupported compress method */,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:13,Security,checksum,checksum,13,/* Incorrect checksum found */,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:25,Security,hash,hash,25,"//!< Tmp space used as a hash table",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:12,Testability,log,logarithm,12,"//!< base-2 logarithm of the LZ77 window size minus 8",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:3,Modifiability,Variab,Variable,3,/* Variable prefixes:; * b_ : Measured wrt the start of the buffer; * f_ : Measured wrt the start of the file (aka file_start); */; /** @brief Holds the internal state information for input and output compression streams*/,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:14,Availability,mask,mask,14,"//!< Distance mask used.",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:13,Security,checksum,checksum,13,"//!< Current checksum without finalize step if any (adler)",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:20,Integrability,wrap,wrapper,20,"//!< keeps track of wrapper header",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:15,Modifiability,variab,variable,15,"//!< temporary variable",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:15,Modifiability,variab,variable,15,"//!< temporary variable",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:70,Performance,cache,cache,70,//!< Internal buffer; /* Stream should be setup such that the head is cache aligned*/,MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:5,Security,Hash,Hash,5,"//!< Hash array",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:21,Availability,avail,available,21,"//!< number of bytes available at next_in",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:21,Availability,avail,available,21,"//!< number of bytes available at next_out",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:10,Energy Efficiency,allocate,allocated,10,"//!< User allocated buffer required for different compression levels",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:43,Performance,perform,performed,43,"//!< Indicate if gzip compression is to be performed",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:5,Testability,Log,Log,5,"//!< Log base 2 of maximum lookback distance, 0 is use default",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:295,Performance,perform,performing,295,"/******************************************************************************/; /* Inflate structures */; /******************************************************************************/; /*; * Inflate_huff_code data structures are used to store a Huffman code for fast; * lookup. It works by performing a lookup in small_code_lookup that hopefully; * yields the correct symbol. Otherwise a lookup into long_code_lookup is; * performed to find the correct symbol. The details of how this works follows:; *; * Let i be some index into small_code_lookup and let e be the associated; * element. Bit 15 in e is a flag. If bit 15 is not set, then index i contains; * a Huffman code for a symbol which has length at most DECODE_LOOKUP_SIZE. Bits; * 0 through 8 are the symbol associated with that code and bits 9 through 12 of; * e represent the number of bits in the code. If bit 15 is set, the i; * corresponds to the first DECODE_LOOKUP_SIZE bits of a Huffman code which has; * length longer than DECODE_LOOKUP_SIZE. In this case, bits 0 through 8; * represent an offset into long_code_lookup table and bits 9 through 12; * represent the maximum length of a Huffman code starting with the bits in the; * index i. The offset into long_code_lookup is for an array associated with all; * codes which start with the bits in i.; *; * The elements of long_code_lookup are in the same format as small_code_lookup,; * except bit 15 is never set. Let i be a number made up of DECODE_LOOKUP_SIZE; * bits. Then all Huffman codes which start with DECODE_LOOKUP_SIZE bits are; * stored in an array starting at index h in long_code_lookup. This index h is; * stored in bits 0 through 9 at index i in small_code_lookup. The index j is an; * index of this array if the number of bits contained in j and i is the number; * of bits in the longest huff_code starting with the bits of i. The symbol; * stored at index j is the symbol whose huffcode can be found in (j <<; * DECODE_LOOKUP_SIZE) | i. Note these arrays will ",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:428,Performance,perform,performed,428,"/******************************************************************************/; /* Inflate structures */; /******************************************************************************/; /*; * Inflate_huff_code data structures are used to store a Huffman code for fast; * lookup. It works by performing a lookup in small_code_lookup that hopefully; * yields the correct symbol. Otherwise a lookup into long_code_lookup is; * performed to find the correct symbol. The details of how this works follows:; *; * Let i be some index into small_code_lookup and let e be the associated; * element. Bit 15 in e is a flag. If bit 15 is not set, then index i contains; * a Huffman code for a symbol which has length at most DECODE_LOOKUP_SIZE. Bits; * 0 through 8 are the symbol associated with that code and bits 9 through 12 of; * e represent the number of bits in the code. If bit 15 is set, the i; * corresponds to the first DECODE_LOOKUP_SIZE bits of a Huffman code which has; * length longer than DECODE_LOOKUP_SIZE. In this case, bits 0 through 8; * represent an offset into long_code_lookup table and bits 9 through 12; * represent the maximum length of a Huffman code starting with the bits in the; * index i. The offset into long_code_lookup is for an array associated with all; * codes which start with the bits in i.; *; * The elements of long_code_lookup are in the same format as small_code_lookup,; * except bit 15 is never set. Let i be a number made up of DECODE_LOOKUP_SIZE; * bits. Then all Huffman codes which start with DECODE_LOOKUP_SIZE bits are; * stored in an array starting at index h in long_code_lookup. This index h is; * stored in bits 0 through 9 at index i in small_code_lookup. The index j is an; * index of this array if the number of bits contained in j and i is the number; * of bits in the longest huff_code starting with the bits of i. The symbol; * stored at index j is the symbol whose huffcode can be found in (j <<; * DECODE_LOOKUP_SIZE) | i. Note these arrays will ",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:21,Availability,avail,available,21,"//!< Number of bytes available at next_out",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:21,Availability,avail,available,21,"//!< Number of bytes available at next_in",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:5,Testability,Log,Log,5,"//!< Log base 2 of maximum lookback distance",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:207,Deployability,Update,Updates,207,"/******************************************************************************/; /* Compression functions */; /******************************************************************************/; /**; * @brief Updates histograms to include the symbols found in the input; * stream. Since this function only updates the histograms, it can be called on; * multiple streams to get a histogram better representing the desired data; * set. When first using histogram it must be initialized by zeroing the; * structure.; *; * @param in_stream: Input stream of data.; * @param length: The length of start_stream.; * @param histogram: The returned histogram of lit/len/dist symbols.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:304,Deployability,update,updates,304,"/******************************************************************************/; /* Compression functions */; /******************************************************************************/; /**; * @brief Updates histograms to include the symbols found in the input; * stream. Since this function only updates the histograms, it can be called on; * multiple streams to get a histogram better representing the desired data; * set. When first using histogram it must be initialized by zeroing the; * structure.; *; * @param in_stream: Input stream of data.; * @param length: The length of start_stream.; * @param histogram: The returned histogram of lit/len/dist symbols.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:198,Integrability,wrap,wrapper,198,"/**; * @brief Reinitialize compression stream data structure. Performs the same; * action as isal_deflate_init, but does not change user supplied input such as; * the level, flush type, compression wrapper (like gzip), hufftables, and; * end_of_stream_flag.; *; * @param stream Structure holding state information on the compression streams.; * @returns none; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:62,Performance,Perform,Performs,62,"/**; * @brief Reinitialize compression stream data structure. Performs the same; * action as isal_deflate_init, but does not change user supplied input such as; * the level, flush type, compression wrapper (like gzip), hufftables, and; * end_of_stream_flag.; *; * @param stream Structure holding state information on the compression streams.; * @returns none; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:177,Energy Efficiency,reduce,reduce,177,"/**; * @brief Reset compression dictionary to use; *; * Similar to isal_deflate_set_dict() but on pre-processed dictionary; * data. Pairing with isal_deflate_process_dict() can reduce the processing time; * on subsequent compression with dictionary especially on small files.; *; * Like isal_deflate_set_dict(), this function is to be called after; * isal_deflate_init, or after completing a SYNC_FLUSH or FULL_FLUSH and before; * the next call do isal_deflate. Changing compression level between dictionary; * process and reset will cause return of ISAL_INVALID_STATE.; *; * @param stream Structure holding state information on the compression streams.; * @param dict_str: Structure with pre-processed dictionary info.; * @returns COMP_OK,; * ISAL_INVALID_STATE or other (dictionary could not be reset); */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:638,Deployability,update,updated,638,"/**; * @brief Fast data (deflate) compression for storage applications.; *; * The call to isal_deflate() will take data from the input buffer (updating; * next_in, avail_in and write a compressed stream to the output buffer; * (updating next_out and avail_out). The function returns when either the input; * buffer is empty or the output buffer is full.; *; * On entry to isal_deflate(), next_in points to an input buffer and avail_in; * indicates the length of that buffer. Similarly next_out points to an empty; * output buffer and avail_out indicates the size of that buffer.; *; * The fields total_in and total_out start at 0 and are updated by; * isal_deflate(). These reflect the total number of bytes read or written so far.; *; * When the last input buffer is passed in, signaled by setting the; * end_of_stream, the routine will complete compression at the end of the input; * buffer, as long as the output buffer is big enough.; *; * The compression level can be set by setting level to any value between; * ISAL_DEF_MIN_LEVEL and ISAL_DEF_MAX_LEVEL. When the compression level is; * ISAL_DEF_MIN_LEVEL, hufftables can be set to a table trained for the the; * specific data type being compressed to achieve better compression. When a; * higher compression level is desired, a larger generic memory buffer needs to; * be supplied by setting level_buf and level_buf_size to represent the chunk of; * memory. For level x, the suggest size for this buffer this buffer is; * ISAL_DEFL_LVLx_DEFAULT. The defines ISAL_DEFL_LVLx_MIN, ISAL_DEFL_LVLx_SMALL,; * ISAL_DEFL_LVLx_MEDIUM, ISAL_DEFL_LVLx_LARGE, and ISAL_DEFL_LVLx_EXTRA_LARGE; * are also provided as other suggested sizes.; *; * The equivalent of the zlib FLUSH_SYNC operation is currently supported.; * Flush types can be NO_FLUSH, SYNC_FLUSH or FULL_FLUSH. Default flush type is; * NO_FLUSH. A SYNC_ OR FULL_ flush will byte align the deflate block by; * appending an empty stored block once all input has been compressed, including; * th",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:825,Integrability,rout,routine,825,"/**; * @brief Fast data (deflate) compression for storage applications.; *; * The call to isal_deflate() will take data from the input buffer (updating; * next_in, avail_in and write a compressed stream to the output buffer; * (updating next_out and avail_out). The function returns when either the input; * buffer is empty or the output buffer is full.; *; * On entry to isal_deflate(), next_in points to an input buffer and avail_in; * indicates the length of that buffer. Similarly next_out points to an empty; * output buffer and avail_out indicates the size of that buffer.; *; * The fields total_in and total_out start at 0 and are updated by; * isal_deflate(). These reflect the total number of bytes read or written so far.; *; * When the last input buffer is passed in, signaled by setting the; * end_of_stream, the routine will complete compression at the end of the input; * buffer, as long as the output buffer is big enough.; *; * The compression level can be set by setting level to any value between; * ISAL_DEF_MIN_LEVEL and ISAL_DEF_MAX_LEVEL. When the compression level is; * ISAL_DEF_MIN_LEVEL, hufftables can be set to a table trained for the the; * specific data type being compressed to achieve better compression. When a; * higher compression level is desired, a larger generic memory buffer needs to; * be supplied by setting level_buf and level_buf_size to represent the chunk of; * memory. For level x, the suggest size for this buffer this buffer is; * ISAL_DEFL_LVLx_DEFAULT. The defines ISAL_DEFL_LVLx_MIN, ISAL_DEFL_LVLx_SMALL,; * ISAL_DEFL_LVLx_MEDIUM, ISAL_DEFL_LVLx_LARGE, and ISAL_DEFL_LVLx_EXTRA_LARGE; * are also provided as other suggested sizes.; *; * The equivalent of the zlib FLUSH_SYNC operation is currently supported.; * Flush types can be NO_FLUSH, SYNC_FLUSH or FULL_FLUSH. Default flush type is; * NO_FLUSH. A SYNC_ OR FULL_ flush will byte align the deflate block by; * appending an empty stored block once all input has been compressed, including; * th",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:121,Integrability,rout,routine,121,"/**; * @brief Fast data (deflate) stateless compression for storage applications.; *; * Stateless (one shot) compression routine with a similar interface to; * isal_deflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire compressed output. Max; * expansion is limited to the input size plus the header size of a stored/raw; * block.; *; * When the compression level is set to 1, unlike in isal_deflate(), level_buf; * may be optionally set depending on what what performance is desired.; *; * For stateless the flush types NO_FLUSH and FULL_FLUSH are supported.; * FULL_FLUSH will byte align the output deflate block so additional blocks can; * be easily appended.; *; * If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip; * trailer are written around the deflate compressed data. If gzip_flag is set; * to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written.; *; * @param stream Structure holding state information on the compression streams.; * @return COMP_OK (if everything is ok),; * INVALID_FLUSH (if an invalid FLUSH is selected),; * ISAL_INVALID_LEVEL (if an invalid compression level is selected),; * ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough),; * STATELESS_OVERFLOW (if output buffer will not fit output).; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:144,Integrability,interface,interface,144,"/**; * @brief Fast data (deflate) stateless compression for storage applications.; *; * Stateless (one shot) compression routine with a similar interface to; * isal_deflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire compressed output. Max; * expansion is limited to the input size plus the header size of a stored/raw; * block.; *; * When the compression level is set to 1, unlike in isal_deflate(), level_buf; * may be optionally set depending on what what performance is desired.; *; * For stateless the flush types NO_FLUSH and FULL_FLUSH are supported.; * FULL_FLUSH will byte align the output deflate block so additional blocks can; * be easily appended.; *; * If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip; * trailer are written around the deflate compressed data. If gzip_flag is set; * to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written.; *; * @param stream Structure holding state information on the compression streams.; * @return COMP_OK (if everything is ok),; * INVALID_FLUSH (if an invalid FLUSH is selected),; * ISAL_INVALID_LEVEL (if an invalid compression level is selected),; * ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough),; * STATELESS_OVERFLOW (if output buffer will not fit output).; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:505,Integrability,depend,depending,505,"/**; * @brief Fast data (deflate) stateless compression for storage applications.; *; * Stateless (one shot) compression routine with a similar interface to; * isal_deflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire compressed output. Max; * expansion is limited to the input size plus the header size of a stored/raw; * block.; *; * When the compression level is set to 1, unlike in isal_deflate(), level_buf; * may be optionally set depending on what what performance is desired.; *; * For stateless the flush types NO_FLUSH and FULL_FLUSH are supported.; * FULL_FLUSH will byte align the output deflate block so additional blocks can; * be easily appended.; *; * If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip; * trailer are written around the deflate compressed data. If gzip_flag is set; * to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written.; *; * @param stream Structure holding state information on the compression streams.; * @return COMP_OK (if everything is ok),; * INVALID_FLUSH (if an invalid FLUSH is selected),; * ISAL_INVALID_LEVEL (if an invalid compression level is selected),; * ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough),; * STATELESS_OVERFLOW (if output buffer will not fit output).; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:528,Performance,perform,performance,528,"/**; * @brief Fast data (deflate) stateless compression for storage applications.; *; * Stateless (one shot) compression routine with a similar interface to; * isal_deflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire compressed output. Max; * expansion is limited to the input size plus the header size of a stored/raw; * block.; *; * When the compression level is set to 1, unlike in isal_deflate(), level_buf; * may be optionally set depending on what what performance is desired.; *; * For stateless the flush types NO_FLUSH and FULL_FLUSH are supported.; * FULL_FLUSH will byte align the output deflate block so additional blocks can; * be easily appended.; *; * If the gzip_flag is set to IGZIP_GZIP, a generic gzip header and the gzip; * trailer are written around the deflate compressed data. If gzip_flag is set; * to IGZIP_GZIP_NO_HDR, then only the gzip trailer is written.; *; * @param stream Structure holding state information on the compression streams.; * @return COMP_OK (if everything is ok),; * INVALID_FLUSH (if an invalid FLUSH is selected),; * ISAL_INVALID_LEVEL (if an invalid compression level is selected),; * ISAL_INVALID_LEVEL_BUF (if the level buffer is not large enough),; * STATELESS_OVERFLOW (if output buffer will not fit output).; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1109,Security,checksum,checksum,1109,"/**; * @brief Read and return gzip header information; *; * On entry state must be initialized and next_in pointing to a gzip compressed; * buffer. The buffers gz_hdr->extra, gz_hdr->name, gz_hdr->comments and the; * buffer lengths must be set to record the corresponding field, or set to NULL; * to disregard that gzip header information. If one of these buffers overflows,; * the user can reallocate a larger buffer and call this function again to; * continue reading the header information.; *; * @param state: Structure holding state information on the decompression stream.; * @param gz_hdr: Structure to return data encoded in the gzip header; * @returns ISAL_DECOMP_OK (header was successfully parsed); * ISAL_END_INPUT (all input was parsed),; * ISAL_NAME_OVERFLOW (gz_hdr->name overflowed while parsing),; * ISAL_COMMENT_OVERFLOW (gz_hdr->comment overflowed while parsing),; * ISAL_EXTRA_OVERFLOW (gz_hdr->extra overflowed while parsing),; * ISAL_INVALID_WRAPPER (invalid gzip header found),; * ISAL_UNSUPPORTED_METHOD (deflate is not the compression method),; * ISAL_INCORRECT_CHECKSUM (gzip header checksum was incorrect); */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:516,Security,checksum,checksum,516,"/**; * @brief Read and return zlib header information; *; * On entry state must be initialized and next_in pointing to a zlib compressed; * buffer.; *; * @param state: Structure holding state information on the decompression stream.; * @param zlib_hdr: Structure to return data encoded in the zlib header; * @returns ISAL_DECOMP_OK (header was successfully parsed),; * ISAL_END_INPUT (all input was parsed),; * ISAL_UNSUPPORTED_METHOD (deflate is not the compression method),; * ISAL_INCORRECT_CHECKSUM (zlib header checksum was incorrect); */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:344,Deployability,update,updated,344,"/**; * @brief Fast data (deflate) decompression for storage applications.; *; * On entry to isal_inflate(), next_in points to an input buffer and avail_in; * indicates the length of that buffer. Similarly next_out points to an empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1125,Deployability,update,updated,1125," * On entry to isal_inflate(), next_in points to an input buffer and avail_in; * indicates the length of that buffer. Similarly next_out points to an empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * I",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1102,Security,checksum,checksum,1102," * On entry to isal_inflate(), next_in points to an input buffer and avail_in; * indicates the length of that buffer. Similarly next_out points to an empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * I",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1284,Security,checksum,checksum,1284,"empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * ISAL_NEED_DICT,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1314,Security,checksum,checksum,1314,"empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * ISAL_NEED_DICT,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1494,Security,checksum,checksum,1494,"empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * ISAL_NEED_DICT,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1515,Security,checksum,checksum,1515,"empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * ISAL_NEED_DICT,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:1734,Testability,log,log,1734,"empty; * output buffer and avail_out indicates the size of that buffer.; *; * The field total_out starts at 0 and is updated by isal_inflate(). This; * reflects the total number of bytes written so far.; *; * The call to isal_inflate() will take data from the input buffer (updating; * next_in, avail_in and write a decompressed stream to the output buffer; * (updating next_out and avail_out). The function returns when the input buffer; * is empty, the output buffer is full, invalid data is found, or in the case of; * zlib formatted data if a dictionary is specified. The current state of the; * decompression on exit can be read from state->block-state.; *; * If the crc_flag is set to ISAL_GZIP_NO_HDR the gzip crc of the output is; * stored in state->crc. Alternatively, if the crc_flag is set to; * ISAL_ZLIB_NO_HDR the adler32 of the output is stored in state->crc (checksum; * may not be updated until decompression is complete). When the crc_flag is set; * to ISAL_GZIP_NO_HDR_VER or ISAL_ZLIB_NO_HDR_VER, the behavior is the same,; * except the checksum is verified with the checksum after immediately following; * the deflate data. If the crc_flag is set to ISAL_GZIP or ISAL_ZLIB, the; * gzip/zlib header is parsed, state->crc is set to the appropriate checksum,; * and the checksum is verified. If the crc_flag is set to ISAL_DEFLATE; * (default), then the data is treated as a raw deflate block.; *; * The element state->hist_bits has values from 0 to 15, where values of 1 to 15; * are the log base 2 size of the matching window and 0 is the default with; * maximum history size.; *; * If a dictionary is required, a call to isal_inflate_set_dict will set the; * dictionary.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_INVALID_BLOCK,; * ISAL_NEED_DICT,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:125,Integrability,rout,routine,125,"/**; * @brief Fast data (deflate) stateless decompression for storage applications.; *; * Stateless (one shot) decompression routine with a similar interface to; * isal_inflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire decompressed; * output. Dictionaries are not supported.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_END_INPUT (if all input was decompressed),; * ISAL_NEED_DICT,; * ISAL_OUT_OVERFLOW (if output buffer ran out of space),; * ISAL_INVALID_BLOCK,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:148,Integrability,interface,interface,148,"/**; * @brief Fast data (deflate) stateless decompression for storage applications.; *; * Stateless (one shot) decompression routine with a similar interface to; * isal_inflate() but operates on entire input buffer at one time. Parameter; * avail_out must be large enough to fit the entire decompressed; * output. Dictionaries are not supported.; *; * @param state Structure holding state information on the compression streams.; * @return ISAL_DECOMP_OK (if everything is ok),; * ISAL_END_INPUT (if all input was decompressed),; * ISAL_NEED_DICT,; * ISAL_OUT_OVERFLOW (if output buffer ran out of space),; * ISAL_INVALID_BLOCK,; * ISAL_INVALID_SYMBOL,; * ISAL_INVALID_LOOKBACK,; * ISAL_INVALID_WRAPPER,; * ISAL_UNSUPPORTED_METHOD,; * ISAL_INCORRECT_CHECKSUM.; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:220,Security,checksum,checksum,220,"/******************************************************************************/; /* Other functions */; /******************************************************************************/; /**; * @brief Calculate Adler-32 checksum, runs appropriate version.; *; * This function determines what instruction sets are enabled and selects the; * appropriate version at runtime.; *; * @param init: initial Adler-32 value; * @param buf: buffer to calculate checksum on; * @param len: buffer length in bytes; *; * @returns 32-bit Adler-32 checksum; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:449,Security,checksum,checksum,449,"/******************************************************************************/; /* Other functions */; /******************************************************************************/; /**; * @brief Calculate Adler-32 checksum, runs appropriate version.; *; * This function determines what instruction sets are enabled and selects the; * appropriate version at runtime.; *; * @param init: initial Adler-32 value; * @param buf: buffer to calculate checksum on; * @param len: buffer length in bytes; *; * @returns 32-bit Adler-32 checksum; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h:530,Security,checksum,checksum,530,"/******************************************************************************/; /* Other functions */; /******************************************************************************/; /**; * @brief Calculate Adler-32 checksum, runs appropriate version.; *; * This function determines what instruction sets are enabled and selects the; * appropriate version at runtime.; *; * @param init: initial Adler-32 value; * @param buf: buffer to calculate checksum on; * @param len: buffer length in bytes; *; * @returns 32-bit Adler-32 checksum; */",MatchSource.CODE_COMMENT,src/igzip_lib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/igzip_lib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:8,Energy Efficiency,adapt,adapter,8,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:68,Energy Efficiency,adapt,adapters,68,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:8,Integrability,adapter,adapter,8,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:68,Integrability,adapter,adapters,68,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:8,Modifiability,adapt,adapter,8,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h:68,Modifiability,adapt,adapters,68,"// some adapter sequences are from https://github.com/stephenturner/adapters/blob/master/adapters_combined_256_unique.fasta",MatchSource.CODE_COMMENT,src/knownadapters.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/knownadapters.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:127,Safety,avoid,avoid,127,"/*; * On 32-bit Windows, gcc assumes 16-byte stack alignment but MSVC only 4.; * Realign the stack when entering libdeflate to avoid crashing in SSE/AVX; * code when called from an MSVC-compiled application.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:36,Energy Efficiency,allocate,allocates,36,"/*; * libdeflate_alloc_compressor() allocates a new compressor that supports; * DEFLATE, zlib, and gzip compression. 'compression_level' is the compression; * level on a zlib-like scale but with a higher maximum value (1 = fastest, 6 =; * medium/default, 9 = slow, 12 = slowest). The return value is a pointer to; * the new compressor, or NULL if out of memory.; *; * Note: for compression, the sliding window size is defined at compilation time; * to 32768, the largest size permissible in the DEFLATE format. It cannot be; * changed at runtime.; *; * A single compressor is not safe to use by multiple threads concurrently.; * However, different threads may use different compressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:612,Performance,concurren,concurrently,612,"/*; * libdeflate_alloc_compressor() allocates a new compressor that supports; * DEFLATE, zlib, and gzip compression. 'compression_level' is the compression; * level on a zlib-like scale but with a higher maximum value (1 = fastest, 6 =; * medium/default, 9 = slow, 12 = slowest). The return value is a pointer to; * the new compressor, or NULL if out of memory.; *; * Note: for compression, the sliding window size is defined at compilation time; * to 32768, the largest size permissible in the DEFLATE format. It cannot be; * changed at runtime.; *; * A single compressor is not safe to use by multiple threads concurrently.; * However, different threads may use different compressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:686,Performance,concurren,concurrently,686,"/*; * libdeflate_alloc_compressor() allocates a new compressor that supports; * DEFLATE, zlib, and gzip compression. 'compression_level' is the compression; * level on a zlib-like scale but with a higher maximum value (1 = fastest, 6 =; * medium/default, 9 = slow, 12 = slowest). The return value is a pointer to; * the new compressor, or NULL if out of memory.; *; * Note: for compression, the sliding window size is defined at compilation time; * to 32768, the largest size permissible in the DEFLATE format. It cannot be; * changed at runtime.; *; * A single compressor is not safe to use by multiple threads concurrently.; * However, different threads may use different compressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:580,Safety,safe,safe,580,"/*; * libdeflate_alloc_compressor() allocates a new compressor that supports; * DEFLATE, zlib, and gzip compression. 'compression_level' is the compression; * level on a zlib-like scale but with a higher maximum value (1 = fastest, 6 =; * medium/default, 9 = slow, 12 = slowest). The return value is a pointer to; * the new compressor, or NULL if out of memory.; *; * Note: for compression, the sliding window size is defined at compilation time; * to 32768, the largest size permissible in the DEFLATE format. It cannot be; * changed at runtime.; *; * A single compressor is not safe to use by multiple threads concurrently.; * However, different threads may use different compressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:36,Performance,perform,performs,36,"/*; * libdeflate_deflate_compress() performs raw DEFLATE compression on a buffer of; * data. The function attempts to compress 'in_nbytes' bytes of data located at; * 'in' and write the results to 'out', which has space for 'out_nbytes_avail'; * bytes. The return value is the compressed size in bytes, or 0 if the data; * could not be compressed to 'out_nbytes_avail' bytes or fewer.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:696,Energy Efficiency,allocate,allocated,696,"/*; * libdeflate_deflate_compress_bound() returns a worst-case upper bound on the; * number of bytes of compressed data that may be produced by compressing any; * buffer of length less than or equal to 'in_nbytes' using; * libdeflate_deflate_compress() with the specified compressor. Mathematically,; * this bound will necessarily be a number greater than or equal to 'in_nbytes'.; * It may be an overestimate of the true upper bound. The return value is; * guaranteed to be the same for all invocations with the same compressor and; * same 'in_nbytes'.; *; * As a special case, 'compressor' may be NULL. This causes the bound to be; * taken across *any* libdeflate_compressor that could ever be allocated with; * this build of the library, with any options.; *; * Note that this function is not necessary in many applications. With; * block-based compression, it is usually preferable to separately store the; * uncompressed size of each block and to store any blocks that did not compress; * to less than their original size uncompressed. In that scenario, there is no; * need to know the worst-case compressed size, since the maximum number of; * bytes of compressed data that may be used would always be one less than the; * input length. You can just pass a buffer of that size to; * libdeflate_deflate_compress() and store the data uncompressed if; * libdeflate_deflate_compress() returns 0, indicating that the compressed data; * did not fit into the provided output buffer.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:74,Integrability,wrap,wrapper,74,"/*; * Like libdeflate_deflate_compress(), but stores the data in the zlib wrapper; * format.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:74,Integrability,wrap,wrapper,74,"/*; * Like libdeflate_deflate_compress(), but stores the data in the gzip wrapper; * format.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:63,Energy Efficiency,allocate,allocated,63,"/*; * libdeflate_free_compressor() frees a compressor that was allocated with; * libdeflate_alloc_compressor(). If a NULL pointer is passed in, no action is; * taken.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:38,Energy Efficiency,allocate,allocates,38,"/*; * libdeflate_alloc_decompressor() allocates a new decompressor that can be used; * for DEFLATE, zlib, and gzip decompression. The return value is a pointer to; * the new decompressor, or NULL if out of memory.; *; * This function takes no parameters, and the returned decompressor is valid for; * decompressing data that was compressed at any compression level and with any; * sliding window size.; *; * A single decompressor is not safe to use by multiple threads concurrently.; * However, different threads may use different decompressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:469,Performance,concurren,concurrently,469,"/*; * libdeflate_alloc_decompressor() allocates a new decompressor that can be used; * for DEFLATE, zlib, and gzip decompression. The return value is a pointer to; * the new decompressor, or NULL if out of memory.; *; * This function takes no parameters, and the returned decompressor is valid for; * decompressing data that was compressed at any compression level and with any; * sliding window size.; *; * A single decompressor is not safe to use by multiple threads concurrently.; * However, different threads may use different decompressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:545,Performance,concurren,concurrently,545,"/*; * libdeflate_alloc_decompressor() allocates a new decompressor that can be used; * for DEFLATE, zlib, and gzip decompression. The return value is a pointer to; * the new decompressor, or NULL if out of memory.; *; * This function takes no parameters, and the returned decompressor is valid for; * decompressing data that was compressed at any compression level and with any; * sliding window size.; *; * A single decompressor is not safe to use by multiple threads concurrently.; * However, different threads may use different decompressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:437,Safety,safe,safe,437,"/*; * libdeflate_alloc_decompressor() allocates a new decompressor that can be used; * for DEFLATE, zlib, and gzip decompression. The return value is a pointer to; * the new decompressor, or NULL if out of memory.; *; * This function takes no parameters, and the returned decompressor is valid for; * decompressing data that was compressed at any compression level and with any; * sliding window size.; *; * A single decompressor is not safe to use by multiple threads concurrently.; * However, different threads may use different decompressors concurrently.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:65,Integrability,wrap,wrapper,65,"/*; * Like libdeflate_deflate_decompress(), but assumes the zlib wrapper format; * instead of raw DEFLATE.; *; * Decompression will stop at the end of the zlib stream, even if it is shorter; * than 'in_nbytes'. If you need to know exactly where the zlib stream ended,; * use libdeflate_zlib_decompress_ex().; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:65,Integrability,wrap,wrapper,65,"/*; * Like libdeflate_deflate_decompress(), but assumes the gzip wrapper format; * instead of raw DEFLATE.; *; * If multiple gzip-compressed members are concatenated, then only the first; * will be decompressed. Use libdeflate_gzip_decompress_ex() if you need; * multi-member support.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:67,Energy Efficiency,allocate,allocated,67,"/*; * libdeflate_free_decompressor() frees a decompressor that was allocated with; * libdeflate_alloc_decompressor(). If a NULL pointer is passed in, no action; * is taken.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:208,Deployability,update,updates,208,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:288,Deployability,update,updated,288,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:85,Security,Checksum,Checksums,85,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:235,Security,checksum,checksum,235,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:296,Security,checksum,checksum,296,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:326,Security,checksum,checksum,326,"/* ========================================================================== */; /* Checksums */; /* ========================================================================== */; /*; * libdeflate_adler32() updates a running Adler-32 checksum with 'len' bytes of; * data and returns the updated checksum. When starting a new checksum, the; * required initial value for 'adler' is 1. This value is also returned when; * 'buffer' is specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:25,Deployability,update,updates,25,"/*; * libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data; * and returns the updated checksum. When starting a new checksum, the required; * initial value for 'crc' is 0. This value is also returned when 'buffer' is; * specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:103,Deployability,update,updated,103,"/*; * libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data; * and returns the updated checksum. When starting a new checksum, the required; * initial value for 'crc' is 0. This value is also returned when 'buffer' is; * specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:50,Security,checksum,checksum,50,"/*; * libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data; * and returns the updated checksum. When starting a new checksum, the required; * initial value for 'crc' is 0. This value is also returned when 'buffer' is; * specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:111,Security,checksum,checksum,111,"/*; * libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data; * and returns the updated checksum. When starting a new checksum, the required; * initial value for 'crc' is 0. This value is also returned when 'buffer' is; * specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:141,Security,checksum,checksum,141,"/*; * libdeflate_crc32() updates a running CRC-32 checksum with 'len' bytes of data; * and returns the updated checksum. When starting a new checksum, the required; * initial value for 'crc' is 0. This value is also returned when 'buffer' is; * specified as NULL.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h:201,Deployability,Install,Install,201,"/* ========================================================================== */; /* Custom memory allocator */; /* ========================================================================== */; /*; * Install a custom memory allocator which libdeflate will use for all memory; * allocations. 'malloc_func' is a function that must behave like malloc(), and; * 'free_func' is a function that must behave like free().; *; * There must not be any libdeflate_compressor or libdeflate_decompressor; * structures in existence when calling this function.; */",MatchSource.CODE_COMMENT,src/libdeflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/libdeflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:14,Modifiability,refactor,refactoring,14,"// TODO: code refactoring to remove these global variables",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:49,Modifiability,variab,variables,49,"// TODO: code refactoring to remove these global variables",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Energy Efficiency,adapt,adapter,3,"// adapter",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Integrability,adapter,adapter,3,"// adapter",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Modifiability,adapt,adapter,3,"// adapter",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Energy Efficiency,adapt,adapter,3,"// adapter cutting",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Integrability,adapter,adapter,3,"// adapter cutting",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp:3,Modifiability,adapt,adapter,3,"// adapter cutting",MatchSource.CODE_COMMENT,src/main.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/main.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Energy Efficiency,adapt,adapter,12,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:44,Energy Efficiency,adapt,adapter,44,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Integrability,adapter,adapter,12,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:44,Integrability,adapter,adapter,44,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Modifiability,adapt,adapter,12,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:44,Modifiability,adapt,adapter,44,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:3,Security,validat,validate,3,"// validate adapter sequence for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:3,Security,validat,validate,3,"// validate bases",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Energy Efficiency,adapt,adapter,12,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:46,Energy Efficiency,adapt,adapter,46,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Integrability,adapter,adapter,12,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:46,Integrability,adapter,adapter,46,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:12,Modifiability,adapt,adapter,12,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:46,Modifiability,adapt,adapter,46,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:3,Security,validat,validate,3,"// validate adapter sequenceR2 for single end adapter trimming",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:3,Security,validat,validate,3,"// validate bases",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp:3,Security,validat,validate,3,"// validate bases",MatchSource.CODE_COMMENT,src/options.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h:10,Modifiability,rewrite,rewrite,10,"// do not rewrite existing files",MatchSource.CODE_COMMENT,src/options.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h:3,Energy Efficiency,adapt,adapter,3,"// adapter options",MatchSource.CODE_COMMENT,src/options.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h:3,Integrability,adapter,adapter,3,"// adapter options",MatchSource.CODE_COMMENT,src/options.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h:3,Modifiability,adapt,adapter,3,"// adapter options",MatchSource.CODE_COMMENT,src/options.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/options.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:33,Energy Efficiency,adapt,adapter,33,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:232,Energy Efficiency,adapt,adapter,232,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:33,Integrability,adapter,adapter,33,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:232,Integrability,adapter,adapter,232,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:33,Modifiability,adapt,adapter,33,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp:232,Modifiability,adapt,adapter,232,"// reverse; // in this case, the adapter is sequenced since TEMPLATE_LEN < SEQ_LEN; // check if distance can get smaller if offset goes negative; // this only happens when insert DNA is shorter than sequencing read length, and some adapter/primer is sequenced but not trimmed cleanly; // we go reversely",MatchSource.CODE_COMMENT,src/overlapanalysis.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/overlapanalysis.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/peprocessor.cpp:3,Modifiability,config,configured,3,"// configured to process only first N reads",MatchSource.CODE_COMMENT,src/peprocessor.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/peprocessor.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/peprocessor.cpp:3,Modifiability,config,configured,3,"// configured to process only first N reads",MatchSource.CODE_COMMENT,src/peprocessor.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/peprocessor.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/read.h:46,Availability,error,error,46,"// merge a pair, without consideration of seq error caused false INDEL",MatchSource.CODE_COMMENT,src/read.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/read.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/readpool.h:29,Energy Efficiency,reduce,reduce,29,"// in-memory pooled Reads to reduce new/delete operations; // for each thread, one SISC list is used",MatchSource.CODE_COMMENT,src/readpool.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/readpool.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/seprocessor.cpp:3,Modifiability,config,configured,3,"// configured to process only first N reads",MatchSource.CODE_COMMENT,src/seprocessor.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/seprocessor.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/singleproducersingleconsumerlist.h:104,Energy Efficiency,charge,charge,104,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */; // A ultra-fast lock-free linked list for single-producer, single-consumer threading; // Memory usage overhead: 3M bytes per list, if you want to save memory, please use smaller block and smaller ring buffer; // The type T is usually a pointer, a internal type (such as int, long), or a class supports assignment T a = b;; /* WARNING: only supports up to 1G unconsumed elements in list, ; which means: produced - consumed must < 1G,; this is usually much more than enough,; but if you want to support even more unconsumed elements, ; please modify the value of blocksRingBufferSize as you want.; */",MatchSource.CODE_COMMENT,src/singleproducersingleconsumerlist.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/singleproducersingleconsumerlist.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/singleproducersingleconsumerlist.h:967,Integrability,CONTRACT,CONTRACT,967,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */; // A ultra-fast lock-free linked list for single-producer, single-consumer threading; // Memory usage overhead: 3M bytes per list, if you want to save memory, please use smaller block and smaller ring buffer; // The type T is usually a pointer, a internal type (such as int, long), or a class supports assignment T a = b;; /* WARNING: only supports up to 1G unconsumed elements in list, ; which means: produced - consumed must < 1G,; this is usually much more than enough,; but if you want to support even more unconsumed elements, ; please modify the value of blocksRingBufferSize as you want.; */",MatchSource.CODE_COMMENT,src/singleproducersingleconsumerlist.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/singleproducersingleconsumerlist.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp:3,Modifiability,extend,extend,3,"// extend the buffer to make sure it's long enough",MatchSource.CODE_COMMENT,src/stats.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp:3,Availability,down,down,3,"// down sampling if it's too long",MatchSource.CODE_COMMENT,src/stats.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp:7,Testability,log,log,7,"// use log plot if it's too long",MatchSource.CODE_COMMENT,src/stats.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp:3,Availability,down,down,3,"// down sampling if it's too long",MatchSource.CODE_COMMENT,src/stats.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp:7,Testability,log,log,7,"// use log plot if it's too long",MatchSource.CODE_COMMENT,src/stats.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/stats.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/threadconfig.cpp:174,Deployability,pipeline,pipelines,174,"// if a task of writting N files is assigned to this thread, but the input file doesn't have so many reads to input; // write some empty files so it will not break following pipelines",MatchSource.CODE_COMMENT,src/threadconfig.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/threadconfig.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.cpp:104,Energy Efficiency,charge,charge,104,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/writer.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.cpp:967,Integrability,CONTRACT,CONTRACT,967,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/writer.cpp,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.cpp
https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.h:104,Energy Efficiency,charge,charge,104,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/writer.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.h:967,Integrability,CONTRACT,CONTRACT,967,"/*; MIT License. Copyright (c) 2021 Shifu Chen <chen@haplox.com>. Permission is hereby granted, free of charge, to any person obtaining a copy; of this software and associated documentation files (the ""Software""), to deal; in the Software without restriction, including without limitation the rights; to use, copy, modify, merge, publish, distribute, sublicense, and/or sell; copies of the Software, and to permit persons to whom the Software is; furnished to do so, subject to the following conditions:. The above copyright notice and this permission notice shall be included in all; copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR; IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,; FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE; AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER; LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE; SOFTWARE.; */",MatchSource.CODE_COMMENT,src/writer.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/writer.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:129,Safety,avoid,avoid,129,"/* define NO_GZIP when compiling if you want to disable gzip header and; trailer creation by deflate(). NO_GZIP would be used to avoid linking in; the crc code when it is not needed. For shared libraries, gzip encoding; should be left enabled. */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:286,Performance,perform,performed,286,"/* Sliding window. Input bytes are read into the second half of the window,; * and move to the first half later to keep a dictionary of at least wSize; * bytes. With this organization, matches are limited to a distance of; * wSize-MAX_MATCH bytes, but this ensures that IO is always; * performed with a length multiple of the block size. Also, it limits; * the window size to 64K, which is quite useful on MSDOS.; * To do: use the user input buffer as sliding window.; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:34,Security,hash,hash,34,"/* Link to older string with same hash index. To limit the size of this; * array to 64K, this link is maintained only for the last 32K strings.; * An index in this array is thus a window index modulo 32K.; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:16,Security,hash,hash,16,/* Heads of the hash chains or NIL. */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:3,Security,hash,hash,3,/* hash index of string to be inserted */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:25,Security,hash,hash,25,/* number of elements in hash table */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:163,Security,hash,hash,163,"/* Number of bits by which ins_h must be shifted at each input; * step. It must be such that after MIN_MATCH steps, the oldest; * byte no longer takes part in the hash key, that is:; * hash_shift * MIN_MATCH >= hash_bits; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:26,Security,hash,hash,26,"/* To speed up deflation, hash chains are never searched beyond this; * length. A higher limit improves compression ratio but degrades the; * speed.; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:29,Security,hash,hash,29,/* Insert new strings in the hash table only if the match length is not; * greater than this length. This saves time but degrades compression.; * max_insert_length is used only for compression levels <= 3.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:686,Energy Efficiency,adapt,adaptation,686,"/* Size of match buffer for literals/lengths. There are 4 reasons for; * limiting lit_bufsize to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input; * data is still in the window so we can still emit a stored block even; * when input comes from standard input. (This can also be done for; * all blocks if lit_bufsize is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * This is applicable only for zip (not gzip or zlib).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting; * trees more frequently.; * - I can't count above 4; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:889,Energy Efficiency,adapt,adaptation,889,"/* Size of match buffer for literals/lengths. There are 4 reasons for; * limiting lit_bufsize to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input; * data is still in the window so we can still emit a stored block even; * when input comes from standard input. (This can also be done for; * all blocks if lit_bufsize is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * This is applicable only for zip (not gzip or zlib).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting; * trees more frequently.; * - I can't count above 4; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:686,Modifiability,adapt,adaptation,686,"/* Size of match buffer for literals/lengths. There are 4 reasons for; * limiting lit_bufsize to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input; * data is still in the window so we can still emit a stored block even; * when input comes from standard input. (This can also be done for; * all blocks if lit_bufsize is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * This is applicable only for zip (not gzip or zlib).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting; * trees more frequently.; * - I can't count above 4; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:889,Modifiability,adapt,adaptation,889,"/* Size of match buffer for literals/lengths. There are 4 reasons for; * limiting lit_bufsize to 64K:; * - frequencies can be kept in 16 bit counters; * - if compression is not successful for the first block, all input; * data is still in the window so we can still emit a stored block even; * when input comes from standard input. (This can also be done for; * all blocks if lit_bufsize is not greater than 32K.); * - if compression is not successful for a file smaller than 64K, we can; * even emit a stored file instead of a stored block (saving 5 bytes).; * This is applicable only for zip (not gzip or zlib).; * - creating new Huffman trees less frequently may not provide fast; * adaptation to changes in the input data statistics. (Take for; * example a binary file with poorly compressible code followed by; * a highly compressible string table.) Smaller buffer sizes give; * fast adaptation but have of course the overhead of transmitting; * trees more frequently.; * - I can't count above 4; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:28,Usability,simpl,simplify,28,"/* Buffer for distances. To simplify the code, d_buf and l_buf have; * the same number of elements. To use different lengths, an extra flag; * array would be necessary.; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:213,Deployability,update,updated,213,/* High water mark offset in window for initialized bytes -- bytes above; * this are set to zero in order to avoid memory check warnings when; * longest match routines access bytes past the input. This is then; * updated to the new high water mark.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:159,Integrability,rout,routines,159,/* High water mark offset in window for initialized bytes -- bytes above; * this are set to zero in order to avoid memory check warnings when; * longest match routines access bytes past the input. This is then; * updated to the new high water mark.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:109,Safety,avoid,avoid,109,/* High water mark offset in window for initialized bytes -- bytes above; * this are set to zero in order to avoid memory check warnings when; * longest match routines access bytes past the input. This is then; * updated to the new high water mark.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:168,Security,access,access,168,/* High water mark offset in window for initialized bytes -- bytes above; * this are set to zero in order to avoid memory check warnings when; * longest match routines access bytes past the input. This is then; * updated to the new high water mark.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:38,Testability,assert,assertion,38,/* Output a byte on the stream.; * IN assertion: there is enough room in pending_buf.; */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:15,Usability,simpl,simplify,15,"/* In order to simplify the code, particularly on 16 bit machines, match; * distances are limited to MAX_DIST instead of WSIZE.; */",MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:95,Availability,error,errors,95,/* Number of bytes after end of data in window to initialize in order to avoid; memory checker errors from longest match routines */; /* in trees.c */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:121,Integrability,rout,routines,121,/* Number of bytes after end of data in window to initialize in order to avoid; memory checker errors from longest match routines */; /* in trees.c */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h:73,Safety,avoid,avoid,73,/* Number of bytes after end of data in window to initialize in order to avoid; memory checker errors from longest match routines */; /* in trees.c */,MatchSource.CODE_COMMENT,src/zlib/deflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/deflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:26,Availability,avail,available,26,"/* In Win32, vsnprintf is available as the ""non-ANSI"" _vsnprintf. */",MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:37,Security,integrity,integrity,37,"/* gzip modes, also provide a little integrity check on the passed structure */",MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:3,Security,expose,exposed,3,/* exposed contents for gzgetc() macro */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:50,Availability,avail,available,50,"/* ""x"" for exposed */; /* x.have: number of bytes available at x.next */; /* x.next: next output data to deliver or write */; /* x.pos: current position in uncompressed data */; /* used for both reading and writing */",MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:11,Security,expose,exposed,11,"/* ""x"" for exposed */; /* x.have: number of bytes available at x.next */; /* x.next: next output data to deliver or write */; /* x.pos: current position in uncompressed data */; /* used for both reading and writing */",MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:18,Availability,error,error,18,/* path or fd for error messages */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:24,Integrability,message,messages,24,/* path or fd for error messages */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:28,Energy Efficiency,allocate,allocated,28,"/* buffer size, zero if not allocated yet */",MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:39,Availability,error,error,39,/* true if seek request pending */; /* error information */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:3,Availability,error,error,3,/* error code */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:3,Availability,error,error,3,/* error message */; /* zlib inflate or deflate stream */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h:9,Integrability,message,message,9,/* error message */; /* zlib inflate or deflate stream */,MatchSource.CODE_COMMENT,src/zlib/gzguts.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/gzguts.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:486,Safety,avoid,avoid,486,"/* inflate.h -- internal inflate state definition; * Copyright (C) 1995-2009 Mark Adler; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* define NO_GZIP when compiling if you want to disable gzip header and; trailer decoding by inflate(). NO_GZIP would be used to avoid linking in; the crc code when it is not needed. For shared libraries, gzip decoding; should be left enabled. */",MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:14,Availability,error,error,14,/* got a data error -- remain here until reset */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:27,Availability,error,error,27,/* got an inflate() memory error -- remain here until reset */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:15,Integrability,synchroniz,synchronization,15,/* looking for synchronization bytes to restart inflate() */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:81,Availability,error,error,81,/*; State transitions between above modes -. (most modes can go to BAD or MEM on error -- not shown for clarity). Process header:; HEAD -> (gzip) or (zlib) or (raw); (gzip) -> FLAGS -> TIME -> OS -> EXLEN -> EXTRA -> NAME -> COMMENT ->; HCRC -> TYPE; (zlib) -> DICTID or TYPE; DICTID -> DICT -> TYPE; (raw) -> TYPEDO; Read deflate blocks:; TYPE -> TYPEDO -> STORED or TABLE or LEN_ or CHECK; STORED -> COPY_ -> COPY -> TYPE; TABLE -> LENLENS -> CODELENS -> LEN_; LEN_ -> LEN; Read deflate codes in fixed or dynamic block:; LEN -> LENEXT or LIT or TYPE; LENEXT -> DIST -> DISTEXT -> MATCH -> LEN; LIT -> LEN; Process trailer:; CHECK -> LENGTH -> DONE; */; /* state maintained between inflate() calls. Approximately 10K bytes. */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:3,Testability,log,log,3,/* log base 2 of requested window size */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:3,Energy Efficiency,allocate,allocated,3,"/* allocated sliding window, if needed */; /* bit accumulator */",MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h:8,Availability,avail,available,8,/* next available space in codes[] */,MatchSource.CODE_COMMENT,src/zlib/inflate.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inflate.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inftrees.h:999,Deployability,update,updated,999,"/* op values as set by inflate_table():; 00000000 - literal; 0000tttt - table link, tttt != 0 is the number of table index bits; 0001eeee - length or distance, eeee is the number of extra bits; 01100000 - end of block; 01000000 - invalid code; */; /* Maximum size of the dynamic table. The maximum number of code structures is; 1444, which is the sum of 852 for literal/length codes and 592 for distance; codes. These values were found by exhaustive searches using the program; examples/enough.c found in the zlib distribtution. The arguments to that; program are the number of symbols, the initial root table size, and the; maximum bit length of a code. ""enough 286 9 15"" for literal/length codes; returns returns 852, and ""enough 30 6 15"" for distance codes returns 592.; The initial root table size (9 or 6) is found in the fifth argument of the; inflate_table() calls in inflate.c and infback.c. If the root table size is; changed, then these maximum sizes would be need to be recalculated and; updated. */",MatchSource.CODE_COMMENT,src/zlib/inftrees.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/inftrees.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:14,Deployability,configurat,configuration,14,"/* zconf.h -- configuration of the zlib compression library; * Copyright (C) 1995-2013 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:14,Modifiability,config,configuration,14,"/* zconf.h -- configuration of the zlib compression library; * Copyright (C) 1995-2013 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:221,Modifiability,config,configure,221,"/*; * If you *really* need a unique prefix for all types and library functions,; * compile with -DZ_PREFIX. The ""standard"" zlib should be compiled without it.; * Even better than compiling with -DZ_PREFIX would be to use configure to set; * this permanently in zconf.h using ""./configure --zprefix"".; */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:278,Modifiability,config,configure,278,"/*; * If you *really* need a unique prefix for all types and library functions,; * compile with -DZ_PREFIX. The ""standard"" zlib should be compiled without it.; * Even better than compiling with -DZ_PREFIX would be to use configure to set; * this permanently in zconf.h using ""./configure --zprefix"".; */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:28,Modifiability,config,configure,28,/* may be set to #if 1 by ./configure */,MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:61,Energy Efficiency,allocate,allocate,61,/*; * Compile with -DMAXSEG_64K if the alloc function cannot allocate more; * than 64k bytes at a time (needed on systems with 16-bit int).; */,MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:243,Energy Efficiency,reduce,reduce,243,"/* The memory requirements for deflate are (in bytes):; (1 << (windowBits+2)) + (1 << (memLevel+9)); that is: 128K for windowBits=15 + 128K for memLevel = 8 (default values); plus a few kilobytes for small objects. For example, if you want to reduce; the default memory requirements from 256K to 128K, compile with; make CFLAGS=""-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7""; Of course this will generally degrade compression (there's no free lunch). The memory requirements for inflate are (in bytes) 1 << windowBits; that is, 32K for windowBits=15 (default value) plus a few kilobytes; for small objects.; */; /* Type declarations */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:153,Testability,test,tested,153,"/* The following definitions for FAR are needed only for MSDOS mixed; * model programming (small or medium model with some far allocations).; * This was tested only with MSC; for other MSDOS compilers you may have; * to define NO_MEMCPY in zutil.h. If you don't need the mixed model,; * just define FAR to be empty.; */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:105,Performance,perform,performance,105,"/* If building or using zlib as a DLL, define ZLIB_DLL.; * This is not mandatory, but it offers a little performance increase.; */",MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:28,Modifiability,config,configure,28,/* may be set to #if 1 by ./configure */,MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h:28,Modifiability,config,configure,28,/* may be set to #if 1 by ./configure */,MatchSource.CODE_COMMENT,src/zlib/zconf.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zconf.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:13,Integrability,interface,interface,13,"/* zlib.h -- interface of the 'zlib' general purpose compression library; version 1.2.8, April 28th, 2013. Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler. This software is provided 'as-is', without any express or implied; warranty. In no event will the authors be held liable for any damages; arising from the use of this software. Permission is granted to anyone to use this software for any purpose,; including commercial applications, and to alter it and redistribute it; freely, subject to the following restrictions:. 1. The origin of this software must not be misrepresented; you must not; claim that you wrote the original software. If you use this software; in a product, an acknowledgment in the product documentation would be; appreciated but is not required.; 2. Altered source versions must be plainly marked as such, and must not be; misrepresented as being the original software.; 3. This notice may not be removed or altered from any source distribution. Jean-loup Gailly Mark Adler; jloup@gzip.org madler@alumni.caltech.edu. The data format used by the zlib library is described by RFCs (Request for; Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950; (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1484,Deployability,install,install,1484,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:300,Integrability,interface,interface,300,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:691,Integrability,wrap,wrapper,691,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:723,Integrability,wrap,wrapped,723,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:879,Integrability,interface,interface,879,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1024,Integrability,wrap,wrapper,1024,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1057,Integrability,wrap,wrapped,1057,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:106,Security,integrity,integrity,106,"/*; The 'zlib' compression library provides in-memory compression and; decompression functions, including integrity checks of the uncompressed data.; This version of the library supports only one compression method (deflation); but other algorithms will be added later and will have the same stream; interface. Compression can be done in a single step if the buffers are large enough,; or can be done by repeated calls of the compression function. In the latter; case, the application must provide more input and/or consume the output; (providing more output space) before each call. The compressed data format used by default by the in-memory functions is; the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped; around a deflate stream, which is itself documented in RFC 1951. The library also supports reading and writing files in gzip (.gz) format; with an interface similar to that of stdio using the functions that start; with ""gz"". The gzip format is different from the zlib format. gzip is a; gzip wrapper, documented in RFC 1952, wrapped around a deflate stream. This library can optionally read and write gzip streams in memory as well. The zlib format was designed to be compact and fast for use in memory; and on communications channels. The gzip format was designed for single-; file compression on file systems, has a larger header than zlib to maintain; directory information, and uses a different, slower check method than zlib. The library does not install any signal handler. The decoder checks; the consistency of the compressed data, so the library should never crash; even in case of corrupted input.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:19,Availability,avail,available,19,/* number of bytes available at next_in */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:8,Availability,error,error,8,"/* last error message, NULL if no error */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:34,Availability,error,error,34,"/* last error message, NULL if no error */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:14,Integrability,message,message,14,"/* last error message, NULL if no error */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:11,Energy Efficiency,allocate,allocate,11,/* used to allocate the internal state */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:52,Integrability,rout,routines,52,/*; gzip header information passed to and from zlib routines. See RFC 1952; for more details on the meanings of these fields.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:25,Deployability,update,update,25,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:97,Deployability,update,update,97,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:325,Deployability,update,updated,325,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:811,Energy Efficiency,allocate,allocate,811,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:870,Energy Efficiency,allocate,allocate,870,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1164,Energy Efficiency,reduce,reduce,1164,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:678,Performance,multi-thread,multi-threaded,678,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:739,Safety,safe,safe,739,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1195,Safety,avoid,avoid,1195,"/*; The application must update next_in and avail_in when avail_in has dropped; to zero. It must update next_out and avail_out when avail_out has dropped; to zero. The application must initialize zalloc, zfree and opaque before; calling the init function. All other fields are set by the compression; library and must not be updated by the application. The opaque value provided by the application will be passed as the first; parameter for calls of zalloc and zfree. This can be useful for custom; memory management. The compression library attaches no meaning to the; opaque value. zalloc must return Z_NULL if there is not enough memory for the object.; If zlib is used in a multi-threaded application, zalloc and zfree must be; thread safe. On 16-bit systems, the functions zalloc and zfree must be able to allocate; exactly 65536 bytes, but will not be required to allocate more than this if; the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS, pointers; returned by zalloc for objects of exactly 65536 bytes *must* have their; offset normalized to zero. The default allocation function provided by this; library ensures this (see zutil.c). To reduce memory requirements and avoid; any allocation of 64K objects, at the expense of compression ratio, compile; the library with -DMAX_WBITS=14 (see zconf.h). The fields total_in and total_out can be used for statistics or progress; reports. After compression, total_in holds the total size of the; uncompressed data and may be saved for use in the decompressor (particularly; if the decompressor wants to decompress everything in a single step).; */; /* constants */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:84,Availability,error,errors,84,"/* Return codes for the compression/decompression functions. Negative values; * are errors, positive values are used for special but normal events.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1224,Availability,error,error,1224,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:540,Deployability,update,updates,540,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1230,Integrability,message,message,1230,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1260,Performance,perform,perform,1260,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:761,Usability,simpl,simply,761,"/* The application can compare zlibVersion and ZLIB_VERSION for consistency.; If the first character differs, the library code actually used is not; compatible with the zlib.h header file used by the application. This check; is automatically made by deflateInit and inflateInit.; */; /*; ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));. Initializes the internal stream state for compression. The fields; zalloc, zfree and opaque must be initialized before by the caller. If; zalloc and zfree are set to Z_NULL, deflateInit updates them to use default; allocation functions. The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:; 1 gives best speed, 9 gives best compression, 0 gives no compression at all; (the input data is simply copied a block at a time). Z_DEFAULT_COMPRESSION; requests a default compromise between speed and compression (currently; equivalent to level 6). deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if level is not a valid compression level, or; Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible; with the version assumed by the caller (ZLIB_VERSION). msg is set to null; if there is no error message. deflateInit does not perform any compression:; this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1916,Availability,avail,available,1916,"ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output space has been; provided before the call.) Flushing may degrade compression for some; compression algorithms and so it should be used only when necessary. This; completes the current deflate block and follows it with an empty stored block; that is three bits plus filler bits to the next byte, followed by four bytes; (00 00 ff ff). If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the; output buffer, but the output is not aligned to a byte boundary. All of the; input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.; This completes the current deflate block and follows it with an empty fixed; codes block that is 10 bits long. This assures that enough bytes are output; in order for the decompressor to finish the block before the empty fixed code; block. If flush is set to Z_BLOC",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2509,Availability,avail,available,2509,"there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output space has been; provided before the call.) Flushing may degrade compression for some; compression algorithms and so it should be used only when necessary. This; completes the current deflate block and follows it with an empty stored block; that is three bits plus filler bits to the next byte, followed by four bytes; (00 00 ff ff). If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the; output buffer, but the output is not aligned to a byte boundary. All of the; input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.; This completes the current deflate block and follows it with an empty fixed; codes block that is 10 bits long. This assures that enough bytes are output; in order for the decompressor to finish the block before the empty fixed code; block. If flush is set to Z_BLOCK, a deflate block is completed and emitted, as; for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to; seven bits of the current block are held to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; ",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4435,Availability,error,error,4435,"e next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affec",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:386,Deployability,update,update,386,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:545,Deployability,update,updated,545,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:674,Deployability,update,update,674,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3824,Deployability,update,updated,3824,"ck. If flush is set to Z_BLOCK, a deflate block is completed and emitted, as; for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to; seven bits of the current block are held to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_ST",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4350,Deployability,update,updated,4350,"e next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affec",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5054,Deployability,update,update,5054,"il the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affect the; compression algorithm in any manner. deflate() returns Z_OK if some progress has been made (more input; processed or more output produced), Z_STREAM_END if all input has been; consumed and all output has been produced (only when flush is set to; Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example; if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible; (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not; fatal, and deflate() can be called again with more input and more output; space to continue compressing.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:161,Performance,latency,latency,161,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:291,Performance,perform,performs,291,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4013,Safety,avoid,avoid,4013," to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all in",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3598,Security,access,access,3598,"o far will be available to the decompressor, as for Z_SYNC_FLUSH.; This completes the current deflate block and follows it with an empty fixed; codes block that is 10 bits long. This assures that enough bytes are output; in order for the decompressor to finish the block before the empty fixed code; block. If flush is set to Z_BLOCK, a deflate block is completed and emitted, as; for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to; seven bits of the current block are held to be written as the next byte after; the next deflate block is completed. In this case, the decompressor may not; be provided enough bits at this point in order to complete decompression of; the data provided so far to the compressor. It may need to wait for the next; block to be emitted. This is for advanced applications that need to control; the emission of deflate blocks. If flush is set to Z_FULL_FLUSH, all output is flushed as with; Z_SYNC_FLUSH, and the compression state is reset so that decompression can; restart from this point if previous compressed data has been damaged or if; random access is desired. Using Z_FULL_FLUSH too often can seriously degrade; compression. If deflate returns with avail_out == 0, this function must be called again; with the same value of the flush parameter and more output space (updated; avail_out), until the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only po",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4978,Security,checksum,checksum,4978,"il the flush is complete (deflate returns with non-zero; avail_out). In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that; avail_out is greater than six to avoid repeated flush markers due to; avail_out == 0 on return. If the parameter flush is set to Z_FINISH, pending input is processed,; pending output is flushed and deflate returns with Z_STREAM_END if there was; enough output space; if deflate returns with Z_OK, this function must be; called again with Z_FINISH and more output space (updated avail_out) but no; more input data, until it returns with Z_STREAM_END or an error. After; deflate has returned Z_STREAM_END, the only possible operations on the stream; are deflateReset or deflateEnd. Z_FINISH can be used immediately after deflateInit if all the compression; is to be done in a single step. In this case, avail_out must be at least the; value returned by deflateBound (see below). Then deflate is guaranteed to; return Z_STREAM_END. If not enough output space is provided, deflate will; not return Z_STREAM_END, and it must be called again as described above. deflate() sets strm->adler to the adler32 checksum of all input read; so far (that is, total_in bytes). deflate() may update strm->data_type if it can make a good guess about; the input data type (Z_BINARY or Z_TEXT). In doubt, the data is considered; binary. This field is only for information purposes and does not affect the; compression algorithm in any manner. deflate() returns Z_OK if some progress has been made (more input; processed or more output produced), Z_STREAM_END if all input has been; consumed and all output has been produced (only when flush is set to; Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example; if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible; (for example avail_in or avail_out was zero). Note that Z_BUF_ERROR is not; fatal, and deflate() can be called again with more input and more output; space to continue compressing.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:574,Usability,resume,resume,574,"/*; deflate compresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. deflate performs one or both of the; following actions:. - Compress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in and avail_in are updated and; processing will resume at this point for the next call of deflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. This action is forced if the parameter flush is non zero.; Forcing flush frequently degrades the compression ratio, so this parameter; should be set only when necessary (in interactive applications). Some; output may be provided even if flush is not set. Before the call of deflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating avail_in or avail_out accordingly; avail_out should; never be zero before the call. The application can consume the compressed; output when it wants, for example when the output buffer is full (avail_out; == 0), or after each call of deflate(). If deflate returns Z_OK and with; zero avail_out, it must be called again after making room in the output; buffer because there might be more output pending. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to; decide how much data to accumulate before producing output, in order to; maximize compression. If the parameter flush is set to Z_SYNC_FLUSH, all pending output is; flushed to the output buffer and the output is aligned on a byte boundary, so; that the decompressor can get all input data available so far. (In; particular avail_in is zero after the call if enough output sp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:344,Availability,error,error,344,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1369,Availability,error,error,1369,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1009,Deployability,update,updates,1009,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:20,Energy Efficiency,allocate,allocated,20,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:841,Energy Efficiency,allocate,allocates,841,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:733,Integrability,depend,depends,733,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1375,Integrability,message,message,1375,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1405,Performance,perform,perform,1405,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the; stream state was inconsistent, Z_DATA_ERROR if the stream was freed; prematurely (some input or output was discarded). In the error case, msg; may be set but then points to a static string (which must not be; deallocated).; */; /*; ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));. Initializes the internal stream state for decompression. The fields; next_in, avail_in, zalloc, zfree and opaque must be initialized before by; the caller. If next_in is not Z_NULL and avail_in is large enough (the; exact value depends on the compression method), inflateInit determines the; compression method from the zlib header and allocates all data structures; accordingly; otherwise the allocation will be deferred to the first call of; inflate. If zalloc and zfree are set to Z_NULL, inflateInit updates them to; use default allocation functions. inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit() does not process any header information -- that is deferred; until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3430,Availability,error,error,3430,"header up to just before the first byte of the deflate; stream. The end-of-block will not be indicated until all of the uncompressed; data from that block has been written to strm->next_out. The number of; unused bits may in general be greater than seven, except when bit 7 of; data_type is set, in which case the number of unused bits will be less than; eight. data_type is set as noted here every time inflate() returns for all; flush options, and so can be used to determine the amount of currently; consumed input in bits. The Z_TREES option behaves as Z_BLOCK does, but it also returns when the; end of each deflate block header is reached, before any actual data in that; block is decoded. This allows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5207,Availability,error,error,5207,"lso informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progre",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:6932,Availability,recover,recovery,6932," Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() can be called again with more input and more output space to; continue decompressing. If Z_DATA_ERROR is returned, the application may; then call inflateSync() to look for a good compression block if a partial; recovery of the data is desired.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:390,Deployability,update,update,390,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:535,Deployability,update,updated,535,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:664,Deployability,update,update,664,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4130,Energy Efficiency,reduce,reduces,4130,"lows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4320,Energy Efficiency,allocate,allocated,4320,"mmediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its com",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5465,Integrability,wrap,wrapped,5465,"ways flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsisten",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5481,Integrability,wrap,wrapped,5481,"ways flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsisten",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5870,Integrability,wrap,wrapped,5870,"see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() can be called again with more input and more output space to; continue decompressing. If Z_DATA_ERROR is returned, the application may; then call inflateSync() to look for a good com",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:163,Performance,latency,latency,163,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:293,Performance,perform,performs,293,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3475,Performance,perform,performed,3475,"ll of the uncompressed; data from that block has been written to strm->next_out. The number of; unused bits may in general be greater than seven, except when bit 7 of; data_type is set, in which case the number of unused bits will be less than; eight. data_type is set as noted here every time inflate() returns for all; flush options, and so can be used to determine the amount of currently; consumed input in bits. The Z_TREES option behaves as Z_BLOCK does, but it also returns when the; end of each deflate block header is reached, before any actual data in that; block is decoded. This allows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3892,Performance,perform,perform,3892," currently; consumed input in bits. The Z_TREES option behaves as Z_BLOCK does, but it also returns when the; end of each deflate block header is reached, before any actual data in that; block is decoded. This allows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed af",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5787,Performance,perform,perform,5787," when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() ca",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4776,Safety,avoid,avoids,4776,"ressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; i",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5523,Safety,detect,detected,5523,"pproach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:6932,Safety,recover,recovery,6932," Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupted (input stream not conforming to the zlib format or incorrect check; value), Z_STREAM_ERROR if the stream structure was inconsistent (for example; next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,; Z_BUF_ERROR if no progress is possible or if there was not enough room in the; output buffer when Z_FINISH is used. Note that Z_BUF_ERROR is not fatal, and; inflate() can be called again with more input and more output space to; continue decompressing. If Z_DATA_ERROR is returned, the application may; then call inflateSync() to look for a good compression block if a partial; recovery of the data is desired.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3192,Security,access,access,3192,"sed bits in the last byte taken from strm->next_in, plus 64 if; inflate() is currently decoding the last block in the deflate stream, plus; 128 if inflate() returned immediately after decoding an end-of-block code or; decoding the complete header up to just before the first byte of the deflate; stream. The end-of-block will not be indicated until all of the uncompressed; data from that block has been written to strm->next_out. The number of; unused bits may in general be greater than seven, except when bit 7 of; data_type is set, in which case the number of unused bits will be less than; eight. data_type is set as noted here every time inflate() returns for all; flush options, and so can be used to determine the amount of currently; consumed input in bits. The Z_TREES option behaves as Z_BLOCK does, but it also returns when the; end of each deflate block header is reached, before any actual data in that; block is decoded. This allows the caller to determine the length of the; deflate block header for later use in random access within a deflate block.; 256 is added to the value of strm->data_type when inflate() returns; immediately after reaching the end of the deflate block header. inflate() should normally be called until it returns Z_STREAM_END or an; error. However if all decompression is to be performed in a single step (a; single call of inflate), the parameter flush should be set to Z_FINISH. In; this case all pending input is processed and all pending output is flushed;; avail_out must be large enough to hold all of the uncompressed data for the; operation to complete. (The size of the uncompressed data may have been; saved by the compressor for this purpose.) The use of Z_FINISH is not; required to perform an inflation in one step. However it may be used to; inform inflate that a faster approach can be used for the single inflate(); call. Z_FINISH also informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory fo",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4978,Security,checksum,checksum,4978,"lso informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progre",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5103,Security,checksum,checksum,5103,"lso informs inflate to not maintain a sliding window if the; stream completes, which reduces inflate's memory footprint. If the stream; does not complete, either because not all of the stream is provided or not; enough output space is provided, then a sliding window will be allocated and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progre",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5309,Security,checksum,checksum,5309,"ed and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupte",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:5397,Security,checksum,checksum,5397,"ed and; inflate() can be called again to continue the operation as if Z_NO_FLUSH had; been used. In this implementation, inflate() always flushes as much output as; possible to the output buffer, and always uses the faster approach on the; first call. So the effects of the flush parameter in this implementation are; on the return value of inflate() as noted below, when inflate() returns early; when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of; memory for a sliding window when Z_FINISH is used. If a preset dictionary is needed after this call (see inflateSetDictionary; below), inflate sets strm->adler to the Adler-32 checksum of the dictionary; chosen by the compressor and returns Z_NEED_DICT; otherwise it sets; strm->adler to the Adler-32 checksum of all output produced so far (that is,; total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described; below. At the end of the stream, inflate() checks that its computed adler32; checksum is equal to that saved by the compressor and returns Z_STREAM_END; only if the checksum is correct. inflate() can decompress and check either zlib-wrapped or gzip-wrapped; deflate data. The header type is detected automatically, if requested when; initializing with inflateInit2(). Any information contained in the gzip; header is not retained, so applications that need that information should; instead use raw inflate, see inflateInit2() below, or inflateBack() and; perform their own processing of the gzip header and trailer. When processing; gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output; producted so far. The CRC-32 is checked against the gzip trailer. inflate() returns Z_OK if some progress has been made (more input processed; or more output produced), Z_STREAM_END if the end of the compressed data has; been reached and all uncompressed output has been produced, Z_NEED_DICT if a; preset dictionary is needed at this point, Z_DATA_ERROR if the input data was; corrupte",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:564,Usability,resume,resume,564,"/*; inflate decompresses as much data as possible, and stops when the input; buffer becomes empty or the output buffer becomes full. It may introduce; some output latency (reading input without producing any output) except when; forced to flush. The detailed semantics are as follows. inflate performs one or both of the; following actions:. - Decompress more input starting at next_in and update next_in and avail_in; accordingly. If not all input can be processed (because there is not; enough room in the output buffer), next_in is updated and processing will; resume at this point for the next call of inflate(). - Provide more output starting at next_out and update next_out and avail_out; accordingly. inflate() provides as much output as possible, until there is; no more input data or no more space in the output buffer (see below about; the flush parameter). Before the call of inflate(), the application should ensure that at least; one of the actions is possible, by providing more input and/or consuming more; output, and updating the next_* and avail_* values accordingly. The; application can consume the uncompressed output when it wants, for example; when the output buffer is full (avail_out == 0), or after each call of; inflate(). If inflate returns Z_OK and with zero avail_out, it must be; called again after making room in the output buffer because there might be; more output pending. The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,; Z_BLOCK, or Z_TREES. Z_SYNC_FLUSH requests that inflate() flush as much; output as possible to the output buffer. Z_BLOCK requests that inflate(); stop if and when it gets to the next deflate block boundary. When decoding; the zlib or gzip format, this will cause inflate() to return immediately; after the header and before the first block. When doing a raw inflate,; inflate() will go ahead and process the first block, and will return when it; gets to the end of that block, or when it runs out of data. The Z_BLO",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:256,Availability,error,error,256,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state; was inconsistent. In the error case, msg may be set but then points to a; static string (which must not be deallocated).; */; /* Advanced functions */; /*; The following functions are needed only in some special applications.; */; /*; ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,; int level,; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3495,Availability,error,error,3495,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:20,Energy Efficiency,allocate,allocated,20,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state; was inconsistent. In the error case, msg may be set but then points to a; static string (which must not be deallocated).; */; /* Advanced functions */; /*; The following functions are needed only in some special applications.; */; /*; ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,; int level,; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1907,Energy Efficiency,allocate,allocated,1907,"arithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PN",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2002,Energy Efficiency,reduce,reduces,2002,"e library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed ",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1582,Integrability,wrap,wrapper,1582,"; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small valu",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3501,Integrability,message,message,3501,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2216,Performance,tune,tune,2216,"aw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2615,Performance,tune,tuned,2615,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3532,Performance,perform,perform,3532,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2345,Safety,predict,predictor,2345,"l not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library ve",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:897,Testability,log,logarithm,897,"/*; All dynamically allocated data structures for this stream are freed.; This function discards any unprocessed input and does not flush any pending; output. inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state; was inconsistent. In the error case, msg may be set but then points to a; static string (which must not be deallocated).; */; /* Advanced functions */; /*; The following functions are needed only in some special applications.; */; /*; ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,; int level,; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1505,Usability,simpl,simple,1505,"; int method,; int windowBits,; int memLevel,; int strategy));. This is another version of deflateInit with more compression options. The; fields next_in, zalloc, zfree and opaque must be initialized before by the; caller. The method parameter is the compression method. It must be Z_DEFLATED in; this version of the library. The windowBits parameter is the base two logarithm of the window size; (the size of the history buffer). It should be in the range 8..15 for this; version of the library. Larger values of this parameter result in better; compression at the expense of memory usage. The default value is 15 if; deflateInit is used instead. windowBits can also be -8..-15 for raw deflate. In this case, -windowBits; determines the window size. deflate() will then generate raw deflate data; with no zlib header or trailer, and will not compute an adler32 check value. windowBits can also be greater than 15 for optional gzip encoding. Add; 16 to windowBits to write a simple gzip header and trailer around the; compressed data instead of a zlib wrapper. The gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small valu",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3127,Usability,simpl,simpler,3127,"e gzip header will have no; file name, no extra data, no comment, no modification time (set to zero), no; header crc, and the operating system will be set to 255 (unknown). If a; gzip stream is being written, strm->adler is a crc32 instead of an adler32. The memLevel parameter specifies how much memory should be allocated; for the internal compression state. memLevel=1 uses minimum memory but is; slow and reduces compression ratio; memLevel=9 uses maximum memory for; optimal speed. The default value is 8. See zconf.h for total memory usage; as a function of windowBits and memLevel. The strategy parameter is used to tune the compression algorithm. Use the; value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a; filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no; string match), or Z_RLE to limit match distances to one (run-length; encoding). Filtered data consists mostly of small values with a somewhat; random distribution. In this case, the compression algorithm is tuned to; compress them better. The effect of Z_FILTERED is to force more Huffman; coding and less string matching; it is somewhat intermediate between; Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY. Z_RLE is designed to be almost as; fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data. The; strategy parameter only affects the compression ratio but not the; correctness of the compressed output even if it is not set appropriately.; Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler; decoder for special applications. deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid; method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is; incompatible with the version assumed by the caller (ZLIB_VERSION). msg is; set to null if there is no error message. deflateInit2 does not perform any; compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1092,Integrability,Depend,Depending,1092," deflateReset, and before any call of deflate. When doing raw deflate, this; function must be called either before any call of deflate, or immediately; after the completion of a deflate block, i.e. after all input has been; consumed and all output has been delivered when using any of the flush; options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The; compressor and decompressor must use exactly the same dictionary (see; inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size; provided in deflateInit or deflateInit2. Thus the strings most likely to be; useful should be put at the end of the dictionary, not at the front. In; addition, the current implementation of deflate will use at most the window; size minus 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is not set. deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a; parameter is invalid (e.g. dictionary being Z_NULL) or the stream state is; inconsistent (for example if deflate has already been called for",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2312,Performance,perform,perform,2312,"fter the completion of a deflate block, i.e. after all input has been; consumed and all output has been delivered when using any of the flush; options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The; compressor and decompressor must use exactly the same dictionary (see; inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size; provided in deflateInit or deflateInit2. Thus the strings most likely to be; useful should be put at the end of the dictionary, not at the front. In; addition, the current implementation of deflate will use at most the window; size minus 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is not set. deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a; parameter is invalid (e.g. dictionary being Z_NULL) or the stream state is; inconsistent (for example if deflate has already been called for this stream; or if not at a block boundary for raw deflate). deflateSetDictionary does; not perform any compression: this will be done by deflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:982,Safety,predict,predicted,982,"/*; Initializes the compression dictionary from the given byte sequence; without producing any compressed output. When using the zlib format, this; function must be called immediately after deflateInit, deflateInit2 or; deflateReset, and before any call of deflate. When doing raw deflate, this; function must be called either before any call of deflate, or immediately; after the completion of a deflate block, i.e. after all input has been; consumed and all output has been delivered when using any of the flush; options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH. The; compressor and decompressor must use exactly the same dictionary (see; inflateSetDictionary). The dictionary should consist of strings (byte sequences) that are likely; to be encountered later in the data to be compressed, with the most commonly; used strings preferably put towards the end of the dictionary. Using a; dictionary is most useful when the data to be compressed is short and can be; predicted with good accuracy; the data can then be compressed better than; with the default empty dictionary. Depending on the size of the compression data structures selected by; deflateInit or deflateInit2, a part of the dictionary may in effect be; discarded, for example if the dictionary is larger than the window size; provided in deflateInit or deflateInit2. Thus the strings most likely to be; useful should be put at the end of the dictionary, not at the front. In; addition, the current implementation of deflate will use at most the window; size minus 262 bytes of the provided dictionary. Upon return of this function, strm->adler is set to the adler32 value; of the dictionary; the decompressor may later use this value to determine; which dictionary has been used by the compressor. (The adler32 value; applies to the whole dictionary even if only a subset of the dictionary is; actually used by the compressor.) If a raw deflate was requested, then the; adler32 value is not computed and strm->adler is n",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:349,Availability,avail,available,349,"/*; Dynamically update the compression level and compression strategy. The; interpretation of level and strategy is as in deflateInit2. This can be; used to switch between compression and straight copy of the input data, or; to switch to a different kind of input data requiring a different strategy.; If the compression level is changed, the input available so far is; compressed with the old level (and may be flushed); the new level will take; effect only at the next call of deflate(). Before the call of deflateParams, the stream state must be set as for; a call of deflate(), since the currently available input may have to be; compressed and flushed. In particular, strm->avail_out must be non-zero. deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source; stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if; strm->avail_out was zero.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:602,Availability,avail,available,602,"/*; Dynamically update the compression level and compression strategy. The; interpretation of level and strategy is as in deflateInit2. This can be; used to switch between compression and straight copy of the input data, or; to switch to a different kind of input data requiring a different strategy.; If the compression level is changed, the input available so far is; compressed with the old level (and may be flushed); the new level will take; effect only at the next call of deflate(). Before the call of deflateParams, the stream state must be set as for; a call of deflate(), since the currently available input may have to be; compressed and flushed. In particular, strm->avail_out must be non-zero. deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source; stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if; strm->avail_out was zero.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:16,Deployability,update,update,16,"/*; Dynamically update the compression level and compression strategy. The; interpretation of level and strategy is as in deflateInit2. This can be; used to switch between compression and straight copy of the input data, or; to switch to a different kind of input data requiring a different strategy.; If the compression level is changed, the input available so far is; compressed with the old level (and may be flushed); the new level will take; effect only at the next call of deflate(). Before the call of deflateParams, the stream state must be set as for; a call of deflate(), since the currently available input may have to be; compressed and flushed. In particular, strm->avail_out must be non-zero. deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source; stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if; strm->avail_out was zero.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:9,Performance,tune,tune,9,"/*; Fine tune deflate's internal compression parameters. This should only be; used by someone who understands the algorithm used by zlib's deflate for; searching for the best matching string, and even then only by the most; fanatic optimizer trying to squeeze out the last compressed bit for their; specific input data. Read the deflate.c source code for the meaning of the; max_lazy, good_length, nice_length, and max_chain parameters. deflateTune() can be called after deflateInit() or deflateInit2(), and; returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:232,Performance,optimiz,optimizer,232,"/*; Fine tune deflate's internal compression parameters. This should only be; used by someone who understands the algorithm used by zlib's deflate for; searching for the best matching string, and even then only by the most; fanatic optimizer trying to squeeze out the last compressed bit for their; specific input data. Read the deflate.c source code for the meaning of the; max_lazy, good_length, nice_length, and max_chain parameters. deflateTune() can be called after deflateInit() or deflateInit2(), and; returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:222,Energy Efficiency,allocate,allocate,222,"/*; deflateBound() returns an upper bound on the compressed size after; deflation of sourceLen bytes. It must be called after deflateInit() or; deflateInit2(), and after deflateSetHeader(), if used. This would be used; to allocate an output buffer for deflation in a single pass, and so would be; called before deflate(). If that first deflate() call is provided the; sourceLen input bytes, an output buffer allocated to the size returned by; deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed; to return Z_STREAM_END. Note that it is possible for the compressed size to; be larger than the value returned by deflateBound() if flush options other; than Z_FINISH or Z_NO_FLUSH are used.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:408,Energy Efficiency,allocate,allocated,408,"/*; deflateBound() returns an upper bound on the compressed size after; deflation of sourceLen bytes. It must be called after deflateInit() or; deflateInit2(), and after deflateSetHeader(), if used. This would be used; to allocate an output buffer for deflation in a single pass, and so would be; called before deflate(). If that first deflate() call is provided the; sourceLen input bytes, an output buffer allocated to the size returned by; deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed; to return Z_STREAM_END. Note that it is possible for the compressed size to; be larger than the value returned by deflateBound() if flush options other; than Z_FINISH or Z_NO_FLUSH are used.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:123,Availability,avail,available,123,"/*; deflatePending() returns the number of bytes and bits of output that have; been generated, but not yet provided in the available output. The bytes not; provided would be due to the available output space having being consumed.; The number of bits of output not provided are between 0 and 7, where they; await more bits to join them in order to fill out a full byte. If pending; or bits are Z_NULL, then those values are not set. deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:185,Availability,avail,available,185,"/*; deflatePending() returns the number of bytes and bits of output that have; been generated, but not yet provided in the available output. The bytes not; provided would be due to the available output space having being consumed.; The number of bits of output not provided are between 0 and 7, where they; await more bits to join them in order to fill out a full byte. If pending; or bits are Z_NULL, then those values are not set. deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:595,Availability,avail,available,595,"/*; deflateSetHeader() provides gzip header information for when a gzip; stream is requested by deflateInit2(). deflateSetHeader() may be called; after deflateInit2() or deflateReset() and before the first call of; deflate(). The text, time, os, extra field, name, and comment information; in the provided gz_header structure are written to the gzip header (xflag is; ignored -- the extra flags are set according to the compression level). The; caller must assure that, if not Z_NULL, name and comment are terminated with; a zero byte, and that if extra is not Z_NULL, that extra_len bytes are; available there. If hcrc is true, a gzip header crc is included. Note that; the current versions of the command-line version of gzip (up through version; 1.3.x) do not support header crc's, and will report that it is a ""multi-part; gzip file"" and give up. If deflateSetHeader is not used, the default gzip header has text false,; the time set to zero, and os set to 255, with no extra, name, or comment; fields. The gzip header is returned to the default state by deflateReset(). deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,; int windowBits));. This is another version of inflateInit with an extra parameter. The; fields next_in, avail_in, zalloc, zfree and opaque must be initialized; before by the caller. The windowBits parameter is the base two logarithm of the maximum window; size (the size of the history buffer). It should be in the range 8..15 for; this version of the library. The default value is 15 if inflateInit is used; instead. windowBits must be greater than or equal to the windowBits value; provided to deflateInit2() while compressing, or it must be equal to 15 if; deflateInit2() was not used. If a compressed stream with a larger window; size is given as input, inflate() will return with the error code; Z_DATA_ERROR instead of trying to allocate a larger wind",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1933,Availability,error,error,1933,"alse,; the time set to zero, and os set to 255, with no extra, name, or comment; fields. The gzip header is returned to the default state by deflateReset(). deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,; int windowBits));. This is another version of inflateInit with an extra parameter. The; fields next_in, avail_in, zalloc, zfree and opaque must be initialized; before by the caller. The windowBits parameter is the base two logarithm of the maximum window; size (the size of the history buffer). It should be in the range 8..15 for; this version of the library. The default value is 15 if inflateInit is used; instead. windowBits must be greater than or equal to the windowBits value; provided to deflateInit2() while compressing, or it must be equal to 15 if; deflateInit2() was not used. If a compressed stream with a larger window; size is given as input, inflate() will return with the error code; Z_DATA_ERROR instead of trying to allocate a larger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() appli",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3589,Availability,error,error,3589,"rger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is a; crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit2 does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit2() does not process any header information -- that is; deferred until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1979,Energy Efficiency,allocate,allocate,1979,"alse,; the time set to zero, and os set to 255, with no extra, name, or comment; fields. The gzip header is returned to the default state by deflateReset(). deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,; int windowBits));. This is another version of inflateInit with an extra parameter. The; fields next_in, avail_in, zalloc, zfree and opaque must be initialized; before by the caller. The windowBits parameter is the base two logarithm of the maximum window; size (the size of the history buffer). It should be in the range 8..15 for; this version of the library. The default value is 15 if inflateInit is used; instead. windowBits must be greater than or equal to the windowBits value; provided to deflateInit2() while compressing, or it must be equal to 15 if; deflateInit2() was not used. If a compressed stream with a larger window; size is given as input, inflate() will return with the error code; Z_DATA_ERROR instead of trying to allocate a larger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() appli",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3595,Integrability,message,message,3595,"rger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is a; crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit2 does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit2() does not process any header information -- that is; deferred until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3626,Performance,perform,perform,3626,"rger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is a; crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit2 does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit2() does not process any header information -- that is; deferred until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3098,Safety,detect,detection,3098,"rger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate compressed data format; such as zip. Those formats provide their own check values. If a custom; format is developed using the raw deflate format for compressed data, it is; recommended that a check value such as an adler32 or a crc32 be applied to; the uncompressed data as is done in the zlib, gzip, and zip formats. For; most applications, the zlib format should be used as is. Note that comments; above on the use in deflateInit2() applies to the magnitude of windowBits. windowBits can also be greater than 15 for optional gzip decoding. Add; 32 to windowBits to enable zlib and gzip decoding with automatic header; detection, or add 16 to decode only the gzip format (the zlib format will; return a Z_DATA_ERROR). If a gzip stream is being decoded, strm->adler is a; crc32 instead of an adler32. inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough; memory, Z_VERSION_ERROR if the zlib library version is incompatible with the; version assumed by the caller, or Z_STREAM_ERROR if the parameters are; invalid, such as a null pointer to the structure. msg is set to null if; there is no error message. inflateInit2 does not perform any decompression; apart from possibly reading the zlib header if present: actual decompression; will be done by inflate(). (So next_in and avail_in may be modified, but; next_out and avail_out are unused and unchanged.) The current implementation; of inflateInit2() does not process any header information -- that is; deferred until inflate() is called.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1467,Testability,log,logarithm,1467,"LL, name and comment are terminated with; a zero byte, and that if extra is not Z_NULL, that extra_len bytes are; available there. If hcrc is true, a gzip header crc is included. Note that; the current versions of the command-line version of gzip (up through version; 1.3.x) do not support header crc's, and will report that it is a ""multi-part; gzip file"" and give up. If deflateSetHeader is not used, the default gzip header has text false,; the time set to zero, and os set to 255, with no extra, name, or comment; fields. The gzip header is returned to the default state by deflateReset(). deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,; int windowBits));. This is another version of inflateInit with an extra parameter. The; fields next_in, avail_in, zalloc, zfree and opaque must be initialized; before by the caller. The windowBits parameter is the base two logarithm of the maximum window; size (the size of the history buffer). It should be in the range 8..15 for; this version of the library. The default value is 15 if inflateInit is used; instead. windowBits must be greater than or equal to the windowBits value; provided to deflateInit2() while compressing, or it must be equal to 15 if; deflateInit2() was not used. If a compressed stream with a larger window; size is given as input, inflate() will return with the error code; Z_DATA_ERROR instead of trying to allocate a larger window. windowBits can also be zero to request that inflate use the window size in; the zlib header of the compressed stream. windowBits can also be -8..-15 for raw inflate. In this case, -windowBits; determines the window size. inflate() will then process raw deflate data,; not looking for a zlib or gzip header, not generating a check value, and not; looking for any check values for comparison at the end of the stream. This; is for use with other formats that use the deflate comp",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1014,Performance,perform,perform,1014,"/*; Initializes the decompression dictionary from the given uncompressed byte; sequence. This function must be called immediately after a call of inflate,; if that call returned Z_NEED_DICT. The dictionary chosen by the compressor; can be determined from the adler32 value returned by that call of inflate.; The compressor and decompressor must use exactly the same dictionary (see; deflateSetDictionary). For raw inflate, this function can be called at any; time to set the dictionary. If the provided dictionary is smaller than the; window and there is already data in the window, then the provided dictionary; will amend what's there. The application must insure that the dictionary; that was used for compression is provided. inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a; parameter is invalid (e.g. dictionary being Z_NULL) or the stream state is; inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the; expected one (incorrect adler32 value). inflateSetDictionary does not; perform any decompression: this will be done by subsequent calls of; inflate().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:158,Availability,avail,available,158,"/*; Skips invalid compressed data until a possible full flush point (see above; for the description of deflate with Z_FULL_FLUSH) can be found, or until all; available input is skipped. No output is provided. inflateSync searches for a 00 00 FF FF pattern in the compressed data.; All full flush points have this pattern, but not all occurrences of this; pattern are full flush points. inflateSync returns Z_OK if a possible full flush point has been found,; Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point; has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.; In the success case, the application may save the current current value of; total_in which indicates where valid compressed data was found. In the; error case, the application may repeatedly call inflateSync, providing more; input each time, until success or end of the input data.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:759,Availability,error,error,759,"/*; Skips invalid compressed data until a possible full flush point (see above; for the description of deflate with Z_FULL_FLUSH) can be found, or until all; available input is skipped. No output is provided. inflateSync searches for a 00 00 FF FF pattern in the compressed data.; All full flush points have this pattern, but not all occurrences of this; pattern are full flush points. inflateSync returns Z_OK if a possible full flush point has been found,; Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point; has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.; In the success case, the application may save the current current value of; total_in which indicates where valid compressed data was found. In the; error case, the application may repeatedly call inflateSync, providing more; input each time, until success or end of the input data.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:115,Security,access,accessing,115,"/*; Sets the destination stream as a complete copy of the source stream. This function can be useful when randomly accessing a large stream. The; first pass through the stream can periodically record the inflate state,; allowing restarting inflate at those points when randomly accessing the; stream. inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_STREAM_ERROR if the source stream state was inconsistent; (such as zalloc being Z_NULL). msg is left unchanged in both source and; destination.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:278,Security,access,accessing,278,"/*; Sets the destination stream as a complete copy of the source stream. This function can be useful when randomly accessing a large stream. The; first pass through the stream can periodically record the inflate state,; allowing restarting inflate at those points when randomly accessing the; stream. inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_STREAM_ERROR if the source stream state was inconsistent; (such as zalloc being Z_NULL). msg is left unchanged in both source and; destination.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:81,Integrability,wrap,wrap,81,"/*; This function is the same as inflateReset, but it also permits changing; the wrap and window size requests. The windowBits parameter is interpreted; the same as it is for inflateInit2. inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent (such as zalloc or state being Z_NULL), or if; the windowBits parameter is invalid.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:657,Usability,clear,clear,657,"/*; This function inserts bits in the inflate input stream. The intent is; that this function is used to start inflating at a bit position in the; middle of a byte. The provided bits will be used before any bytes are used; from next_in. This function should only be used with raw inflate, and; should be used before the first inflate() call after inflateInit2() or; inflateReset(). bits must be less than or equal to 16, and that many of the; least significant bits of value will be inserted in the input. If bits is negative, then the input stream bit buffer is emptied. Then; inflatePrime() can be called again to put bits in the buffer. This is used; to clear out bits leftover after feeding inflate a block description prior; to feeding inflate codes. inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:167,Availability,down,down,167,"/*; This function returns two values, one in the lower 16 bits of the return; value, and the other in the remaining upper bits, obtained by shifting the; return value down 16 bits. If the upper value is -1 and the lower value is; zero, then inflate() is currently decoding information outside of a block.; If the upper value is -1 and the lower value is non-zero, then inflate is in; the middle of a stored block, with the lower value equaling the number of; bytes from the input remaining to copy. If the upper value is not -1, then; it is the number of bits back from the current bit position in the input of; the code (literal or length/distance pair) currently being processed. In; that case the lower value is the number of bytes already emitted for that; code. A code is being processed if inflate is waiting for more input to complete; decoding of the code, or if it has completed decoding but is waiting for; more output space to write the literal or match data. inflateMark() is used to mark locations in the input data for random; access, which may be at bit positions, and to note those cases where the; output of a code may span boundaries of random access blocks. The current; location in the input stream can be determined from avail_in and data_type; as noted in the description for the Z_BLOCK flush parameter for inflate. inflateMark returns the value noted above or -1 << 16 if the provided; source stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1041,Security,access,access,1041,"/*; This function returns two values, one in the lower 16 bits of the return; value, and the other in the remaining upper bits, obtained by shifting the; return value down 16 bits. If the upper value is -1 and the lower value is; zero, then inflate() is currently decoding information outside of a block.; If the upper value is -1 and the lower value is non-zero, then inflate is in; the middle of a stored block, with the lower value equaling the number of; bytes from the input remaining to copy. If the upper value is not -1, then; it is the number of bits back from the current bit position in the input of; the code (literal or length/distance pair) currently being processed. In; that case the lower value is the number of bytes already emitted for that; code. A code is being processed if inflate is waiting for more input to complete; decoding of the code, or if it has completed decoding but is waiting for; more output space to write the literal or match data. inflateMark() is used to mark locations in the input data for random; access, which may be at bit positions, and to note those cases where the; output of a code may span boundaries of random access blocks. The current; location in the input stream can be determined from avail_in and data_type; as noted in the description for the Z_BLOCK flush parameter for inflate. inflateMark returns the value noted above or -1 << 16 if the provided; source stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1162,Security,access,access,1162,"/*; This function returns two values, one in the lower 16 bits of the return; value, and the other in the remaining upper bits, obtained by shifting the; return value down 16 bits. If the upper value is -1 and the lower value is; zero, then inflate() is currently decoding information outside of a block.; If the upper value is -1 and the lower value is non-zero, then inflate is in; the middle of a stored block, with the lower value equaling the number of; bytes from the input remaining to copy. If the upper value is not -1, then; it is the number of bits back from the current bit position in the input of; the code (literal or length/distance pair) currently being processed. In; that case the lower value is the number of bytes already emitted for that; code. A code is being processed if inflate is waiting for more input to complete; decoding of the code, or if it has completed decoding but is waiting for; more output space to write the literal or match data. inflateMark() is used to mark locations in the input data for random; access, which may be at bit positions, and to note those cases where the; output of a code may span boundaries of random access blocks. The current; location in the input stream can be determined from avail_in and data_type; as noted in the description for the Z_BLOCK flush parameter for inflate. inflateMark returns the value noted above or -1 << 16 if the provided; source stream state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1685,Energy Efficiency,allocate,allocated,1685,"er; contents. hcrc is set to true if there is a header CRC. (The header CRC; was valid if done is set to one.) If extra is not Z_NULL, then extra_max; contains the maximum number of bytes to write to extra. Once done is true,; extra_len contains the actual extra field length, and extra contains the; extra field, or that field truncated if extra_max is less than extra_len.; If name is not Z_NULL, then up to name_max characters are written there,; terminated with a zero unless the length is greater than name_max. If; comment is not Z_NULL, then up to comm_max characters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window ",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3181,Energy Efficiency,allocate,allocated,3181,"aracters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window is a caller; supplied buffer of that size. Except for special applications where it is; assured that deflate was used with small window sizes, windowBits must be 15; and a 32K byte window must be supplied to be able to decompress general; deflate streams. See inflateBack() for the usage of these routines. inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of; the parameters are invalid, Z_MEM_ERROR if the internal state could not be; allocated, or Z_VERSION_ERROR if the version of the library does not match; the version of the header file.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2623,Integrability,rout,routines,2623,"aracters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window is a caller; supplied buffer of that size. Except for special applications where it is; assured that deflate was used with small window sizes, windowBits must be 15; and a 32K byte window must be supplied to be able to decompress general; deflate streams. See inflateBack() for the usage of these routines. inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of; the parameters are invalid, Z_MEM_ERROR if the internal state could not be; allocated, or Z_VERSION_ERROR if the version of the library does not match; the version of the header file.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3024,Integrability,rout,routines,3024,"aracters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window is a caller; supplied buffer of that size. Except for special applications where it is; assured that deflate was used with small window sizes, windowBits must be 15; and a 32K byte window must be supplied to be able to decompress general; deflate streams. See inflateBack() for the usage of these routines. inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of; the parameters are invalid, Z_MEM_ERROR if the internal state could not be; allocated, or Z_VERSION_ERROR if the version of the library does not match; the version of the header file.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2670,Testability,log,logarithm,2670,"aracters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window is a caller; supplied buffer of that size. Except for special applications where it is; assured that deflate was used with small window sizes, windowBits must be 15; and a 32K byte window must be supplied to be able to decompress general; deflate streams. See inflateBack() for the usage of these routines. inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of; the parameters are invalid, Z_MEM_ERROR if the internal state could not be; allocated, or Z_VERSION_ERROR if the version of the library does not match; the version of the header file.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1870,Usability,simpl,simply,1870,"is not Z_NULL, then extra_max; contains the maximum number of bytes to write to extra. Once done is true,; extra_len contains the actual extra field length, and extra contains the; extra field, or that field truncated if extra_max is less than extra_len.; If name is not Z_NULL, then up to name_max characters are written there,; terminated with a zero unless the length is greater than name_max. If; comment is not Z_NULL, then up to comm_max characters are written there,; terminated with a zero unless the length is greater than comm_max. When any; of extra, name, or comment are not Z_NULL and the respective field is not; present in the header, then that field is set to Z_NULL to signal its; absence. This allows the use of deflateSetHeader() with the returned; structure to duplicate the header. However if those fields are set to; allocated memory, then the application will need to save those pointers; elsewhere so that they can be eventually freed. If inflateGetHeader is not used, then the header information is simply; discarded. The header is always checked for validity, including the header; CRC if present. inflateReset() will reset the process to discard the header; information. The application would need to call inflateGetHeader() again to; retrieve the header from the next gzip stream. inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source; stream state was inconsistent.; */; /*; ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,; unsigned char FAR *window));. Initialize the internal stream state for decompression using inflateBack(); calls. The fields zalloc, zfree and opaque in strm must be initialized; before the call. If zalloc and zfree are Z_NULL, then the default library-; derived memory allocation routines are used. windowBits is the base two; logarithm of the window size, in the range 8..15. window is a caller; supplied buffer of that size. Except for special applications where it is; assured that deflate was used wi",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1559,Availability,error,error,1559,"t until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provid",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1827,Availability,avail,available,1827,"p header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1930,Availability,error,error,1930,"p header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2085,Availability,failure,failure,2085,"iler on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and o",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:2156,Availability,error,error,2156," stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be ",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3491,Availability,error,error,3491,"out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be optionally used to pass any information that the caller-; supplied in() and out() functions need to do their job. On return, inflateBack() will set strm->next_in and strm->avail_in to; pass back any unused input that was provided by the last in() call. The; return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR; if in() or out() returned an error, Z_DATA_ERROR if there was a format error; in the deflate stream (in which case strm->msg is set to indicate the nature; of the error), or Z_STREAM_ERROR if the stream was not properly initialized.; In the case of Z_BUF_ERROR, an input or output error can be distinguished; using strm->next_in which will be Z_NULL only if in() returned an error. If; strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning; non-zero. (in() will always be called before out(), so strm->next_in is; assured to be defined if out() returns non-zero.) Note that inflateBack(); cannot return Z_OK.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3533,Availability,error,error,3533,"out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be optionally used to pass any information that the caller-; supplied in() and out() functions need to do their job. On return, inflateBack() will set strm->next_in and strm->avail_in to; pass back any unused input that was provided by the last in() call. The; return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR; if in() or out() returned an error, Z_DATA_ERROR if there was a format error; in the deflate stream (in which case strm->msg is set to indicate the nature; of the error), or Z_STREAM_ERROR if the stream was not properly initialized.; In the case of Z_BUF_ERROR, an input or output error can be distinguished; using strm->next_in which will be Z_NULL only if in() returned an error. If; strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning; non-zero. (in() will always be called before out(), so strm->next_in is; assured to be defined if out() returns non-zero.) Note that inflateBack(); cannot return Z_OK.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3625,Availability,error,error,3625,"out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be optionally used to pass any information that the caller-; supplied in() and out() functions need to do their job. On return, inflateBack() will set strm->next_in and strm->avail_in to; pass back any unused input that was provided by the last in() call. The; return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR; if in() or out() returned an error, Z_DATA_ERROR if there was a format error; in the deflate stream (in which case strm->msg is set to indicate the nature; of the error), or Z_STREAM_ERROR if the stream was not properly initialized.; In the case of Z_BUF_ERROR, an input or output error can be distinguished; using strm->next_in which will be Z_NULL only if in() returned an error. If; strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning; non-zero. (in() will always be called before out(), so strm->next_in is; assured to be defined if out() returns non-zero.) Note that inflateBack(); cannot return Z_OK.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3743,Availability,error,error,3743,"out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be optionally used to pass any information that the caller-; supplied in() and out() functions need to do their job. On return, inflateBack() will set strm->next_in and strm->avail_in to; pass back any unused input that was provided by the last in() call. The; return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR; if in() or out() returned an error, Z_DATA_ERROR if there was a format error; in the deflate stream (in which case strm->msg is set to indicate the nature; of the error), or Z_STREAM_ERROR if the stream was not properly initialized.; In the case of Z_BUF_ERROR, an input or output error can be distinguished; using strm->next_in which will be Z_NULL only if in() returned an error. If; strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning; non-zero. (in() will always be called before out(), so strm->next_in is; assured to be defined if out() returns non-zero.) Note that inflateBack(); cannot return Z_OK.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3837,Availability,error,error,3837,"out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provided input on the first call by; setting strm->next_in and strm->avail_in. If that input is exhausted, then; in() will be called. Therefore strm->next_in must be initialized before; calling inflateBack(). If strm->next_in is Z_NULL, then in() will be called; immediately for input. If strm->next_in is not Z_NULL, then strm->avail_in; must also be initialized, and then if strm->avail_in is not zero, input will; initially be taken from strm->next_in[0 .. strm->avail_in - 1]. The in_desc and out_desc parameters of inflateBack() is passed as the; first parameter of in() and out() respectively when they are called. These; descriptors can be optionally used to pass any information that the caller-; supplied in() and out() functions need to do their job. On return, inflateBack() will set strm->next_in and strm->avail_in to; pass back any unused input that was provided by the last in() call. The; return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR; if in() or out() returned an error, Z_DATA_ERROR if there was a format error; in the deflate stream (in which case strm->msg is set to indicate the nature; of the error), or Z_STREAM_ERROR if the stream was not properly initialized.; In the case of Z_BUF_ERROR, an input or output error can be distinguished; using strm->next_in which will be Z_NULL only if in() returned an error. If; strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning; non-zero. (in() will always be called before out(), so strm->next_in is; assured to be defined if out() returns non-zero.) Note that inflateBack(); cannot return Z_OK.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:132,Energy Efficiency,efficient,efficient,132,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:560,Energy Efficiency,allocate,allocate,560,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:806,Energy Efficiency,allocate,allocated,806,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:75,Integrability,interface,interface,75,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:897,Integrability,rout,routine,897,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1090,Integrability,rout,routine,1090,"terface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1437,Integrability,rout,routines,1437,"t until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the uncompressed data buf[0..len-1]. out(); should return zero on success, or non-zero on failure. If out() returns; non-zero, inflateBack() will return with an error. Neither in() nor out(); are permitted to change the contents of the window provided to; inflateBackInit(), which is also the buffer that out() uses to write from.; The length written by out() will be at most the window size. Any non-zero; amount of input may be provided by in(). For convenience, inflateBack() can be provid",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:196,Safety,avoid,avoids,196,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:257,Usability,simpl,simply,257,"/*; inflateBack() does a raw inflate with a single call using a call-back; interface for input and output. This is potentially more efficient than; inflate() for file i/o applications, in that it avoids copying between the; output and the sliding window by simply making the window itself the output; buffer. inflate() can be faster on modern CPUs when used with large; buffers. inflateBack() trusts the application to not change the output; buffer passed by the output function, at least until inflateBack() returns. inflateBackInit() must be called first to allocate the internal state; and to initialize the state with the user-provided window buffer.; inflateBack() may then be used multiple times to inflate a complete, raw; deflate stream with each call. inflateBackEnd() is then called to free the; allocated state. A raw deflate stream is one with no zlib or gzip header or trailer.; This routine would normally be used in a utility that reads zip or gzip; files and writes out uncompressed files. The utility would decode the; header and process the trailer on its own, hence this routine expects only; the raw deflate stream to decompress. This is different from the normal; behavior of inflate(), which expects either a zlib or gzip header and; trailer around the deflate stream. inflateBack() uses two subroutines supplied by the caller that are then; called by inflateBack() for input and output. inflateBack() calls those; routines until it reads a complete deflate stream and writes out all of the; uncompressed data, or until it encounters an error. The function's; parameters and return types are defined above in the in_func and out_func; typedefs. inflateBack() will call in(in_desc, &buf) which should return the; number of bytes of provided input, and a pointer to that input in buf. If; there is no input available, in() must return zero--buf is ignored in that; case--and inflateBack() will return a buffer error. inflateBack() will call; out(out_desc, buf, len) to write the un",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:15,Energy Efficiency,allocate,allocated,15,"/*; All memory allocated by inflateBackInit() is freed. inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream; state was inconsistent.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:444,Safety,safe,safe,444,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:721,Safety,avoid,avoid,721,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:834,Safety,detect,detect,834,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:870,Safety,avoid,avoid,870,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1314,Security,secur,secure,1314,"/* Return flags indicating compile-time options. Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:; 1.0: size of uInt; 3.2: size of uLong; 5.4: size of voidpf (pointer); 7.6: size of z_off_t. Compiler, assembler, and debug options:; 8: DEBUG; 9: ASMV or ASMINF -- use ASM code; 10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention; 11: 0 (reserved). One-time table building (smaller code, but not thread-safe if true):; 12: BUILDFIXED -- build static block decoding tables when needed; 13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed; 14,15: 0 (reserved). Library content (indicates missing functionality):; 16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking; deflate code when not needed); 17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect; and decode gzip streams (to avoid linking crc code); 18-19: 0 (reserved). Operation variations (changes in library functionality):; 20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate; 21: FASTEST -- deflate algorithm with only one, lowest compression level; 22,23: 0 (reserved). The sprintf variant used by gzprintf (zero is best):; 24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format; 25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!; 26: 0 = returns value, 1 = void -- 1 means inferred string length returned. Remainder:; 27-31: 0 (reserved); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:141,Integrability,interface,interface,141,"/* utility functions */; /*; The following utility functions are implemented on top of the basic; stream-oriented functions. To simplify the interface, some default options; are assumed (compression level and memory usage, standard memory allocation; functions). The source code of these utility functions can be modified if; you need special options.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:128,Usability,simpl,simplify,128,"/* utility functions */; /*; The following utility functions are implemented on top of the basic; stream-oriented functions. To simplify the interface, some default options; are assumed (compression level and memory usage, standard memory allocation; functions). The source code of these utility functions can be modified if; you need special options.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:180,Energy Efficiency,allocate,allocate,180,/*; compressBound() returns an upper bound on the compressed size after; compress() or compress2() on sourceLen bytes. It would be used before a; compress() or compress2() call to allocate the destination buffer.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:965,Integrability,interface,interface,965,"/*; Decompresses the source buffer into the destination buffer. sourceLen is; the byte length of the source buffer. Upon entry, destLen is the total size; of the destination buffer, which must be large enough to hold the entire; uncompressed data. (The size of the uncompressed data must have been saved; previously by the compressor and transmitted to the decompressor by some; mechanism outside the scope of this compression library.) Upon exit, destLen; is the actual size of the uncompressed buffer. uncompress returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_BUF_ERROR if there was not enough room in the output; buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete. In; the case where there is not enough room, uncompress() will fill the output; buffer with the uncompressed data up to that point.; */; /* gzip file access functions */; /*; This library supports reading and writing files in gzip (.gz) format with; an interface similar to that of stdio, using the functions that start with; ""gz"". The gzip format is different from the zlib format. gzip is a gzip; wrapper, documented in RFC 1952, wrapped around a deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1111,Integrability,wrap,wrapper,1111,"/*; Decompresses the source buffer into the destination buffer. sourceLen is; the byte length of the source buffer. Upon entry, destLen is the total size; of the destination buffer, which must be large enough to hold the entire; uncompressed data. (The size of the uncompressed data must have been saved; previously by the compressor and transmitted to the decompressor by some; mechanism outside the scope of this compression library.) Upon exit, destLen; is the actual size of the uncompressed buffer. uncompress returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_BUF_ERROR if there was not enough room in the output; buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete. In; the case where there is not enough room, uncompress() will fill the output; buffer with the uncompressed data up to that point.; */; /* gzip file access functions */; /*; This library supports reading and writing files in gzip (.gz) format with; an interface similar to that of stdio, using the functions that start with; ""gz"". The gzip format is different from the zlib format. gzip is a gzip; wrapper, documented in RFC 1952, wrapped around a deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1144,Integrability,wrap,wrapped,1144,"/*; Decompresses the source buffer into the destination buffer. sourceLen is; the byte length of the source buffer. Upon entry, destLen is the total size; of the destination buffer, which must be large enough to hold the entire; uncompressed data. (The size of the uncompressed data must have been saved; previously by the compressor and transmitted to the decompressor by some; mechanism outside the scope of this compression library.) Upon exit, destLen; is the actual size of the uncompressed buffer. uncompress returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_BUF_ERROR if there was not enough room in the output; buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete. In; the case where there is not enough room, uncompress() will fill the output; buffer with the uncompressed data up to that point.; */; /* gzip file access functions */; /*; This library supports reading and writing files in gzip (.gz) format with; an interface similar to that of stdio, using the functions that start with; ""gz"". The gzip format is different from the zlib format. gzip is a gzip; wrapper, documented in RFC 1952, wrapped around a deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:862,Security,access,access,862,"/*; Decompresses the source buffer into the destination buffer. sourceLen is; the byte length of the source buffer. Upon entry, destLen is the total size; of the destination buffer, which must be large enough to hold the entire; uncompressed data. (The size of the uncompressed data must have been saved; previously by the compressor and transmitted to the decompressor by some; mechanism outside the scope of this compression library.) Upon exit, destLen; is the actual size of the uncompressed buffer. uncompress returns Z_OK if success, Z_MEM_ERROR if there was not; enough memory, Z_BUF_ERROR if there was not enough room in the output; buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete. In; the case where there is not enough room, uncompress() will fill the output; buffer with the uncompressed data up to that point.; */; /* gzip file access functions */; /*; This library supports reading and writing files in gzip (.gz) format with; an interface similar to that of stdio, using the functions that start with; ""gz"". The gzip format is different from the zlib format. gzip is a gzip; wrapper, documented in RFC 1952, wrapped around a deflate stream.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:780,Availability,error,error,780,"/* semi-opaque gzip file descriptor */; /*; ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));. Opens a gzip (.gz) file for reading or writing. The mode parameter is as; in fopen (""rb"" or ""wb"") but can also include a compression level (""wb9"") or; a strategy: 'f' for filtered data as in ""wb6f"", 'h' for Huffman-only; compression as in ""wb1h"", 'R' for run-length encoding as in ""wb1R"", or 'F'; for fixed code compression as in ""wb9F"". (See the description of; deflateInit2 for more information about the strategy parameter.) 'T' will; request transparent writing or appending with no compression and not using; the gzip format. ""a"" can be used instead of ""w"" to request that the gzip stream that will; be written be appended to the file. ""+"" will result in an error, since; reading and writing to the same gzip file is not supported. The addition of; ""x"" when writing will create the file exclusively, which fails if the file; already exists. On systems that support it, the addition of ""e"" when; reading or writing will set the flag to close the file on an execve() call. These functions, as well as gzip, will read and decode a sequence of gzip; streams in a file. The append function of gzopen() can be used to create; such a file. (Also see gzflush() for another way to do this.) When; appending, gzopen does not test whether the file begins with a gzip stream,; nor does it look for the end of the gzip streams to begin appending. gzopen; will simply append a gzip stream to the existing file. gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. When; reading, this will be detected automatically by looking for the magic two-; byte gzip header. gzopen returns NULL if the file could not be opened, if there was; insufficient memory to allocate the gzFile state, or if an invalid mode was; specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).; errno can be checked to de",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1849,Energy Efficiency,allocate,allocate,1849,"nst char *path, const char *mode));. Opens a gzip (.gz) file for reading or writing. The mode parameter is as; in fopen (""rb"" or ""wb"") but can also include a compression level (""wb9"") or; a strategy: 'f' for filtered data as in ""wb6f"", 'h' for Huffman-only; compression as in ""wb1h"", 'R' for run-length encoding as in ""wb1R"", or 'F'; for fixed code compression as in ""wb9F"". (See the description of; deflateInit2 for more information about the strategy parameter.) 'T' will; request transparent writing or appending with no compression and not using; the gzip format. ""a"" can be used instead of ""w"" to request that the gzip stream that will; be written be appended to the file. ""+"" will result in an error, since; reading and writing to the same gzip file is not supported. The addition of; ""x"" when writing will create the file exclusively, which fails if the file; already exists. On systems that support it, the addition of ""e"" when; reading or writing will set the flag to close the file on an execve() call. These functions, as well as gzip, will read and decode a sequence of gzip; streams in a file. The append function of gzopen() can be used to create; such a file. (Also see gzflush() for another way to do this.) When; appending, gzopen does not test whether the file begins with a gzip stream,; nor does it look for the end of the gzip streams to begin appending. gzopen; will simply append a gzip stream to the existing file. gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. When; reading, this will be detected automatically by looking for the magic two-; byte gzip header. gzopen returns NULL if the file could not be opened, if there was; insufficient memory to allocate the gzFile state, or if an invalid mode was; specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).; errno can be checked to determine if the reason gzopen failed was that the; file could not be opened.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1687,Safety,detect,detected,1687,"nst char *path, const char *mode));. Opens a gzip (.gz) file for reading or writing. The mode parameter is as; in fopen (""rb"" or ""wb"") but can also include a compression level (""wb9"") or; a strategy: 'f' for filtered data as in ""wb6f"", 'h' for Huffman-only; compression as in ""wb1h"", 'R' for run-length encoding as in ""wb1R"", or 'F'; for fixed code compression as in ""wb9F"". (See the description of; deflateInit2 for more information about the strategy parameter.) 'T' will; request transparent writing or appending with no compression and not using; the gzip format. ""a"" can be used instead of ""w"" to request that the gzip stream that will; be written be appended to the file. ""+"" will result in an error, since; reading and writing to the same gzip file is not supported. The addition of; ""x"" when writing will create the file exclusively, which fails if the file; already exists. On systems that support it, the addition of ""e"" when; reading or writing will set the flag to close the file on an execve() call. These functions, as well as gzip, will read and decode a sequence of gzip; streams in a file. The append function of gzopen() can be used to create; such a file. (Also see gzflush() for another way to do this.) When; appending, gzopen does not test whether the file begins with a gzip stream,; nor does it look for the end of the gzip streams to begin appending. gzopen; will simply append a gzip stream to the existing file. gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. When; reading, this will be detected automatically by looking for the magic two-; byte gzip header. gzopen returns NULL if the file could not be opened, if there was; insufficient memory to allocate the gzFile state, or if an invalid mode was; specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).; errno can be checked to determine if the reason gzopen failed was that the; file could not be opened.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1337,Testability,test,test,1337,"nst char *path, const char *mode));. Opens a gzip (.gz) file for reading or writing. The mode parameter is as; in fopen (""rb"" or ""wb"") but can also include a compression level (""wb9"") or; a strategy: 'f' for filtered data as in ""wb6f"", 'h' for Huffman-only; compression as in ""wb1h"", 'R' for run-length encoding as in ""wb1R"", or 'F'; for fixed code compression as in ""wb9F"". (See the description of; deflateInit2 for more information about the strategy parameter.) 'T' will; request transparent writing or appending with no compression and not using; the gzip format. ""a"" can be used instead of ""w"" to request that the gzip stream that will; be written be appended to the file. ""+"" will result in an error, since; reading and writing to the same gzip file is not supported. The addition of; ""x"" when writing will create the file exclusively, which fails if the file; already exists. On systems that support it, the addition of ""e"" when; reading or writing will set the flag to close the file on an execve() call. These functions, as well as gzip, will read and decode a sequence of gzip; streams in a file. The append function of gzopen() can be used to create; such a file. (Also see gzflush() for another way to do this.) When; appending, gzopen does not test whether the file begins with a gzip stream,; nor does it look for the end of the gzip streams to begin appending. gzopen; will simply append a gzip stream to the existing file. gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. When; reading, this will be detected automatically by looking for the magic two-; byte gzip header. gzopen returns NULL if the file could not be opened, if there was; insufficient memory to allocate the gzFile state, or if an invalid mode was; specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).; errno can be checked to determine if the reason gzopen failed was that the; file could not be opened.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1469,Usability,simpl,simply,1469,"nst char *path, const char *mode));. Opens a gzip (.gz) file for reading or writing. The mode parameter is as; in fopen (""rb"" or ""wb"") but can also include a compression level (""wb9"") or; a strategy: 'f' for filtered data as in ""wb6f"", 'h' for Huffman-only; compression as in ""wb1h"", 'R' for run-length encoding as in ""wb1R"", or 'F'; for fixed code compression as in ""wb9F"". (See the description of; deflateInit2 for more information about the strategy parameter.) 'T' will; request transparent writing or appending with no compression and not using; the gzip format. ""a"" can be used instead of ""w"" to request that the gzip stream that will; be written be appended to the file. ""+"" will result in an error, since; reading and writing to the same gzip file is not supported. The addition of; ""x"" when writing will create the file exclusively, which fails if the file; already exists. On systems that support it, the addition of ""e"" when; reading or writing will set the flag to close the file on an execve() call. These functions, as well as gzip, will read and decode a sequence of gzip; streams in a file. The append function of gzopen() can be used to create; such a file. (Also see gzflush() for another way to do this.) When; appending, gzopen does not test whether the file begins with a gzip stream,; nor does it look for the end of the gzip streams to begin appending. gzopen; will simply append a gzip stream to the existing file. gzopen can be used to read a file which is not in gzip format; in this; case gzread will directly read from the file without decompression. When; reading, this will be detected automatically by looking for the magic two-; byte gzip header. gzopen returns NULL if the file could not be opened, if there was; insufficient memory to allocate the gzFile state, or if an invalid mode was; specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).; errno can be checked to determine if the reason gzopen failed was that the; file could not be opened.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:899,Energy Efficiency,allocate,allocate,899,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:510,Safety,avoid,avoid,510,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:674,Safety,avoid,avoid,674,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1150,Safety,detect,detect,1150,"/*; gzdopen associates a gzFile with the file descriptor fd. File descriptors; are obtained from calls like open, dup, creat, pipe or fileno (if the file; has been previously opened with fopen). The mode parameter is as in gzopen. The next call of gzclose on the returned gzFile will also close the file; descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor; fd. If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,; mode);. The duplicated descriptor should be saved to avoid a leak, since; gzdopen does not close fd if it fails. If you are using fileno() to get the; file descriptor from a FILE *, then you will have to use dup() to avoid; double-close()ing the file descriptor. Both gzclose() and fclose() will; close the associated file descriptor, so they need to have different file; descriptors. gzdopen returns NULL if there was insufficient memory to allocate the; gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not; provided, or '+' was provided), or if fd is -1. The file descriptor is not; used until the next gz* read, write, seek, or close operation, so gzdopen; will not detect if fd is invalid (unless fd is -1).; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:680,Availability,failure,failure,680,"/*; Set the internal buffer size used by this library's functions. The; default buffer size is 8192 bytes. This function must be called after; gzopen() or gzdopen(), and before any other calls that read or write the; file. The buffer memory allocation is always deferred to the first read or; write. Two buffers are allocated, either both of the specified size when; writing, or one of the specified size and the other twice that size when; reading. A larger buffer size of, for example, 64K or 128K bytes will; noticeably increase the speed of decompression (reading). The new buffer size also affects the maximum length for gzprintf(). gzbuffer() returns 0 on success, or -1 on failure, such as being called; too late.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:316,Energy Efficiency,allocate,allocated,316,"/*; Set the internal buffer size used by this library's functions. The; default buffer size is 8192 bytes. This function must be called after; gzopen() or gzdopen(), and before any other calls that read or write the; file. The buffer memory allocation is always deferred to the first read or; write. Two buffers are allocated, either both of the specified size when; writing, or one of the specified size and the other twice that size when; reading. A larger buffer size of, for example, 64K or 128K bytes will; noticeably increase the speed of decompression (reading). The new buffer size also affects the maximum length for gzprintf(). gzbuffer() returns 0 on success, or -1 on failure, such as being called; too late.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:16,Deployability,update,update,16,"/*; Dynamically update the compression level or strategy. See the description; of deflateInit2 for the meaning of these parameters. gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not; opened for writing.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:552,Availability,error,error,552,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:712,Availability,avail,available,712,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:736,Availability,error,error,736,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1136,Availability,error,error,1136,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1437,Availability,error,error,1437,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:625,Performance,concurren,concurrently,625,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1313,Safety,detect,detect,1313,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:823,Usability,clear,clear,823,"/*; Reads the given number of uncompressed bytes from the compressed file. If; the input file is not in gzip format, gzread copies the given number of; bytes into the buffer directly from the file. After reaching the end of a gzip stream in the input, gzread will continue; to read, looking for another gzip stream. Any number of gzip streams may be; concatenated in the input file, and will all be decompressed by gzread().; If something other than a gzip stream is encountered after a gzip stream,; that remaining trailing garbage is ignored (and no error is returned). gzread can be used to read a gzip file that is being concurrently written.; Upon reaching the end of the input, gzread will return with the available; data. If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then; gzclearerr can be used to clear the end of file indicator in order to permit; gzread to be tried again. Z_OK indicates that a gzip stream was completed; on the last gzread. Z_BUF_ERROR indicates that the input file ended in the; middle of a gzip stream. Note that gzread does not return -1 in the event; of an incomplete gzip stream. This error is deferred until gzclose(), which; will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip; stream. Alternatively, gzerror can be used before gzclose to detect this; case. gzread returns the number of uncompressed bytes actually read, less than; len for end of file, or -1 for error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:151,Availability,error,error,151,/*; Writes the given number of uncompressed bytes into the compressed file.; gzwrite returns the number of uncompressed bytes written or 0 in case of; error.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:208,Availability,error,error,208,"/*; Converts, formats, and writes the arguments to the compressed file under; control of the format string, as in fprintf. gzprintf returns the number of; uncompressed bytes actually written, or 0 in case of error. The number of; uncompressed bytes written is limited to 8191, or one less than the buffer; size given to gzbuffer(). The caller should assure that this limit is not; exceeded. If it is exceeded, then gzprintf() will return an error (0) with; nothing written. In this case, there may also be a buffer overflow with; unpredictable consequences, which is possible only if zlib was compiled with; the insecure functions sprintf() or vsprintf() because the secure snprintf(); or vsnprintf() functions were not available. This can be determined using; zlibCompileFlags().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:441,Availability,error,error,441,"/*; Converts, formats, and writes the arguments to the compressed file under; control of the format string, as in fprintf. gzprintf returns the number of; uncompressed bytes actually written, or 0 in case of error. The number of; uncompressed bytes written is limited to 8191, or one less than the buffer; size given to gzbuffer(). The caller should assure that this limit is not; exceeded. If it is exceeded, then gzprintf() will return an error (0) with; nothing written. In this case, there may also be a buffer overflow with; unpredictable consequences, which is possible only if zlib was compiled with; the insecure functions sprintf() or vsprintf() because the secure snprintf(); or vsnprintf() functions were not available. This can be determined using; zlibCompileFlags().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:720,Availability,avail,available,720,"/*; Converts, formats, and writes the arguments to the compressed file under; control of the format string, as in fprintf. gzprintf returns the number of; uncompressed bytes actually written, or 0 in case of error. The number of; uncompressed bytes written is limited to 8191, or one less than the buffer; size given to gzbuffer(). The caller should assure that this limit is not; exceeded. If it is exceeded, then gzprintf() will return an error (0) with; nothing written. In this case, there may also be a buffer overflow with; unpredictable consequences, which is possible only if zlib was compiled with; the insecure functions sprintf() or vsprintf() because the secure snprintf(); or vsnprintf() functions were not available. This can be determined using; zlibCompileFlags().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:667,Security,secur,secure,667,"/*; Converts, formats, and writes the arguments to the compressed file under; control of the format string, as in fprintf. gzprintf returns the number of; uncompressed bytes actually written, or 0 in case of error. The number of; uncompressed bytes written is limited to 8191, or one less than the buffer; size given to gzbuffer(). The caller should assure that this limit is not; exceeded. If it is exceeded, then gzprintf() will return an error (0) with; nothing written. In this case, there may also be a buffer overflow with; unpredictable consequences, which is possible only if zlib was compiled with; the insecure functions sprintf() or vsprintf() because the secure snprintf(); or vsnprintf() functions were not available. This can be determined using; zlibCompileFlags().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:177,Availability,error,error,177,"/*; Writes the given null-terminated string to the compressed file, excluding; the terminating null character. gzputs returns the number of characters written, or -1 in case of error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:467,Availability,error,error,467,"/*; Reads bytes from the compressed file until len-1 characters are read, or a; newline character is read and transferred to buf, or an end-of-file; condition is encountered. If any characters are read or if len == 1, the; string is terminated with a null character. If no characters are read due; to an end-of-file or len < 1, then the buffer is left untouched. gzgets returns buf which is a null-terminated string, or it returns NULL; for end-of-file or in case of error. If there was an error, the contents at; buf are indeterminate.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:490,Availability,error,error,490,"/*; Reads bytes from the compressed file until len-1 characters are read, or a; newline character is read and transferred to buf, or an end-of-file; condition is encountered. If any characters are read or if len == 1, the; string is terminated with a null character. If no characters are read due; to an end-of-file or len < 1, then the buffer is left untouched. gzgets returns buf which is a null-terminated string, or it returns NULL; for end-of-file or in case of error. If there was an error, the contents at; buf are indeterminate.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:132,Availability,error,error,132,"/*; Writes c, converted to an unsigned char, into the compressed file. gzputc; returns the value that was written, or -1 in case of error.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:103,Availability,error,error,103,"/*; Reads one byte from the compressed file. gzgetc returns this byte or -1; in case of end of file or error. This is implemented as a macro for speed.; As such, it does not do all of the checking the other functions do. I.e.; it does not check to see if file is NULL, nor whether the structure file; points to has been clobbered or not.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:196,Availability,failure,failure,196,"/*; Push one character back onto the stream to be read as the first character; on the next read. At least one character of push-back is allowed.; gzungetc() returns the character pushed, or -1 on failure. gzungetc() will; fail if c is -1, and may fail if a character has been pushed but not read; yet. If gzungetc is used immediately after gzopen or gzdopen, at least the; output buffer size of pushed characters is allowed. (See gzbuffer above.); The pushed character will be discarded if the stream is repositioned with; gzseek() or gzrewind().; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:140,Availability,error,error,140,"/*; Flushes all pending output into the compressed file. The parameter flush; is as in the deflate() function. The return value is the zlib error number; (see function gzerror below). gzflush is only permitted when writing. If the flush parameter is Z_FINISH, the remaining data is written and the; gzip stream is completed in the output. If gzwrite() is called again, a new; gzip stream will be started in the output. gzread() is able to read such; concatented gzip streams. gzflush should be called only when strictly necessary because it will; degrade compression if called too often.; */; /*; ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,; z_off_t offset, int whence));. Sets the starting position for the next gzread or gzwrite on the given; compressed file. The offset represents a number of bytes in the; uncompressed data stream. The whence parameter is defined as in lseek(2);; the value SEEK_END is not supported. If the file is opened for reading, this function is emulated but can be; extremely slow. If the file is opened for writing, only forward seeks are; supported; gzseek then compresses a sequence of zeroes up to the new; starting position. gzseek returns the resulting offset location as measured in bytes from; the beginning of the uncompressed stream, or -1 in case of error, in; particular if the file is opened for writing and the new starting position; would be before the current position.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:1294,Availability,error,error,1294,"/*; Flushes all pending output into the compressed file. The parameter flush; is as in the deflate() function. The return value is the zlib error number; (see function gzerror below). gzflush is only permitted when writing. If the flush parameter is Z_FINISH, the remaining data is written and the; gzip stream is completed in the output. If gzwrite() is called again, a new; gzip stream will be started in the output. gzread() is able to read such; concatented gzip streams. gzflush should be called only when strictly necessary because it will; degrade compression if called too often.; */; /*; ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,; z_off_t offset, int whence));. Sets the starting position for the next gzread or gzwrite on the given; compressed file. The offset represents a number of bytes in the; uncompressed data stream. The whence parameter is defined as in lseek(2);; the value SEEK_END is not supported. If the file is opened for reading, this function is emulated but can be; extremely slow. If the file is opened for writing, only forward seeks are; supported; gzseek then compresses a sequence of zeroes up to the new; starting position. gzseek returns the resulting offset location as measured in bytes from; the beginning of the uncompressed stream, or -1 in case of error, in; particular if the file is opened for writing and the new starting position; would be before the current position.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:929,Availability,error,error,929,"/*; Rewinds the given file. This function is supported only for reading. gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET); */; /*; ZEXTERN z_off_t ZEXPORT gztell OF((gzFile file));. Returns the starting position for the next gzread or gzwrite on the given; compressed file. This position represents a number of bytes in the; uncompressed data stream, and is zero when starting, even if appending or; reading a gzip stream from the middle of a file using gzdopen(). gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR); */; /*; ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));. Returns the current offset in the file being read or written. This offset; includes the count of bytes that precede the gzip stream, for example when; appending or when using gzdopen() for reading. When reading, the offset; does not include as yet unused buffered input. This information can be used; for a progress indicator. On error, gzoffset() returns -1.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:699,Safety,detect,detected,699,"/*; Returns true (1) if the end-of-file indicator has been set while reading,; false (0) otherwise. Note that the end-of-file indicator is set only if the; read tried to go past the end of the input, but came up short. Therefore,; just like feof(), gzeof() may return false even if there is no more data to; read, in the event that the last read request was for the exact number of; bytes remaining in the input file. This will happen if the input file size; is an exact multiple of the buffer size. If gzeof() returns true, then the read functions will return no more data,; unless the end-of-file indicator is reset by gzclearerr() and the input file; has grown since the previous end of file was detected.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:325,Energy Efficiency,allocate,allocated,325,"/*; Returns true (1) if file is being copied directly while reading, or false; (0) if file is a gzip stream being decompressed. If the input file is empty, gzdirect() will return true, since the input; does not contain a gzip stream. If gzdirect() is used immediately after gzopen() or gzdopen() it will; cause buffers to be allocated to allow reading the file to determine if it; is a gzip file. Therefore if gzbuffer() is used, it should be called before; gzdirect(). When writing, gzdirect() returns true (1) if transparent writing was; requested (""wT"" for the gzopen() mode), or false (0) otherwise. (Note:; gzdirect() is not needed when writing. Transparent writing must be; explicitly requested, so the application already knows the answer. When; linking statically, using gzdirect() will include all of the zlib code for; gzip file reading and decompression, which may not be desired.); */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:446,Availability,error,error,446,"/*; Flushes all pending output if necessary, closes the compressed file and; deallocates the (de)compression state. Note that once file is closed, you; cannot call gzerror with file, since its structures have been deallocated.; gzclose must not be called more than once on the same file, just as free; must not be called more than once on the same allocation. gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a; file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the; last read ended in the middle of a gzip stream, or Z_OK on success.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:193,Safety,avoid,avoid,193,"/*; Same as gzclose(), but gzclose_r() is only for use when reading, and; gzclose_w() is only for use when writing or appending. The advantage to; using these instead of gzclose() is that they avoid linking in zlib; compression or decompression code that is not used when only reading or only; writing respectively. If gzclose() is used, then both compression and; decompression code will be included the application when linking to a static; zlib library.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:16,Availability,error,error,16,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:43,Availability,error,error,43,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:117,Availability,error,error,117,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:137,Availability,error,error,137,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:289,Availability,error,error,289,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:518,Availability,avail,available,518,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:569,Availability,error,errors,569,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:22,Integrability,message,message,22,"/*; Returns the error message for the last error which occurred on the given; compressed file. errnum is set to zlib error number. If an error occurred; in the file system and not in the compression library, errnum is set to; Z_ERRNO and the application may consult errno to get the exact error code. The application must not modify the returned string. Future calls to; this function may invalidate the previously returned string. If file is; closed, then the string previously returned by gzerror will no longer be; available. gzerror() should be used to distinguish errors from end-of-file for those; functions above that do not distinguish those cases in their return values.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:15,Availability,error,error,15,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:182,Performance,concurren,concurrently,182,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4,Usability,Clear,Clears,4,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:79,Usability,clear,clearerr,79,/*; Clears the error and end-of-file flags for file. This is analogous to the; clearerr() function in stdio. This is useful for continuing to read a gzip; file that is being written concurrently.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:18,Security,checksum,checksum,18,/* !Z_SOLO */; /* checksum functions */; /*; These functions are not related to compression but are exported; anyway because they might be useful in applications using the compression; library.; */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:222,Availability,reliab,reliable,222,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:450,Availability,error,error,450,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4,Deployability,Update,Update,4,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:84,Deployability,update,updated,84,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:30,Security,checksum,checksum,30,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:92,Security,checksum,checksum,92,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:178,Security,checksum,checksum,178,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:200,Security,checksum,checksum,200,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:577,Security,checksum,checksums,577,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:677,Security,checksum,checksums,677,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:772,Security,checksum,checksum,772,"/*; Update a running Adler-32 checksum with the bytes buf[0..len-1] and; return the updated checksum. If buf is Z_NULL, this function returns the; required initial value for the checksum. An Adler-32 checksum is almost as reliable as a CRC32 but can be computed; much faster. Usage example:. uLong adler = adler32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; adler = adler32(adler, buffer, length);; }; if (adler != original_adler) error();; */; /*; ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,; z_off_t len2));. Combine two Adler-32 checksums into one. For two sequences of bytes, seq1; and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for; each, adler1 and adler2. adler32_combine() returns the Adler-32 checksum of; seq1 and seq2 concatenated, requiring only adler1, adler2, and len2. Note; that the z_off_t type (like off_t) is a signed integer. If len2 is; negative, the result has no meaning or utility.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:455,Availability,error,error,455,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is Z_NULL, this function returns the required; initial value for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application. Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */; /*; ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));. Combine two CRC-32 check values into one. For two sequences of bytes,; seq1 and seq2 with lengths len1 and len2, CRC-32 check values were; calculated for each, crc1 and crc2. crc32_combine() returns the CRC-32; check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and; len2.; */; /* various hacks, don't look :) */; /* deflateInit and inflateInit are macros to allow checking the zlib version; * and the compiler's view of z_stream:; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:4,Deployability,Update,Update,4,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is Z_NULL, this function returns the required; initial value for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application. Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */; /*; ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));. Combine two CRC-32 check values into one. For two sequences of bytes,; seq1 and seq2 with lengths len1 and len2, CRC-32 check values were; calculated for each, crc1 and crc2. crc32_combine() returns the CRC-32; check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and; len2.; */; /* various hacks, don't look :) */; /* deflateInit and inflateInit are macros to allow checking the zlib version; * and the compiler's view of z_stream:; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:73,Deployability,update,updated,73,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is Z_NULL, this function returns the required; initial value for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application. Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */; /*; ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));. Combine two CRC-32 check values into one. For two sequences of bytes,; seq1 and seq2 with lengths len1 and len2, CRC-32 check values were; calculated for each, crc1 and crc2. crc32_combine() returns the CRC-32; check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and; len2.; */; /* various hacks, don't look :) */; /* deflateInit and inflateInit are macros to allow checking the zlib version; * and the compiler's view of z_stream:; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:220,Performance,perform,performed,220,"/*; Update a running CRC-32 with the bytes buf[0..len-1] and return the; updated CRC-32. If buf is Z_NULL, this function returns the required; initial value for the crc. Pre- and post-conditioning (one's complement) is; performed within this function so it shouldn't be done by the application. Usage example:. uLong crc = crc32(0L, Z_NULL, 0);. while (read_buffer(buffer, length) != EOF) {; crc = crc32(crc, buffer, length);; }; if (crc != original_crc) error();; */; /*; ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));. Combine two CRC-32 check values into one. For two sequences of bytes,; seq1 and seq2 with lengths len1 and len2, CRC-32 check values were; calculated for each, crc1 and crc2. crc32_combine() returns the CRC-32; check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and; len2.; */; /* various hacks, don't look :) */; /* deflateInit and inflateInit are macros to allow checking the zlib version; * and the compiler's view of z_stream:; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:50,Security,expose,exposed,50,"/* gzgetc() macro and its supporting function and exposed data structure. Note; * that the real internal state is much larger than the exposed structure.; * This abbreviated structure exposes just enough for the gzgetc() macro. The; * user should not mess with these exposed elements, since their names or; * behavior could change in the future, perhaps even capriciously. They can; * only be used by the gzgetc() macro. You have been warned.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:135,Security,expose,exposed,135,"/* gzgetc() macro and its supporting function and exposed data structure. Note; * that the real internal state is much larger than the exposed structure.; * This abbreviated structure exposes just enough for the gzgetc() macro. The; * user should not mess with these exposed elements, since their names or; * behavior could change in the future, perhaps even capriciously. They can; * only be used by the gzgetc() macro. You have been warned.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:184,Security,expose,exposes,184,"/* gzgetc() macro and its supporting function and exposed data structure. Note; * that the real internal state is much larger than the exposed structure.; * This abbreviated structure exposes just enough for the gzgetc() macro. The; * user should not mess with these exposed elements, since their names or; * behavior could change in the future, perhaps even capriciously. They can; * only be used by the gzgetc() macro. You have been warned.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:267,Security,expose,exposed,267,"/* gzgetc() macro and its supporting function and exposed data structure. Note; * that the real internal state is much larger than the exposed structure.; * This abbreviated structure exposes just enough for the gzgetc() macro. The; * user should not mess with these exposed elements, since their names or; * behavior could change in the future, perhaps even capriciously. They can; * only be used by the gzgetc() macro. You have been warned.; */",MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h:3,Usability,undo,undocumented,3,/* undocumented functions */,MatchSource.CODE_COMMENT,src/zlib/zlib.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zlib.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h:37,Deployability,configurat,configuration,37,"/* zutil.h -- internal interface and configuration of the compression library; * Copyright (C) 1995-2013 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,src/zlib/zutil.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h:23,Integrability,interface,interface,23,"/* zutil.h -- internal interface and configuration of the compression library; * Copyright (C) 1995-2013 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,src/zlib/zutil.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h:37,Modifiability,config,configuration,37,"/* zutil.h -- internal interface and configuration of the compression library; * Copyright (C) 1995-2013 Jean-loup Gailly.; * For conditions of distribution and use, see copyright notice in zlib.h; */; /* WARNING: this file should *not* be used by applications. It is; part of the implementation of the compression library and is; subject to change. Applications should only use zlib.h.; */; /* @(#) $Id$ */",MatchSource.CODE_COMMENT,src/zlib/zutil.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h:49,Safety,avoid,avoid,49,/* indexed by 2-zlib_error */; /* (size given to avoid silly warnings with Visual C++) */,MatchSource.CODE_COMMENT,src/zlib/zutil.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h
https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h:10,Integrability,depend,dependencies,10,/* target dependencies */,MatchSource.CODE_COMMENT,src/zlib/zutil.h,OpenGene,fastp,v0.23.4,,https://github.com/OpenGene/fastp/tree/v0.23.4/src/zlib/zutil.h
