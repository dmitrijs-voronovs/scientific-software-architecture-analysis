id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:80,Usability,simpl,simplification,80,"// TODO: Conservatively intersecting FMF. If Res == C2, the transform; // was a simplification (so Arg0 and its original flags could; // propagate?)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Performance,Optimiz,Optimize,3,// Optimize negation in matrix multiplication.; // -A * -B -> A * B,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Performance,optimiz,optimize,8,// Only optimize if the negated operand has only one use.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Usability,simpl,simplify,10,// Try to simplify the underlying FMul.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Usability,simpl,simplify,10,// Try to simplify the underlying FMul. We can only apply simplifications; // that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:58,Usability,simpl,simplifications,58,// Try to simplify the underlying FMul. We can only apply simplifications; // that do not require rounding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,Energy Efficiency,reduce,reduce,50,"// If we know that the sign argument is positive, reduce to FABS:; // copysign Mag, +Sign --> fabs Mag",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:50,Energy Efficiency,reduce,reduce,50,"// If we know that the sign argument is negative, reduce to FNABS:; // copysign Mag, -Sign --> fneg (fabs Mag)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:59,Modifiability,rewrite,rewrites,59,"// Peek through changes of magnitude's sign-bit. This call rewrites those:; // copysign (fabs X), Sign --> copysign X, Sign; // copysign (fneg X), Sign --> copysign X, Sign",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:313,Availability,down,down,313,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:164,Safety,avoid,avoids,164,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:226,Safety,safe,safe,226,"// ldexp(ldexp(x, a), b) -> ldexp(x, a + b); //; // The danger is if the first ldexp would overflow to infinity or underflow; // to zero, but the combined exponent avoids it. We ignore this with; // reassoc.; //; // It's also safe to fold if we know both exponents are >= 0 or <= 0 since; // it would just double down on the overflow/underflow which would occur; // anyway.; //; // TODO: Could do better if we had range tracking for the input value; // exponent. Also could broaden sign check to cover == 0 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:30,Safety,safe,safe,30,// TODO: Add nsw/nuw probably safe if integer type exceeds exponent; // width.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:45,Security,authenticat,authenticating,45,// AuthKey will be the key we need to end up authenticating against in; // whatever we replace this sequence with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:55,Usability,simpl,simplify,55,// Check for constant LHS & RHS - in this case we just simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Usability,simpl,simplify,12,// Couldn't simplify - canonicalize constant to the RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Usability,Simpl,Simplify,3,// Simplify Q -> V -> Q conversion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:52,Availability,Mask,Mask,52,// Check if every byte has common bits in Bytes and Mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:194,Modifiability,variab,variable,194,"// If the stacksave and the stackrestore are in the same BB, and there is; // no intervening call, alloca, or stackrestore of a different stacksave,; // remove the restore. This can happen when variable allocas are DCE'd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Availability,down,down,8,// Scan down this block to see if there is another stack restore in the; // same block without an intervening call/alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:40,Usability,resume,resume,40,"// If the stack restore is in a return, resume, or unwind block and if there; // are no allocas or calls between the restore and the return, nuke the; // restore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:34,Safety,detect,detect,34,// Asan needs to poison memory to detect invalid access which is possible; // even for empty lifetime range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:49,Security,access,access,49,// Asan needs to poison memory to detect invalid access which is possible; // even for empty lifetime range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,Availability,redundant,redundant,189,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:189,Safety,redund,redundant,189,"// Remove an assume if it is followed by an identical assume.; // TODO: Do we need this? Unless there are conflicting assumptions, the; // computeKnownBits(IIOperand) below here eliminates redundant assumes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:12,Performance,load,load,12,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:62,Performance,load,load,62,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:98,Performance,load,load,98,// assume( (load addr) != null ) -> add 'nonnull' metadata to load; // (if assume is valid at the load),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,Safety,avoid,avoid,232,"// Separate storage assumptions apply to the underlying allocations, not any; // particular pointer within them. When evaluating the hints for AA purposes; // we getUnderlyingObject them; by precomputing the answers here we can; // avoid having to do so repeatedly there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:25,Safety,safe,safe,25,// Not having a limit is safe because InstCombine removes unreachable; // code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,Availability,redundant,redundant,93,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:93,Safety,redund,redundant,93,"// If there is a dominating assume with the same condition as this one,; // then this one is redundant, and should be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Deployability,Update,Update,3,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Performance,cache,cache,14,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:97,Usability,simpl,simplified,97,// Update the cache of affected values for this assumption (we might be; // here because we just simplified the condition).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:36,Safety,avoid,avoid,36,// Note: Using context-free form to avoid compile time blow up,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:16,Testability,log,logical,16,"// Canonicalize logical or/and reductions:; // Or reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp ne iReduxWidth %val, 0; // And reduction for i1 is represented as:; // %val = bitcast <ReduxWidth x i1> to iReduxWidth; // %res = cmp eq iReduxWidth %val, 11111",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:73,Modifiability,extend,extended,73,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:130,Modifiability,extend,extended,130,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:193,Modifiability,extend,extended,193,// Exclusive disjunction reduction over the vector with; // (potentially-extended) i1 element type is actually a; // (potentially-extended) arithmetic `add` reduction over the original; // non-extended value:; // vector_reduce_xor(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_add(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:62,Modifiability,extend,extended,62,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:124,Modifiability,extend,extended,124,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:184,Modifiability,extend,extended,184,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:138,Testability,log,logical,138,// Multiplicative reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially zero-extended); // logical `and` reduction over the original non-extended value:; // vector_reduce_mul(?ext(<n x i1>)); // -->; // zext(vector_reduce_and(<n x i1>)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:57,Modifiability,extend,extended,57,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:114,Modifiability,extend,extended,114,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,Modifiability,extend,extended,179,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:128,Testability,log,logical,128,"// UMin/UMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_u{min,max}(?ext(<n x i1>)); // -->; // ?ext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:57,Modifiability,extend,extended,57,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:114,Modifiability,extend,extended,114,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:179,Modifiability,extend,extended,179,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:128,Testability,log,logical,128,"// SMin/SMax reduction over the vector with (potentially-extended); // i1 element type is actually a (potentially-extended); // logical `and`/`or` reduction over the original non-extended value:; // vector_reduce_s{min,max}(<n x i1>); // -->; // vector_reduce_{or,and}(<n x i1>); // and; // vector_reduce_s{min,max}(sext(<n x i1>)); // -->; // sext(vector_reduce_{or,and}(<n x i1>)); // and; // vector_reduce_s{min,max}(zext(<n x i1>)); // -->; // zext(vector_reduce_{and,or}(<n x i1>))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:176,Performance,perform,perform,176,"// Try to fold intrinsic into select operands. This is legal if:; // * The intrinsic is speculatable.; // * The select condition is not a vector, or the intrinsic does not; // perform cross-lane operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:21,Usability,simpl,simplification,21,// Fence instruction simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:56,Integrability,depend,dependent,56,// This check is solely here to handle arbitrary target-dependent syncscopes.; // TODO: Can remove if does not matter in practice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Usability,simpl,simplification,14,// InvokeInst simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:14,Usability,simpl,simplification,14,// CallBrInst simplification,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:8,Performance,optimiz,optimizing,8,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:71,Performance,optimiz,optimizeCall,71,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:150,Performance,optimiz,optimizeCall,150,// Skip optimizing notail and musttail calls so; // LibCallSimplifier::optimizeCall doesn't have to preserve those invariants.; // LibCallSimplifier::optimizeCall should try to preseve tail calls though.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:112,Usability,simpl,simpler,112,"// Strip off at most one level of pointer casts, looking for an alloca. This; // is good enough in practice and simpler than handling any number of casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:147,Performance,optimiz,optimized,147,"// Given a call to llvm.adjust.trampoline, find and return the corresponding; // call to llvm.init.trampoline if the call to the trampoline can be optimized; // to a direct call to a function. Otherwise return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:45,Energy Efficiency,power,power,45,// Add alignment attribute if alignment is a power of two constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize the call if possible, we require DataLayout for most of; // this. None of these calls are seen as possibly dead so go ahead and; // delete the instruction now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:10,Energy Efficiency,reduce,reduce,10,// We can reduce the size of gc live bundle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:3,Deployability,Update,Update,3,// Update all gc.relocates,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:232,Safety,avoid,avoid,232,"// Prevent us turning:; // declare void @takes_i32_inalloca(i32* inalloca); // call void bitcast (void (i32*)* @takes_i32_inalloca to void (i32)*)(i32 0); //; // into:; // call void @takes_i32_inalloca(i32* null); //; // Similarly, avoid folding away bitcasts of byval calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:108,Safety,safe,safely,108,// Cannot transform this parameter value.; // Check if there are any incompatible attributes we cannot drop safely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:35,Safety,safe,safe,35,"// Okay, we decided that this is a safe thing to do: go ahead and start; // inserting cast instructions as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp:133,Safety,safe,safe,133,// Add any parameter attributes except the ones incompatible with the new; // type. Note that we made sure all incompatible ones are safe to drop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:220,Availability,Mask,Mask,220,"// Canonicalize a unary shuffle after the cast if neither operation changes; // the size or element size of the input vector.; // TODO: We could allow size-changing ops if that doesn't harm codegen.; // cast (shuffle X, Mask) --> shuffle (cast X), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:248,Availability,Mask,Mask,248,"// Canonicalize a unary shuffle after the cast if neither operation changes; // the size or element size of the input vector.; // TODO: We could allow size-changing ops if that doesn't harm codegen.; // cast (shuffle X, Mask) --> shuffle (cast X), Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:15,Performance,scalab,scalable,15,// TODO: Allow scalable vectors?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:12,Modifiability,extend,extend,12,// We don't extend or shrink something that has multiple uses -- doing so; // would require duplicating the instruction which isn't profitable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:485,Energy Efficiency,efficient,efficiently,485,"/// Return true if we can evaluate the specified expression tree as type Ty; /// instead of its larger type, and arrive with the same value.; /// This is used by code that tries to eliminate truncates.; ///; /// Ty will always be a type smaller than V. We should return true if trunc(V); /// can be computed by computing V in the smaller type. If V is an instruction,; /// then trunc(inst(x,y)) can be computed as inst(trunc(x),trunc(y)), which only; /// makes sense if x and y can be efficiently truncated.; ///; /// This function works on both vectors and scalars.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:42,Modifiability,extend,extended,42,// These operators can all arbitrarily be extended or truncated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:108,Performance,perform,perform,108,"// If we are truncating the result of this SHL, and if it's a shift of an; // inrange amount, we can always perform a SHL in a smaller type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:30,Testability,log,logical,30,"// If this is a truncate of a logical shr, we can truncate it to a smaller; // lshr iff we know that the bits we would otherwise be shifting in are; // already zeros.; // TODO: It is enough to check that the bits we would be shifting in are; // zero - use AmtKnownBits.getMaxValue().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:56,Safety,safe,safe,56,"// If the integer type can hold the max FP value, it is safe to cast; // directly to that type. Otherwise, we may create poison via overflow; // that did not exist in the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Testability,log,logically,61,"/// Given a vector that is bitcast to an integer, optionally logically; /// right-shifted, and truncated, convert it to an extractelement.; /// Example (big endian):; /// trunc (lshr (bitcast <4 x i32> %X to i128), 32) to i32; /// --->; /// extractelement <4 x i32> %X, 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Energy Efficiency,power,power-of-,96,"// Bail out on strange types. It is possible to handle some of these patterns; // even with non-power-of-2 sizes, but it is not a likely scenario.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:27,Availability,mask,masked,27,"// The shift amount may be masked with negation:; // (shl ShVal0, (X & (Width - 1))) | (lshr ShVal1, ((-X) & (Width - 1)))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Availability,mask,masking,61,"// Same as above, but the shift amount may be extended after masking:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:46,Modifiability,extend,extended,46,"// Same as above, but the shift amount may be extended after masking:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:77,Modifiability,extend,extend,77,"// Adjust the width of ShAmt for narrowed funnel shift operation:; // - Zero-extend if ShAmt is narrower than the destination type.; // - Truncate if ShAmt is wider, discarding non-significant high-order bits.; // This prepares ShAmt for llvm.fshl.i8(trunc(ShVal), trunc(ShVal),; // zext/trunc(ShAmt)).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:47,Testability,log,logic,47,/// Try to narrow the width of math or bitwise logic instructions by pulling a; /// truncate ahead of binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:149,Safety,avoid,avoid,149,"/// Try to narrow the width of a splat shuffle. This could be generalized to any; /// shuffle with a constant operand, but we limit the transform to avoid; /// creating a shuffle type that targets may not be able to lower effectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:257,Modifiability,extend,extended,257,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:335,Modifiability,variab,variable,335,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:165,Safety,avoid,avoid,165,"/// Try to narrow the width of an insert element. This could be generalized for; /// any vector constant, but we limit the transform to insertion into undef to; /// avoid potential backend problems from unsupported insertion widths. This; /// could also be extended to handle the case of inserting a scalar constant; /// into a vector variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Usability,simpl,simple,120,"// Attempt to truncate the entire input expression tree to the destination; // type. Only do this if the dest type is a simple type, don't convert the; // expression tree to something weird like i93 unless the source is also; // strange.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:183,Performance,optimiz,optimizations,183,"// For integer types, check if we can shorten the entire input expression to; // DestWidth * 2, which won't allow removing the truncate, but reducing the; // width may enable further optimizations, e.g. allowing for larger; // vectorization factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Testability,Test,Test,3,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:123,Usability,simpl,simplification,123,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:148,Usability,simpl,simplifying,148,"// Test if the trunc is the user of a select which is part of a; // minimum or maximum operation. If so, don't do any more simplification.; // Even simplifying demanded bits can break the canonical form of a; // min/max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:17,Usability,simpl,simplify,17,// See if we can simplify any instructions used by the input whose sole; // purpose is to compute bits we don't care about.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:62,Performance,optimiz,optimize,62,"// For vectors, we do not canonicalize all truncs to icmp, so optimize; // patterns that would be covered within visitICmpInst.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:9,Availability,Mask,Mask,9,// TODO: Mask high bits with 'and'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Modifiability,extend,extend,96,// Skip shifts of shift by constants. It undoes a combine in; // FoldShiftByConstant and is the extend in reg pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:41,Usability,undo,undoes,41,// Skip shifts of shift by constants. It undoes a combine in; // FoldShiftByConstant and is the extend in reg pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:168,Safety,avoid,avoid,168,"// If we are just checking for a icmp eq of a single bit and zext'ing it; // to an integer, then shift the bit to the appropriate place and then; // cast to integer to avoid the comparison.; // FIXME: This set of transforms does not check for extra uses and/or creates; // an extra instruction (an optional final cast is not included; // in the transform comments). We may also want to favor icmp over; // shifts in cases of equal instructions because icmp has better; // analysis in general (invert the transform).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a logical shr by shiftamt.; // Insert the shift to put the result in the low bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:13,Testability,log,logical,13,// Perform a logical shr by shiftamt.; // Insert the shift to put the result in the low bit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Deployability,Toggle,Toggle,3,"// Toggle the low bit for ""X == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:50,Availability,mask,mask,50,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Testability,Test,Test,3,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:20,Usability,clear,clear,20,"// Test if a bit is clear/set using a shifted-one mask:; // zext (icmp eq (and X, (1 << ShAmt)), 0) --> and (lshr (not X), ShAmt), 1; // zext (icmp ne (and X, (1 << ShAmt)), 0) --> and (lshr X, ShAmt), 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:319,Modifiability,extend,extend,319,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:689,Usability,clear,cleared,689,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:765,Usability,clear,clear,765,"/// Determine if the specified value can be computed in the specified wider type; /// and produce the same low bits. If not, return false.; ///; /// If this function returns true, it can also return a non-zero number of bits; /// (in BitsToClear) which indicates that the value it computes is correct for; /// the zero extend, but that the additional BitsToClear bits need to be zero'd; /// out. For example, to promote something like:; ///; /// %B = trunc i64 %A to i32; /// %C = lshr i32 %B, 8; /// %E = zext i32 %C to i64; ///; /// CanEvaluateZExtd for the 'lshr' will return true, and BitsToClear will be; /// set to 8 to indicate that the promoted value needs to have bits 24-31; /// cleared in addition to bits 32-63. Since an 'and' will be generated to; /// clear the top bits anyway, doing this has no extra cost.; ///; /// This function works on both vectors and scalars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Usability,clear,clear,61,// These can all be promoted if neither operand has 'bits to clear'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Usability,clear,clear,53,"// If the operation is an AND/OR/XOR and the bits to clear are zero in the; // other side, BitsToClear is ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Availability,Mask,MaskedValueIsZero,10,"// We use MaskedValueIsZero here for generality, but the case we care; // about the most is constant RHS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:98,Energy Efficiency,reduce,reduce,98,"// We can promote shl(x, cst) if we can promote x. Since shl overwrites the; // upper bits we can reduce BitsToClear by the shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:92,Usability,clear,clear,92,"// We can promote lshr(x, cst) if we can promote x. This requires the; // ultimate 'and' to clear out the high zero bits we're clearing out though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:127,Usability,clear,clearing,127,"// We can promote lshr(x, cst) if we can promote x. This requires the; // ultimate 'and' to clear out the high zero bits we're clearing out though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:18,Modifiability,variab,variable,18,// Cannot promote variable LSHR.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:100,Modifiability,extend,extended,100,"// llvm.vscale() can always be executed in larger type, because the; // value is automatically zero-extended.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this zero extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:103,Performance,optimiz,optimize,103,"// If this zero extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Modifiability,extend,extend,10,// Try to extend the entire expression tree to the wide destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:29,Usability,clear,clear,29,// We need to emit an AND to clear the high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:144,Testability,log,logical,144,// If this is a TRUNC followed by a ZEXT then we are dealing with integral; // types and if the sizes are just right we can convert this into a logical; // 'and' which will be much cheaper than the pair of casts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:82,Availability,mask,mask,82,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:116,Availability,mask,mask,116,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:155,Availability,mask,mask,155,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:21,Modifiability,extend,extending,21,"// If we're actually extending zero bits, then if; // SrcSize < DstSize: zext(a & mask); // SrcSize == DstSize: a & mask; // SrcSize > DstSize: trunc(a) & mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,Availability,mask,masking,25,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:96,Availability,mask,mask,96,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:247,Availability,mask,mask,247,"// If we are truncating, masking, and then zexting back to the original type,; // that's just a mask. This is not handled by canEvaluateZextd if the; // intermediate values have extra uses. This could be generalized further for; // a non-constant mask operand.; // zext (and (trunc X), C) --> and X, (zext C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this zero extend is only used by a shift, add nneg flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Energy Efficiency,power,power,120,"// If we know that only one bit of the LHS of the icmp can be set and we; // have an equality comparison with zero or a power of 2, we can transform; // the icmp and sext into bitwise/integer operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:15,Testability,test,tests,15,// If the icmp tests for a known zero bit we can constant fold it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a right shift to place the desired bit in the LSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Performance,Perform,Perform,3,// Perform a left shift to place the desired bit in the MSB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:42,Modifiability,extend,extended,42,// These operators can all arbitrarily be extended if their inputs can.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:16,Modifiability,extend,extend,16,"// If this sign extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this sext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:103,Performance,optimiz,optimize,103,"// If this sign extend is only used by a truncate, let the truncate be; // eliminated before we try to optimize this sext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:22,Modifiability,extend,extended,22,"// If the value being extended is zero or positive, use a zext instead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:10,Modifiability,extend,extend,10,// Try to extend the entire expression tree to the wide destination type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:47,Modifiability,extend,extend,47,// We need to emit a shl + ashr to do the sign extend.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:81,Testability,log,logic,81,"// If we are replacing shifted-in high zero bits with sign bits, convert; // the logic shift to arithmetic shift and eliminate the cast to; // intermediate type:; // sext (trunc (lshr Y, C)) --> sext/trunc (ashr Y, C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:393,Modifiability,extend,extend,393,"// If the input is a shl/ashr pair of a same constant, then this is a sign; // extension from a smaller value. If we could trust arbitrary bitwidth; // integers, we could turn this into a truncate to the smaller bit and then; // use a sext for the whole extension. Since we don't, look deeper and check; // for a truncate. If the source and dest are the same type, eliminate the; // trunc and extend and just do shifts. For example, turn:; // %a = trunc i32 %i to i8; // %b = shl i8 %a, C; // %c = ashr i8 %b, C; // %d = sext i8 %c to i32; // into:; // %a = shl i32 %i, 32-(8-C); // %d = ashr i32 %a, 32-(8-C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:94,Safety,safe,safely,94,"// Determine if this is a vector of ConstantFPs and if so, return the minimal; // type we can safely truncate all elements to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,Safety,safe,safely,36,/// Find the minimum FP type we can safely truncate to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:134,Integrability,wrap,wrapped,134,// We can only correctly find a minimum type for a scalable vector when it is; // a splat. For splats of constant values the fpext is wrapped up as a; // ConstantExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:51,Performance,scalab,scalable,51,// We can only correctly find a minimum type for a scalable vector when it is; // a splat. For splats of constant values the fpext is wrapped up as a; // ConstantExpr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:67,Performance,scalab,scalable,67,// Try to shrink a vector of FP constants. This returns nullptr on scalable; // vectors,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:66,Safety,avoid,avoid,66,"// If this is uitofp (fptosi F), the source needs an extra bit to avoid; // potential rounding of negative FP input values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:135,Modifiability,extend,extend,135,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:104,Safety,avoid,avoid,104,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:322,Safety,safe,safely,322,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:76,Usability,simpl,simplify,76,"// If we have fptrunc(OpI (fpextend x), (fpextend y)), we would like to; // simplify this expression to avoid one or more of the trunc/extend; // operations if we can do so without changing the numerical results.; //; // The exact manner in which the widths of the operands interact to limit; // what we can and cannot do safely varies from operation to operation, and; // is explained below in the various case statements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:244,Performance,perform,perform,244,"// For multiplication, the infinitely precise result has at most; // LHSWidth + RHSWidth significant bits; if OpWidth is sufficient; // that such a value can be exactly represented, then no double; // rounding can possibly occur; we can safely perform the operation; // in the destination format if it can represent both sources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:237,Safety,safe,safely,237,"// For multiplication, the infinitely precise result has at most; // LHSWidth + RHSWidth significant bits; if OpWidth is sufficient; // that such a value can be exactly represented, then no double; // rounding can possibly occur; we can safely perform the operation; // in the destination format if it can represent both sources.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:120,Usability,simpl,simply,120,"// Remainder is straightforward. Remainder is always exact, so the; // type of OpI doesn't enter into things at all. We simply evaluate; // in whichever source type is larger, then convert to the; // destination type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:45,Modifiability,extend,extended,45,"// If we are truncating a select that has an extended operand, we can; // narrow the other operand and do the select as a narrow op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:83,Safety,safe,safe,83,"/// fpto{s/u}i({u/s}itofp(X)) --> X or zext(X) or sext(X) or trunc(X); /// This is safe if the intermediate type has enough bits in its mantissa to; /// accurately represent all values of X. For example, this won't work with; /// i64 -> float -> i64.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:124,Integrability,depend,depend,124,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:215,Safety,safe,safe,215,"// Since we can assume the conversion won't overflow, our decision as to; // whether the input will fit in the float should depend on the minimum; // of the input range and output range.; // This means this is also safe for a signed input and unsigned output, since; // a negative input would lead to undefined behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:169,Security,expose,exposed,169,"// If the source integer type is not the intptr_t type for this target, do a; // trunc or zext to the intptr_t type, then inttoptr of it. This allows the; // cast to be exposed to other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:163,Security,expose,exposed,163,"// If the destination integer type is not the intptr_t type for this target,; // do a ptrtoint to intptr_t then do a trunc or zext. This allows the cast; // to be exposed to other transforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:72,Modifiability,extend,extended,72,"/// This input value (which is known to have vector type) is being zero extended; /// or truncated to the specified vector type. Since the zext/trunc is done; /// using an integer type, we have a (bitcast(cast(bitcast))) pattern,; /// endianness will impact which end of the vector that is extended or; /// truncated.; ///; /// A vector is always stored with index 0 at the lowest address, which; /// corresponds to the most significant bits for a big endian stored integer and; /// the least significant bits for little endian. A trunc/zext of an integer; /// impacts the big end of the integer. Thus, we need to add/remove elements at; /// the front of the vector for big endian targets, and the back of the vector; /// for little endian targets.; ///; /// Try to replace it with a shuffle (and vector/vector bitcast) if possible.; ///; /// The source and destination vector types may have different element types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:290,Modifiability,extend,extended,290,"/// This input value (which is known to have vector type) is being zero extended; /// or truncated to the specified vector type. Since the zext/trunc is done; /// using an integer type, we have a (bitcast(cast(bitcast))) pattern,; /// endianness will impact which end of the vector that is extended or; /// truncated.; ///; /// A vector is always stored with index 0 at the lowest address, which; /// corresponds to the most significant bits for a big endian stored integer and; /// the least significant bits for little endian. A trunc/zext of an integer; /// impacts the big end of the integer. Thus, we need to add/remove elements at; /// the front of the vector for big endian targets, and the back of the vector; /// for little endian targets.; ///; /// Try to replace it with a shuffle (and vector/vector bitcast) if possible.; ///; /// The source and destination vector types may have different element types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:23,Performance,optimiz,optimization,23,"// We can only do this optimization if the output is a multiple of the input; // element size, or the input is a multiple of the output element size.; // Convert the input type to have the same element type as the output.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Availability,mask,mask,53,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,Integrability,depend,depends,99,"// Now that the element types match, get the shuffle mask and RHS of the; // shuffle to use, which depends on whether we're increasing or decreasing the; // size of the input.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:25,Availability,mask,mask,25,"// Make sure the shuffle mask selects the ""least significant bits"" by; // keeping elements from back of the src vector for big endian, and from the; // front for little endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Availability,mask,mask,61,// Use first elt from V2 when indicating zero in the shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:3,Modifiability,Extend,Extend,3,"// Extend with null values in the ""most significant bits"" by adding elements; // in front of the src vector for big endian, and at the back for little; // endian.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:198,Performance,Optimiz,OptimizeIntegerToVectorInsertions,198,"/// V is a value which is inserted into a vector of VecEltTy.; /// Look through the value to see if we can decompose it into; /// insertions into the vector. See the example in the comment for; /// OptimizeIntegerToVectorInsertions for the pattern this handles.; /// The type of V is always a non-zero multiple of VecEltTy's size.; /// Shift is the number of bits between the lsb of V and the lsb of; /// the vector.; ///; /// This returns false if the pattern can't be matched or true if it can,; /// filling in Elements with the elements found here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:13,Availability,down,down,13,"// If we got down to a value of the right type, we win, try inserting into the; // right element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:207,Performance,optimiz,optimize,207,"/// If the input is an 'or' instruction, we may be doing shifts and ors to; /// assemble the elements of the vector manually.; /// Try to rip the code out and replace it with insertelements. This is to; /// optimize code like this:; ///; /// %tmp37 = bitcast float %inc to i32; /// %tmp38 = zext i32 %tmp37 to i64; /// %tmp31 = bitcast float %inc5 to i32; /// %tmp32 = zext i32 %tmp31 to i64; /// %tmp33 = shl i64 %tmp32, 32; /// %ins35 = or i64 %tmp33, %tmp38; /// %tmp43 = bitcast i64 %ins35 to <2 x float>; ///; /// Into two insertelements that do ""buildvector{%inc, %inc5}"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:36,Safety,avoid,avoid,36,"// Only solve DestType is vector to avoid inverse transform in visitBitCast.; // bitcast (extractelement <1 x elt>, dest) -> bitcast(<1 x elt>, dest)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:33,Testability,log,logic,33,/// Change the type of a bitwise logic operation if we can eliminate a bitcast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:58,Safety,avoid,avoid,58,"// FIXME: This transform is restricted to vector types to avoid backend; // problems caused by creating potentially illegal operations. If a fix-up is; // added to handle that situation, we can remove this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(bitcast(X), bitcast(Y))) -> bitcast'(logic(bitcast'(X), Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:54,Testability,log,logic,54,"// bitcast(logic(bitcast(X), bitcast(Y))) -> bitcast'(logic(bitcast'(X), Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(bitcast(X), Y)) --> logic'(X, bitcast(Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:37,Testability,log,logic,37,"// bitcast(logic(bitcast(X), Y)) --> logic'(X, bitcast(Y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:11,Testability,log,logic,11,"// bitcast(logic(Y, bitcast(X))) --> logic'(bitcast(Y), X)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:37,Testability,log,logic,37,"// bitcast(logic(Y, bitcast(X))) --> logic'(bitcast(Y), X)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:62,Testability,log,logic,62,"// Canonicalize vector bitcasts to come before vector bitwise logic with a; // constant. This eases recognition of special constants for later ops.; // Example:; // icmp u/s (a ^ signmask), (b ^ signmask) --> icmp s/u a, b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:12,Testability,log,logic,12,"// bitcast (logic X, C) --> logic (bitcast X, C')",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:28,Testability,log,logic,28,"// bitcast (logic X, C) --> logic (bitcast X, C')",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:99,Safety,avoid,avoid,99,"// FIXME: This transform is restricted from changing the select between; // scalars and vectors to avoid backend problems caused by creating; // potentially illegal operations. If a fix-up is added to handle that; // situation, we can remove this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:41,Performance,load,load,41,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:65,Performance,load,loaded,65,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:110,Performance,load,load,110,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:185,Performance,optimiz,optimize,185,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:235,Performance,load,load,235,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:267,Performance,load,load,267,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:206,Usability,simpl,simplicity,206,"// If there is a sequence of one or more load instructions, each loaded; // value is used as address of later load instruction, bitcast is; // necessary to change the value type, don't optimize it. For; // simplicity we give up if the load address comes from another load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:19,Performance,load,load,19,"// Don't tranform ""load <256 x i32>, <256 x i32>*"" to; // ""load x86_amx, x86_amx*"", because x86_amx* is invalid.; // TODO: Remove this check when bitcast between vector and x86_amx; // is replaced with a specific intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:59,Performance,load,load,59,"// Don't tranform ""load <256 x i32>, <256 x i32>*"" to; // ""load x86_amx, x86_amx*"", because x86_amx* is invalid.; // TODO: Remove this check when bitcast between vector and x86_amx; // is replaced with a specific intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:8,Performance,Load,LoadInst,8,"// If a LoadInst has more than one use, changing the type of loaded; // value may create another bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:61,Performance,load,loaded,61,"// If a LoadInst has more than one use, changing the type of loaded; // value may create another bitcast.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:74,Modifiability,rewrite,rewrite,74,"// Check that each user of each old PHI node is something that we can; // rewrite, so that all of the old PHI nodes can be cleaned up afterwards.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:74,Modifiability,rewrite,rewrite,74,"// As long as the user is another old PHI node, then even if we don't; // rewrite it, the PHI web we're considering won't have any users; // outside itself, so it'll be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:14,Performance,perform,perform,14,// Explicitly perform load combine to make sure no opposing transform; // can remove the bitcast in the meantime and trigger an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:22,Performance,load,load,22,// Explicitly perform load combine to make sure no opposing transform; // can remove the bitcast in the meantime and trigger an infinite loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:18,Performance,load,load,18,"// Remove the old load and its use in the old phi, which itself becomes; // dead once the whole transform finishes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:68,Testability,log,logic,68,// Convert an artificial vector insert into more analyzable bitwise logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp:53,Availability,Mask,MaskC,53,"// bitcast (inselt (bitcast X), Y, 0) --> or (and X, MaskC), (zext Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCasts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:95,Deployability,update,updates,95,/// Returns true if the exploded icmp can be expressed as a signed comparison; /// to zero and updates the predicate accordingly.; /// The signedness of the comparison is preserved.; /// TODO: Refactor with decomposeBitTestICmp()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:193,Modifiability,Refactor,Refactor,193,/// Returns true if the exploded icmp can be expressed as a signed comparison; /// to zero and updates the predicate accordingly.; /// The signedness of the comparison is preserved.; /// TODO: Refactor with decomposeBitTestICmp()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:386,Availability,mask,masked,386,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:114,Modifiability,variab,variable,114,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,Performance,load,load,60,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:230,Performance,load,load,230,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:260,Performance,optimiz,optimize,260,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:279,Performance,load,load,279,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:370,Performance,load,loaded,370,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:159,Usability,simpl,simplify,159,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:188,Usability,simpl,simple,188,"/// This is called when we see this pattern:; /// cmp pred (load (gep GV, ...)), cmpcst; /// where GV is a global variable with a constant initializer. Try to simplify; /// this into some simple computation that does not need the load. For example; /// we can optimize ""icmp eq (load (gep ""foo"", 0, i)), 0"" into ""icmp eq i, 3"".; ///; /// If AndCst is non-null, then the loaded value is masked with that constant; /// before doing the comparison. This handles cases like ""A[i]&4 == 0"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Performance,optimiz,optimization,32,"// There are many forms of this optimization we can handle, for now, just do; // the simple index into a single-dimensional array.; //; // Require: GEP GV, 0, i {{, constant indices}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Usability,simpl,simple,85,"// There are many forms of this optimization we can handle, for now, just do; // the simple index into a single-dimensional array.; //; // Require: GEP GV, 0, i {{, constant indices}}",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Modifiability,variab,variable,32,// Check that indices after the variable are constants and in-range for the; // type they index. Collect the indices. This is typically for arrays of; // structs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Variab,Variable,3,// Variable index.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Variab,Variables,3,"// Variables for our state machines.; // FirstTrueElement/SecondTrueElement - Used to emit a comparison of the form; // ""i == 47 | i == 87"", where 47 is the first index the condition is true for,; // and 87 is the second (and last) index. FirstTrueElement is -2 when; // undefined, otherwise set to the first true element. SecondTrueElement is; // -2 when undefined, -3 when overdefined and >= 0 when that index is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,Availability,mask,masked,21,"// If the element is masked, handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Extend,Extend,3,// Extend range state machines to cover this element in case there is an; // undef in the middle of the range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:79,Deployability,update,update,79,"// Otherwise, we know if the comparison is true or false for this element,; // update our state machines.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update the TrueElement state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update double-compare state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update range state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update the FalseElement state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update double-compare state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Deployability,Update,Update,3,// Update range state machine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Deployability,update,update,32,"// If this element is in range, update our magic bitvector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Availability,down,down,93,"// If the index is larger than the pointer offset size of the target, truncate; // the index down like the GEP would do implicitly. We don't have to do this; // for an inbounds GEP because the index can't be out of range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:73,Performance,load,load,73,"// If a magic bitvector captures the entire comparison state; // of this load, replace it with computation that does:; // ((magic_cst >> i) & 1) != 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Modifiability,rewrite,rewrite,27,/// Returns true if we can rewrite Start as a GEP with pointer Base; /// and some integer offset. The nodes that need to be re-written; /// for this transformation will be added to Explored.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Modifiability,variab,variable,45,// Only allow inbounds GEPs with at most one variable offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Performance,Perform,Perform,3,// Perform all the substitutions. This is a bit tricky because we can; // have cycles in our use-def chains.; // 1. Create the PHI nodes without any incoming values.; // 2. Create all the other values.; // 3. Add the edges for the PHI nodes.; // 4. Emit GEPs to get the original pointers.; // 5. Remove the original instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:46,Integrability,depend,dependencies,46,// Create empty phi nodes. This avoids cyclic dependencies when creating; // the remaining instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Safety,avoid,avoids,32,// Create empty phi nodes. This avoids cyclic dependencies when creating; // the remaining instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Rewrite,RewriteGEPAsOffset,3,"// RewriteGEPAsOffset has replaced RHS and all of its uses with a re-written; // GEP having PtrBase as the pointer base, and has returned in NewRHS the; // offset. Since Index is the offset of LHS to the base pointer, we will now; // compare the offsets instead of comparing the pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:600,Usability,simpl,simply,600,"// For most address spaces, an allocation can't be placed at null, but null; // itself is treated as a 0 size allocation in the in bounds rules. Thus,; // the only valid inbounds address derived from null, is null itself.; // Thus, we have four cases to consider:; // 1) Base == nullptr, Offset == 0 -> inbounds, null; // 2) Base == nullptr, Offset != 0 -> poison as the result is out of bounds; // 3) Base != nullptr, Offset == (-base) -> poison (crossing allocations); // 4) Base != nullptr, Offset != (-base) -> nonnull (and possibly poison); //; // (Note if we're indexing a type of size 0, that simply collapses into one; // of the buckets above.); //; // In general, we're allowed to make values less poison (i.e. remove; // sources of full UB), so in this case, we just select between the two; // non-poison cases (1 and 4 above).; //; // For vectors, we apply the same reasoning on a per-lane basis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Availability,mask,mask,34,/// The value of the map is a bit mask of which icmp operands the alloca is; /// used in.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:182,Energy Efficiency,reduce,reduces,182,"// We need to check that U is based *only* on the alloca, and doesn't; // have other contributions from a select/phi operand.; // TODO: We could check whether getUnderlyingObjects() reduces to one; // object, which would allow looking through phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:100,Energy Efficiency,power,power,100,// There are multiple solutions if we are comparing against -1 and the LHS; // of the ashr is not a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:80,Modifiability,extend,extended,80,"// This is only really a signed overflow check if the inputs have been; // sign-extended; check for that condition. For example, if CI2 is 2^31 and; // the operands of the add are 64 bits wide, we need at least 33 sign bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:128,Availability,down,downwards,128,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:91,Usability,Simpl,SimplifyDemandedBits,91,"// Only accept truncates for now. We would really like a nice recursive; // predicate like SimplifyDemandedBits, but which goes downwards the use-def; // chain to see which bits of a value are actually demanded. If the; // original add had another add which was then immediately truncated, we; // could still do the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:116,Energy Efficiency,efficient,efficiently,116,"// If the pattern matches, truncate the inputs to the narrower type and; // use the sadd_with_overflow intrinsic to efficiently compute both the; // result and the overflow bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:56,Modifiability,extend,extended,56,"// The inner add was the result of the narrow add, zero extended to the; // wider type. Replace it with the result computed by the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Energy Efficiency,power,power-of-two,71,"/// If we have:; /// icmp eq/ne (urem/srem %x, %y), 0; /// iff %y is a power-of-two, we can replace this with a bit test:; /// icmp eq/ne (and %x, (add %y, -1)), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:116,Testability,test,test,116,"/// If we have:; /// icmp eq/ne (urem/srem %x, %y), 0; /// iff %y is a power-of-two, we can replace this with a bit test:; /// icmp eq/ne (and %x, (add %y, -1)), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:123,Testability,test,test,123,/// Fold equality-comparison between zero and any (maybe truncated) right-shift; /// by one-less-than-bitwidth into a sign test on the original value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:86,Safety,avoid,avoid,86,"// `isKnownNonZero` does more analysis than just `!KnownBits.One.isZero()`; // but to avoid unnecessary work, first just if this is an obvious case.; // if X non-zero and NoOverflow(X * Y); // (icmp eq/ne Y)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:171,Usability,simpl,simplified,171,"// Note, we are skipping cases:; // if Y % 2 != 0 AND X % 2 != 0; // (false/true); // if X non-zero and Y non-zero and NoOverflow(X * Y); // (false/true); // Those can be simplified later as we would have already replaced the (icmp; // eq/ne (mul X, Y)) with (icmp eq/ne X/Y) and if X/Y is known non-zero that; // will fold to a constant elsewhere.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:147,Modifiability,extend,extended,147,"/// Fold icmp Pred X, C.; /// TODO: This code structure does not make sense. The saturating add fold; /// should be moved to some other helper and extended as noted below (it is also; /// possible that code has been made unnecessary - do we canonicalize IR to; /// overflow/saturating intrinsics or not?).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:128,Performance,perform,performs,128,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,Safety,safe,safe,82,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:379,Safety,safe,safe,379,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Usability,Simpl,Simplify,253,"// Match the following pattern, which is a common idiom when writing; // overflow-safe integer arithmetic functions. The source performs an addition; // in wider type and explicitly checks for overflow using comparisons against; // INT_MIN and INT_MAX. Simplify by using the sadd_with_overflow intrinsic.; //; // TODO: This could probably be generalized to handle other overflow-safe; // operations if we worked out the formulas to compute the appropriate magic; // constants.; //; // sum = a + b; // if (sum+128 >u 255) ... -> llvm.sadd.with.overflow.i8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Usability,simpl,simple,22,"// We already checked simple implication in InstSimplify, only handle complex; // cases here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Modifiability,variab,variable,27,"// We have 2 compares of a variable with constants. Calculate the constant; // ranges of those compares to see if we can transform the 2nd compare:; // DomBB:; // DomCond = icmp DomPred X, DomC; // br DomCond, CmpBB, FalseBB; // CmpBB:; // Cmp = icmp Pred X, C",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:172,Safety,avoid,avoid,172,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:149,Testability,test,test,149,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:224,Testability,test,test,224,"// Canonicalizing a sign bit comparison that gets used in a branch,; // pessimizes codegen by generating branch on zero instruction instead; // of a test and branch. So we avoid canonicalizing in such situations; // because test and branch instruction has better branch displacement; // than compare and branch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Safety,Avoid,Avoid,3,// Avoid an infinite loop with min/max canonicalization.; // TODO: This will be unnecessary if we canonicalize to min/max intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:21,Availability,mask,mask,21,// Canonicalize to a mask and wider compare if the wide type is suitable:; // (trunc X to i8) == C --> (X & 0xff) == (zext C),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify icmp eq (trunc x to i8), 42 -> icmp eq x, 42|highbits if all; // of the high bits truncated out of x are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Testability,test,tests,32,"// If this is a comparison that tests the signbit (X < 0) or (x > -1),; // fold the xor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Availability,Mask,Mask,3,// Mask constant magic can eliminate an 'xor' with unsigned compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Energy Efficiency,power,power,47,"// (xor X, ~C) >u C --> X <u ~C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, C) >u C --> X >u C (when C+1 is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, -C) <u C --> X >u ~C (when C is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Energy Efficiency,power,power,45,"// (xor X, C) <u C --> X >u ~C (when -C is a power of 2)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Energy Efficiency,power,power-of-,8,/// For power-of-2 C:; /// ((X s>> ShiftC) ^ X) u< C --> (X + C) u< (C << 1); /// ((X s>> ShiftC) ^ X) u> (C - 1) --> (X + C) u> ((C << 1) - 1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:209,Security,access,access,209,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:236,Usability,simpl,simple,236,"// If this is: (X >> C3) & C2 != C1 (where any shift and any compare could; // exist), turn it into (X & (C2 << C3)) != (C1 << C3). This happens a LOT in; // code produced by the clang front-end, for bitfield access.; // This seemingly simple opportunity to fold away a shift turns out to be; // rather complicated. See PR17827 for details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:114,Availability,mask,mask,114,"// For a left shift, we can fold if the comparison is not signed. We can; // also fold a signed comparison if the mask value and comparison value; // are not negative. These constraints may not be obvious, but we can; // prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:131,Availability,mask,mask,131,"// For a logical right shift, we can fold if the comparison is not signed.; // We can also fold a signed comparison if the shifted mask value and the; // shifted comparison value are not negative. These constraints may not be; // obvious, but we can prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Testability,log,logical,9,"// For a logical right shift, we can fold if the comparison is not signed.; // We can also fold a signed comparison if the shifted mask value and the; // shifted comparison value are not negative. These constraints may not be; // obvious, but we can prove that they are correct using an SMT solver.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Performance,perform,perform,9,// Don't perform the following transforms if the AND has multiple uses,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:50,Energy Efficiency,power,power-of-,50,// Set high zeros of C2 to allow matching negated power-of-2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:106,Energy Efficiency,power,power,106,// Restrict this fold only for single-use 'and' (PR10267).; // ((%x & C) == 0) --> %x u< (-C) iff (-C) is power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:343,Modifiability,Extend,Extending,343,"// If the LHS is an 'and' of a truncate and we can widen the and/compare to; // the input width without changing the value produced, eliminate the cast:; //; // icmp (and (trunc W), C2), C1 -> icmp (and W, C2'), C1'; //; // We can do this transformation if the constants do not have their sign bits; // set or if it is an equality comparison. Extending a relational comparison; // when we're checking the sign bit would not work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,Energy Efficiency,reduce,reduce,63,// TODO: Is this a good transform for vectors? Wider types may reduce; // throughput. Should this transform be limited (even for scalars) by using; // shouldChangeType()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:74,Performance,throughput,throughput,74,// TODO: Is this a good transform for vectors? Wider types may reduce; // throughput. Should this transform be limited (even for scalars) by using; // shouldChangeType()?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Modifiability,refactor,refactor,54,"// TODO: These all require that Y is constant too, so refactor with the above.; // Try to optimize things like ""A[i] & 42 == 0"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:90,Performance,optimiz,optimize,90,"// TODO: These all require that Y is constant too, so refactor with the above.; // Try to optimize things like ""A[i] & 42 == 0"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:73,Energy Efficiency,power,power,73,// X & -C == -C -> X > u ~C; // X & -C != -C -> X <= u ~C; // iff C is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:433,Modifiability,Extend,Extend,433,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,testing,13,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:405,Testability,log,logic,405,"// If we are testing the intersection of 2 select-of-nonzero-constants with no; // common bits set, it's the same as checking if exactly one select condition; // is set:; // ((A ? TC : FC) & (B ? TC : FC)) == 0 --> xor A, B; // ((A ? TC : FC) & (B ? TC : FC)) != 0 --> not(xor A, B); // TODO: Generalize for non-constant values.; // TODO: Handle signed/unsigned predicates.; // TODO: Handle other bitwise logic connectors.; // TODO: Extend to handle a non-zero compare constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Energy Efficiency,power,power,69,// X | C == C --> X <=u C; // X | C != C --> X >u C; // iff C+1 is a power of 2 (C is a bitmask of the low bits),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Availability,mask,mask,54,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Availability,mask,mask,93,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:109,Availability,Mask,MaskC,109,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:131,Availability,Mask,MaskC,131,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:145,Availability,Mask,MaskC,145,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:160,Availability,Mask,MaskC,160,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:182,Availability,Mask,MaskC,182,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:196,Availability,Mask,MaskC,196,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:82,Usability,clear,clear,82,// More general: canonicalize 'equality with set bits mask' to; // 'equality with clear bits mask'.; // (X | MaskC) == C --> (X & ~MaskC) == C ^ MaskC; // (X | MaskC) != C --> (X & ~MaskC) != C ^ MaskC,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify icmp eq (or (ptrtoint P), (ptrtoint Q)), 0; // -> and (icmp eq P, null), (icmp eq Q, null).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:16,Testability,test,test,16,"// If this is a test of the sign bit and the multiply is sign-preserving with; // a constant operand, use the multiply LHS operand instead:; // (X * +MulC) < 0 --> X < 0; // (X * -MulC) < 0 --> X > 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Integrability,wrap,wrap,28,"// If the multiply does not wrap or the constant is odd, try to divide the; // compare constant by the multiplication factor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:148,Testability,Assert,Assert,148,"// With a matching no-overflow guarantee, fold the constants:; // (X * MulC) < C --> X < (C / MulC); // (X * MulC) > C --> X > (C / MulC); // TODO: Assert that Pred is not equal to SGE, SLE, UGE, ULE?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Performance,perform,perform,58,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited, it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Usability,simpl,simplified,126,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited, it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Availability,mask,mask,136,"// NSW guarantees that we are only shifting out sign bits from the high bits,; // so we can ASHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Availability,mask,mask,136,"// NUW guarantees that we are only shifting out zero bits from the high bits,; // so we can LSHR the compare constant without needing a mask and eliminate; // the shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:12,Energy Efficiency,reduce,reduce,12,// Strength-reduce the shift into an 'and'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Testability,test,test,71,"// Otherwise, if this is a comparison of the sign bit, simplify to and/test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:55,Usability,simpl,simplify,55,"// Otherwise, if this is a comparison of the sign bit, simplify to and/test.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Testability,test,test,29,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:54,Testability,test,test,54,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,// Simplify 'shl' inequality test into 'and' equality test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:36,Energy Efficiency,power,power,36,// (X l<< C2) u<=/u> C1 iff C1+1 is power of two -> X & (~C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Energy Efficiency,power,power,34,// (X l<< C2) u</u>= C1 iff C1 is power of two -> X & (-C1 l>> C2) ==/!= 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:32,Energy Efficiency,power,power-of-,32,"// If the shifted constant is a power-of-2, test the shift amount directly:; // (ShiftValC >> Y) >u C --> X <u (LZ(C) - LZ(ShiftValC)); // (ShiftValC >> Y) <u C --> X >=u (LZ(C-1) - LZ(ShiftValC))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:44,Testability,test,test,44,"// If the shifted constant is a power-of-2, test the shift amount directly:; // (ShiftValC >> Y) >u C --> X <u (LZ(C) - LZ(ShiftValC)); // (ShiftValC >> Y) <u C --> X >=u (LZ(C-1) - LZ(ShiftValC))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Performance,perform,perform,58,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Usability,simpl,simplified,125,"// Check that the shift amount is in range. If not, don't perform undefined; // shifts. When the shift is visited it will be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:146,Testability,assert,assert,146,"// TODO: If we could guarantee that InstSimplify would handle all of the; // constant-value-based preconditions in the folds below, then we could assert; // those conditions rather than checking them. This is difficult because of; // undef/poison (PR34838).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:113,Testability,test,test,113,"// If the compare constant has significant bits above the lowest sign-bit,; // then convert an unsigned cmp to a test of the sign-bit:; // (ashr X, ShiftC) u> C --> X s< 0; // (ashr X, ShiftC) u< C --> X s> -1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Energy Efficiency,power,power-of-,85,// Match an 'is positive' or 'is negative' comparison of remainder by a; // constant power-of-2 value:; // (X % pow2C) sgt/slt 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Availability,Mask,Mask,3,// Mask off the sign bit and the modulo bits (low-bits).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Availability,mask,masked,70,// For 'is positive?' check that the sign-bit is clear and at least 1 masked; // bit is set. Example:; // (i8 X % 32) s> 0 --> (X & 159) s> 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,clear,clear,49,// For 'is positive?' check that the sign-bit is clear and at least 1 masked; // bit is set. Example:; // (i8 X % 32) s> 0 --> (X & 159) s> 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:68,Availability,mask,masked,68,// For 'is negative?' check that the sign-bit is set and at least 1 masked; // bit is set. Example:; // (i16 X % 4) s< 0 --> (X & 32771) u> 32768,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Testability,test,test,47,"// Fold: icmp pred ([us]div X, C2), C -> range test; // Fold this div into the comparison, producing a range check.; // Determine, based on the divide type, what the range is being; // checked. If there is an overflow on the low or high side, remember; // it, otherwise compute the range [low, hi) bounding the new value.; // See: InsertRangeTest above for the kinds of replacements possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:141,Testability,log,logic,141,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:431,Testability,test,tests,431,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:350,Usability,Simpl,Simply,350,// FIXME: If the operand types don't match the type of the divide; // then don't attempt this transform. The code below doesn't have the; // logic to deal with a signed divide and an unsigned compare (and; // vice versa). This is because (x /s C2) <s C produces different; // results than (x /s C2) <u C or (x /u C2) <s C or even; // (x /u C2) <u C. Simply casting the operands and result won't; // work. :( The if statement below tests that condition and bails; // if it finds it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:213,Testability,assert,assert,213,"// The ProdOV computation fails on divide by 0 and divide by -1. Cases with; // INT_MIN will also fail if the divisor is 1. Although folds of all these; // division-by-constant cases should be present, we can not assert that they; // have happened before we reach this icmp instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:394,Modifiability,variab,variable,394,"// Figure out the interval that is being checked. For example, a comparison; // like ""X /u 5 == 0"" is really checking that X is in the interval [0, 5).; // Compute this interval based on the constants involved and the signedness of; // the compare/divide. This computes a half-open interval, keeping track of; // whether either value in the interval overflows. After analysis each; // overflow variable is set to 0 if it's corresponding bound variable is valid; // -1 if overflowed off the bottom end, or +1 if overflowed off the top end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:443,Modifiability,variab,variable,443,"// Figure out the interval that is being checked. For example, a comparison; // like ""X /u 5 == 0"" is really checking that X is in the interval [0, 5).; // Compute this interval based on the constants involved and the signedness of; // the compare/divide. This computes a half-open interval, keeping track of; // whether either value in the interval overflows. After analysis each; // overflow variable is set to 0 if it's corresponding bound variable is valid; // -1 if overflowed off the bottom end, or +1 if overflowed off the top end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:217,Testability,test,test,217,"// X - Y == 0 --> X == Y.; // X - Y != 0 --> X != Y.; // TODO: We allow this with multiple uses as long as the other uses are not; // in phis. The phi use check is guarding against a codegen regression; // for a loop test. If the backend could undo this (and possibly; // subsequent transforms), we would not need this hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:244,Usability,undo,undo,244,"// X - Y == 0 --> X == Y.; // X - Y != 0 --> X != Y.; // TODO: We allow this with multiple uses as long as the other uses are not; // in phis. The phi use check is guarding against a codegen regression; // for a loop test. If the backend could undo this (and possibly; // subsequent transforms), we would not need this hack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:240,Testability,test,test,240,// The following transforms are only worth it if the only user of the subtract; // is the icmp.; // TODO: This is an artificial restriction for all of the transforms below; // that only need a single replacement icmp. Can these use the phi test; // like the transform above here?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:81,Energy Efficiency,power,power,81,// C2 - Y <u C -> (Y | (C - 1)) == C2; // iff (C2 & (C - 1)) == C - 1 and C is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Energy Efficiency,power,power,67,// C2 - Y >u C -> (Y | C) != C2; // iff C2 & C == C and C + 1 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:38,Energy Efficiency,reduce,reduce,38,// We have handled special cases that reduce.; // Canonicalize any remaining sub to add as:; // (C2 - Y) > C --> (Y + ~C2) < ~C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:23,Integrability,wrap,wrap,23,"// If the add does not wrap, we can always adjust the compare by subtracting; // the constants. Equality comparisons are handled elsewhere. SGE/SLE/UGE/ULE; // are canonicalized to SGT/SLT/UGT/ULT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:76,Testability,assert,assert,76,"// If there is overflow, the result must be true or false.; // TODO: Can we assert there is no overflow because InstSimplify always; // handles those cases?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Integrability,wrap,wrapping,69,// This set of folds is intentionally placed after folds that use no-wrapping; // flags because those folds are likely better for later analysis/codegen.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Energy Efficiency,power,power,67,// X+C <u C2 -> (X & -C2) == C; // iff C & (C2-1) == 0; // C2 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,Energy Efficiency,power,power,65,// X+C >u C2 -> (X & ~C2) != C; // iff C & C2 == 0; // C2+1 is a power of 2,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,test,13,// The range test idiom can use either ult or ugt. Arbitrarily canonicalize; // to the ult form.; // X+C2 >u C -> X+(C2-C-1) <u ~C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:15,Performance,perform,perform,15,// And kind-of perform the result swap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:12,Testability,test,testing,12,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Testability,test,test,253,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:337,Testability,test,test,337,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:303,Usability,simpl,simplify,303,"// If we're testing a constant value against the result of a three way; // comparison, the result can be expressed directly in terms of the; // original values being compared. Note: We could possibly be more; // aggressive here and remove the hasOneUse test. The original select is; // really likely to simplify or sink when we remove a test of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:297,Usability,simpl,simplify,297,"// This generates the new instruction that will replace the original Cmp; // Instruction. Instead of enumerating the various combinations when; // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus; // false, we rely on chaining of ORs and future passes of InstCombine to; // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).; // When none of the three constants satisfy the predicate for the RHS (C),; // the entire original Cmp can be simplified to a false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:473,Usability,simpl,simplified,473,"// This generates the new instruction that will replace the original Cmp; // Instruction. Instead of enumerating the various combinations when; // TrueWhenLessThan, TrueWhenEqual and TrueWhenGreaterThan are true versus; // false, we rely on chaining of ORs and future passes of InstCombine to; // simplify the OR further (i.e. a s< b || a == b becomes a s<= b).; // When none of the three constants satisfy the predicate for the RHS (C),; // the entire original Cmp can be simplified to a false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:86,Modifiability,extend,extend,86,"// If this is a sign-bit test of a bitcast of a casted FP value, eliminate; // the FP extend/truncate because that cast does not change the sign-bit.; // This is true for all standard IEEE-754 types and the X86 80-bit type.; // The sign-bit is always the most significant bit in those types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:25,Testability,test,test,25,"// If this is a sign-bit test of a bitcast of a casted FP value, eliminate; // the FP extend/truncate because that cast does not change the sign-bit.; // This is true for all standard IEEE-754 types and the X86 80-bit type.; // The sign-bit is always the most significant bit in those types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Energy Efficiency,Power,Power,29,// We can't currently handle Power style floating point operations here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:420,Energy Efficiency,reduce,reduce,420,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Testability,test,test,125,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,Usability,clear,clear,162,"// If this is checking if all elements of a vector compare are set or not,; // invert the casted vector equality compare and test if all compare; // elements are clear or not. Compare against zero is generally easier for; // analysis and codegen.; // icmp eq/ne (bitcast (not X) to iN), -1 --> icmp eq/ne (bitcast X to iN), 0; // Example: are all elements equal? --> are zero elements not equal?; // TODO: Try harder to reduce compare of 2 freely invertible operands?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Modifiability,extend,extended,45,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:125,Modifiability,extend,extend,125,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:65,Usability,clear,clear,65,"// If this is checking if all elements of an extended vector are clear or not,; // compare in a narrow type to eliminate the extend:; // icmp eq/ne (bitcast (ext X) to iN), 0 --> icmp eq/ne (bitcast X to iM), 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Availability,Mask,Mask,34,// Check whether every element of Mask is the same constant,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:98,Modifiability,extend,extend,98,"// For now, we only support constant integers while folding the; // ICMP(SELECT)) pattern. We can extend this to support vector of integers; // similar to the cases handled by binary ops above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:61,Energy Efficiency,efficient,efficiently,61,"// Replace ((add A, B) != 0) with (A != -B) if A or B is; // efficiently invertible, or if the add has just this one use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Availability,mask,mask,47,// Comparing if all bits outside of a constant mask are set?; // Replace (X | C) == -1 with (X & ~C) == ~C.; // This removes the -1 constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Energy Efficiency,Power,Power,3,// Power of 2 test:; // isPow2OrZero : ctpop(X) u< 2; // isPow2 : ctpop(X) == 1; // NotPow2OrZero: ctpop(X) u> 1; // NotPow2 : ctpop(X) != 1; // If we know any bit of X can be folded to:; // IsPow2 : X & (~Bit) == 0; // NotPow2 : X & (~Bit) != 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:14,Testability,test,test,14,// Power of 2 test:; // isPow2OrZero : ctpop(X) u< 2; // isPow2 : ctpop(X) == 1; // NotPow2OrZero: ctpop(X) u> 1; // NotPow2 : ctpop(X) != 1; // If we know any bit of X can be folded to:; // IsPow2 : X & (~Bit) == 0; // NotPow2 : X & (~Bit) != 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:30,Modifiability,refactor,refactored,30,// TODO: These folds could be refactored to be part of the above calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:39,Usability,simpl,simple,39,/// Handle icmp with constant (but not simple integer constant) RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize things like ""A[i] > 4"" to index computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:107,Testability,log,logical,107,"// Try to fold the comparison into the select arms, which will cause the; // select to be converted into a logical and/or.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:19,Performance,perform,perform,19,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:235,Usability,simpl,simplify,235,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:338,Usability,simpl,simpler,338,"// We only want to perform this transformation if it will not lead to; // additional code. This is true if either both sides of the select; // fold to a constant (in which case the icmp is replaced with a select; // which will usually simplify) or this is the only user of the; // select (in which case we are trading a select+icmp for a simpler; // select+icmp) or all uses of the select can be replaced based on; // dominance information (""Global cases"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:177,Availability,Mask,Mask,177,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:205,Availability,Mask,Mask,205,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:221,Availability,Mask,Mask,221,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:429,Availability,Mask,Mask,429,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Usability,simpl,simplified,28,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy truncation.; /// Folds:; /// icmp SrcPred (x & Mask), x to icmp DstPred x, Mask; /// Where Mask is some pattern that produces all-ones in low bits:; /// (-1 >> y); /// ((-1 << y) >> y) <- non-canonical, has extra uses; /// ~(-1 << y); /// ((1 << y) + (-1)) <- non-canonical, has extra uses; /// The Mask can be a constant, too.; /// For some predicates, the operands are commutative.; /// For others, x can only be on a specific side.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:7,Availability,mask,mask,7,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,Safety,safe,safe,94,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:214,Safety,safe,safe,214,"// The mask value may be a vector constant that has undefined elements. But it; // may not be safe to propagate those undefs into the new compare, so replace; // those elements by copying an existing, defined, and safe scalar constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:162,Availability,Mask,MaskedBits,162,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:202,Availability,Mask,MaskedBits,202,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:218,Availability,Mask,MaskedBits,218,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:348,Availability,Mask,MaskedBits,348,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Usability,simpl,simplified,28,"/// Some comparisons can be simplified.; /// In this case, we are looking for comparisons that look like; /// a check for a lossy signed truncation.; /// Folds: (MaskedBits is a constant.); /// ((%x << MaskedBits) a>> MaskedBits) SrcPred %x; /// Into:; /// (add %x, (1 << (KeptBits-1))) DstPred (1 << KeptBits); /// Where KeptBits = bitwidth(%x) - MaskedBits",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Availability,Mask,MaskedBits,11,"// ((%x << MaskedBits) a>> MaskedBits) == %x; // =>; // (add %x, (1 << (KeptBits-1))) u< (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Availability,Mask,MaskedBits,27,"// ((%x << MaskedBits) a>> MaskedBits) == %x; // =>; // (add %x, (1 << (KeptBits-1))) u< (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Availability,Mask,MaskedBits,11,"// ((%x << MaskedBits) a>> MaskedBits) != %x; // =>; // (add %x, (1 << (KeptBits-1))) u>= (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:27,Availability,Mask,MaskedBits,27,"// ((%x << MaskedBits) a>> MaskedBits) != %x; // =>; // (add %x, (1 << (KeptBits-1))) u>= (1 << KeptBits)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:29,Availability,Mask,MaskedBits,29,// KeptBits = bitwidth(%x) - MaskedBits,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:135,Modifiability,rewrite,rewrite,135,"// Given pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // we should move shifts to the same hand of 'and', i.e. rewrite as; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // We are only interested in opposite logical shifts here.; // One of the shifts can be truncated.; // If we can, we want to end up creating 'lshr' shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:253,Testability,log,logical,253,"// Given pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // we should move shifts to the same hand of 'and', i.e. rewrite as; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // We are only interested in opposite logical shifts here.; // One of the shifts can be truncated.; // If we can, we want to end up creating 'lshr' shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:28,Testability,log,logical,28,"// Look for an 'and' of two logical shifts, one of which may be truncated.; // We use m_TruncOrSelf() on the RHS to correctly handle commutative case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:118,Modifiability,rewrite,rewrite,118,"// As input, we have the following pattern:; // icmp eq/ne (and ((x shift Q), (y oppositeshift K))), 0; // We want to rewrite that as:; // icmp eq/ne (and (x shift (Q+K)), y), 0 iff (Q+K) u< bitwidth(x); // While we know that originally (Q+K) would not overflow; // (because 2 * (N-1) u<= iN -1), we have looked past extensions of; // shift amounts. so it may now overflow in smaller bitwidth.; // To ensure that does not happen, we need to ensure that the total maximal; // shift amount is still representable in that smaller bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:199,Performance,perform,perform,199,"// It isn't obvious whether it's worth it to analyze non-constants here.; // Also, let's basically give up on non-splat cases, pessimizing vectors.; // If *any* of these preconditions matches we can perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:188,Safety,avoid,avoid,188,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:84,Testability,log,logic,84,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:127,Usability,simpl,simplifyICmpWithBinOp,127,"/// Try to fold icmp (binop), X or icmp X, (binop).; /// TODO: A large part of this logic is duplicated in InstSimplify's; /// simplifyICmpWithBinOp(). We should be able to share that and avoid the code; /// duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Testability,log,logic,11,// Special logic for binary operators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Availability,mask,mask,70,// Similar to above: an unsigned overflow comparison may use offset + mask:; // ((Op1 + C) & C) u< Op1 --> Op1 != 0; // ((Op1 + C) & C) u>= Op1 --> Op1 == 0; // Op0 u> ((Op0 + C) & C) --> Op0 != 0; // Op0 u<= ((Op0 + C) & C) --> Op0 == 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Safety,avoid,avoid,31,// We don't check hasOneUse to avoid increasing register pressure because; // the value we use is the same value this instruction was already using.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:45,Availability,Mask,Mask,45,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:57,Availability,Mask,Mask,57,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:67,Availability,Mask,Mask,67,"// icmp eq/ne (X * C), (Y * C) --> icmp (X & Mask), (Y & Mask); // Mask = -1 >> count-trailing-zeros(C).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Energy Efficiency,power,power-of-,31,// Canonicalize checking for a power-of-2-or-zero value:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:72,Availability,mask,mask,72,"// Transform ""icmp eq (trunc (lshr(X, cst1)), cst"" to; // ""icmp (and X, mask), cst""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Performance,optimiz,optimizations,97,// Only do this when A has multiple uses. This is most important to do; // when it exposes other optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:83,Security,expose,exposes,83,// Only do this when A has multiple uses. This is most important to do; // when it exposes other optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:58,Availability,mask,mask,58,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:84,Availability,mask,masks,84,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:134,Availability,mask,mask,134,// Try to canonicalize trunc + compare-to-constant into a mask + cmp.; // The trunc masks high bits while the compare may effectively mask low bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:121,Availability,mask,masked-high-bits,121,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:192,Availability,mask,masked-high-bits,192,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:42,Testability,test,tests,42,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,Usability,clear,clear,138,// This matches patterns corresponding to tests of the signbit as well as:; // (trunc X) u< C --> (X & -C) == 0 (are all masked-high-bits clear?); // (trunc X) u> C --> (X & ~C) != 0 (are any masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:43,Availability,mask,mask,43,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:95,Availability,mask,masked-high-bits,95,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Energy Efficiency,power,power-of-,22,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:112,Usability,clear,clear,112,// If C is a negative power-of-2 (high-bit mask):; // (trunc X) u< C --> (X & C) != C (are any masked-high-bits clear?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Availability,mask,masked-high-bits,97,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,Energy Efficiency,power,power-of-,18,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Usability,clear,clear,34,// If C is not-of-power-of-2 (one clear bit):; // (trunc X) u> C --> (X & (C+1)) == C+1 (are all masked-high-bits set?),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Modifiability,Extend,Extend,3,// Extend the narrower operand to the type of the wider operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Modifiability,extend,extended,31,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Usability,simpl,simplifies,47,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:31,Modifiability,extend,extended,31,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:47,Usability,simpl,simplifies,47,// A signed comparison of sign extended values simplifies into a; // signed comparison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Modifiability,extend,extended,10,"// The re-extended constant changed, partly changed (in the case of a vector),; // or could not be determined to be equal (in the case of a constant; // expression), so the constant cannot be represented in the shorter type.; // All the cases that fold to true or false will have already been handled; // by simplifyICmpInst, so only deal with the tricky case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:308,Usability,simpl,simplifyICmpInst,308,"// The re-extended constant changed, partly changed (in the case of a vector),; // or could not be determined to be equal (in the case of a constant; // expression), so the constant cannot be represented in the shorter type.; // All the cases that fold to true or false will have already been handled; // by simplifyICmpInst, so only deal with the tricky case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:42,Testability,test,test,42,"/// Recognize and process idiom involving test for multiplication; /// overflow.; ///; /// The caller has matched a pattern of the form:; /// I = cmp u (mul(zext A, zext B), V; /// The function checks if this is a test for overflow and if so replaces; /// multiplication with call to 'mul.with.overflow' intrinsic.; ///; /// \param I Compare instruction.; /// \param MulVal Result of 'mult' instruction. It is one of the arguments of; /// the compare instruction. Must be of integer type.; /// \param OtherVal The other argument of compare instruction.; /// \returns Instruction which must replace the compare instruction, NULL if no; /// replacement required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:214,Testability,test,test,214,"/// Recognize and process idiom involving test for multiplication; /// overflow.; ///; /// The caller has matched a pattern of the form:; /// I = cmp u (mul(zext A, zext B), V; /// The function checks if this is a test for overflow and if so replaces; /// multiplication with call to 'mul.with.overflow' intrinsic.; ///; /// \param I Compare instruction.; /// \param MulVal Result of 'mult' instruction. It is one of the arguments of; /// the compare instruction. Must be of integer type.; /// \param OtherVal The other argument of compare instruction.; /// \returns Instruction which must replace the compare instruction, NULL if no; /// replacement required.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:106,Performance,perform,performing,106,"// In this case we could have the operand of the binary operation; // being defined in another block, and performing the replacement; // could break the dominance relation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:185,Availability,mask,mask,185,"// If there are uses of mul result other than the comparison, we know that; // they are truncation or binary AND. Change them to use result of; // mul.with.overflow and adjust properly mask/size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:18,Availability,mask,mask,18,// Replace (mul & mask) --> zext (mul.with.overflow & short_mask),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:79,Integrability,depend,depending,79,"// The original icmp gets replaced with the overflow value, maybe inverted; // depending on predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:152,Availability,mask,mask,152,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:9,Performance,perform,performing,9,"/// When performing a comparison against a constant, it is possible that not all; /// the bits in the LHS are demanded. This helper method computes the mask that; /// IS demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:1169,Performance,optimiz,optimization,1169,"/// True when a select result is replaced by one of its operands; /// in select-icmp sequence. This will eventually result in the elimination; /// of the select.; ///; /// \param SI Select instruction; /// \param Icmp Compare instruction; /// \param SIOpd Operand that replaces the select; ///; /// Notes:; /// - The replacement is global and requires dominator information; /// - The caller is responsible for the actual replacement; ///; /// Example:; ///; /// entry:; /// %4 = select i1 %3, %C* %0, %C* null; /// %5 = icmp eq %C* %4, null; /// br i1 %5, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %4, i64 0, i32 0; /// ...; ///; /// can be transformed to; ///; /// %5 = icmp eq %C* %0, null; /// %6 = select i1 %3, i1 %5, i1 true; /// br i1 %6, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %0, i64 0, i32 0 // replace by %0!; ///; /// Similar when the first operand of the select is a constant or/and; /// the compare is for not equal rather than equal.; ///; /// NOTE: The function is only called when the select and compare constants; /// are equal, the optimization can work only for EQ predicates. This is not a; /// major restriction since a NE compare should be 'normalized' to an equal; /// compare, which usually happens in the combiner and test case; /// select-cmp-br.ll checks for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:1362,Testability,test,test,1362,"/// True when a select result is replaced by one of its operands; /// in select-icmp sequence. This will eventually result in the elimination; /// of the select.; ///; /// \param SI Select instruction; /// \param Icmp Compare instruction; /// \param SIOpd Operand that replaces the select; ///; /// Notes:; /// - The replacement is global and requires dominator information; /// - The caller is responsible for the actual replacement; ///; /// Example:; ///; /// entry:; /// %4 = select i1 %3, %C* %0, %C* null; /// %5 = icmp eq %C* %4, null; /// br i1 %5, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %4, i64 0, i32 0; /// ...; ///; /// can be transformed to; ///; /// %5 = icmp eq %C* %0, null; /// %6 = select i1 %3, i1 %5, i1 true; /// br i1 %6, label %9, label %7; /// ...; /// ; <label>:7 ; preds = %entry; /// %8 = getelementptr inbounds %C* %0, i64 0, i32 0 // replace by %0!; ///; /// Similar when the first operand of the select is a constant or/and; /// the compare is for not equal rather than equal.; ///; /// NOTE: The function is only called when the select and compare constants; /// are equal, the optimization can work only for EQ predicates. This is not a; /// major restriction since a NE compare should be 'normalized' to an equal; /// compare, which usually happens in the combiner and test case; /// select-cmp-br.ll checks for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:94,Energy Efficiency,efficient,efficiently,94,"// The check for the single predecessor is not the best that can be; // done. But it protects efficiently against cases like when SI's; // home block has two successors, Succ and Succ1, and Succ1 predecessor; // of Succ. Then SI can't be replaced by SIOpd because the use that gets; // replaced can be reached on either path. So the uniqueness check; // guarantees that the path all uses of SI (outside SI's parent) are on; // is disjoint from all other paths out of SI. But that information; // is more expensive to compute, and the trade-off here is in favor; // of compile-time. It should also be noticed that we check for a single; // predecessor and not only uniqueness. This to handle the situation when; // Succ and Succ1 points to the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:201,Availability,reliab,reliably,201,// Don't use dominating conditions when folding icmp using known bits. This; // may convert signed into unsigned predicates in ways that other passes; // (especially IndVarSimplify) may not be able to reliably undo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:210,Usability,undo,undo,210,// Don't use dominating conditions when folding icmp using known bits. This; // may convert signed into unsigned predicates in ways that other passes; // (especially IndVarSimplify) may not be able to reliably undo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,Simpl,SimplifyDemandedBits,49,"// If Min and Max are known to be the same, then SimplifyDemandedBits figured; // out that the LHS or RHS is a constant. Constant fold this now, so that; // code below can assume that Min != Max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:75,Usability,simpl,simplify,75,"// Based on the range information we know about the LHS, see if we can; // simplify this comparison. For example, (x&4) < 8 is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:93,Energy Efficiency,reduce,reduce,93,"/// If one operand of an icmp is effectively a bool (value range of {0,1}),; /// then try to reduce patterns based on that limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:40,Safety,safe,safely,40,// Check if the constant operand can be safely incremented/decremented; // without overflowing/underflowing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:37,Safety,safe,safely,37,// Bail out if the constant can't be safely incremented/decremented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,scalab,scalable,10,// Handle scalable splat,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:37,Safety,safe,safely,37,// Bail out if the constant can't be safely incremented/decremented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:17,Safety,safe,safe,17,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:136,Safety,safe,safe,136,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:204,Safety,safe,safe,204,"// It may not be safe to change a compare predicate in the presence of; // undefined elements, so replace those elements with the first safe constant; // that we found.; // TODO: in case of poison, it is safe; let's replace undefs only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:70,Deployability,update,update,70,"/// If we have a comparison with a non-canonical predicate, if we can update; /// all the users, invert the predicate and adjust all the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Energy Efficiency,adapt,adapt,8,"// And, adapt users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:8,Modifiability,adapt,adapt,8,"// And, adapt users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:43,Usability,simpl,simplified,43,// A boolean compared to true/false can be simplified to Op0/true/false in; // 14 out of the 20 (10 predicates * 2 constants) possible combinations.; // Cases not handled by InstSimplify are always 'not' of Op0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:63,Availability,mask,mask,63,"// If both arguments of the cmp are shuffles that use the same mask and; // shuffle within a single vector, move the shuffle after the cmp:; // cmp (shuffle V1, M), (shuffle V2, M) --> shuffle (cmp V1, V2), M",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Availability,recover,recover,126,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:69,Safety,safe,safety,69,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:126,Safety,recover,recover,126,"// We allow undefs in matching, but this transform removes those for safety.; // Demanded elements analysis should be able to recover some/all of that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:57,Energy Efficiency,reduce,reduce,57,"/// This function folds patterns produced by lowering of reduce idioms, such as; /// llvm.vector.reduce.and which are lowered into instruction chains. This code; /// attempts to generate fewer number of scalar comparisons instead of vector; /// comparisons when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Energy Efficiency,reduce,reduce,97,"/// This function folds patterns produced by lowering of reduce idioms, such as; /// llvm.vector.reduce.and which are lowered into instruction chains. This code; /// attempts to generate fewer number of scalar comparisons instead of vector; /// comparisons when possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:34,Energy Efficiency,reduce,reduce,34,"// Match lowering of @llvm.vector.reduce.and. Turn; /// %vec_ne = icmp ne <8 x i8> %lhs, %rhs; /// %scalar_ne = bitcast <8 x i1> %vec_ne to i8; /// %res = icmp <pred> i8 %scalar_ne, 0; ///; /// into; ///; /// %lhs.scalar = bitcast <8 x i8> %lhs to i64; /// %rhs.scalar = bitcast <8 x i8> %rhs to i64; /// %res = icmp <pred> i64 %lhs.scalar, %rhs.scalar; ///; /// for <pred> in {ne, eq}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,"// Try to optimize 'icmp GEP, P' or 'icmp P, GEP'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Testability,Test,Test,3,"// Test if the ICmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms, such as ScalarEvolution; // and CodeGen. And in this case, at least one of the comparison; // operands has at least one user besides the compare (the select),; // which would often largely negate the benefit of folding anyway.; //; // Do the same for the other patterns recognized by matchSelectPattern.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:311,Availability,down,down,311,"// FIXME: We only do this after checking for min/max to prevent infinite; // looping caused by a reverse canonicalization of these patterns for min/max.; // FIXME: The organization of folds is a mess. These would naturally go into; // canonicalizeCmpWithConstant(), but we can't move all of the above folds; // down here after the min/max restriction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:59,Usability,clear,clear,59,// For i32: x <u 2147483648 -> x >s -1 -> true if sign bit clear,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,Integrability,wrap,wrapping,33,"// The folds in here may rely on wrapping flags and special constants, so; // they can break up min/max idioms in some cases but not seemingly similar; // patterns.; // FIXME: It may be possible to enhance select folding to make this; // unnecessary. It may also be moot if we canonicalize to min/max; // intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:198,Modifiability,enhance,enhance,198,"// The folds in here may rely on wrapping flags and special constants, so; // they can break up min/max idioms in some cases but not seemingly similar; // patterns.; // FIXME: It may be possible to enhance select folding to make this; // unnecessary. It may also be moot if we canonicalize to min/max; // intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:41,Testability,test,test,41,// Try to match comparison as a sign bit test. Intentionally do this after; // foldICmpInstWithConstant() to potentially let other folds to happen first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:453,Integrability,depend,depend,453,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:138,Usability,simpl,simplified,138,"// In case of a comparison with two select instructions having the same; // condition, check whether one of the resulting branches can be simplified.; // If so, just compare the other branch and select the appropriate result.; // For example:; // %tmp1 = select i1 %cmp, i32 %y, i32 %x; // %tmp2 = select i1 %cmp, i32 %z, i32 %x; // %cmp2 = icmp slt i32 %tmp2, %tmp1; // The icmp will result false for the false value of selects and the result; // will depend upon the comparison of true values of selects if %cmp is; // true. Thus, transform this into:; // %cmp = icmp slt i32 %y, %z; // %sel = select i1 %cond, i1 %cmp, i1 false; // This handles similar cases to transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:49,Usability,simpl,simplified,49,// Check whether comparison of TrueValues can be simplified,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:50,Usability,simpl,simplified,50,// Check whether comparison of FalseValues can be simplified,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:10,Performance,optimiz,optimize,10,// Try to optimize equality comparisons against alloca-based pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:97,Energy Efficiency,power,power,97,// Transform (X & ~Y) == 0 --> (X & Y) != 0; // and (X & ~Y) != 0 --> (X & Y) == 0; // if A is a power of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:11,Testability,test,test,11,// Signbit test folds; // Fold (X u>> BitWidth - 1 Pred ZExt(i1)) --> X s< 0 Pred i1; // Fold (X s>> BitWidth - 1 Pred SExt(i1)) --> X s< 0 Pred i1,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:44,Availability,down,downwards,44,"// Following test does NOT adjust InputSize downwards for signed inputs,; // because the most negative value still requires all the mantissa bits; // to distinguish it from one less than that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:13,Testability,test,test,13,"// Following test does NOT adjust InputSize downwards for signed inputs,; // because the most negative value still requires all the mantissa bits; // to distinguish it from one less than that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:33,Usability,simpl,simplify,33,"// Otherwise, we can potentially simplify the comparison. We know that it; // will always come through as an integer value and we know the constant is; // not a NAN (it would have been previously simplified).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:196,Usability,simpl,simplified,196,"// Otherwise, we can potentially simplify the comparison. We know that it; // will always come through as an integer value and we know the constant is; // not a NAN (it would have been previously simplified).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Testability,test,test,85,"// When C is not 0.0 and infinities are not allowed:; // (C / X) < 0.0 is a sign-bit test of X; // (C / X) < 0.0 --> X < 0.0 (if C is positive); // (C / X) < 0.0 --> X > 0.0 (if C is negative, swap the predicate); //; // Proof:; // Multiply (C / X) < 0.0 by X * X / C.; // - X is non zero, if it is the flag 'ninf' is violated.; // - C defines the sign of X * X * C. Thus it also defines whether to swap; // the predicate. C is also non zero by definition.; //; // Thus X * X / C is non zero and the transformation is valid. [qed]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:64,Safety,avoid,avoid,64,// Check the properties of the dividend. It must not be zero to avoid a; // division by zero (see Proof).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize fabs(X) compared with zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Usability,Simpl,Simplify,3,"// Simplify 'fcmp pred X, X'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:3,Testability,Test,Test,3,"// Test if the FCmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms, such as ScalarEvolution; // and CodeGen. And in this case, at least one of the comparison; // operands has at least one user besides the compare (the select),; // which would often largely negate the benefit of folding anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:60,Energy Efficiency,reduce,reduce,60,"// X can't possibly equal the higher-precision constant, so reduce any; // equality comparison.; // TODO: Other predicates can be handled via getFCmpCode().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:71,Safety,Avoid,Avoid,71,"// fcmp (fpext X), C -> fcmp X, (fptrunc C) if fptrunc is lossless; // Avoid lossy conversions and denormals.; // Zero is a special case that's OK to convert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:22,Testability,test,test,22,// Convert a sign-bit test of an FP value into a cast and integer compare.; // TODO: Simplify if the copysign constant is 0.0 or NaN.; // TODO: Handle non-zero compare constants.; // TODO: Handle other predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp:85,Usability,Simpl,Simplify,85,// Convert a sign-bit test of an FP value into a cast and integer compare.; // TODO: Simplify if the copysign constant is 0.0 or NaN.; // TODO: Handle non-zero compare constants.; // TODO: Handle other predicates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineCompares.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:428,Integrability,interface,interfaces,428,"//===- InstCombineInternal.h - InstCombine pass internals -------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; ///; /// This file provides internal interfaces used to implement the InstCombine.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Perform,Perform,4,/// Perform early cleanup and prepare the InstCombine worklist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:103,Integrability,rout,routine,103,/// True when DB dominates all uses of DI except UI.; /// UI must be in the same block as DI.; /// The routine checks that the DI parent and DB are different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:37,Performance,optimiz,optimizing,37,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:176,Performance,perform,performed,176,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:121,Testability,log,logic,121,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:153,Testability,log,logic,153,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:98,Usability,simpl,simplification,98,"/// Classify whether a cast is worth optimizing.; ///; /// This is a helper to decide whether the simplification of; /// logic(cast(A), cast(B)) to cast(logic(A, B)) should be performed.; ///; /// \param CI The cast we are interested in.; ///; /// \return true if this cast actually results in any code being generated and; /// if it cannot already be eliminated by some other transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Performance,optimiz,optimize,11,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:397,Usability,simpl,simplification,397,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:436,Usability,simpl,simplified,436,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:575,Usability,simpl,simplification,575,"/// Try to optimize a sequence of instructions checking if an operation; /// on LHS and RHS overflows.; ///; /// If this overflow check is done via one of the overflow check intrinsics,; /// then CtxI has to be the call instruction calling that intrinsic. If this; /// overflow check is done by arithmetic followed by a compare, then CtxI has; /// to be the arithmetic instruction.; ///; /// If a simplification is possible, stores the simplified result of the; /// operation in OperationResult and result of the overflow check in; /// OverflowResult, and return true. If no simplification is possible,; /// returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:290,Performance,perform,performed,290,/// Transform (zext icmp) to bitwise / integer operations in order to; /// eliminate it.; ///; /// \param ICI The icmp of the (zext icmp) pair we are interested in.; /// \parem CI The zext of the (zext icmp) pair we are interested in.; ///; /// \return null if the transformation cannot be performed. If the; /// transformation can be performed the new instruction that replaces the; /// (zext icmp) pair will be returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:335,Performance,perform,performed,335,/// Transform (zext icmp) to bitwise / integer operations in order to; /// eliminate it.; ///; /// \param ICI The icmp of the (zext icmp) pair we are interested in.; /// \parem CI The zext of the (zext icmp) pair we are interested in.; ///; /// \return null if the transformation cannot be performed. If the; /// transformation can be performed the new instruction that replaces the; /// (zext icmp) pair will be returned.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Optimiz,Optimize,4,"/// Optimize (fcmp)&(fcmp) or (fcmp)|(fcmp).; /// NOTE: Unlike most of instcombine, this returns a Value which should; /// already be inserted into the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:3,Performance,Optimiz,Optimize,3,"// Optimize one of these forms:; // and i1 Op, SI / select i1 Op, i1 SI, i1 false (if IsAnd = true); // or i1 Op, SI / select i1 Op, i1 true, i1 SI (if IsAnd = false); // into simplier select instruction using isImpliedCondition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:176,Usability,simpl,simplier,176,"// Optimize one of these forms:; // and i1 Op, SI / select i1 Op, i1 SI, i1 false (if IsAnd = true); // or i1 Op, SI / select i1 Op, i1 true, i1 SI (if IsAnd = false); // into simplier select instruction using isImpliedCondition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:97,Modifiability,rewrite,rewrite,97,/// Create and insert the idiom we use to indicate a block is unreachable; /// without having to rewrite the CFG from within InstCombine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:56,Energy Efficiency,reduce,reduced,56,// Make sure that we reprocess all operands now that we reduced their; // use counts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:4,Performance,Perform,Performs,4,/// Performs a few simplifications for operators which are associative; /// or commutative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:19,Usability,simpl,simplifications,19,/// Performs a few simplifications for operators which are associative; /// or commutative.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:235,Usability,simpl,simplifications,235,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:323,Usability,simpl,simplified,323,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:367,Usability,simpl,simplify,367,"/// Tries to simplify binary operations which some other binary; /// operation distributes over.; ///; /// It does this by either by factorizing out common terms (eg ""(A*B)+(A*C)""; /// -> ""A*(B+C)"") or expanding out if this results in simplifications (eg: ""A; /// & (B | C) -> (A&B) | (A&C)"" if this is a win). Returns the simplified; /// value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,/// Tries to simplify add operations using the definition of remainder.; ///; /// The definition of remainder is X % C = X - (X / C ) * C. The add; /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to; /// X % (C0 * C1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:202,Usability,simpl,simplified,202,/// Tries to simplify add operations using the definition of remainder.; ///; /// The definition of remainder is X % C = X - (X / C ) * C. The add; /// expression X % C0 + (( X / C0 ) % C1) * C0 can be simplified to; /// X % (C0 * C1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:74,Energy Efficiency,efficient,efficiently,74,// Binary Op helper for select operations where the expression can be; // efficiently reorganized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:177,Availability,Mask,Mask,177,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // -> (BinOp (logic_shift (BinOp X, Y)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:248,Availability,Mask,Mask,248,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // -> (BinOp (logic_shift (BinOp X, Y)), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,"/// Tries to simplify binops of select and cast of the select condition.; ///; /// (Binop (cast C), (select C, T, F)); /// -> (select C, C0, C1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations by factorizing out common terms; /// (e. g. ""(A*B)+(A*C)"" -> ""A*(B+C)"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:33,Usability,simpl,simpler,33,/// Attempts to replace V with a simpler value based on the demanded; /// bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:113,Usability,simpl,simplifications,113,"/// Helper routine of SimplifyDemandedUseBits. It computes KnownZero/KnownOne; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:59,Usability,simpl,simplify,59,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify demanded; /// bit for ""r1 = shr x, c1; r2 = shl r1, c2"" instruction sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:13,Usability,simpl,simplify,13,/// Tries to simplify operands to an integer instruction based on its; /// demanded bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:196,Usability,simpl,simplifies,196,"/// For a binary operator with 2 phi operands, try to hoist the binary; /// operation before the phi. This can result in fewer instructions in; /// patterns where at least one set of phi operands simplifies.; /// Example:; /// BB3: binop (phi [X, BB1], [C1, BB2]), (phi [Y, BB1], [C2, BB2]); /// -->; /// BB1: BO = binop X, Y; /// BB3: phi [BO, BB1], [(binop C1, C2), BB2]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:26,Integrability,wrap,wrapper,26,/// This is a convenience wrapper function for the above two functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h:67,Performance,perform,performed,67,"/// Attempt to negate \p Root. Retuns nullptr if negation can't be performed,; /// otherwise returns negated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineInternal.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:428,Performance,load,load,428,"//===- InstCombineLoadStoreAlloca.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the visit functions for load, store and alloca.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:496,Performance,optimiz,optimize,496,"/// isOnlyCopiedFromConstantMemory - Recursively walk the uses of a (derived); /// pointer to an alloca. Ignore any reads of the pointer, return false if we; /// see any stores or other unknown uses. If we see pointer arithmetic, keep; /// track of whether it moves the pointer (with IsOffset) but otherwise traverse; /// the uses. If we see a memcpy/memmove that targets an unoffseted pointer to; /// the alloca, and if the source pointer is a pointer to a constant memory; /// location, we can optimize this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:23,Performance,load,loads,23,"// Ignore non-volatile loads, they are always ok.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,load,load,64,// If this is the function being called then we treat it like a load and; // ignore it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:78,Performance,load,load,78,"// If this call site doesn't modify the memory, then we know it is just; // a load (but one that potentially returns the value itself), so we can; // ignore it if we know that the value isn't captured.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:101,Performance,load,load,101,"// If the transfer is using the alloca as a source of the transfer, then; // ignore it since it is a load (unless the transfer is volatile).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,Safety,safe,safely,77,"// If the pointer has been offset from the start of the alloca, we can't; // safely handle this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:31,Safety,safe,safe,31,"// Otherwise, the transform is safe. Remember the copy instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:176,Security,expose,exposed,176,"// Ensure that the alloca array size argument has type equal to the offset; // size of the alloca() pointer, which, in the tyical case, is intptr_t,; // so that any casting is exposed early.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:309,Availability,down,down,309,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:262,Integrability,depend,depending,262,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:357,Performance,load,load,357,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:417,Performance,load,load,417,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:586,Performance,load,load,586,"// If I and V are pointers in different address space, it is not allowed to; // use replaceAllUsesWith since I and V have different types. A; // non-target-specific transformation should not use addrspacecast on V since; // the two address space may be disjoint depending on target.; //; // This class chases down uses of the old pointer until reaching the load; // instructions, then replaces the old pointer in the load instructions with; // the new pointer. If during the chasing it sees bitcast or GEP, it will; // create new bitcast or GEP with the new pointer and use them in the load; // instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:156,Energy Efficiency,allocate,allocate,156,"// Move all alloca's of zero byte objects to the entry block and merge them; // together. Note that we only do this for alloca's, because malloc should; // allocate and return a unique pointer, even for a zero byte allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,load,load,35,// Are we allowed to form a atomic load or store of this type?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:24,Performance,load,load,24,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:93,Performance,load,load,93,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:210,Performance,load,loaded,210,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:310,Performance,load,load,310,"/// Helper to combine a load to a new type.; ///; /// This just does the work of combining a load to a new type. It handles; /// metadata, etc., and returns the new instruction. The \c NewTy should be the; /// loaded *value* type. This will convert it to a pointer, cast the operand to; /// that pointer type, load it, etc.; ///; /// Note that this will create all of the instructions with whatever insert; /// point the \c InstCombinerImpl currently is using.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:79,Integrability,rout,routine,79,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a store instruction changing *only its; // type*. The only metadata it makes sense to drop is metadata which is; // invalidated when the pointer type changes. This should essentially; // never be the case in LLVM, but we explicitly switch over only known; // metadata to be conservatively correct. If you are adding metadata to; // LLVM which pertains to stores, you almost certainly want to add it; // here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:415,Integrability,rout,routine,415,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:12,Performance,load,loads,12,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:162,Performance,load,load,162,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:207,Performance,load,load,207,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:278,Performance,load,loading,278,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:375,Performance,load,load,375,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:456,Performance,load,load,456,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:483,Performance,load,loads,483,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:603,Performance,load,loads,603,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:759,Performance,load,load,759,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:783,Performance,load,load,783,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:952,Performance,load,loaded,952,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:869,Safety,risk,risky,869,"/// Combine loads to match the type of their uses' value after looking; /// through intervening bitcasts.; ///; /// The core idea here is that if the result of a load is used in an operation,; /// we should load the type most conducive to that operation. For example, when; /// loading an integer and converting that immediately to a pointer, we should; /// instead directly load a pointer.; ///; /// However, this routine must never change the width of a load or the number of; /// loads as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows loads to more closely model the types; /// of their consuming operations.; ///; /// Currently, we also refuse to change the precise type used for an atomic load; /// or a volatile load. This is debatable, and might be reasonable to change; /// later. However, it is risky in case some backend or other part of LLVM is; /// relying on the exact type loaded to select appropriate atomic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:87,Performance,load,loads,87,// FIXME: We could probably with some care handle both volatile and ordered; // atomic loads here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:111,Usability,clear,clear,111,// FIXME: We could probably with some care handle both volatile and ordered; // atomic loads here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:30,Performance,load,loaded,30,"// Fold away bit casts of the loaded value by loading the desired type.; // Note that we should not do this for pointer<->integer casts,; // because that would result in type punning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:46,Performance,load,loading,46,"// Fold away bit casts of the loaded value by loading the desired type.; // Note that we should not do this for pointer<->integer casts,; // because that would result in type punning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:38,Performance,load,loads,38,// FIXME: We should also canonicalize loads of vectors when their elements are; // cast to other types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:104,Usability,clear,clear,104,// FIXME: We could probably with some care handle both volatile and atomic; // stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:122,Deployability,pipeline,pipeline,122,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,load,loads,26,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,scalab,scalable,35,// Don't unpack for structure with scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:63,Performance,load,load,63,// Propagate AA metadata. It'll still be valid on the narrowed load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,optimiz,optimize,64,"// Bail out if the array is too large. Ideally we would like to optimize; // arrays of arbitrary size but this has a terrible impact on compile time.; // The threshold here is chosen arbitrarily, maybe needs a little bit of; // tuning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:58,Integrability,wrap,wrap,58,"// Make sure that, even if the multiplication below would wrap as an; // uint64_t, we still do the right thing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:376,Performance,load,load,376,"// If we're indexing into an object of a known size, and the outer index is; // not a constant, but having any value but zero would lead to undefined; // behavior, replace it with zero.; //; // For example, if we have:; // @f.a = private unnamed_addr constant [1 x i32] [i32 12], align 4; // ...; // %arrayidx = getelementptr inbounds [1 x i32]* @f.a, i64 0, i64 %x; // ... = load i32* %arrayidx, align 4; // Then we know that we can replace %x in the GEP with i64 0.; //; // FIXME: We could fold any GEP index to zero that would cause UB if it were; // not zero. Currently, we only handle the first such index. Also, we could; // also search through non-zero constant indices if we kept track of the; // offsets those indices implied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:50,Availability,avail,available,50,"// Size information about scalable vectors is not available, so we cannot; // deduce whether indexing at n is undefined behaviour or not. Bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,scalab,scalable,26,"// Size information about scalable vectors is not available, so we cannot; // deduce whether indexing at n is undefined behaviour or not. Bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:144,Integrability,wrap,wrap,144,"// FIXME: If the GEP is not inbounds, and there are extra indices after the; // one we'll replace, those could cause the address computation to wrap; // (rendering the IsAllNonNegative() check below insufficient). We can do; // better, ignoring zero indices (and other indices we can prove small; // enough not to wrap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:314,Integrability,wrap,wrap,314,"// FIXME: If the GEP is not inbounds, and there are extra indices after the; // one we'll replace, those could cause the address computation to wrap; // (rendering the IsAllNonNegative() check below insufficient). We can do; // better, ignoring zero indices (and other indices we can prove small; // enough not to wrap).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:43,Modifiability,variab,variable,43,"// If we're indexing into an object with a variable index for the memory; // access, but the object has only one element, we can assume that the index; // will always be zero. If we replace the GEP, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:77,Security,access,access,77,"// If we're indexing into an object with a variable index for the memory; // access, but the object has only one element, we can assume that the index; // will always be zero. If we replace the GEP, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:27,Performance,load,loaded,27,// Try to canonicalize the loaded type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:29,Performance,load,load,29,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:49,Performance,load,load,49,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:121,Security,access,accesses,121,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:13,Usability,simpl,simple,13,"// Do really simple store-to-load forwarding and load CSE, to catch cases; // where there are several consecutive memory accesses to the same location,; // separated by a few arithmetic operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:78,Performance,load,loads,78,// None of the following transforms are legal for volatile/ordered atomic; // loads. Most of them do apply for unordered atomics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load(gep null, ...) -> unreachable; // load null/undef -> unreachable; // TODO: Consider a target hook for valid address spaces for this xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:42,Performance,load,load,42,"// load(gep null, ...) -> unreachable; // load null/undef -> unreachable; // TODO: Consider a target hook for valid address spaces for this xforms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:276,Performance,load,loads,276,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:370,Performance,load,load,370,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:467,Performance,load,load,467,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:163,Safety,redund,redundancy,163,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:155,Security,expose,exposes,155,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:130,Usability,simpl,simplifications,130,"// Change select and PHI nodes to select values instead of addresses: this; // helps alias analysis out a lot, allows many others simplifications, and; // exposes redundancy in the code.; //; // Note that we cannot do the transformation unless we know that the; // introduced loads cannot trap! Something like this is valid as long as; // the condition is always false: load (select bool %C, int* null, int* %G),; // but it would not be valid if we transformed it to load from null; // unconditionally.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:51,Performance,load,load,51,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:61,Performance,load,load,61,"// load (select (Cond, &V1, &V2)) --> select(Cond, load &V1, load &V2).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (cond, null, P)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:36,Performance,load,load,36,"// load (select (cond, null, P)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Performance,load,load,3,"// load (select (cond, P, null)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:36,Performance,load,load,36,"// load (select (cond, P, null)) -> load P",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:497,Safety,safe,safely,497,"/// Look for extractelement/insertvalue sequence that acts like a bitcast.; ///; /// \returns underlying value that was ""cast"", or nullptr otherwise.; ///; /// For example, if we have:; ///; /// %E0 = extractelement <2 x double> %U, i32 0; /// %V0 = insertvalue [2 x double] undef, double %E0, 0; /// %E1 = extractelement <2 x double> %U, i32 1; /// %V1 = insertvalue [2 x double] %V0, double %E1, 1; ///; /// and the layout of a <2 x double> is isomorphic to a [2 x double],; /// then %V1 can be safely approximated by a conceptual ""bitcast"" of %U.; /// Note that %U may contain non-undef values where %V1 has undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:263,Integrability,rout,routine,263,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:709,Safety,risk,risky,709,"/// Combine stores to match the type of value being stored.; ///; /// The core idea here is that the memory does not have any intrinsic type and; /// where we can we should match the type of a store to the type of value being; /// stored.; ///; /// However, this routine must never change the width of a store or the number of; /// stores as that would introduce a semantic change. This combine is expected to; /// be a semantic no-op which just allows stores to more closely model the types; /// of their incoming values.; ///; /// Currently, we also refuse to change the precise type used for an atomic or; /// volatile store. This is debatable, and might be reasonable to change later.; /// However, it is risky in case some backend or other part of LLVM is relying; /// on the exact type stored to select appropriate atomic operations.; ///; /// \returns true if the store was successfully combined away. This indicates; /// the caller must erase the store instruction. We have to let the caller erase; /// the store instruction as otherwise there is no way to signal whether it was; /// combined or not: IC.EraseInstFromFunction returns a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:112,Usability,clear,clear,112,// FIXME: We could probably with some care handle both volatile and ordered; // atomic stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:104,Usability,clear,clear,104,// FIXME: We could probably with some care handle both volatile and atomic; // stores here but it isn't clear that this is important.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:122,Deployability,pipeline,pipeline,122,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Performance,load,loads,26,// We don't want to break loads with padding here as we'd loose; // the knowledge that padding exists for the rest of the pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:35,Performance,scalab,scalable,35,// Don't unpack for structure with scalable vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:64,Performance,optimiz,optimize,64,"// Bail out if the array is too large. Ideally we would like to optimize; // arrays of arbitrary size but this has a terrible impact on compile time.; // The threshold here is chosen arbitrarily, maybe needs a little bit of; // tuning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:287,Performance,load,load,287,"/// equivalentAddressValues - Test if A and B will obviously have the same; /// value. This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:30,Testability,Test,Test,30,"/// equivalentAddressValues - Test if A and B will obviously have the same; /// value. This includes recognizing that %t0 and %t1 will have the same; /// value in code like this:; /// %t0 = getelementptr \@a, 0, 3; /// store i32 0, i32* %t0; /// %t1 = getelementptr \@a, 0, 3; /// %t2 = load i32* %t1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Testability,Test,Test,3,// Test if the values are trivially equivalent.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:3,Testability,Test,Test,3,"// Test if the values come form identical arithmetic instructions.; // This uses isIdenticalToWhenDefined instead of isIdenticalTo because; // its only used to compare two uses within the same basic block, which; // means that they'll always either have the same value or one of them; // will have an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:103,Modifiability,refactor,refactoring,103,// Don't hack volatile/ordered stores.; // FIXME: Some bits are legal for ordered atomic stores; needs refactoring.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:197,Security,access,accesses,197,"// Do really simple DSE, to catch cases where there are several consecutive; // stores to the same location, separated by a few arithmetic operations. This; // situation often occurs with bitfield accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:13,Usability,simpl,simple,13,"// Do really simple DSE, to catch cases where there are several consecutive; // stores to the same location, separated by a few arithmetic operations. This; // situation often occurs with bitfield accesses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:146,Security,expose,expose,146,"// Manually add back the original store to the worklist now, so it will; // be processed after the operands of the removed store, as this may; // expose additional DSE opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:16,Performance,load,load,16,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:55,Performance,load,loaded,55,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:98,Performance,load,loading,98,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:185,Performance,load,load,185,"// If this is a load, we have to stop. However, if the loaded value is from; // the pointer we're loading and is producing the pointer we're storing,; // then *this* store is dead (X = load P; store X -> P).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:24,Performance,load,load,24,"// Otherwise, this is a load from some other location. Stores before it; // may not be dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:19,Performance,load,loads,19,"// Don't skip over loads, throws or things that can modify memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:48,Usability,Simpl,SimplifyCFG,48,"// store X, null -> turns into 'unreachable' in SimplifyCFG; // store X, GEP(null, Y) -> turns into 'unreachable' in SimplifyCFG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:117,Usability,Simpl,SimplifyCFG,117,"// store X, null -> turns into 'unreachable' in SimplifyCFG; // store X, GEP(null, Y) -> turns into 'unreachable' in SimplifyCFG",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:26,Security,audit,audited,26,// This code has not been audited for volatile/ordered case.; // Check if the successor block has exactly 2 incoming edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp:34,Safety,safe,safe,34,// Advance to a place where it is safe to insert the new store and insert it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineLoadStoreAlloca.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:112,Usability,simpl,simplify,112,"/// The specific integer value is used in a context where it is known to be; /// non-zero. If this allows us to simplify the computation, do so and return; /// the new operand, otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:94,Safety,safe,safe,94,"// If V has multiple uses, then we would have to do more analysis to determine; // if this is safe. For example, the use could be in dynamically unreached; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Energy Efficiency,Power,PowerOfTwo,4,// (PowerOfTwo >>u B) --> isExact since shifting out the result would make it; // inexact. Similarly for <<.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:131,Usability,simpl,simplify,131,"// TODO: Lots more we could do here:; // If V is a phi node, we can call this on each of its operands.; // ""select cond, X, 0"" can simplify to ""X"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:197,Energy Efficiency,reduce,reduces,197,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:78,Safety,detect,detect,78,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:148,Usability,Simpl,SimplifyBinOp,148,"// TODO: This is a specific form of a much more general pattern.; // We could detect a select with any binop identity constant, or we; // could use SimplifyBinOp to see if either arm of the select reduces.; // But that needs to be done carefully and/or while removing potential; // reverse canonicalizations as in InstCombiner::foldSelectIntoOp().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:4,Energy Efficiency,Reduce,Reduce,4,/// Reduce integer multiplication patterns that contain a (+/-1 << Z) factor.; /// Callers are expected to call this twice to handle commuted patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:30,Modifiability,extend,extended,30,// Try to convert multiply of extended operand to narrow negate and shift; // for better analysis.; // This is valid if the shift amount (trailing zeros in the multiplier; // constant) clears more high bits than the bitwidth difference between; // source and destination types:; // ({z/s}ext X) * (-1<<C) --> (zext (-X)) << C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:185,Usability,clear,clears,185,// Try to convert multiply of extended operand to narrow negate and shift; // for better analysis.; // This is valid if the shift amount (trailing zeros in the multiplier; // constant) clears more high bits than the bitwidth difference between; // source and destination types:; // ({z/s}ext X) * (-1<<C) --> (zext (-X)) << C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Usability,Simpl,Simplify,3,// Simplify mul instructions with a constant RHS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:11,Usability,simpl,simplifies,11,// C1*MulC simplifies to a tidier constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:147,Modifiability,extend,extends,147,"// (zext bool X) * (zext bool Y) --> zext (and X, Y); // (sext bool X) * (sext bool Y) --> zext (and X, Y); // Note: -1 * -1 == 1 * 1 == 1 (if the extends match, the result is the same)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:218,Energy Efficiency,reduce,reduce,218,"// The following transforms are done irrespective of the number of uses; // for the expression ""1.0/sqrt(X)"".; // 1) 1.0/sqrt(X) * X -> X/sqrt(X); // 2) X * 1.0/sqrt(X) -> X/sqrt(X); // We always expect the backend to reduce X/sqrt(X) to sqrt(X), if it; // has the necessary (reassoc) fast-math-flags.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:123,Usability,simpl,simplify,123,"// Like the similar transform in instsimplify, this requires 'nsz' because; // sqrt(-0.0) = -0.0, and -0.0 * -0.0 does not simplify to -0.0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:85,Energy Efficiency,power,power,85,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:186,Performance,latency,latency,186,"// (X*Y) * X => (X*X) * Y where Y != X; // The purpose is two-fold:; // 1) to form a power expression (of X).; // 2) potentially shorten the critical path: After transformation, the; // latency of the instruction Y is amortized by the expression of X*X,; // and therefore Y is in a ""less critical"" position compared to what it; // was before the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:184,Safety,safe,safely,184,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Usability,Simpl,Simplify,3,"// Simplify FMUL recurrences starting with 0.0 to 0.0 if nnan and nsz are set.; // Given a phi node with entry value as 0 and it used in fmul operation,; // we can replace fmul with 0 safely and eleminate loop operation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:137,Performance,optimiz,optimized,137,"// We cannot preserve ninf if nnan flag is not set.; // If X is NaN and Y is Inf then in original program we had NaN * NaN,; // while in optimized version NaN * Inf and this is a poison with ninf flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,Integrability,wrap,wrap,23,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shifted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:43,Integrability,wrap,wrap,43,// Both operands must have the matching no-wrap for this kind of division.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:23,Integrability,wrap,wrap,23,"// With appropriate no-wrap constraints, remove a common factor in the; // dividend and divisor that is disguised as a left-shift amount.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Energy Efficiency,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Modifiability,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,Usability,simpl,simplifyDivRemOfSelectWithZeroOp,174,"// If the divisor is a select-of-constants, try to constant fold all div ops:; // C / (select Cond, TrueC, FalseC) --> select Cond, (C / TrueC), (C / FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:3,Safety,avoid,avoid,3,// avoid X udiv 0,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:27,Integrability,wrap,wrap,27,"// With the appropriate no-wrap constraint, remove a multiply by the divisor; // after peeking through another divide:; // ((Op1 * X) / Y) / Op1 --> X / Y",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:163,Availability,failure,failure,163,"// Take the exact integer log2 of the value. If DoFold is true, create the; // actual instructions, otherwise return a non-null dummy value. Return nullptr; // on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:10,Testability,assert,assert,10,// FIXME: assert that Op1 isn't/doesn't contain undef.; // log2(2^C) -> C,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:17,Testability,test,tests,17,"// The remaining tests are all recursive, so bail out if we hit the limit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:68,Performance,optimiz,optimization,68,"// log2(Cond ? X : Y) -> Cond ? log2(X) : log2(Y); // FIXME: missed optimization: if one of the hands of select is/contains; // undef, just directly pick the other one.; // FIXME: can both hands contain undef?; // FIXME: Require one use?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:20,Modifiability,extend,extended,20,"/// If we have zero-extended operands of an unsigned div or rem, we may be able; /// to narrow the operation (sink the zext below the math).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:27,Modifiability,extend,extended,27,"// If the dividend is sign-extended and the constant divisor is small enough; // to fit in the source type, shrink the division to the narrower type:; // (sext X) sdiv C --> sext (X sdiv C)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:81,Modifiability,enhance,enhanced,81,// -X / C --> X / -C (if the negation doesn't overflow).; // TODO: This could be enhanced to handle arbitrary vector constants by; // checking if all elements are not the min-signed-val.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:56,Safety,Safe,Safe,56,"// X sdiv (1 << Y) -> X udiv (1 << Y) ( -> X u>> Y); // Safe because the only negative value (1 << Y) can take on is; // INT_MIN, and X sdiv INT_MIN == X udiv INT_MIN == 0 if X doesn't have; // the sign bit set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:64,Safety,safe,safe,64,"// If the constant divisor has an exact inverse, this is always safe. If not,; // then we can still create a reciprocal if fast-math-flags allow it and the; // constant is a regular number (not zero, infinite, or denormal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:185,Performance,optimiz,optimization,185,"// Z / pow(X, Y) --> Z * pow(X, -Y); // Z / exp{2}(Y) --> Z * exp{2}(-Y); // In the general case, this creates an extra instruction, but fmul allows; // for better canonicalization and optimization than fdiv.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:130,Safety,avoid,avoided,130,"// Z / (1.0 / Y) => (Y * Z); //; // This is a special case of Z / (X / Y) => (Y * Z) / X, with X = 1.0. The; // m_OneUse check is avoided because even in the case of the multiple uses; // for 1.0/Y, the number of instructions remain the same and a division is; // replaced by a multiplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:72,Integrability,wrap,wraparound,72,"// powi(X, Y) / X --> powi(X, Y-1); // This is legal when (Y - 1) can't wraparound, in which case reassoc and nnan; // are required.; // TODO: Multi-use may be also better off creating Powi(x,y-1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:92,Integrability,depend,depending,92,"// Helper function to emit either (RemSimplificationC << X) or; // (RemSimplificationC * X) depending on whether we matched Op0/Op1 as; // (shl V, X) or (mul V, X) respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Energy Efficiency,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:168,Modifiability,Adapt,Adapt,168,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:174,Usability,simpl,simplifyDivRemOfSelectWithZeroOp,174,"// If the divisor is a select-of-constants, try to constant fold all rem ops:; // C % (select Cond, TrueC, FalseC) --> select Cond, (C % TrueC), (C % FalseC); // TODO: Adapt simplifyDivRemOfSelectWithZeroOp to allow this and other folds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:150,Availability,fault,fault,150,"// foldOpIntoPhi will speculate instructions to the end of the PHI's; // predecessor blocks, so do this only if we know the srem or urem; // will not fault.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp:39,Energy Efficiency,power,power,39,"// X urem Y -> X and Y-1, where Y is a power of 2,",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineMulDivRem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:23,Usability,simpl,simply,23,"// In i1, negation can simply be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:15,Testability,log,logic,15,"// Rest of the logic is recursive, so if it's time to give up then it's time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:21,Performance,cache,cached,21,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:89,Performance,cache,cache,89,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:181,Performance,cache,cache,181,"// We did not find a cached result for negation of V. While there,; // let's temporairly cache a placeholder value, with the idea that if later; // during negation we fetch it from cache, we'll know we're in a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:7,Performance,cache,cache,7,// And cache the (real) result for the future.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp:51,Safety,avoid,avoid,51,"// We must cleanup newly-inserted instructions, to avoid any potential; // endless combine looping.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineNegator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:795,Performance,Load,Load,795,"// Replace Integer typed PHI PN if the PHI's value is used as a pointer value.; // If there is an existing pointer typed PHI that produces the same value as PN,; // replace PN and the IntToPtr operation with it. Otherwise, synthesize a new; // PHI node:; //; // Case-1:; // bb1:; // int_init = PtrToInt(ptr_init); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); //; // ==>; // bb1:; // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; //; // Case-2:; // bb1:; // int_ptr = BitCast(ptr_ptr); // int_init = Load(int_ptr); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); // ==>; // bb1:; // ptr_init = Load(ptr_ptr); // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:1045,Performance,Load,Load,1045,"// Replace Integer typed PHI PN if the PHI's value is used as a pointer value.; // If there is an existing pointer typed PHI that produces the same value as PN,; // replace PN and the IntToPtr operation with it. Otherwise, synthesize a new; // PHI node:; //; // Case-1:; // bb1:; // int_init = PtrToInt(ptr_init); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); //; // ==>; // bb1:; // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; //; // Case-2:; // bb1:; // int_ptr = BitCast(ptr_ptr); // int_init = Load(int_ptr); // br label %bb2; // bb2:; // int_val = PHI([int_init, %bb1], [int_val_inc, %bb2]; // ptr_val2 = IntToPtr(int_val); // ...; // use(ptr_val2); // ptr_val_inc = ...; // inc_val_inc = PtrToInt(ptr_val_inc); // ==>; // bb1:; // ptr_init = Load(ptr_ptr); // br label %bb2; // bb2:; // ptr_val = PHI([ptr_init, %bb1], [ptr_val_inc, %bb2]; // ...; // use(ptr_val); // ptr_val_inc = ...; // ...; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:28,Performance,load,load,28,// For a single use integer load:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:52,Availability,avail,available,52,"// Push the integer typed Load instruction into the available; // value set, and fix it up later when the pointer typed PHI; // is synthesized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:26,Performance,Load,Load,26,"// Push the integer typed Load instruction into the available; // value set, and fix it up later when the pointer typed PHI; // is synthesized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:117,Usability,undo,undo,117,"// Explicitly replace the inttoptr (rather than inserting a ptrtoint) here,; // to make sure another transform can't undo it in the meantime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:48,Performance,Load,Load,48,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:88,Performance,load,load,88,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Performance,load,load,147,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:162,Performance,load,load,162,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:302,Performance,load,load,302,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:121,Usability,simpl,simplified,121,"// Need to insert a BitCast.; // For an integer Load instruction with a single use, the load + IntToPtr; // cast will be simplified into a pointer load:; // %v = load i64, i64* %a.ip, align 8; // %v.cast = inttoptr i64 %v to float **; // ==>; // %v.ptrp = bitcast i64 * %a.ip to float **; // %v.cast = load float *, float ** %v.ptrp, align 8",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:117,Usability,undo,undo,117,"// Explicitly replace the inttoptr (rather than inserting a ptrtoint) here,; // to make sure another transform can't undo it in the meantime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:76,Performance,optimiz,optimization,76,// Iterating over all operands to check presence of target pointers for; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:63,Deployability,a/b,a/b,63,"/// If we have something like phi [add (a,b), add(a,c)] and if a/b/c and the; /// adds all have a single user, turn this into a phi and a single binop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,Safety,safe,safe,22,"// Otherwise, this is safe to transform!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:218,Modifiability,variab,variable,218,"// Don't merge two GEPs when two operands differ (introducing phi nodes); // if one of the PHIs has a constant for the index. The index may be; // substantially cheaper to compute for the constants, so making it a; // variable index could pessimize the path. This also handles the case; // for struct indices, which must always be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:306,Performance,load,load,306,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:354,Performance,load,load,354,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:427,Performance,load,load,427,"// If all of the base pointers of the PHI'd GEPs are from allocas, don't; // bother doing this transformation. At best, this will just save a bit of; // offset calculation, but all the predecessors will have to materialize the; // stack address into a register anyway. We'd actually rather *clone* the; // load up into the predecessors so that we have a load of a gep of an alloca,; // which can usually all be folded into the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:87,Modifiability,variab,variable,87,"// Otherwise, this is safe to transform. Insert PHI nodes for each operand; // that is variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:22,Safety,safe,safe,22,"// Otherwise, this is safe to transform. Insert PHI nodes for each operand; // that is variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,Performance,load,load,55,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:151,Performance,load,load,151,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:198,Performance,load,load,198,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:298,Performance,load,load,298,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:38,Safety,safe,safe,38,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:262,Safety,safe,safe,262,"/// Return true if we know that it is safe to sink the load out of the block; /// that defines it. This means that it must be obvious the value of the load is; /// not changed from the point of the load to the end of the block it is in.; ///; /// Finally, it is safe, but not profitable, to sink a load targeting a; /// non-address-taken alloca. Doing so will cause us to not promote the alloca; /// to a register.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:75,Performance,load,load,75,// Calls that only access inaccessible memory do not block sinking the; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:19,Security,access,access,19,// Calls that only access inaccessible memory do not block sinking the; // load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:11,Performance,load,load,11,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Performance,load,load,147,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:307,Performance,load,load,307,"// If this load is a load from a GEP with a constant offset from an alloca,; // then we don't want to sink it. In its present form, it will be; // load [constant stack offset]. Sinking it will cause us to have to; // materialize the stack addresses in each predecessor in a register only to; // do a shared load from register in the successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:19,Performance,load,loads,19,"// When processing loads, we need to propagate two bits of information to the; // sunk load: whether it is volatile, and what its alignment is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:87,Performance,load,load,87,"// When processing loads, we need to propagate two bits of information to the; // sunk load: whether it is volatile, and what its alignment is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:33,Performance,load,loaded,33,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:80,Performance,load,load,80,// We can't sink the load if the loaded value could be modified between the; // load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:29,Performance,load,loads,29,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:43,Performance,load,load,43,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:109,Performance,load,load,109,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:21,Performance,load,load,21,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:33,Performance,load,loaded,33,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:80,Performance,load,load,80,// We can't sink the load if the loaded value could be modified between; // the load and the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:29,Performance,load,loads,29,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:43,Performance,load,load,43,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:109,Performance,load,load,109,"// If the PHI is of volatile loads and the load block has multiple; // successors, sinking it would remove a load of the volatile value from; // the path through the other successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:26,Performance,load,load,26,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:105,Performance,load,loads,105,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:183,Performance,load,load,183,"// If this was a volatile load that we are merging, make sure to loop through; // and mark all the input loads as non-volatile. If we don't do this, we will; // insert a new volatile load and the old ones will not be deletable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:76,Modifiability,variab,variable,76,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:231,Performance,perform,performed,231,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:316,Security,expose,expose,316,"// The more common cases of a phi with no constant operands or just one; // variable operand are handled by FoldPHIArgOpIntoPHI() and foldOpIntoPhi(); // respectively. foldOpIntoPhi() wants to do the opposite transform that is; // performed here. It tries to replicate a cast in the phi operand's basic; // block to expose other folding opportunities. Thus, InstCombine will; // infinite loop without this check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:55,Safety,safe,safe,55,"// All incoming values are zexts or constants that are safe to truncate.; // Create a new phi node of the narrow type, phi together all of the new; // operands, and zext the result back to the original type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:257,Usability,simpl,simplifying,257,"// Scan the instruction, looking for input operations that can be folded away.; // If all input operands to the phi are the same instruction (e.g. a cast from; // the same type or ""+42"") we can pull the operation through the PHI, reducing; // code size and simplifying code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:147,Modifiability,rewrite,rewrite,147,"// PHIUsers - Keep track of all of the truncated values extracted from a set; // of PHIs, along with their offset. These are the things we want to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:141,Safety,avoid,avoid,141,"// PHIs are often mutually cyclic, so we keep track of a whole set of PHI; // nodes which are extracted from. PHIsToSlice is a set we use to avoid; // revisiting PHIs, PHIsInspected is a ordered list of PHIs that we need to; // check the uses of (to ensure they are all extracts).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:97,Safety,avoid,avoid,97,// PredValues - This is a temporary used when rewriting PHI nodes. It is; // hoisted out here to avoid construction/destruction thrashing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,Availability,redundant,redundant,85,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:85,Safety,redund,redundant,85,// ExtractedVals - Each new PHI we introduce is saved here so we don't; // introduce redundant PHIs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:3,Usability,Simpl,Simplify,3,// Simplify the following patterns:; // if (cond); // / \; // ... ...; // \ /; // phi [true] [false]; // and; // switch (cond); // case v1: / \ case v2:; // ... ...; // \ /; // phi [v1] [v2]; // Make sure all inputs are constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:3,Integrability,Depend,Depending,3,"// Depending on the constant, the condition may need to be inverted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:11,Usability,simpl,simplification,11,// PHINode simplification; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:163,Modifiability,variab,variables,163,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:314,Modifiability,variab,variable,314,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:206,Safety,Detect,Detecting,206,"// If this phi has a single use, and if that use just computes a value for; // the next iteration of a loop, delete the phi. This occurs with unused; // induction variables, e.g. ""for (int j = 0; ; ++j);"". Detecting this; // common case here is good because the only other things that catch this; // are induction variable analysis (sometimes) and ADCE, which is only run; // late.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:556,Availability,down,down,556,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:59,Safety,safe,safe,59,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:451,Usability,simpl,simple,451,"// When a PHI is used only to be compared with zero, it is safe to replace; // an incoming value proved as known nonzero with any non-zero constant.; // For example, in the code below, the incoming value %v can be replaced; // with any non-zero constant based on the fact that the PHI is only used to; // be compared with zero and %v is a known non-zero value:; // %v = select %cond, 1, 2; // %p = phi [%v, BB] ...; // icmp eq, %p, 0; // FIXME: To be simple, handle only integer type for now.; // This handles a small number of uses to keep the complexity down, and an; // icmp(or(phi)) can equally be replaced with any non-zero constant as the; // ""or"" will only add bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp:195,Integrability,depend,depend,195,"// If there are multiple PHIs, sort their operands so that they all list; // the blocks in the same order. This will help identical PHIs be eliminated; // by other passes. Other passes shouldn't depend on this for correctness; // however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombinePHI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:27,Modifiability,variab,variable,27,"// Last, match the compare variable operand with a binop operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:75,Energy Efficiency,power,power,75,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:125,Energy Efficiency,power,power-of-,125,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:308,Integrability,depend,depending,308,"/// This folds:; /// select (icmp eq (and X, C1)), TC, FC; /// iff C1 is a power 2 and the difference between TC and FC is a power-of-2.; /// To something like:; /// (shr (and (X, C1)), (log2(C1) - log2(TC-FC))) + FC; /// Or:; /// (shl (and (X, C1)), (log2(TC-FC) - log2(C1))) + FC; /// With some variations depending if FC is larger than TC, or the shift; /// isn't needed, or the bit widths don't match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:240,Energy Efficiency,reduce,reduce,240,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:231,Usability,simpl,simplify,231,"// In general, when both constants are non-zero, we would need an offset to; // replace the select. This would require more instructions than we started; // with. But there's one special-case that we handle here because it can; // simplify/reduce the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:89,Availability,mask,masked,89,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:175,Testability,log,logic,175,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:188,Usability,clear,clear,188,"// If the select constants differ by exactly one bit and that's the same; // bit that is masked and checked by the select condition, the select can; // be replaced by bitwise logic to set/clear one bit of the constant result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,masked,10,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:29,Usability,clear,clear,29,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:36,Usability,clear,clear,36,"// If the masked bit in V is clear, clear or set the bit in the result:; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) ^ TC; // (V & AndMaskC) == 0 ? TC : FC --> (V & AndMaskC) | TC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,masked,10,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Usability,clear,clear,41,"// If the masked bit in V is set, set or clear the bit in the result:; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) | FC; // (V & AndMaskC) != 0 ? TC : FC --> (V & AndMaskC) ^ FC",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Energy Efficiency,power,power-of-,41,// Make sure one of the select arms is a power-of-2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:120,Modifiability,enhance,enhanced,120,// TODO: The one-use restrictions for a scalar select could be eased if; // the fold of a select in visitLoadInst() was enhanced to match a pattern; // that includes a cast.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:236,Energy Efficiency,reduce,reduce,236,"// Only handle binary operators (including two-operand getelementptr) with; // one-use here. As with the cast case above, it may be possible to relax the; // one-use constraint, but that needs be examined carefully since it may not; // reduce the total number of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:196,Safety,safe,safe,196,"// If we are sinking div/rem after a select, we may need to freeze the; // condition because div/rem may induce immediate UB with a poison operand.; // For example, the following transform is not safe if Cond can ever be poison; // because we can replace poison with zero and then we have div-by-zero that; // didn't exist in the original code:; // Cond ? x/y : x/z --> x / (Cond ? y : z)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:40,Safety,safe,safe,40,"// A udiv/urem with a common divisor is safe because UB can only occur with; // div-by-zero, and that would be present in the original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:74,Performance,optimiz,optimization,74,/// Try to fold the select into one of the operands to allow further; /// optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:114,Testability,test,tests,114,// TODO: We probably ought to revisit cases where the select and FP; // instructions have different flags and add tests to ensure the; // behaviour is correct.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Safety,Avoid,Avoid,3,"// Avoid creating select between 2 constants unless it's selecting; // between 0, 1 and -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:118,Modifiability,variab,variable,118,// The shift must be valid.; // TODO: This restricts the fold to constant shift amounts. Is there a way to; // handle variable shifts safely? PR47012,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:134,Safety,safe,safely,134,// The shift must be valid.; // TODO: This restricts the fold to constant shift amounts. Is there a way to; // handle variable shifts safely? PR47012,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:104,Availability,mask,mask,104,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), 0, (shl [nsw/nuw] X, C2));; /// iff C1 is a mask and the number of its leading zeros is equal to C2; /// into:; /// shl X, C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:296,Energy Efficiency,power,powers,296,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:348,Testability,Log,Log,348,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:358,Testability,Log,Log,358,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:386,Testability,Log,Log,386,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:396,Testability,Log,Log,396,"/// We want to turn:; /// (select (icmp eq (and X, C1), 0), Y, (BinOp Y, C2)); /// into:; /// IF C2 u>= C1; /// (BinOp Y, (shl (and X, C1), C3)); /// ELSE; /// (BinOp Y, (lshr (and X, C1), C3)); /// iff:; /// 0 on the RHS is the identity value (i.e add, xor, shl, etc...); /// C1 and C2 are both powers of 2; /// where:; /// IF C2 u>= C1; /// C3 = Log(C2) - Log(C1); /// ELSE; /// C3 = Log(C1) - Log(C2); ///; /// This transform handles cases where:; /// 1. The icmp predicate is inverted; /// 2. The select operands are reversed; /// 3. The magnitude of C2 and C1 are flipped",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Availability,mask,masked,37,/// Canonicalize a set or clear of a masked set of constant bits to; /// select-of-constants form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:26,Usability,clear,clear,26,/// Canonicalize a set or clear of a masked set of constant bits to; /// select-of-constants form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:194,Usability,simpl,simplified,194,// Assuming that constant compared with zero is not undef (but it may be; // a vector with some undef elements). Otherwise (when a constant is undef); // the select expression should be already simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:182,Availability,mask,masked,182,// Check that TrueVal is a constant instead of matching it with m_Zero(); // to handle the case when it is a scalar undef value or a vector containing; // non-zero elements that are masked by undef elements in the compare; // constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Modifiability,variab,variables,37,// Match unsigned saturated add of 2 variables with an unnecessary 'not'.; // There are 8 commuted variants.; // Canonicalize -1 (saturated result) to true value of the select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:37,Modifiability,variab,variables,37,// Match unsigned saturated add of 2 variables with an unnecessary 'not'.; // Strictness of the comparison is irrelevant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Integrability,wrap,wrapping,44,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,Safety,detect,detected,23,// The overflow may be detected via the add wrapping round.; // This is only valid for strict comparison!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:23,Integrability,wrap,wrap,23,// With any pair of no-wrap subtracts:; // (A > B) ? (A - B) : (B - A) --> abs(A - B),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:336,Safety,safe,safe,336,"// The remaining subtract is not ""nuw"" any more.; // If there's one use of the subtract (no other use than the use we are; // about to replace), then we know that the sub is ""nsw"" in this context; // even if it was only ""nuw"" before. If there's another use, then we can't; // add ""nsw"" to the existing instruction because it may not be safe in the; // other user's context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:127,Usability,clear,cleared,127,"/// Attempt to fold a cttz/ctlz followed by a icmp plus select into a single; /// call to cttz/ctlz with flag 'is_zero_poison' cleared.; ///; /// For example, we can fold the following code sequence:; /// \code; /// %0 = tail call i32 @llvm.cttz.i32(i32 %x, i1 true); /// %1 = icmp ne i32 %x, 0; /// %2 = select i1 %1, i32 %0, i32 32; /// \code; ///; /// into:; /// %0 = tail call i32 @llvm.cttz.i32(i32 %x, i1 false)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Modifiability,extend,extend,13,// Skip zero extend/truncate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:14,Usability,clear,clear,14,"// Explicitly clear the 'is_zero_poison' flag. It's always valid to go from; // true to false on this flag, so we can replace it for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:764,Integrability,Wrap,Wrapping,764,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:263,Safety,safe,safe,263,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:167,Usability,simpl,simplifying,167,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:328,Usability,simpl,simplified,328,"/// If we have a select with an equality comparison, then we know the value in; /// one of the arms of the select. See if substituting this value into an arm; /// and simplifying the result yields the same value as the other arm.; ///; /// To make this transform safe, we must drop poison-generating flags; /// (nsw, etc) if we simplified to a binop because the select may be guarding; /// that poison from propagating. If the existing binop already had no; /// poison-generating flags, then this transform can be done by instsimplify.; ///; /// Consider:; /// %cmp = icmp eq i32 %x, 2147483647; /// %add = add nsw i32 %x, 1; /// %sel = select i1 %cmp, i32 -2147483648, i32 %add; ///; /// We can't replace %sel with %add unless we strip away the flags.; /// TODO: Wrapping flags could be preserved in some cases with better analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:211,Safety,avoid,avoid,211,"// In X == Y ? f(X) : Z, try to evaluate f(Y) and replace the operand.; // Make sure Y cannot be undef though, as we might pick different values for; // undef in the icmp and in f(Y). Additionally, take care to avoid replacing; // X == Y ? X : Z with X == Y ? Y : Z, as that would lead to an infinite; // replacement cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:87,Safety,avoid,avoid,87,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:41,Usability,simpl,simplification,41,// Require either the replacement or the simplification result to be a; // constant to avoid infinite loops.; // FIXME: Make this check more precise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:159,Safety,safe,safe,159,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:28,Usability,simpl,simplify,28,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:384,Usability,clear,clear,384,"// Even if TrueVal does not simplify, we can directly replace a use of; // CmpLHS with CmpRHS, as long as the instruction is not used anywhere; // else and is safe to speculatively execute (we may end up executing it; // with different operands, which should not cause side-effects or trigger; // undefined behavior). Only do this if CmpRHS is a constant, as; // profitability is not clear for other cases.; // FIXME: Support vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:24,Performance,perform,performed,24,"// InstSimplify already performed this fold if it was possible subject to; // current poison-generating flags. Check whether dropping poison-generating; // flags enables the transform.; // Try each equivalence substitution possibility.; // We have an 'EQ' comparison, so the select's false value will propagate.; // Example:; // (X == 42) ? 43 : (X + 1) --> (X == 42) ? (X + 1) : (X + 1) --> X + 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:89,Usability,simpl,simplified,89,"// Although icmp ult %x, 0 is an unusual thing to try and should generally; // have been simplified, it does not verify with undef inputs so ensure we; // are not in a strange state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:159,Modifiability,extend,extend,159,"// If we are matching from a truncated input, we need to sext the; // ReplacementLow and ReplacementHigh values. Only do the transform if they; // are free to extend due to being constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:73,Safety,abort,abort,73,"// If the [input] type of comparison and select type are different, lets abort; // for now. We could try to compare constants with trunc/[zs]ext though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:143,Safety,avoid,avoid,143,// ULT with 'add' of a constant is canonical. See foldICmpAddConstant().; // FIXME: Are there more magic icmp predicate+constant pairs we must avoid?; // Or should we just abandon this transform entirely?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:43,Safety,detect,detect,43,"// NOTE: if we wanted to, this is where to detect integer MIN/MAX",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:132,Safety,avoid,avoid,132,"// Canonicalize a signbit condition to use zero constant by swapping:; // (CmpLHS > -1) ? TV : FV --> (CmpLHS < 0) ? FV : TV; // To avoid conflicts (infinite loops) with other canonicalizations, this is; // not applied with any constant select arm.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:64,Modifiability,refactor,refactoring,64,// FIXME: This code is nearly duplicated in InstSimplify. Using/refactoring; // decomposeBitTestICmp() might help.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Modifiability,extend,extending,13,"// If we are extending from a boolean type or if we can create a select that; // has the same size operands as its condition, try to narrow the select.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:115,Availability,mask,mask,115,"// Undef in a select condition (choose one of the operands) does not mean; // the same thing as undef in a shuffle mask (any value is acceptable), so; // give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:106,Energy Efficiency,reduce,reduces,106,"// select (extelt V, Index), T, F --> select (splat V, Index), T, F; // Splatting the extracted condition reduces code (we could directly create a; // splat shuffle of the source vector to eliminate the intermediate step).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:702,Deployability,update,update,702,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:46,Testability,test,test,46,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:133,Testability,test,tests,133,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:866,Usability,simpl,simplified,866,"/// Try to eliminate select instructions that test the returned flag of cmpxchg; /// instructions.; ///; /// If a select instruction tests the returned flag of a cmpxchg instruction and; /// selects between the returned value of the cmpxchg instruction its compare; /// operand, the result of the select will always be equal to its false value.; /// For example:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 1; /// %2 = extractvalue { i64, i1 } %0, 0; /// %3 = select i1 %1, i64 %compare, i64 %2; /// ret i64 %3; ///; /// The returned value of the cmpxchg instruction (%2) is the original value; /// located at %ptr prior to any update. If the cmpxchg operation succeeds, %2; /// must have been equal to %compare. Thus, the result of the select is always; /// equal to %2, and the code can be simplified to:; ///; /// %0 = cmpxchg i64* %ptr, i64 %compare, i64 %new_value seq_cst seq_cst; /// %1 = extractvalue { i64, i1 } %0, 0; /// ret i64 %1; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:90,Usability,simpl,simplify,90,"// If the select has a single user, and this user is a select instruction that; // we can simplify, skip the cmpxchg simplification for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:117,Usability,simpl,simplification,117,"// If the select has a single user, and this user is a select instruction that; // we can simplify, skip the cmpxchg simplification for now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:11,Energy Efficiency,reduce,reduce,11,"/// Try to reduce a funnel/rotate pattern that includes a compare and select; /// into a funnel shift intrinsic. Example:; /// rotl32(a, b) --> (b == 0 ? a : ((a >> (32 - b)) | (a << b))); /// --> call llvm.fshl.i32(a, a, b); /// fshl32(a, b, c) --> (c == 0 ? a : ((b >> (32 - c)) | (a << c))); /// --> call llvm.fshl.i32(a, b, c); /// fshr32(a, b, c) --> (c == 0 ? b : ((a >> (32 - c)) | (b << c))); /// --> call llvm.fshr.i32(a, b, c)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:18,Energy Efficiency,power,power-of-,18,// This must be a power-of-2 type for a bitmasking transform to be valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:32,Safety,avoid,avoids,32,// This is a funnel/rotate that avoids shift-by-bitwidth UB in a suboptimal way.; // Convert to funnel shift intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:110,Modifiability,variab,variable,110,"// Match select ?, TC, FC where the constants are equal but negated.; // TODO: Generalize to handle a negated variable operand?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:200,Availability,mask,mask,200,"// A select of a ""select shuffle"" with a common operand can be rearranged; // to select followed by ""select shuffle"". Because of poison, this only works; // in the case of a shuffle with no undefined mask elements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:9,Availability,avail,availability,9,// Check availability.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:13,Energy Efficiency,reduce,reduce,13,"/// Tries to reduce a pattern that arises when calculating the remainder of the; /// Euclidean division. When the divisor is a power of two and is guaranteed not; /// to be negative, a signed remainder can be folded with a bitwise and.; ///; /// (x % n) < 0 ? (x % n) + n : (x % n); /// -> x & (n - 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:127,Energy Efficiency,power,power,127,"/// Tries to reduce a pattern that arises when calculating the remainder of the; /// Euclidean division. When the divisor is a power of two and is guaranteed not; /// to be negative, a signed remainder can be folded with a bitwise and.; ///; /// (x % n) < 0 ? (x % n) + n : (x % n); /// -> x & (n - 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:419,Availability,mask,mask,419,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:375,Energy Efficiency,power,power-of-two,375,"// Match the following IR pattern:; // %x.lowbits = and i8 %x, %lowbitmask; // %x.lowbits.are.zero = icmp eq i8 %x.lowbits, 0; // %x.biased = add i8 %x, %bias; // %x.biased.highbits = and i8 %x.biased, %highbitmask; // %x.roundedup = select i1 %x.lowbits.are.zero, i8 %x, i8 %x.biased.highbits; // Define:; // %alignment = add i8 %lowbitmask, 1; // Iff 1. an %alignment is a power-of-two (aka, %lowbitmask is a low bit mask); // and 2. %bias is equal to either %lowbitmask or %alignment,; // and 3. %highbitmask is equal to ~%lowbitmask (aka, to -%alignment); // then this pattern can be transformed into:; // %x.offset = add i8 %x, %lowbitmask; // %x.roundedup = and i8 %x.offset, %highbitmask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:261,Modifiability,rewrite,rewrite,261,"// namespace; /// Look for patterns like; /// %outer.cond = select i1 %inner.cond, i1 %alt.cond, i1 false; /// %inner.sel = select i1 %inner.cond, i8 %inner.sel.t, i8 %inner.sel.f; /// %outer.sel = select i1 %outer.cond, i8 %outer.sel.t, i8 %inner.sel; /// and rewrite it as; /// %inner.sel = select i1 %cond.alternative, i8 %sel.outer.t, i8 %sel.inner.t; /// %sel.outer = select i1 %cond.inner, i8 %inner.sel, i8 %sel.inner.f",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Integrability,Depend,Depending,3,"// Depending on the logical op, inner select might be in different hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:20,Testability,log,logical,20,"// Depending on the logical op, inner select might be in different hand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Safety,avoid,avoid,25,// Profitability check - avoid increasing instruction count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:51,Testability,Log,LogicalAnd,51,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:66,Testability,Log,LogicalOr,66,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:135,Testability,Log,LogicalAnd,135,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:201,Testability,Log,LogicalOr,201,"// An unsimplified select condition can match both LogicalAnd and LogicalOr; // (select true, true, false). Since below we assume that LogicalAnd implies; // InnerSel match the FVal and vice versa for LogicalOr, we can't match the; // alternative pattern here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:92,Testability,log,logical,92,"// Finally, match the condition that was driving the outermost `select`,; // it should be a logical operation between the condition that was driving; // the innermost `select` (after accounting for the possible inversions; // of the condition), and some other condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Safety,Avoid,Avoid,3,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:91,Testability,assert,assert,91,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:178,Usability,simpl,simplified,178,// Avoid potential infinite loops by checking for non-constant condition.; // TODO: Can we assert instead by improving canonicalizeSelectToShuffle()?; // Scalar select must have simplified?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Safety,safe,safe,44,// Folding select to and/or i1 isn't poison safe in general. impliesPoison; // checks whether folding it does not convert a well-defined value into; // poison.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:47,Safety,avoid,avoid,47,"// We match the ""full"" 0 or 1 constant here to avoid a potential infinite; // loop with vectors that may have undefined/poison elements.; // select a, false, b -> select !a, b, false",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Safety,safe,safely,25,// Return true if we can safely remove the select instruction for std::bit_ceil; // pattern.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:200,Deployability,update,update,200,"// Match the operation that's used to compute CtlzOp from CommonAncestor. If; // CtlzOp == CommonAncestor, return true as no operation is needed. If a; // match is found, execute the operation on CR, update CR, and return true.; // Otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:58,Deployability,update,updated,58,// Cond0 is either CtlzOp or CtlzOp's parent. CR has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:67,Deployability,update,updated,67,// Cond0's parent is either CtlzOp or CtlzOp's parent. CR has been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:406,Availability,mask,masked,406,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:532,Availability,mask,masked,532,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:492,Performance,optimiz,optimized,492,"// Transform the std::bit_ceil(X) pattern like:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %sub = sub i32 32, %ctlz; // %shl = shl i32 1, %sub; // %ugt = icmp ugt i32 %x, 1; // %sel = select i1 %ugt, i32 %shl, i32 1; //; // into:; //; // %dec = add i32 %x, -1; // %ctlz = tail call i32 @llvm.ctlz.i32(i32 %dec, i1 false); // %neg = sub i32 0, %ctlz; // %masked = and i32 %ctlz, 31; // %shl = shl i32 1, %sub; //; // Note that the select is optimized away while the shift count is masked with; // 31. We handle some variations of the input operand like std::bit_ceil(X +; // 1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:181,Availability,Mask,Masking,181,"// Build 1 << (-CTLZ & (BitWidth-1)). The negation likely corresponds to a; // single hardware instruction as opposed to BitWidth - CTLZ, where BitWidth; // is an integer constant. Masking with BitWidth-1 comes free on some; // hardware as part of the shift instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:256,Modifiability,extend,extend,256,"// Selecting between two integer or vector splat integer constants?; //; // Note that we don't handle a scalar select of vectors:; // select i1 %c, <2 x i8> <1, 1>, <2 x i8> <0, 0>; // because that may need 3 instructions to splat the condition value:; // extend, insertelement, shufflevector.; //; // Do not handle i1 TrueVal and FalseVal otherwise would result in; // zext/sext i1 to i1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:229,Testability,log,logic,229,"// Fold out scale-if-equals-zero pattern.; //; // This pattern appears in code with denormal range checks after it's; // assumed denormals are treated as zero. This drops a canonicalization.; // TODO: Could relax the signed zero logic. We just need to know the sign; // of the result matches (fmul x, y has the same sign as x).; //; // TODO: Handle always-canonicalizing variant that selects some value or 1; // scaling factor in the fmul visitor.; // TODO: Handle ldexp too",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Usability,simpl,simplify,10,"// Try to simplify a binop sandwiched between 2 selects with the same; // condition. This is not valid for div/rem because the select might be; // preventing a division-by-zero.; // TODO: A div/rem restriction is conservative; use something like; // isSafeToSpeculativelyExecute().; // select(C, binop(select(C, X, Y), W), Z) -> select(C, binop(X, W), Z)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:112,Energy Efficiency,reduce,reduce,112,"// If we can compute the condition, there's no need for a select.; // Like the above fold, we are attempting to reduce compile-time cost by; // putting this fold here with limitations rather than in InstSimplify.; // The motivation for this call into value tracking is to take advantage of; // the assumption cache, so make sure that is populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:309,Performance,cache,cache,309,"// If we can compute the condition, there's no need for a select.; // Like the above fold, we are attempting to reduce compile-time cost by; // putting this fold here with limitations rather than in InstSimplify.; // The motivation for this call into value tracking is to take advantage of; // the assumption cache, so make sure that is populated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:25,Testability,test,test,25,// Simplify selects that test the returned flag of cmpxchg instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:3,Usability,Simpl,Simplify,3,// Simplify selects that test the returned flag of cmpxchg instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:10,Availability,mask,mask,10,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:24,Availability,mask,mask,24,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:47,Availability,mask,mask,47,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:59,Performance,Load,Load,59,"// select(mask, mload(,,mask,0), 0) -> mload(,,mask,0); // Load inst is intentionally not checked for hasOneUse()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:173,Availability,mask,masks,173,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:44,Performance,load,load,44,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:157,Performance,load,load,157,// We can remove the select by ensuring the load zeros all lanes the; // select would have. We determine this by proving there is no overlap; // between the load and select masks.; // (i.e (load_mask & select_mask) == 0 == no overlap),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:9,Testability,log,logical,9,"// Match logical variants of the pattern,; // and transform them iff that gets rid of inversions.; // (~x) | y --> ~(x & (~y)); // (~x) & y --> ~(x | (~y))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp:34,Testability,log,logical,34,// We cannot swap the operands of logical and/or.; // TODO: Can we swap the operands by inserting a freeze?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSelect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:81,Modifiability,rewrite,rewrite,81,"// As input, we have the following pattern:; // Sh0 (Sh1 X, Q), K; // We want to rewrite that as:; // Sh x, (Q+K) iff (Q+K) u< bitwidth(x); // While we know that originally (Q+K) would not overflow; // (because 2 * (N-1) u<= iN -1), we have looked past extensions of; // shift amounts. so it may now overflow in smaller bitwidth.; // To ensure that does not happen, we need to ensure that the total maximal; // shift amount is still representable in that smaller bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:68,Modifiability,rewrite,rewrite,68,"// Given pattern:; // (x shiftopcode Q) shiftopcode K; // we should rewrite it as; // x shiftopcode (Q+K) iff (Q+K) u< bitwidth(x) and; //; // This is valid for any shift, but they must be identical, and we must be; // careful in case we have (zext(Q)+zext(K)) and look past extensions,; // (Q+K) must not overflow or else (Q+K) u< bitwidth(x) is bogus.; //; // AnalyzeForSignBitExtraction indicates that we will only analyze whether this; // pattern has any 2 right-shifts that sum to 1 less than original bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:16,Performance,perform,perform,16,"// FIXME: could perform constant-folding.; // If there was a truncation, and we have a right-shift, we can only fold if; // we are left with the original sign bit. Likewise, if we were just checking; // that this is a sighbit extraction, this is the place to check it.; // FIXME: zero shift amount is also legal here, but we can't *easily* check; // more than one predicate so it's not really worth it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:191,Availability,mask,mask,191,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:213,Availability,mask,mask,213,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:287,Availability,Mask,MaskShAmt,287,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:339,Availability,Mask,MaskShAmt,339,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:386,Availability,Mask,MaskShAmt,386,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:432,Availability,Mask,MaskShAmt,432,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:447,Availability,Mask,MaskShAmt,447,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:487,Availability,Mask,MaskShAmt,487,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:502,Availability,Mask,MaskShAmt,502,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:541,Availability,Mask,MaskShAmt,541,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:556,Availability,Mask,MaskShAmt,556,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:670,Availability,Mask,MaskShAmt,670,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:733,Availability,Mask,MaskShAmt,733,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:771,Availability,Mask,MaskShAmt,771,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:72,Performance,perform,performs,72,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:611,Usability,simpl,simplified,611,"// If we have some pattern that leaves only some low bits set, and then performs; // left-shift of those bits, if none of the bits that are left after the final; // shift are modified by the mask, we can omit the mask.; //; // There are many variants to this pattern:; // a) (x & ((1 << MaskShAmt) - 1)) << ShiftShAmt; // b) (x & (~(-1 << MaskShAmt))) << ShiftShAmt; // c) (x & (-1 l>> MaskShAmt)) << ShiftShAmt; // d) (x & ((-1 << MaskShAmt) l>> MaskShAmt)) << ShiftShAmt; // e) ((x << MaskShAmt) l>> MaskShAmt) << ShiftShAmt; // f) ((x << MaskShAmt) a>> MaskShAmt) << ShiftShAmt; // All these patterns can be simplified to just:; // x << ShiftShAmt; // iff:; // a,b) (MaskShAmt+ShiftShAmt) u>= bitwidth(x); // c,d,e,f) (ShiftShAmt-MaskShAmt) s>= 0 (i.e. ShiftShAmt u>= MaskShAmt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:68,Availability,mask,mask,68,"// *If* there is a truncation between an outer shift and a possibly-mask,; // then said truncation *must* be one-use, else we can't perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:132,Performance,perform,perform,132,"// *If* there is a truncation between an outer shift and a possibly-mask,; // then said truncation *must* be one-use, else we can't perform the fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Availability,mask,mask,7,// The mask must be computed in a type twice as wide to ensure; // that no bits are lost if the sum-of-shifts is wider than the base type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Availability,Mask,MaskShAmt,10,// ((1 << MaskShAmt) - 1),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:12,Availability,mask,maskNbits,12,// (~(-1 << maskNbits)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,Mask,MaskShAmt,11,// (-1 l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,Mask,MaskShAmt,11,// ((-1 << MaskShAmt) l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:26,Availability,Mask,MaskShAmt,26,// ((-1 << MaskShAmt) l>> MaskShAmt),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:20,Availability,Mask,MaskShAmt,20,// Can we simplify (MaskShAmt+ShiftShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Usability,simpl,simplify,10,// Can we simplify (MaskShAmt+ShiftShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:153,Modifiability,extend,extend,153,// Did not simplify.; // In this pattern SumOfShAmts correlates with the number of low bits; // that shall remain in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with final; // shift bitwidth to ensure that the value remains undef when creating the; // subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.; // In this pattern SumOfShAmts correlates with the number of low bits; // that shall remain in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with final; // shift bitwidth to ensure that the value remains undef when creating the; // subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:19,Availability,mask,mask,19,// And compute the mask as usual: ~(-1 << (SumOfShAmts)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:27,Safety,safe,safe,27,// Verify that it would be safe to try to add those two shift amounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:31,Availability,Mask,MaskShAmt,31,// Can we simplify (ShiftShAmt-MaskShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Usability,simpl,simplify,10,// Can we simplify (ShiftShAmt-MaskShAmt) ?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:155,Modifiability,extend,extend,155,// Did not simplify.; // In this pattern ShAmtsDiff correlates with the number of high bits that; // shall be unset in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with negated; // bitwidth of innermost shift to ensure that the value remains undef when; // creating the subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Usability,simpl,simplify,11,// Did not simplify.; // In this pattern ShAmtsDiff correlates with the number of high bits that; // shall be unset in the root value (OuterShift).; // An extend of an undef value becomes zero because the high bits are never; // completely unknown. Replace the `undef` shift amounts with negated; // bitwidth of innermost shift to ensure that the value remains undef when; // creating the subsequent shift op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:19,Availability,mask,mask,19,// And compute the mask as usual: (-1 l>> (NumHighBitsToClear)),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:13,Availability,mask,mask,13,// Does this mask has any unset bits? If not then we can just not apply it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:25,Availability,mask,mask,25,"// If we need to apply a mask, there are several more restrictions we have.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:11,Availability,mask,masking,11,// The old masking instruction must go away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:17,Availability,mask,masking,17,"// The original ""masking"" instruction must not have been`ashr`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:297,Energy Efficiency,reduce,reduces,297,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:305,Integrability,depend,dependency,305,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:56,Testability,log,logic,56,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:234,Testability,log,logic,234,"/// If we have a shift-by-constant of a bin op (bitwise logic op or add/sub w/; /// shl) that itself has a shift-by-constant operand with identical opcode, we; /// may be able to convert that into 2 independent shifts followed by the logic; /// op. This eliminates a use of an intermediate value (reduces dependency; /// chain).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:3,Testability,Log,Logic,3,"// Logic ops and Add are commutative, so check each operand for a match. Sub; // is not so we cannot reoder if we match operand(1) and need to keep the; // operands in their original positions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:37,Modifiability,variab,variable,37,// Pre-shift a constant shifted by a variable amount with constant offset:; // C shift (A add nuw C1) --> (C shift C1) shift A,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:44,Modifiability,variab,variable,44,// Try to pre-shift a constant shifted by a variable amount added with a; // negative number:; // C << (X - AddC) --> (C >> AddC) << X; // and; // C >> (X - AddC) --> (C << AddC) >> X,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:60,Energy Efficiency,power,power,60,// X shift (A srem C) -> X shift (A and (C - 1)) iff C is a power of 2.; // Because shifts by negative values (which could occur if A were negative); // are undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:37,Usability,Simpl,SimplifyDemandedBits,37,// FIXME: Should this get moved into SimplifyDemandedBits by saying we don't; // demand the sign bit (and many others) here??,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:39,Testability,log,logical,39,"/// Return true if we can simplify two logical (either left or right) shifts; /// that have constant shift amounts: OuterShift (InnerShift X, C1), C2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:26,Usability,simpl,simplify,26,"/// Return true if we can simplify two logical (either left or right) shifts; /// that have constant shift amounts: OuterShift (InnerShift X, C1), C2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Testability,log,logical,7,"// Two logical shifts in the same direction:; // shl (shl X, C1), C2 --> shl X, C1 + C2; // lshr (lshr X, C1), C2 --> lshr X, C1 + C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:364,Availability,mask,mask,364,"// If the 2nd shift is bigger than the 1st, we can fold:; // lshr (shl X, C1), C2 --> and (shl X, C1 - C2), C3; // shl (lshr X, C1), C2 --> and (lshr X, C1 - C2), C3; // but it isn't profitable unless we know the and'd out bits are already zero.; // Also, check that the inner shift is valid (less than the type width) or; // we'll crash trying to produce the bit mask for the 'and'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:59,Testability,log,logically,59,"/// See if we can compute the specified value, but shifted logically to the left; /// or right by some number of bits. This should return true if the expression; /// can be computed for the same cost as the current expression tree. This is; /// used to eliminate extraneous shifting from things like:; /// %C = shl i128 %A, 64; /// %D = shl i128 %B, 96; /// %E = or i128 %C, %D; /// %F = lshr i128 %E, 64; /// where the client will ask if E can be computed shifted right by 64-bits. If; /// this succeeds, getShiftedValue() will be called to produce the value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:31,Usability,clear,clear,31,// Change the shift amount and clear the appropriate IR flags.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:7,Testability,log,logical,7,"// Two logical shifts in the same direction:; // shl (shl X, C1), C2 --> shl X, C1 + C2; // lshr (lshr X, C1), C2 --> lshr X, C1 + C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:112,Availability,mask,masked-off,112,"// In general, we would need an 'and' for this transform, but; // canEvaluateShiftedShift() guarantees that the masked-off bits are not used.; // lshr (shl X, C1), C2 --> shl X, C1 - C2; // shl (lshr X, C1), C2 --> lshr X, C1 - C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:10,Performance,perform,perform,10,// Do not perform transform!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:28,Testability,log,logical,28,"// Do not change a 'not' of logical shift because that would create a normal; // 'xor'. The 'not' is likely better for analysis, SCEV, and codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:12,Performance,perform,perform,12,"// Tries to perform; // (lshr (add (zext X), (zext Y)), K); // -> (icmp ult (add X, Y), X); // where; // - The add's operands are zexts from a K-bits integer to a bigger type.; // - The add is only used by the shr, or by iK (or narrower) truncates.; // - The lshr type has more than 2 bits (other types are boolean math).; // - K > 1; // note that; // - The resulting add cannot have nuw/nsw, else on overflow we get a; // poison value and the transform isn't legal anymore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:99,Safety,safe,safely,99,"// Since shift produces a poison value if RHS is equal to or larger than the; // bit width, we can safely assume that RHS is less than the bit width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:24,Usability,simpl,simplified,24,// Oversized shifts are simplified to zero in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:118,Testability,log,logic,118,"// If we have an opposite shift by the same amount, we may be able to; // reorder binops and shifts to eliminate math/logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:24,Usability,simpl,simplified,24,// Oversized shifts are simplified to zero in InstSimplify.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:113,Availability,Mask,MaskC,113,"// If the combined shift fits in the source width:; // (trunc (X >>u C1)) >>u C --> and (trunc (X >>u (C1 + C)), MaskC; //; // If the first shift covers the number of bits truncated, then the; // mask instruction is eliminated (and so the use check is relaxed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:196,Availability,mask,mask,196,"// If the combined shift fits in the source width:; // (trunc (X >>u C1)) >>u C --> and (trunc (X >>u (C1 + C)), MaskC; //; // If the first shift covers the number of bits truncated, then the; // mask instruction is eliminated (and so the use check is relaxed).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:89,Availability,mask,mask,89,"// If the first shift does not cover the number of bits truncated, then; // we require a mask to get rid of high bits in the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:115,Availability,mask,mask,115,"// Look for a ""splat"" mul pattern - it replicates bits across each half of; // a value, so a right shift is just a mask of the low bits:; // lshr i[2N] (mul nuw X, (2^N)+1), N --> and iN X, (2^N)-1; // TODO: Generalize to allow more than just half-width shifts?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce add-carry of bools to logic:; // ((zext BoolX) + (zext BoolY)) >> 1 --> zext (BoolX && BoolY),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:32,Testability,log,logic,32,// Reduce add-carry of bools to logic:; // ((zext BoolX) + (zext BoolY)) >> 1 --> zext (BoolX && BoolY),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:23,Modifiability,variab,variable-length,23,// It should look like variable-length sign-extension on the outside:; // (Val << (bitwidth(Val)-Nbits)) a>> (bitwidth(Val)-Nbits),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,Availability,redundant,redundant,131,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:131,Safety,redund,redundant,131,"// Since the NBits is identical for all shifts, if the outermost and; // innermost shifts are identical, then outermost shifts are redundant.; // If we had truncation, do keep it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:45,Performance,perform,perform,45,"// Finally, bypass two innermost shifts, and perform the outermost shift on; // the operands of the innermost shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp:143,Availability,mask,masked,143,"// Prefer `-(x & 1)` over `(x << (bitwidth(x)-1)) a>> (bitwidth(x)-1)`; // as the pattern to splat the lowest bit.; // FIXME: iff X is already masked, we don't need the one-use check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineShifts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:402,Testability,log,logic,402,"//===- InstCombineSimplifyDemanded.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains logic for simplifying instructions based on information; // about how they are used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:412,Usability,simpl,simplifying,412,"//===- InstCombineSimplifyDemanded.cpp ------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains logic for simplifying instructions based on information; // about how they are used.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:40,Usability,Simpl,SimplifyDemandedBits,40,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:138,Usability,simpl,simplify,138,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:40,Usability,Simpl,SimplifyDemandedBits,40,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:138,Usability,simpl,simplify,138,/// Inst is an integer instruction that SimplifyDemandedBits knows about. See if; /// the instruction has any properties that allow us to simplify its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:17,Usability,Simpl,SimplifyDemandedBits,17,"/// This form of SimplifyDemandedBits simplifies the specified instruction; /// operand if possible, updating it in place. It returns true if it made any; /// change and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:38,Usability,simpl,simplifies,38,"/// This form of SimplifyDemandedBits simplifies the specified instruction; /// operand if possible, updating it in place. It returns true if it made any; /// change and false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:213,Availability,down,downstream,213,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:261,Availability,mask,mask,261,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:244,Integrability,depend,depending,244,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:47,Usability,simpl,simpler,47,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:728,Usability,Simpl,SimplifyDemandedBits,728,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:760,Usability,simpl,simplify,760,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:1207,Usability,simpl,simplification,1207,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:1260,Usability,simpl,simplification,1260,"/// This function attempts to replace V with a simpler value based on the; /// demanded bits. When this function is called, it is known that only the bits; /// set in DemandedMask of the result of V are ever used downstream.; /// Consequently, depending on the mask and V, it may be possible to replace V; /// with a constant or one of its operands. In such cases, this function does; /// the replacement and returns true. In all other cases, it returns false after; /// analyzing the expression and setting KnownOne and known to be one in the; /// expression. Known.Zero contains all the bits that are known to be zero in; /// the expression. These are provided to potentially allow the caller (which; /// might recursively be SimplifyDemandedBits itself) to simplify the; /// expression.; /// Known.One and Known.Zero always follow the invariant that:; /// Known.One & Known.Zero == 0.; /// That is, a bit can't be both 1 and 0. The bits in Known.One and Known.Zero; /// are accurate even for bits not in DemandedMask. Note; /// also that the bitwidth of V, DemandedMask, Known.Zero and Known.One must all; /// be the same.; ///; /// This returns null if it did not change anything and it permits no; /// simplification. This returns V itself if it did some simplification of V's; /// operands based on the information about what bits are demanded. This returns; /// some other non-null value if it found out that V is equal to another value; /// in the context where the specified bits are demanded, but not for all users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:96,Usability,simpl,simplifications,96,"// If there are multiple uses of this value and we aren't at the root, then; // we can't do any simplifications of the operands, because DemandedMask; // only reflects the bits demanded by *one* of the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:272,Testability,log,logic,272,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplified,29,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:137,Usability,simpl,simplify,137,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:208,Usability,simpl,simplify,208,"// If this is the root being simplified, allow it to have multiple uses,; // just set the DemandedMask to all bits so that we can try to simplify the; // operands. This allows visitTruncInst (for example) to simplify the; // operand of a trunc without duplicating all the logic below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Deployability,Update,Update,3,// Update flags after simplifying an operand based on the fact that some high; // order bits are not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,simpl,simplifying,22,// Update flags after simplifying an operand based on the fact that some high; // order bits are not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:84,Integrability,wrap,wrap,84,// Disable the nsw and nuw flags here: We can no longer guarantee that; // we won't wrap after simplification. Removing the nsw/nuw flags is; // legal here because the top bit is not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:95,Usability,simpl,simplification,95,// Disable the nsw and nuw flags here: We can no longer guarantee that; // we won't wrap after simplification. Removing the nsw/nuw flags is; // legal here because the top bit is not demanded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:194,Usability,clear,cleared,194,"// If all of the demanded bits on one side are known, and all of the set; // bits on that side are also known to be set on the other side, turn this; // into an AND, as we know the bits will be cleared.; // e.g. (X | C1) ^ C2 --> (X | C1) & ~C2 iff (C1&C2) == C2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:229,Usability,simpl,simplifying,229,"// If our LHS is an 'and' and if it has one use, and if any of the bits we; // are flipping are known to be set, then the xor is just resetting those; // bits to zero. We can just knock out bits from the 'and' and the 'xor',; // simplifying both of them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:48,Usability,simpl,simplify,48,"// If the operands are constants, see if we can simplify them.; // This is similar to ShrinkDemandedConstant, but for a select we want to; // try to keep the selected constants the same as icmp value constants, if; // we can. This helps not break apart (or helps put back together); // canonical patterns like min and max.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:231,Energy Efficiency,reduce,reduces,231,"// Get the constant out of the ICmp, if there is one.; // Only try this when exactly 1 operand is a constant (if both operands; // are constant, the icmp should eventually simplify). Otherwise, we may; // invert the transform that reduces set bits and infinite-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:172,Usability,simpl,simplify,172,"// Get the constant out of the ICmp, if there is one.; // Only try this when exactly 1 operand is a constant (if both operands; // are constant, the icmp should eventually simplify). Otherwise, we may; // invert the transform that reduces set bits and infinite-loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:77,Availability,mask,mask,77,"// If the constants are not already the same, but can be with the demand; // mask, use the constant value from the ICmp.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Modifiability,extend,extended,22,"// If any of the sign extended bits are demanded, we know that the sign; // bit is demanded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:48,Usability,clear,clear,48,"// If the sign bit of the input is known set or clear, then we know the; // top bits of the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:62,Testability,log,logic,62,"// If we do not need the low bit, try to convert bool math to logic:; // add iN (zext i1 X), (sext i1 Y) --> sext (~X & Y) to iN",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Availability,mask,mask,18,// Right fill the mask of bits for the operands to demand the most; // significant bit and all those below it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:58,Availability,mask,mask,58,"// This is a variable shift, so we can't shift the demand mask by a known; // amount. But if we are not demanding high bits, then we are not; // demanding those bits from the pre-shifted operand either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:13,Modifiability,variab,variable,13,"// This is a variable shift, so we can't shift the demand mask by a known; // amount. But if we are not demanding high bits, then we are not; // demanding those bits from the pre-shifted operand either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:46,Usability,simpl,simplifying,46,// We can't guarantee that nsw/nuw hold after simplifying the operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:152,Modifiability,variab,variable,152,"// If this is an arithmetic shift right and only the low-bit is set, we can; // always convert this into a logical shr, even if the shift amount is; // variable. The low bit of the shift cannot be an input sign bit unless; // the shift amount is >= the size of the datatype, which is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:107,Testability,log,logical,107,"// If this is an arithmetic shift right and only the low-bit is set, we can; // always convert this into a logical shr, even if the shift amount is; // variable. The low bit of the shift cannot be an input sign bit unless; // the shift amount is >= the size of the datatype, which is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Performance,Perform,Perform,3,// Perform the logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:15,Testability,log,logical,15,// Perform the logical shift right.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:62,Availability,Mask,Mask,62,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,Safety,avoid,avoid,102,// SignBits may be out-of-sync with Known.countMinSignBits(). Mask out; // high bits of Known.Zero to avoid conflicts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:27,Availability,mask,mask,27,// TODO: Take the demanded mask of the result into account.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,clear,clear,29,"// Checking if the number of clear bits is odd (parity)? If the type has; // an even number of bits, that's the same as checking if the number of; // set bits is odd, so we can eliminate the 'not' op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:13,Availability,down,down,13,"// Round NTZ down to the next byte. If we have 11 trailing zeros, then; // we need all the bits down to bit 8. Likewise, round NLZ. If we; // have 14 leading zeros, round to 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:96,Availability,down,down,96,"// Round NTZ down to the next byte. If we have 11 trailing zeros, then; // we need all the bits down to bit 8. Likewise, round NLZ. If we; // have 14 leading zeros, round to 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:21,Modifiability,extend,extend,21,// TODO: Should be 1-extend,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:167,Availability,mask,mask,167,"// If the client is only demanding bits we know to be zero, return; // `llvm.ptrmask(p, 0)`. We can't return `null` here due to pointer; // provenance, but making the mask zero will be easily optimizable in; // the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:192,Performance,optimiz,optimizable,192,"// If the client is only demanding bits we know to be zero, return; // `llvm.ptrmask(p, 0)`. We can't return `null` here due to pointer; // provenance, but making the mask zero will be easily optimizable in; // the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:3,Availability,Mask,Mask,3,// Mask in demanded space does nothing.; // NOTE: We may have attributes associated with the return value of the; // llvm.ptrmask intrinsic that will be lost when we just return the; // operand. We should try to preserve them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:43,Usability,simpl,simplify,43,"// If the RHS is a constant, see if we can simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:24,Safety,Avoid,Avoid,24,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:76,Usability,simpl,simplify,76,// fshl is a rotate; // Avoid converting rotate into funnel shift.; // Only simplify if one operand is constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:103,Usability,simpl,simplify,103,"// If the client is only demanding bits that we know, return the known; // constant. We can't directly simplify pointers as a constant because of; // pointer provenance.; // TODO: We could return `(inttoptr const)` for pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:100,Usability,simpl,simplifications,100,"/// Helper routine of SimplifyDemandedUseBits. It computes Known; /// bits. It also tries to handle simplifications that can be done based on; /// DemandedMask, but without modifying the Instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:34,Usability,simpl,simplify,34,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:145,Usability,simpl,simplifications,145,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:238,Usability,simpl,simpler,238,"// Despite the fact that we can't simplify this instruction in all User's; // context, we can at least compute the known bits, and we can; // do simplifications that apply to *just* the one user if we know that; // this instruction has a simpler value in that context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,Usability,simpl,simplify,10,"// We can simplify (X|Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.; // These bits cannot contribute to the result of the 'or' in this context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:10,Usability,simpl,simplify,10,"// We can simplify (X^Y) -> X or Y in the user's context if we know that; // only bits from X or Y are demanded.; // If all of the demanded bits are known zero on one side, return the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:45,Availability,down,downstream,45,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplify,29,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:45,Availability,down,downstream,45,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:29,Usability,simpl,simplify,29,// Compute the Known bits to simplify things downstream.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:11,Integrability,rout,routine,11,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:190,Integrability,depend,depending,190,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:689,Testability,test,test,689,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:22,Usability,Simpl,SimplifyDemandedUseBits,22,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:59,Usability,simpl,simplify,59,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:726,Usability,Simpl,SimplifyDemandedUseBits,726,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:774,Usability,simpl,simplification,774,"/// Helper routine of SimplifyDemandedUseBits. It tries to simplify; /// ""E1 = (X lsr C1) << C2"", where the C1 and C2 are constant, into; /// ""E2 = X << (C2 - C1)"" or ""E2 = X >> (C1 - C2)"", depending on the sign; /// of ""C2-C1"".; ///; /// Suppose E1 and E2 are generally different in bits S={bm, bm+1,; /// ..., bn}, without considering the specific value X is holding.; /// This transformation is legal iff one of following conditions is hold:; /// 1) All the bit in S are 0, in this case E1 == E2.; /// 2) We don't care those bits in S, per the input DemandedMask.; /// 3) Combination of 1) and 2). Some bits in S are 0, and we don't care the; /// rest bits.; ///; /// Currently we only test condition 2).; ///; /// As with SimplifyDemandedUseBits, it returns NULL if the simplification was; /// not successful.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:349,Usability,simpl,simplified,349,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:591,Usability,simpl,simplify,591,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:637,Usability,simpl,simplified,637,"/// The specified value produces a vector with any number of elements.; /// This method analyzes which elements of the operand are poison and; /// returns that information in PoisonElts.; ///; /// DemandedElts contains the set of elements that are actually used by the; /// caller, and by default (AllowMultipleUsers equals false) the value is; /// simplified only if it has a single caller. If AllowMultipleUsers is set; /// to true, DemandedElts refers to the union of sets of elements that are; /// used by all callers.; ///; /// If the information about demanded elements can be used to simplify the; /// operation, the operation is simplified, then the resultant value is; /// returned. This returns null if no change was made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:18,Performance,scalab,scalable,18,// Cannot analyze scalable type. The number of vector elements is not a; // compile-time constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:63,Usability,simpl,simplifying,63,"// Check if this is identity. If so, return 0 since we are not simplifying; // anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:64,Usability,simpl,simplification,64,"// If multiple users are using the root value, proceed with; // simplification conservatively assuming that all elements; // are needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:16,Modifiability,variab,variable,16,"// If this is a variable index, we don't know which element it overwrites.; // demand exactly the same input as we produce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:95,Deployability,update,updated,95,"// Note that we can't propagate undef elt info, because we don't know; // which elt is getting updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:88,Usability,simpl,simpler,88,"// The element inserted overwrites whatever was there, so the input demanded; // set is simpler than the output set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:244,Usability,simpl,simplifyAndSetOp,244,"// If we only demand the element that is being inserted and that element; // was extracted from the same index in another vector with the same type,; // replace this insert with that other vector.; // Note: This is attempted before the call to simplifyAndSetOp because that; // may change PoisonElts to a value that does not match with Vec.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:115,Availability,mask,mask,115,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:206,Availability,mask,mask,206,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:338,Availability,mask,mask,338,"// If this shuffle does not change the vector length and the elements; // demanded by this shuffle are an identity mask, then this shuffle is; // unnecessary.; //; // We are assuming canonical form for the mask, so the source vector is; // operand 0 and operand 1 is not used.; //; // Note that if an element is demanded and this shuffle mask is undefined; // for that element, then the shuffle is not considered an identity; // operation. The shuffle prevents poison from the operand vector from; // leaking to the result by replacing poison with an undefined value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:102,Safety,avoid,avoid,102,// isNullValue() always returns false when called on a ConstantExpr.; // Skip constant expressions to avoid propagating incorrect information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:19,Performance,load,load,19,"// Subtlety: If we load from a pointer, the pointer must be valid; // regardless of whether the element is demanded. Doing otherwise risks; // segfaults which didn't exist in the original program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:133,Safety,risk,risks,133,"// Subtlety: If we load from a pointer, the pointer must be valid; // regardless of whether the element is demanded. Doing otherwise risks; // segfaults which didn't exist in the original program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:100,Availability,mask,mask,100,// Output elements are undefined if the element from both sources are.; // TODO: can strengthen via mask as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp:622,Safety,safe,safe,622,"// Look for an equivalent binop except that one operand has been shuffled.; // If the demand for this binop only includes elements that are the same as; // the other binop, then we may be able to replace this binop with a use of; // the earlier one.; //; // Example:; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt (bo X, Y), 0; // -->; // %other_bo = bo (shuf X, {0}), Y; // %this_extracted_bo = extelt %other_bo, 0; //; // TODO: Handle demand of an arbitrary single element or more than one; // element instead of just element 0.; // TODO: Unlike general demanded elements transforms, this should be safe; // for any (div/rem/shift) opcode too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineSimplifyDemanded.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:80,Performance,scalab,scalable,80,"// Index needs to be lower than the minimum size of the vector, because; // for scalable vector, the vector size is known at run time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:67,Usability,simpl,simplify,67,// An insertelement to the same constant index as our extract will simplify; // to the scalar inserted element. An insertelement to a different constant; // index is irrelevant to our extract.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:39,Modifiability,variab,variable,39,// If the operand is the PHI induction variable:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:198,Usability,Simpl,SimplifyDemandedVectorElts,198,"// Remove insertelement, if we don't use the inserted element.; // extractelement (bitcast (insertelement (Vec, b)), a) ->; // extractelement (bitcast (Vec), a); // FIXME: this should be removed to SimplifyDemandedVectorElts,; // once scale vectors are supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,Integrability,depend,depends,98,"// We are extracting part of the original scalar. How that scalar is; // inserted into the vector depends on the endian-ness. Example:; // Vector Byte Elt Index: 0 1 2 3 4 5 6 7; // +--+--+--+--+--+--+--+--+; // inselt <2 x i32> V, <i32> S, 1: |V0|V1|V2|V3|S0|S1|S2|S3|; // extelt <4 x i16> V', 3: | |S2|S3|; // +--+--+--+--+--+--+--+--+; // If this is little-endian, S2|S3 are the MSB of the 32-bit 'S' value.; // If this is big-endian, S2|S3 are the LSB of the 32-bit 'S' value.; // In this example, we must right-shift little-endian. Big-endian is just a; // truncate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:278,Usability,simpl,simplify,278,"/// Given a constant index for a extractelement or insertelement instruction,; /// return it with the canonical type if it isn't already canonical. We; /// arbitrarily pick 64 bit as our canonical type. The actual bitwidth doesn't; /// matter, we just want a consistent type to simplify CSE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:367,Performance,optimiz,optimized,367,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:291,Security,access,accesses,291,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:474,Testability,assert,assertion,474,"// extractelt (select %x, %vec1, %vec2), %const ->; // select %x, %vec1[%const], %vec2[%const]; // TODO: Support constant folding of multiple select operands:; // extractelt (select %x, %vec1, %vec2), (select %x, %c1, %c2); // If the extractelement will for instance try to do out of bounds accesses; // because of the values of %c1 and/or %c2, the sequence could be optimized; // early. This is currently not possible because constant folding will reach; // an unreachable assertion if it doesn't find a constant operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Usability,simpl,simplify,51,// Canonicalize type of constant indices to i64 to simplify CSE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:80,Performance,scalab,scalable,80,"// Index needs to be lower than the minimum size of the vector, because; // for scalable vector, the vector size is known at run time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:345,Performance,optimiz,optimization,345,"// Find out why we have a vector result - these are a few examples:; // 1. We have a scalar pointer and a vector of indices, or; // 2. We have a vector of pointers and a scalar index, or; // 3. We have a vector of pointers and a vector of indices, etc.; // Here we only consider combining when there is exactly one vector; // operand, since the optimization is less obviously a win due to; // needing more than one extractelements.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:88,Performance,scalab,scalable,88,"// This instruction only demands the single element from the input vector.; // Skip for scalable type, the number of elements is unknown at; // compile-time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,Usability,simpl,simplify,41,"// If the input vector has a single use, simplify it based on this use; // property.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:42,Usability,simpl,simplify,42,"// If the input vector has multiple uses, simplify it based on a union; // of all elements used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Availability,mask,mask,107,"/// If V is a shuffle of values that ONLY returns elements from either LHS or; /// RHS, return the shuffle mask and true. Otherwise, return false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// If so, update the mask to reflect the inserted poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Deployability,update,update,10,"// If so, update the mask to reflect the inserted poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// If so, update the mask to reflect the inserted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Deployability,update,update,10,"// If so, update the mask to reflect the inserted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:88,Availability,mask,mask,88,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Modifiability,extend,extended-from,38,// Create a shuffle mask to widen the extended-from vector using poison; // values. The mask selects all of the values of the original vector followed; // by as many poison values as needed to create a vector of the same length; // as the inserted-to vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:493,Performance,optimiz,optimization,493,"// TODO: This restriction matches the basic block check below when creating; // new extractelement instructions. If that limitation is removed, this one; // could also be removed. But for now, we just bail out to ensure that we; // will replace the extractelement instruction that is feeding our; // insertelement instruction. This allows the insertelement to then be; // replaced by a shufflevector. If the insertelement is not replaced, we can; // induce infinite looping because there's an optimization for extractelement; // that will delete our widening shuffle. This would trigger another attempt; // here to create that shuffle, and we spin forever.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:300,Availability,mask,masks,300,"// TODO: This restriction matches the check in visitInsertElementInst() and; // prevents an infinite loop caused by not turning the extract/insert pair; // into a shuffle. We really should not need either check, but we're lacking; // folds for shufflevectors because we're afraid to generate shuffle masks; // that the backend can't handle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:311,Availability,Mask,Mask,311,"/// We are building a shuffle to create V, which is a sequence of insertelement,; /// extractelement pairs. If PermittedRHS is set, then we must either use it or; /// not rely on the second vector source. Return a std::pair containing the; /// left and right vectors of the proposed shuffle (or 0), and set the Mask; /// parameter as required.; ///; /// Note: we intentionally don't try to fold earlier shuffles since they have; /// often been chosen carefully to be efficiently implementable on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:467,Energy Efficiency,efficient,efficiently,467,"/// We are building a shuffle to create V, which is a sequence of insertelement,; /// extractelement pairs. If PermittedRHS is set, then we must either use it or; /// not rely on the second vector source. Return a std::pair containing the; /// left and right vectors of the proposed shuffle (or 0), and set the Mask; /// parameter as required.; ///; /// Note: we intentionally don't try to fold earlier shuffles since they have; /// often been chosen carefully to be efficiently implementable on the target.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Performance,Cache,Cache,3,"// Cache the (non-uniqified!) list of predecessors in a vector,; // checking the limit at the same time for efficiency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,redundant,redundant,16,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:287,Availability,redundant,redundant,287,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Safety,redund,redundant,16,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:287,Safety,redund,redundant,287,"/// Try to find redundant insertvalue instructions, like the following ones:; /// %0 = insertvalue { i8, i32 } undef, i8 %x, 0; /// %1 = insertvalue { i8, i32 } %0, i8 %y, 0; /// Here the second instruction inserts values at the same indices, as the; /// first one, making the first one redundant.; /// It should be transformed to:; /// %0 = insertvalue { i8, i32 } undef, i8 %y, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,Availability,redundant,redundant,276,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:276,Safety,redund,redundant,276,"// If there is a chain of insertvalue instructions (each of them except the; // last one has only one use and it's another insertvalue insn from this; // chain), check if any of the 'children' uses the same indices as the first; // instruction. In this case, the first one is redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:19,Performance,scalab,scalable,19,"// Can not analyze scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:8,Availability,mask,mask,8,// Each mask element must be undefined or choose a vector element from one of; // the source operands without crossing vector lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:18,Performance,scalab,scalable,18,"// Can not handle scalable type, the number of elements is not a compile-time; // constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:72,Availability,mask,mask,72,"// Splat from element 0, but replace absent elements with poison in the mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,Availability,mask,mask,96,/// Try to fold an insert element into an existing splat shuffle by changing; /// the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:85,Availability,mask,mask,85,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Performance,scalab,scalable,32,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,Availability,mask,mask,23,"// Replace the shuffle mask element at the index of this insert with a zero.; // For example:; // inselt (shuf (inselt undef, X, 0), _, <0,undef,0,undef>), X, 1; // --> shuf (inselt undef, X, 0), poison, <0,0,0,undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Availability,mask,mask,107,/// Try to fold an extract+insert element into an existing identity shuffle by; /// changing the shuffle's mask to include the index of this insert element.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:85,Availability,mask,mask,85,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Performance,scalab,scalable,32,// Bail out early if shuffle is scalable type. The number of elements in; // shuffle mask is unknown at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:23,Availability,mask,mask,23,"// Replace the shuffle mask element at the index of this extract+insert with; // that same index value.; // For example:; // inselt (shuf X, IdMask), (extelt X, IdxC), IdxC --> shuf X, IdMask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:7,Availability,mask,mask,7,// All mask elements besides the inserted element remain the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Availability,mask,mask,10,"// If the mask element was already set, there's nothing to do; // (demanded elements analysis may unset it later).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:205,Modifiability,variab,variable,205,"/// If we have an insertelement instruction feeding into another insertelement; /// and the 2nd is inserting a constant into the vector, canonicalize that; /// constant insertion before the insertion of a variable:; ///; /// insertelement (insertelement X, Y, IdxC1), ScalarC, IdxC2 -->; /// insertelement (insertelement X, ScalarC, IdxC2), Y, IdxC1; ///; /// This has the potential of eliminating the 2nd insertelement instruction; /// via constant folding of the scalar constant into a vector constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex; /// --> shufflevector X, CVec', Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:113,Availability,Mask,Mask,113,"/// insertelt (shufflevector X, CVec, Mask|insertelt X, C1, CIndex1), C, CIndex; /// --> shufflevector X, CVec', Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:132,Usability,clear,clear,132,"// Bail out if the parent has more than one use. In that case, we'd be; // replacing the insertelt with a shuffle, and that's not a clear win.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Availability,mask,mask,51,"// From the above 'select' check, we know that the mask has the same number; // of elements as the vector input operands. We also know that each constant; // input element is used in its lane and can not be used more than once by; // the shuffle. Therefore, replace the constant in the shuffle's constant; // vector with the insertelt constant. Replace the constant in the shuffle's; // mask vector with the insertelt index plus the length of the vector; // (because the constant vector operand of a shuffle is always the 2nd; // operand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:387,Availability,mask,mask,387,"// From the above 'select' check, we know that the mask has the same number; // of elements as the vector input operands. We also know that each constant; // input element is used in its lane and can not be used more than once by; // the shuffle. Therefore, replace the constant in the shuffle's constant; // vector with the insertelt constant. Replace the constant in the shuffle's; // mask vector with the insertelt index plus the length of the vector; // (because the constant vector operand of a shuffle is always the 2nd; // operand).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:188,Availability,mask,mask,188,"// Transform sequences of insertelements ops with constant data/indexes into; // a single shuffle op.; // Can not handle scalable type, the number of elements needed to create; // shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:121,Performance,scalab,scalable,121,"// Transform sequences of insertelements ops with constant data/indexes into; // a single shuffle op.; // Can not handle scalable type, the number of elements needed to create; // shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,Availability,mask,mask,36,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:63,Availability,mask,masks,63,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:138,Availability,mask,mask,138,// Generate new constant vector and mask.; // We have 2 values/masks from the insertelements instructions. Insert them; // into new value/mask vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:57,Modifiability,extend,extended,57,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:151,Modifiability,extend,extend,151,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:182,Modifiability,extend,extended,182,"/// If both the base vector and the inserted element are extended from the same; /// type, do the insert element in the narrow source type followed by extend.; /// TODO: This can be extended to include other cast opcodes, but particularly; /// if we create a wider insertelement, make sure codegen is not harmed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:28,Modifiability,extend,extend,28,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Modifiability,extend,extend,59,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:127,Modifiability,extend,extends,127,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:139,Safety,avoid,avoid,139,"// We are creating a vector extend. If the original vector extend has another; // use, that would mean we end up with 2 vector extends, so avoid that.; // TODO: We could ease the use-clause to ""if at least one op has one use""; // (assuming that the source types match - see next TODO comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:11,Integrability,depend,depends,11,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,Safety,safe,safe,290,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:496,Safety,Detect,Detect,496,"// Pattern depends on endian because we expect lower index is inserted first.; // Big endian:; // inselt (inselt BaseVec, (trunc (lshr X, BW/2), Index0), (trunc X), Index1; // Little endian:; // inselt (inselt BaseVec, (trunc X), Index0), (trunc (lshr X, BW/2)), Index1; // Note: It is not safe to do this transform with an arbitrary base vector; // because the bitcast of that vector to fewer/larger elements could; // allow poison to spill into an element that was not poison before.; // TODO: Detect smaller fractions of the scalar.; // TODO: One-use checks are conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Usability,simpl,simplify,51,// Canonicalize type of constant indices to i64 to simplify CSE,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:245,Availability,mask,mask,245,"// If the inserted element was extracted from some other fixed-length vector; // and both indexes are valid constants, try to turn this into a shuffle.; // Can not handle scalable vector type, the number of elements needed to; // create shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:171,Performance,scalab,scalable,171,"// If the inserted element was extracted from some other fixed-length vector; // and both indexes are valid constants, try to turn this into a shuffle.; // Can not handle scalable vector type, the number of elements needed to; // create shuffle mask is not a compile-time constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:475,Availability,mask,masks,475,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:675,Availability,mask,mask,675,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:703,Modifiability,evolve,evolve,703,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:312,Safety,avoid,avoid,312,"// TODO: Looking at the user(s) to determine if this insert is a; // fold-to-shuffle opportunity does not match the usual instcombine; // constraints. We should decide if the transform is worthy based only; // on this instruction and its operands, but that may not work currently.; //; // Here, we are trying to avoid creating shuffles before reaching; // the end of a chain of extract-insert pairs. This is complicated because; // we do not generally form arbitrary shuffle masks in instcombine; // (because those may codegen poorly), but collectShuffleElements() does; // exactly that.; //; // The rules for determining what is an acceptable target-independent; // shuffle mask are fuzzy because they evolve based on the backend's; // capabilities and real-world impact.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Performance,perform,perform,71,"// The proposed shuffle may be trivial, in which case we shouldn't; // perform the combine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"// We now have a shuffle of LHS, RHS, Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:36,Availability,mask,mask,36,// Propagating an undefined shuffle mask element to integer div/rem is not; // allowed because those opcodes can create immediate undefined behavior; // from an undefined element in an operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:44,Availability,Mask,Mask,44,// Verify that 'CI' does not occur twice in Mask. A single 'insertelement'; // can't put an element into multiple indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:26,Availability,mask,mask,26,// It's possible that the mask has a different number of elements from; // the original cast. We recompute the destination type to match the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:141,Availability,mask,mask,141,// It's possible that the mask has a different number of elements from; // the original cast. We recompute the destination type to match the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Availability,Mask,Mask,3,// Mask.size() does not need to be equal to the number of vector elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,Availability,Mask,Mask,24,"// If element is not in Mask, no need to handle the operand 1 (element to; // be inserted). Just evaluate values in operand 0 according to Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:139,Availability,Mask,Mask,139,"// If element is not in Mask, no need to handle the operand 1 (element to; // be inserted). Just evaluate values in operand 0 according to Mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:70,Energy Efficiency,reduce,reduced,70,"/// A select shuffle of a select shuffle with a shared operand can be reduced; /// to a single select shuffle. This is an obvious improvement in IR, and the; /// backend is expected to lower select shuffles efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:207,Energy Efficiency,efficient,efficiently,207,"/// A select shuffle of a select shuffle with a shared operand can be reduced; /// to a single select shuffle. This is an obvious improvement in IR, and the; /// backend is expected to lower select shuffles efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:10,Availability,mask,mask,10,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:73,Availability,mask,mask,73,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:122,Availability,mask,mask,122,"// If the mask chooses from X (operand 0), it stays the same.; // If the mask chooses from the earlier shuffle, the other mask value is; // transferred to the combined select shuffle:; // shuf X, (shuf X, Y, M1), M --> shuf X, Y, M'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:12,Availability,mask,mask,12,// A select mask with undef elements might look like an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:65,Availability,mask,mask,65,// A select mask with undef elements might look like an identity mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:46,Modifiability,variab,variable,46,"// The identity constant for a binop leaves a variable operand unchanged. For; // a vector, this is a splat of something like 0, -1, or 1.; // If there's no identity constant for this binop, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,"// An undef shuffle mask element may propagate as an undef constant element in; // the new binop. That would produce poison where the original code might not.; // If we already made a safe constant, then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:184,Safety,safe,safe,184,"// An undef shuffle mask element may propagate as an undef constant element in; // the new binop. That would produce poison where the original code might not.; // If we already made a safe constant, then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:29,Availability,mask,mask,29,"// Splat from element 0. Any mask element that is undefined remains undefined.; // For example:; // shuf (inselt undef, X, 2), _, <2,2,undef>; // --> shuf (inselt undef, X, 0), poison, <0,0,undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Testability,assert,assert,16,"// TODO: Can we assert that both operands of a shuffle-select are not undef; // (otherwise, it would have been folded by instsimplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,Safety,safe,safe,195,"// TODO: We drop ""nsw"" if shift is converted into multiply because it may; // not be correct when the shift amount is BitWidth - 1. We could examine; // each vector element to determine if it is safe to keep that flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,Usability,clear,clear,61,// The opcodes must be the same. Use a new name to make that clear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:78,Availability,mask,mask,78,"// We are moving a binop after a shuffle. When a shuffle has an undefined; // mask element, the result is undefined, but it is not poison or undefined; // behavior. That is not necessarily true for div/rem/shift.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:28,Modifiability,variab,variable,28,"// If there are 2 different variable operands, we must create a new shuffle; // (select) first, so check uses to ensure that we don't end up with more; // instructions than we started with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:34,Availability,mask,mask,34,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:390,Availability,mask,mask,390,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:51,Modifiability,variab,variable,51,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:233,Safety,safe,safe,233,"// If we use the original shuffle mask and op1 is *variable*, we would be; // putting an undef into operand 1 of div/rem/shift. This is either UB or; // poison. We do not have to guard against UB when *constants* are op1; // because safe constants guarantee that we do not overflow sdiv/srem (and; // there's no danger for other opcodes).; // TODO: To allow this case, create a new shuffle mask with no undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:195,Availability,mask,mask,195,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:248,Modifiability,variab,variable,248,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:277,Performance,perform,perform,277,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:227,Safety,risk,risk,227,"// Note: In general, we do not create new shuffles in InstCombine because we; // do not know if a target can lower an arbitrary shuffle optimally. In this; // case, the shuffle uses the existing mask, so there is no additional risk.; // Select the variable vectors first, then perform the binop:; // shuffle (op X, C0), (op Y, C1), M --> op (shuffle X, Y, M), C'; // shuffle (op C0, X), (op C1, Y), M --> op C', (shuffle X, Y, M)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:181,Availability,mask,mask,181,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:290,Safety,safe,safe,290,"// Flags are intersected from the 2 source binops. But there are 2 exceptions:; // 1. If we changed an opcode, poison conditions might have changed.; // 2. If the shuffle had undef mask elements, the new binop might have undefs; // where the original code did not. But if we already made a safe constant,; // then there's no danger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:24,Availability,mask,mask,24,"// Last, check that the mask chooses the correct low bits for each narrow; // element in the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:48,Modifiability,extend,extended,48,// We need a narrow condition value. It must be extended with undef elements; // and have the same number of elements as this shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:61,Availability,Mask,Mask,61,"// Match 1-input (unary) shuffle.; // shuffle (fneg/fabs X), Mask --> fneg/fabs (shuffle X, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:92,Availability,Mask,Mask,92,"// Match 1-input (unary) shuffle.; // shuffle (fneg/fabs X), Mask --> fneg/fabs (shuffle X, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:38,Availability,Mask,Mask,38,"// shuf (fneg/fabs X), (fneg/fabs Y), Mask --> fneg/fabs (shuf X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:69,Availability,Mask,Mask,69,"// shuf (fneg/fabs X), (fneg/fabs Y), Mask --> fneg/fabs (shuf X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:31,Availability,Mask,Mask,31,"// shuffle (cast X), (cast Y), Mask --> cast (shuffle X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:60,Availability,Mask,Mask,60,"// shuffle (cast X), (cast Y), Mask --> cast (shuffle X, Y, Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Availability,mask,mask,71,// Try to combine 2 shuffles into 1 shuffle by concatenating a shuffle mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:97,Availability,mask,mask,97,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:244,Availability,mask,mask,244,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:401,Availability,mask,mask,401,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:451,Availability,mask,mask,451,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:486,Availability,mask,mask,486,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:340,Energy Efficiency,efficient,efficiently,340,"// We are extracting a subvector from a shuffle. Remove excess elements from; // the 1st shuffle mask to eliminate the extract.; //; // This transform is conservatively limited to identity extracts because we do; // not allow arbitrary shuffle mask creation as a target-independent transform; // (because we can't guarantee that will lower efficiently).; //; // If the extracting shuffle has an undef mask element, it transfers to the; // new shuffle mask. Otherwise, copy the original mask element. Example:; // shuf (shuf X, Y, <C0, C1, C2, undef, C4>), undef, <0, undef, 2, 3> -->; // shuf X, Y, <C0, undef, C2, undef>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:41,Usability,Simpl,SimplifyDemandedVectorElts,41,"// This is a specialization of a fold in SimplifyDemandedVectorElts. We may; // not be able to handle it there if the insertelement has >1 use.; // If the shuffle has an insertelement operand but does not choose the; // inserted scalar element from that value, then we can replace that shuffle; // operand with the source vector of the insertelement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Availability,Mask,Mask,32,"// shuf (inselt X, ?, IdxC), ?, Mask --> shuf X, ?, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:52,Availability,Mask,Mask,52,"// shuf (inselt X, ?, IdxC), ?, Mask --> shuf X, ?, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Security,access,accesses,81,// Offset the index constant by the vector width because we are checking for; // accesses to the 2nd vector input of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:32,Availability,Mask,Mask,32,"// shuf ?, (inselt X, ?, IdxC), Mask --> shuf ?, X, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:52,Availability,Mask,Mask,52,"// shuf ?, (inselt X, ?, IdxC), Mask --> shuf ?, X, Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:43,Availability,Mask,Mask,43,"// shuffle (insert ?, Scalar, IndexC), V1, Mask --> insert V1, Scalar, IndexC'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:20,Availability,mask,mask,20,// Test the shuffle mask to see if it splices the inserted scalar into the; // operand 1 vector of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:3,Testability,Test,Test,3,// Test the shuffle mask to see if it splices the inserted scalar into the; // operand 1 vector of the shuffle.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,mask,mask,16,// Ignore undef mask elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:12,Deployability,update,updated,12,// Index is updated to the potentially translated insertion lane.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:30,Energy Efficiency,power,power-of-,30,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:242,Energy Efficiency,power,power-of-,242,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:102,Usability,simpl,simplified,102,"// We limit this transform to power-of-2 types because we expect that the; // backend can convert the simplified IR patterns to identical nodes as the; // original IR.; // TODO: If we can verify the same behavior for arbitrary types, the; // power-of-2 checks can be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:125,Availability,mask,mask,125,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:200,Availability,Mask,Mask,200,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:220,Availability,Mask,Mask,220,"// This is a shuffle of 2 widening shuffles. We can shuffle the narrow source; // operands directly by adjusting the shuffle mask to account for the narrower; // types:; // shuf (widen X), (widen Y), Mask --> shuf X, Y, Mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Availability,mask,mask,59,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:145,Availability,mask,mask,145,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:172,Availability,down,down,172,"// If this shuffle is choosing from the 1st narrow op, the mask element is; // the same. If this shuffle is choosing from the 2nd narrow op, the mask; // element is offset down to adjust for the narrow vector widths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:142,Usability,simpl,simplified,142,"// Splatting the first element of the result of a BinOp, where any of the; // BinOp's operands are the result of a first element splat can be simplified to; // splatting the first element of the result of the BinOp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:96,Performance,scalab,scalable,96,// Canonicalize splat shuffle to use poison RHS. Handle this explicitly in; // order to support scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:37,Availability,Mask,Mask,37,"// shuffle (bitcast X), (bitcast Y), Mask --> bitcast (shuffle X, Y, Mask); //; // if X and Y are of the same (vector) type, and the element size is not; // changed by the bitcasts, we can distribute the bitcasts through the; // shuffle, hopefully reducing the number of instructions. We make sure that; // at least one bitcast only has one use, so we don't *increase* the number of; // instructions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:69,Availability,Mask,Mask,69,"// shuffle (bitcast X), (bitcast Y), Mask --> bitcast (shuffle X, Y, Mask); //; // if X and Y are of the same (vector) type, and the element size is not; // changed by the bitcasts, we can distribute the bitcasts through the; // shuffle, hopefully reducing the number of instructions. We make sure that; // at least one bitcast only has one use, so we don't *increase* the number of; // instructions here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:59,Availability,mask,mask,59,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:171,Availability,Mask,Mask,171,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:215,Modifiability,extend,extended,215,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:98,Usability,simpl,simplify,98,"// Peek through a bitcasted shuffle operand by scaling the mask. If the; // simulated shuffle can simplify, then this shuffle is unnecessary:; // shuf (bitcast X), undef, Mask --> bitcast X'; // TODO: This could be extended to allow length-changing shuffles.; // The transform might also be obsoleted if we allowed canonicalization; // of bitcasted shuffles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:26,Availability,mask,mask,26,// Try to create a scaled mask constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:33,Usability,simpl,simplifies,33,"// If the shuffled source vector simplifies, cast that value to this; // shuffle's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:17,Availability,mask,mask,17,"// shuffle x, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:44,Availability,mask,mask,44,"// shuffle x, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:21,Availability,mask,mask,21,"// shuffle undef, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:48,Availability,mask,mask,48,"// shuffle undef, x, mask --> shuffle x, undef, mask'",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:107,Usability,Simpl,SimplifyDemandedVectorElts,107,"// These transforms have the potential to lose undef knowledge, so they are; // intentionally placed after SimplifyDemandedVectorElts().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:216,Availability,mask,mask,216,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:280,Availability,mask,mask,280,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:309,Availability,mask,mask,309,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:381,Availability,mask,mask,381,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:478,Availability,mask,mask,478,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:507,Availability,mask,mask,507,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:518,Availability,mask,mask,518,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:584,Availability,mask,mask,584,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:681,Availability,mask,mask,681,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:708,Availability,mask,mask,708,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:724,Availability,mask,mask,724,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:842,Availability,mask,mask,842,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:936,Availability,mask,mask,936,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:969,Availability,mask,mask,969,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:986,Availability,mask,mask,986,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1108,Availability,mask,mask,1108,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1376,Availability,mask,masks,1376,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:1469,Safety,safe,safe,1469,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:146,Usability,simpl,simplified,146,"// If the LHS is a shufflevector itself, see if we can combine it with this; // one without producing an unusual shuffle.; // Cases that might be simplified:; // 1.; // x1=shuffle(v1,v2,mask1); // x=shuffle(x1,undef,mask); // ==>; // x=shuffle(v1,undef,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : -1; // 2.; // x1=shuffle(v1,undef,mask1); // x=shuffle(x1,x2,mask); // where v1.size() == mask1.size(); // ==>; // x=shuffle(v1,x2,newMask); // newMask[i] = (mask[i] < x1.size()) ? mask1[mask[i]] : mask[i]; // 3.; // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v2.size() == mask2.size(); // ==>; // x=shuffle(x1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask[i] : mask2[mask[i]-x1.size()]+x1.size(); // 4.; // x1=shuffle(v1,undef,mask1); // x2=shuffle(v2,undef,mask2); // x=shuffle(x1,x2,mask); // where v1.size() == v2.size(); // ==>; // x=shuffle(v1,v2,newMask); // newMask[i] = (mask[i] < x1.size()); // ? mask1[mask[i]] : mask2[mask[i]-x1.size()]+v1.size(); //; // Here we are really conservative:; // we are absolutely afraid of producing a shuffle mask not in the input; // program, because the code gen may not be smart enough to turn a merged; // shuffle into two specific shuffles: it may produce worse code. As such,; // we only merge two shuffles if the result is either a splat or one of the; // input shuffle masks. In this case, merging the shuffles just removes; // one instruction, which we know is safe. This is good for things like; // turning: (splat(splat)) -> splat, or; // merge(V[0..n], V[n+1..2n]) -> V[0..2n]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:16,Availability,mask,mask,16,// Create a new mask for the new ShuffleVectorInst so that the new; // ShuffleVectorInst is equivalent to the original one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:135,Availability,mask,mask,135,"// This element is from left hand side vector operand.; //; // If LHS is going to be replaced (case 1, 2, or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Availability,mask,mask,81,"// If the value selected is an poison value, explicitly specify it; // with a -1 mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:140,Availability,mask,mask,140,"// This element is from right hand side vector operand; //; // If the value selected is a poison value, explicitly specify it; // with a -1 mask value. (case 1)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:71,Availability,mask,mask,71,"// If RHS is going to be replaced (case 3 or 4), calculate the; // new mask value for the element.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:81,Availability,mask,mask,81,"// If the value selected is an poison value, explicitly specify it; // with a -1 mask value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:40,Availability,mask,mask,40,"// If LHS's width is changed, shift the mask value accordingly.; // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any; // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.; // If newRHS == newLHS, we want to remap any references from newRHS to; // newLHS so that we can properly identify splats that may occur due to; // obfuscation across the two vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:202,Availability,mask,mask,202,"// If LHS's width is changed, shift the mask value accordingly.; // If newRHS == nullptr, i.e. LHSOp0 == RHSOp0, we want to remap any; // references from RHSOp0 to LHSOp0, so we don't need to shift the mask.; // If newRHS == newLHS, we want to remap any references from newRHS to; // newLHS so that we can properly identify splats that may occur due to; // obfuscation across the two vectors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:17,Availability,mask,mask,17,"// If the result mask is equal to one of the original shuffle masks,; // or is a splat, do the replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp:62,Availability,mask,masks,62,"// If the result mask is equal to one of the original shuffle masks,; // or is a splat, do the replacement.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstCombineVectorOps.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:1278,Energy Efficiency,power,power-of-two,1278,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:800,Performance,perform,performed,800,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:995,Performance,perform,performed,995,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:1189,Testability,log,logical,1189,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:442,Usability,simpl,simple,442,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:535,Usability,simpl,simplification,535,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:696,Usability,simpl,simple,696,"//===- InstructionCombining.cpp - Combine multiple instructions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // InstructionCombining - Combine instructions to form fewer, simple; // instructions. This pass does not modify the CFG. This pass is where; // algebraic simplification happens.; //; // This pass combines things like:; // %Y = add i32 %X, 1; // %Z = add i32 %Y, 1; // into:; // %Z = add i32 %X, 2; //; // This is a simple worklist driven algorithm.; //; // This pass guarantees that the following canonicalizations are performed on; // the program:; // 1. If a binary operator has a constant operand, it is moved to the RHS; // 2. Bitwise operators with constant operands are always grouped so that; // shifts are performed first, then or's, then and's, then xor's.; // 3. Compare instructions are converted from <,>,<=,>= to ==,!= if possible; // 4. All cmp instructions on boolean values are replaced with logical ops; // 5. add X, X is represented as (X*2) => (X << 1); // 6. Multiplies with a power-of-two constant argument are transformed into; // shifts.; // ... etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,Availability,avail,availability,167,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:158,Modifiability,variab,variable,158,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:205,Modifiability,Variab,Variables,205,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:93,Safety,avoid,avoid,93,"// FIXME: Remove this flag when it is no longer necessary to convert; // llvm.dbg.declare to avoid inaccurate debug info. Setting this to false; // increases variable availability at the cost of accuracy. Variables that; // cannot be promoted by mem2reg or SROA will be described as living in memory; // for their entire lifetime. However, passes like DSE and instcombine can; // delete stores to the alloca, leading to misleading and inaccurate debug; // information. This flag can be removed when those passes are fixed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,Safety,avoid,avoid,83,"/// Legal integers and common types are considered desirable. This is used to; /// avoid creating instructions with types that may not be supported well by the; /// the backend.; /// NOTE: This treats i8, i16 and i32 specially because they are common; /// types in frontend languages.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:390,Performance,optimiz,optimizations,390,"/// Return true if it is desirable to convert an integer computation from a; /// given bit width to a new bit width.; /// We don't want to convert from a legal or desirable type (like i8) to an; /// illegal type or from a smaller to a larger illegal type. A width of '1'; /// is always treated as a desirable type because i1 is a fundamental type in; /// IR, and there are many specialized optimizations for i1 types.; /// Common/desirable widths are equally treated as legal to convert to, in; /// order to open up more combining opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:305,Performance,optimiz,optimizations,305,"/// Return true if it is desirable to convert a computation from 'From' to 'To'.; /// We don't want to convert from a legal to an illegal type or from a smaller; /// to a larger illegal type. i1 is always treated as a legal type because it is; /// a fundamental type in IR, and there are many specialized optimizations for; /// i1 types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Modifiability,extend,extended,23,// TODO: This could be extended to allow vectors. Datalayout changes might be; // needed to properly support that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:29,Integrability,Wrap,Wrap,29,"// Return true, if No Signed Wrap should be maintained for I.; // The No Signed Wrap flag can be kept if the operation ""B (I.getOpcode) C"",; // where both B and C should be ConstantInts, results in a constant that does; // not overflow. This function only handles the Add and Sub opcodes. For; // all other opcodes, the function conservatively returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:80,Integrability,Wrap,Wrap,80,"// Return true, if No Signed Wrap should be maintained for I.; // The No Signed Wrap flag can be kept if the operation ""B (I.getOpcode) C"",; // where both B and C should be ConstantInts, results in a constant that does; // not overflow. This function only handles the Add and Sub opcodes. For; // all other opcodes, the function conservatively returns false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:19,Usability,clear,clears,19,/// Conservatively clears subclassOptionalData after a reassociation or; /// commutation. We preserve fast-math flags when applicable as they can be; /// preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Modifiability,Enhance,Enhance,9,// TODO: Enhance logic for other casts and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Testability,log,logic,17,// TODO: Enhance logic for other casts and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Modifiability,Enhance,Enhance,9,// TODO: Enhance logic for other BinOps and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Testability,log,logic,17,// TODO: Enhance logic for other BinOps and remove this check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies IntToPtr/PtrToInt RoundTrip Cast.; // inttoptr ( ptrtoint (x) ) --> x,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Performance,perform,performs,9,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:24,Usability,simpl,simplifications,24,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:417,Usability,simpl,simplifies,417,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:496,Usability,simpl,simplifies,496,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:629,Usability,simpl,simplifies,629,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:708,Usability,simpl,simplifies,708,"/// This performs a few simplifications for operators that are associative or; /// commutative:; ///; /// Commutative operators:; ///; /// 1. Order operands such that they are listed from right (least complex) to; /// left (most complex). This puts constants before unary operators before; /// binary operators.; ///; /// Associative operators:; ///; /// 2. Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.; /// 3. Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.; ///; /// Associative and commutative operators:; ///; /// 4. Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.; /// 5. Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.; /// 6. Transform: ""(A op C1) op (B op C2)"" ==> ""(A op B) op (C1 op C2)""; /// if C1 and C2 are constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""(A op B) op C"" ==> ""A op (B op C)"" if ""B op C"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""A op V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,// Conservatively clear all optional flags since they may not be; // preserved by the reassociation. Reset nsw/nuw based on the above; // analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Usability,Simpl,SimplifyBinOp,36,// Note: this is only valid because SimplifyBinOp doesn't look at; // the operands to Op0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""A op (B op C)"" ==> ""(A op B) op C"" if ""A op B"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""V op C"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""(A op B) op C"" ==> ""(C op A) op B"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""V op B"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simplifies,62,"// Transform: ""A op (B op C)"" ==> ""B op (C op A)"" if ""C op A"" simplifies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""C op A"" simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:6,Usability,simpl,simplifies,6,"// It simplifies to V. Form ""B op V"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,clear,clear,18,"// Conservatively clear the optional flags, since they may not be; // preserved by the reassociation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,Usability,simpl,simplifications,14,// No further simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations by factorizing out common terms; /// (e. g. ""(A*B)+(A*C)"" -> ""A*(B+C)"").",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Usability,simpl,simplifies,54,"// Consider forming ""A op' (B op D)"".; // If ""B op D"" simplifies then it can be formed with no cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Usability,simpl,simplify,23,"// If ""B op D"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Usability,simpl,simplifies,54,"// Consider forming ""(A op C) op' B"".; // If ""A op C"" simplifies then it can be formed with no cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:23,Usability,simpl,simplify,23,"// If ""A op C"" doesn't simplify then only go on if one of the existing; // operations ""A op' B"" and ""C op' D"" will be zapped as no longer used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:183,Usability,simpl,simplfied,183,"// Signed predicates aren't correct in some edge cases like for i2 types, as; // well since (ctpop x) is known [0, log2(BitWidth(x))] almost all signed; // comparisons against it are simplfied to unsigned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Usability,simpl,simplify,95,"// Need extra check for icmp. Note if this check is true, it generally means; // the icmp will simplify to true/false.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Safety,avoid,avoid,33,// Do the transformation here to avoid potentially introducing an infinite; // loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:354,Availability,Mask,Mask,354,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:538,Availability,Mask,Mask,538,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:595,Availability,Mask,Mask,595,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:662,Testability,log,logical,662,"// (Binop1 (Binop2 (logic_shift X, C), C1), (logic_shift Y, C)); // IFF; // 1) the logic_shifts match; // 2) either both binops are binops and one is `and` or; // BinOp1 is `and`; // (logic_shift (inv_logic_shift C1, C), C) == C1 or; //; // -> (logic_shift (Binop1 (Binop2 X, inv_logic_shift(C1, C)), Y), C); //; // (Binop1 (Binop2 (logic_shift X, Amt), Mask), (logic_shift Y, Amt)); // IFF; // 1) the logic_shifts match; // 2) BinOp1 == BinOp2 (if BinOp == `add`, then also requires `shl`).; //; // -> (BinOp (logic_shift (BinOp X, Y)), Mask); //; // (Binop1 (Binop2 (arithmetic_shift X, Amt), Mask), (arithmetic_shift Y, Amt)); // IFF; // 1) Binop1 is bitwise logical operator `and`, `or` or `xor`; // 2) Binop2 is `not`; //; // -> (arithmetic_shift Binop1((not X), Y), Amt)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Availability,mask,masks,38,// Skip Sub as we only match constant masks which will canonicalize to use; // add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Availability,mask,mask,53,// If the BinOp1 is `and` we don't need to check the mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:27,Availability,mask,mask,27,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:100,Availability,mask,mask,100,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Usability,simpl,simplified,113,"// If BinOp2 is `and`, any mask works (this only really helps for non-splat; // vecs, otherwise the mask will be simplified and the following check will; // handle it).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:19,Availability,mask,mask,19,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:92,Availability,Mask,Mask,92,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Availability,Mask,Mask,116,"// Otherwise, need mask that meets the below requirement.; // (logic_shift (inv_logic_shift Mask, ShAmt), ShAmt) == Mask",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:61,Availability,mask,mask,61,"// Otherwise we can only distribute by constant shifting the mask, so; // ensure we have constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:193,Usability,simpl,simplify,193,"// (Binop (zext C), (select C, T, F)); // -> (select C, (binop 1, T), (binop 0, F)); //; // (Binop (sext C), (select C, T, F)); // -> (select C, (binop -1, T), (binop 0, F)); //; // Attempt to simplify binary operations into a select with folded args, when; // one operand of the binop is a select instruction and the other operand is a; // zext/sext extension, whose value is the select condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Modifiability,extend,extended,36,"// TODO: this simplification may be extended to any speculatable instruction,; // not just binops, and would possibly be handled better in FoldOpIntoSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:14,Usability,simpl,simplification,14,"// TODO: this simplification may be extended to any speculatable instruction,; // not just binops, and would possibly be handled better in FoldOpIntoSelect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:124,Usability,simpl,simplified,124,"// If the value used in the zext/sext is the select condition, or the negated; // of the select condition, the binop can be simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Usability,simpl,simplify,18,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:218,Usability,simpl,simplifications,218,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:306,Usability,simpl,simplified,306,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:345,Usability,simpl,simplify,345,"/// This tries to simplify binary operations which some other binary operation; /// distributes over either by factorizing out common terms; /// (eg ""(A*B)+(A*C)"" -> ""A*(B+C)"") or expanding out if this results in; /// simplifications (eg: ""A & (B | C) -> (A&B) | (A&C)"" if this is a win).; /// Returns the simplified value, or null if it didn't simplify.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Usability,simpl,simplifications,116,"// The instruction has the form ""(A op' B) op C"". See if expanding it out; // to ""(A op C) op' (B op C)"" results in simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Safety,safe,safe,53,// op'; // Disable the use of undef because it's not safe to distribute undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Usability,simpl,simplify,33,"// Do ""A op C"" and ""B op C"" both simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""B op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:116,Usability,simpl,simplifications,116,"// The instruction has the form ""A op (B op' C)"". See if expanding it out; // to ""(A op B) op' (A op C)"" results in simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Safety,safe,safe,53,// op'; // Disable the use of undef because it's not safe to distribute undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:33,Usability,simpl,simplify,33,"// Do ""A op B"" and ""A op C"" both simplify?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op B"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Usability,simpl,simplify,17,"// Does ""A op C"" simplify to the identity value for the inner opcode?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:65,Usability,simpl,simplified,65,// We need an 'add' and exactly 1 arm of the select to have been simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:11,Energy Efficiency,adapt,adapt,11,/// Freely adapt every user of V as-if V was changed to !V.; /// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:11,Modifiability,adapt,adapt,11,/// Freely adapt every user of V as-if V was changed to !V.; /// WARNING: only if canFreelyInvertAllUsersOf() said this can be done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:47,Modifiability,extend,extended,47,/// A binop with a constant operand and a sign-extended boolean operand may be; /// converted into a select of constants by applying the binary operation to; /// the constant with the two possible values of the extended boolean (0 or -1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:211,Modifiability,extend,extended,211,/// A binop with a constant operand and a sign-extended boolean operand may be; /// converted into a select of constants by applying the binary operation to; /// the constant with the two possible values of the extended boolean (0 or -1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Testability,log,logical,56,// Bool selects with constant operands can be folded to logical ops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Testability,Test,Test,3,"// Test if a FCmpInst instruction is used exclusively by a select as; // part of a minimum or maximum operation. If so, refrain from doing; // any other folding. This helps out other analyses which understand; // non-obfuscated minimum and maximum idioms. And in this case, at; // least one of the comparison operands has at least one user besides; // the compare (the select), which would often largely negate the; // benefit of folding anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:22,Usability,simpl,simplification,22,// Don't consider the simplification successful if we get back a constant; // expression. That's just an instruction in hiding.; // Also reject the case where we simplify back to the phi node. We wouldn't; // be able to remove it in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:162,Usability,simpl,simplify,162,// Don't consider the simplification successful if we get back a constant; // expression. That's just an instruction in hiding.; // Also reject the case where we simplify back to the phi node. We wouldn't; // be able to remove it in that case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:21,Usability,simpl,simplified,21,// More than one non-simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:31,Usability,simpl,simplified,31,"// If there is exactly one non-simplified value, we can insert a copy of the; // operation in that block. However, if this is a critical edge, we would be; // inserting the computation on some other paths (e.g. inside a loop). Only; // do this if the pred block is unconditionally branching into the phi block.; // Also, make sure that the pred block is not dead code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:181,Performance,optimiz,optimization,181,"// Fold if there is at least one specific constant value in phi0 or phi1's; // incoming values that comes from the same block and this specific constant; // value can be used to do optimization for specific binary operator.; // For example:; // %phi0 = phi i32 [0, %bb0], [%i, %bb1]; // %phi1 = phi i32 [%j, %bb0], [0, %bb1]; // %add = add i32 %phi0, %phi1; // ==>; // %add = phi i32 [%j, %bb0], [%i, %bb1]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:90,Safety,safe,safe,90,// TODO: This check could be tightened to only apply to binops (div/rem) that; // are not safe to speculatively execute. But that could allow hoisting; // potentially expensive instructions (fdiv for example).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:65,Performance,perform,perform,65,"// If both operands of the binop are vector concatenations, then perform the; // narrow binop on each pair of the source operands followed by concatenation; // of the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:235,Availability,mask,mask,235,"// This transform does not have the speculative execution constraint as; // below because the shuffle is a concatenation. The new binops are; // operating on exactly the same elements as the existing binop.; // TODO: We could ease the mask requirement to allow different undef lanes,; // but that requires an analysis of the binop-with-undef output value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Safety,safe,safe,17,"// It may not be safe to reorder shuffles and things like div, urem, etc.; // because we may trap when executing those ops on unknown vector elements.; // See PR20059.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:80,Availability,mask,mask,80,"// If both arguments of the binary operation are shuffles that use the same; // mask and shuffle within a single vector, move the shuffle after the binop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Availability,Mask,Mask,18,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:37,Availability,Mask,Mask,37,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Availability,Mask,Mask,67,"// Op(shuffle(V1, Mask), shuffle(V2, Mask)) -> shuffle(Op(V1, V2), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,Availability,mask,mask,86,"// If both arguments of a commutative binop are select-shuffles that use the; // same mask with commuted operands, the shuffles are unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:51,Availability,mask,mask,51,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:83,Energy Efficiency,reduce,reduces,83,"// TODO: Allow shuffles that contain undefs in the mask?; // That is legal, but it reduces undef knowledge.; // TODO: Allow arbitrary shuffles by shuffling after binop?; // That might be legal, but we have to deal with poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:259,Modifiability,extend,extended,259,// Bail out if:; // 1. The constant vector contains a constant expression.; // 2. The shuffle needs an element of the constant vector that can't; // be mapped to a new constant vector.; // 3. This is a widening shuffle that copies elements of V1 into the; // extended elements (extending with poison is allowed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:278,Modifiability,extend,extending,278,// Bail out if:; // 1. The constant vector contains a constant expression.; // 2. The shuffle needs an element of the constant vector that can't; // be mapped to a new constant vector.; // 3. This is a widening shuffle that copies elements of V1 into the; // extended elements (extending with poison is allowed).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:240,Availability,mask,mask,240,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Modifiability,extend,extend,53,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:184,Safety,safe,safe,184,"// If this is a widening shuffle, we must be able to extend with poison; // elements. If the original binop does not produce a poison in the high; // lanes, then this transform is not safe.; // Similarly for poison lanes due to the shuffle mask, we can only; // transform binops that preserve poison.; // TODO: We could shuffle those non-poison constant values into the; // result by using a constant vector (rather than an poison vector); // as operand 1 of the new binop, but that might be too aggressive; // for target-independent shuffle creation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Safety,safe,safe,17,// It may not be safe to execute a binop on a vector with poison elements; // because the entire instruction can be folded to undef or create poison; // that did not exist in the original code.; // TODO: The shift case should not be necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Availability,Mask,Mask,18,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:53,Availability,Mask,Mask,53,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:81,Availability,Mask,Mask,81,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Availability,Mask,Mask,113,"// Op(shuffle(V1, Mask), C) -> shuffle(Op(V1, NewC), Mask); // Op(C, shuffle(V1, Mask)) -> shuffle(Op(NewC, V1), Mask)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:26,Safety,safe,safe,26,"// FIXME: This may not be safe if the analysis allows undef elements. By; // moving 'Y' before the splat shuffle, we are implicitly assuming; // that it is not undef/poison at the splat index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:35,Performance,perform,perform,35,"// X and Y are splatted values, so perform the binary operation on those; // values followed by a splat followed by the 2nd binary operation:; // bo (splat X), (bo Y, OtherOp) --> bo (splat (bo X, Y)), OtherOp",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:91,Safety,safe,safe,91,// Intersect FMF on both new binops. Other (poison-generating) flags are; // dropped to be safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Modifiability,extend,extend,67,/// Try to narrow the width of a binop if at least 1 operand is an extend of; /// of a value. This requires a potentially expensive known bits check to make; /// sure the narrow op does not overflow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:24,Modifiability,extend,extended,24,// We need at least one extended operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:89,Modifiability,extend,extending,89,"// If that did not match, see if we have a suitable constant operand.; // Truncating and extending must produce the same constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Modifiability,variab,variable,20,// Split Src into a variable part and a constant suffix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:52,Performance,scalab,scalable,52,// FIXME: getIndexedOffsetInType() does not handled scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:84,Performance,perform,performing,84,"// Even if the total offset is inbounds, we may end up representing it; // by first performing a larger negative offset, and then a smaller; // positive one. The large negative offset might go out of bounds. Only; // preserve inbounds if all signs are the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:163,Safety,avoid,avoid,163,"// If they aren't the same type, then the input hasn't been processed; // by the loop above yet (which canonicalizes sequential index types to; // intptr_t). Just avoid transforming this until the input has been; // normalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Deployability,Update,Update,3,// Update the GEP in place if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Testability,Log,LogicOps,3,// LogicOps are special in that we canonicalize them at the cost of an; // instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:92,Performance,scalab,scalable,92,"// For vector geps, use the generic demanded vector support.; // Skip if GEP return type is scalable. The number of elements is unknown at; // compile-time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:113,Modifiability,extend,extend,113,"// If we are using a wider index than needed for this platform, shrink; // it to what we need. If narrower, sign-extend it to what we need.; // This explicit cast can make subsequent optimizations more obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:183,Performance,optimiz,optimizations,183,"// If we are using a wider index than needed for this platform, shrink; // it to what we need. If narrower, sign-extend it to what we need.; // This explicit cast can make subsequent optimizations more obvious.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:265,Modifiability,variab,variable,265,"// Don't fold a GEP into itself through a PHI node. This can only happen; // through the back-edge of a loop. Folding a GEP into itself means that; // the value of the previous iteration needs to be stored in the meantime,; // thus requiring an additional register variable to be live, but not; // actually achieving anything (the GEP still needs to be executed once per; // loop iteration).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:128,Modifiability,variab,variable,128,"// We have not seen any differences yet in the GEPs feeding the; // PHI yet, so we record this one if it is allowed to be a; // variable.; // The first two arguments can vary for any GEP, the rest have to be; // static for struct slots",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:72,Modifiability,extend,extended,72,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:124,Modifiability,variab,variable,124,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:334,Usability,simpl,simpler,334,// The GEP is different by more than one input. While this could be; // extended to support GEPs that vary by more than one variable it; // doesn't make sense since it greatly increases the complexity and; // would result in an R+R+R addressing mode which no backend; // directly supports and would need to be broken into several; // simpler instructions anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:8,Availability,down,down,8,// Sink down a layer of the type for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:57,Availability,down,down,57,// All the GEPs feeding the PHI are identical. Clone one down into our; // BB so that it can be merged with the current GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Performance,scalab,scalable,38,// Skip if GEP source element type is scalable. The type alloc size is unknown; // at compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:112,Safety,safe,safely,112,"// If the only possible side effect of the call is writing to the alloca,; // and the result isn't used, we can safely remove any reads implied by the; // call including those which might read the alloca itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Energy Efficiency,power,power-of-,95,"// Check if alignment and size of a call to aligned_alloc is valid,; // that is alignment is a power-of-2 and the size is a multiple of the; // alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,Availability,redundant,redundant,993,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:993,Safety,redund,redundant,993,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:134,Usability,simpl,simply,134,"// Remove debug intrinsics which describe the value contained within the; // alloca. In addition to removing dbg.{declare,addr} which simply point to; // the alloca, remove dbg.value(<alloca>, ..., DW_OP_deref)'s as well, e.g.:; //; // ```; // define void @foo(i32 %0) {; // %a = alloca i32 ; Deleted.; // store i32 %0, i32* %a; // dbg.value(i32 %0, ""arg0"") ; Not deleted.; // dbg.value(i32* %a, ""arg0"", DW_OP_deref) ; Deleted.; // call void @trivially_inlinable_no_op(i32* %a); // ret void; // }; // ```; //; // This may not be required if we stop describing the contents of allocas; // using dbg.value(<alloca>, ..., DW_OP_deref), but we currently do this in; // the LowerDbgDeclare utility.; //; // If there is a dead store to `%a` in @trivially_inlinable_no_op, the; // ""arg0"" dbg.value may be stale after the call. However, failing to remove; // the DW_OP_deref dbg.value causes large gaps in location coverage.; //; // FIXME: the Assignment Tracking project has now likely made this; // redundant (and it's sometimes harmful).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:243,Performance,perform,performed,243,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:78,Security,access,accessed,78,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:40,Testability,test,test,40,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:115,Testability,test,test,115,"/// Move the call to free before a NULL test.; ///; /// Check if this free is accessed after its argument has been test; /// against NULL (property 0).; /// If yes, it is legal to move this call in its predecessor block.; ///; /// The move is performed only if the block containing the call to free; /// will be removed, i.e.:; /// 1. it has only one predecessor P, and P has two successors; /// 2. it contains the call, noops, and an unconditional branch; /// 3. its successor is the same as its predecessor's successor; ///; /// The profitability is out-of concern here and this function should; /// be called only if the caller knows this transformation would be; /// profitable (e.g., for code size).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:74,Modifiability,extend,extend,74,"// Validate part of constraint #1: Only one predecessor; // FIXME: We can extend the number of predecessor, but in that case, we; // would duplicate the call to free in each predecessor and it may; // not be profitable even for code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,"// Validate part of constraint #1: Only one predecessor; // FIXME: We can extend the number of predecessor, but in that case, we; // would duplicate the call to free in each predecessor and it may; // not be profitable even for code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,"// Validate constraint #2: Does this block contains only the call to; // free, noops, and an unconditional branch?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:212,Performance,perform,performance,212,"// If there are only 2 instructions in the block, at this point,; // this is the call to free and unconditional.; // If there are more than 2 instructions, check that they are noops; // i.e., they won't hurt the performance of the generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,// Validate the rest of constraint #1 by matching on the pred branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Security,Validat,Validate,3,// Validate constraint #3: Ensure the null case just falls through.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:9,Performance,optimiz,optimize,9,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:82,Testability,test,test,82,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Usability,simpl,simplify,95,"// If we optimize for code size, try to move the call to free before the null; // test so that simplify cfg can remove the empty block and dead code; // elimination the branch. I.e., helps to turn something like:; // if (foo) free(foo);; // into; // free(foo);; //; // Note that we can only do this for 'free' and not for any flavor of; // 'operator delete'; there is no 'operator delete' symbol for which we are; // permitted to invent a call, even if we're passing in a null pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:30,Usability,Simpl,SimplifyCFGOpt,30,// WARNING: keep in sync with SimplifyCFGOpt::simplifyUnreachable()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:46,Usability,simpl,simplifyUnreachable,46,// WARNING: keep in sync with SimplifyCFGOpt::simplifyUnreachable()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:167,Usability,simpl,simple,167,"// Try to remove the previous instruction if it must lead to unreachable.; // This includes instructions like stores and ""llvm.assume"" that may not get; // removed by simple dead code elimination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:16,Testability,log,logical-and-with-invert,16,"// Canonicalize logical-and-with-invert as logical-or-with-invert.; // This is done by inverting the condition and swapping successors:; // br (X && !Y), T, F --> br !(X && !Y), F, T --> br (!X || Y), F, T",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:43,Testability,log,logical-or-with-invert,43,"// Canonicalize logical-and-with-invert as logical-or-with-invert.; // This is done by inverting the condition and swapping successors:; // br (X && !Y), T, F --> br !(X && !Y), F, T --> br (!X || Y), F, T",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:37,Availability,mask,mask,37,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Integrability,wrap,wrap,20,"// If the shift may wrap, we need to mask off the shifted bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:98,Usability,simpl,simplify,98,// We're extracting from an overflow intrinsic. See if we're the only user.; // That allows us to simplify multiple result intrinsics to simpler things; // that just get one value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Usability,simpl,simpler,137,// We're extracting from an overflow intrinsic. See if we're the only user.; // That allows us to simplify multiple result intrinsics to simpler things; // that just get one value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Integrability,wrap,wrap,18,"// Compute the no-wrap range for LHS given RHS=C, then construct an; // equivalent icmp, potentially using an offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:62,Usability,simpl,simply,62,"// The insert list is a prefix of the extract list; // We can simply remove the common indices from the extract and make it; // operate on the inserted value instead of the insertvalue result.; // i.e., replace; // %I = insertvalue { i32, { i32 } } %A, { i32 } { i32 42 }, 1; // %E = extractvalue { i32, { i32 } } %I, 1, 0; // with; // %E extractvalue { i32 } { i32 42 }, 0",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:38,Performance,scalab,scalable,38,// Bail out if the aggregate contains scalable vector type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:99,Energy Efficiency,reduce,reduces,99,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:55,Modifiability,rewrite,rewrite,55,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:25,Performance,load,load,25,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:77,Performance,load,load,77,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:123,Performance,load,load,123,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:134,Performance,load,load,134,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:221,Performance,optimiz,optimized,221,"// If the (non-volatile) load only has one use, we can rewrite this to a; // load from a GEP. This reduces the size of the load. If a load is used; // only by extractvalue instructions then this either must have been; // optimized before, or it is a struct with padding, in which case we; // don't want to do the transformation as it loses padding knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:54,Performance,load,load,54,"// We need to insert these at the location of the old load, not at that of; // the extractvalue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Performance,load,load,56,"// Whatever aliasing information we had for the orignal load must also; // hold for the smaller load, so propagate the annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:96,Performance,load,load,96,"// Whatever aliasing information we had for the orignal load must also; // hold for the smaller load, so propagate the annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:17,Performance,load,load,17,"// Returning the load directly will cause the main loop to insert it in; // the wrong spot, so use replaceInstUsesWith().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:320,Performance,load,loads,320,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:345,Performance,load,load,345,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:383,Performance,load,load,383,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:432,Performance,load,load,432,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:452,Performance,load,load,452,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:12,Usability,simpl,simplify,12,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:94,Usability,simpl,simplified,94,"// We could simplify extracts from other values. Note that nested extracts may; // already be simplified implicitly by the above: extract (extract (insert) ); // will be translated into extract ( insert ( extract ) ) first and then just; // the value inserted, if appropriate. Similarly for extracts from single-use; // loads: extract (extract (load)) will be translated to extract (load (gep)); // and if again single-use then via load (gep (gep)) to load (gep).; // However, double extracts from e.g. function arguments or return values; // aren't handled yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:86,Usability,clear,clear,86,"// The GCC C EH and Rust personality only exists to support cleanups, so; // it's not clear what the semantics of catch clauses are.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:7,Testability,log,logic,7,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Testability,log,logic,137,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:221,Testability,log,logic,221,"// The logic here should be correct for any real-world personality function.; // However if that turns out not to be true, the offending logic can always; // be conditioned on the personality function, like the catch-all logic is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the list of clauses, eg by removing repeated catch clauses; // (these are often created by inlining).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Availability,redundant,redundant,36,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:36,Safety,redund,redundant,36,// Repeated catch clause - drop the redundant copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:212,Usability,simpl,simpler,212,"// An empty filter catches everything, so there is no point in keeping any; // following clauses or marking the landingpad as having a cleanup. By; // dealing with this case here the following code is made a bit simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:321,Performance,optimiz,optimizations,321,"// If several filters occur in a row then reorder them so that the shortest; // filters come first (those with the smallest number of elements). This is; // advantageous because shorter filters are more likely to match, speeding up; // unwinding, but mostly because it increases the effectiveness of the other; // filter optimizations below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:359,Performance,perform,perform,359,"// If typeinfos matched if and only if equal, then the elements of a filter L; // that occurs later than a filter F could be replaced by the intersection of; // the elements of F and L. In reality two typeinfos can match without being; // equal (for example if one represents a C++ class, and the other some class; // derived from it) so it would be wrong to perform this transform in general.; // However the transform is correct and useful if F is a subset of L. In that; // case L can be replaced by F, and thus removed altogether since repeating a; // filter is pointless. So here we look at all pairs of filters F and L where; // L follows F in the list of clauses, and remove L if every element of F is; // an element of L. This can occur when inlining C++ functions with exception; // specifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:115,Usability,Clear,Clear,115,"// Even if none of the clauses changed, we may nonetheless have understood; // that the cleanup flag is pointless. Clear it if so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:95,Energy Efficiency,reduce,reduces,95,"// While we could change the other users of OrigOp to use freeze(OrigOp), that; // potentially reduces their optimization potential, so let's only do this iff; // the OrigOp is only used by the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:109,Performance,optimiz,optimization,109,"// While we could change the other users of OrigOp to use freeze(OrigOp), that; // potentially reduces their optimization potential, so let's only do this iff; // the OrigOp is only used by the freeze.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:137,Usability,simpl,simply,137,"// We can't push the freeze through an instruction which can itself create; // poison. If the only source of new poison is flags, we can simply; // strip them (since we know the only use is the freeze and nothing can; // benefit from them.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Safety,Detect,Detect,3,"// Detect whether this is a recurrence with a start value and some number of; // backedge values. We'll check whether we can push the freeze through the; // backedge values (possibly dropping poison flags along the way) until we; // reach the phi again. In that case, we can move the freeze to the start; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:541,Safety,avoid,avoid,541,"// If I is freeze(undef), check its uses and fold it to a fixed constant.; // - or: pick -1; // - select's condition: if the true value is constant, choose it by making; // the condition true.; // - default: pick 0; //; // Note that this transform is intentionally done here rather than; // via an analysis in InstSimplify or at individual user sites. That is; // because we must produce the same value for all uses of the freeze -; // it's the reason ""freeze"" exists!; //; // TODO: This could use getBinopAbsorber() / getBinopIdentity() to avoid; // duplicating logic for binops at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:563,Testability,log,logic,563,"// If I is freeze(undef), check its uses and fold it to a fixed constant.; // - or: pick -1; // - select's condition: if the true value is constant, choose it by making; // the condition true.; // - default: pick 0; //; // Note that this transform is intentionally done here rather than; // via an analysis in InstSimplify or at individual user sites. That is; // because we must produce the same value for all uses of the freeze -; // it's the reason ""freeze"" exists!; //; // TODO: This could use getBinopAbsorber() / getBinopIdentity() to avoid; // duplicating logic for binops at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:67,Modifiability,extend,extend,67,"// TODO: handle e.g. store to alloca here - only worth doing if we extend; // to allow reload along used path as described below. Otherwise, this; // is simply a store to a dead allocation which will be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:153,Usability,simpl,simply,153,"// TODO: handle e.g. store to alloca here - only worth doing if we extend; // to allow reload along used path as described below. Otherwise, this; // is simply a store to a dead allocation which will be removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:22,Security,access,access,22,"// TODO: allow memory access dominated by move point? Note that since AI; // could have a reference to itself captured by the call, we would need to; // account for cycles in doing so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:133,Safety,safe,safe,133,"/// Try to move the specified instruction from its current block into the; /// beginning of DestBlock, which can only happen if it's safe to move the; /// instruction past all of the instructions between it and the end of its; /// block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:48,Performance,load,loads,48,"// Cannot move control-flow-involving, volatile loads, vaarg, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Performance,load,load,20,// We can only sink load instructions if there is nothing between the load and; // the end of block that could change the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:70,Performance,load,load,70,// We can only sink load instructions if there is nothing between the load and; // the end of block that could change the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:175,Modifiability,variab,variables,175,"// Also sink all related debug uses from the source basic block. Otherwise we; // get debug use before the def. Attempt to salvage debug uses first, to; // maximise the range variables have location for. If we cannot salvage, then; // mark the location undef: we know it was supposed to receive a new location; // here, but that computation has been sunk.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:89,Availability,avail,available,89,"// For all debug values in the destination block, the sunk instruction; // will still be available, so they do not need to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:138,Modifiability,variab,variable,138,"// Process the sinking DbgUsersToSalvage in reverse order, as we only want; // to clone the last appearing debug intrinsic for each given variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:87,Modifiability,variab,variable,87,"// A dbg.declare instruction should not be cloned, since there can only be; // one per variable fragment. It should be left in the original place; // because the sunk instruction is not an alloca (otherwise we could not be; // here).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:3,Performance,Perform,Perform,3,"// Perform salvaging without the clones, then sink the clones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:78,Energy Efficiency,reduce,reduce,78,"// Check to see if we can DCE the instruction. We do this already here to; // reduce the number of uses and thus allow other folds to trigger.; // Note that eraseInstFromFunction() may push additional instructions on; // the deferred worklist, so this will DCE whole instruction chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:87,Usability,Simpl,SimplifyCFG,87,"// Try sinking to another block. If that block is unreachable, then do; // not bother. SimplifyCFG should handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:417,Availability,down,down,417,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:289,Usability,resume,resume,289,"// See if the user is one of our successors that has only one; // predecessor, so that we don't have to split the critical edge.; // Another option where we can sink is a block that ends with a; // terminator that does not pass control to other block (such as; // return or unreachable or resume). In this case:; // - I dominates the User (by SSA form);; // - the User will be executed at most once.; // So sinking I down to User is always profitable or neutral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:20,Usability,simpl,simple,20,"// Okay, the CFG is simple enough, try to sink this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:75,Security,expose,expose,75,"// We'll add uses of the sunk instruction below, but since; // sinking can expose opportunities for it's *operands* add; // them to the worklist",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:56,Usability,simpl,simplify,56,"// Now that we have an instruction, try combining it to simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:213,Safety,safe,safely,213,"// Track the scopes used by !alias.scope and !noalias. In a function, a; // @llvm.experimental.noalias.scope.decl is only useful if that scope is used; // by both sets. If not, the declaration of the scope can be safely omitted.; // The MDNode of the scope can be omitted as well for the instructions that are; // part of this function. We do not do that at this point, as this might become; // too time consuming to do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:205,Energy Efficiency,power,powerful,205,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:286,Safety,avoid,avoid,286,"/// Populate the IC worklist from a function, by walking it in reverse; /// post-order and adding all reachable code to the worklist.; ///; /// This has a couple of tricks to make the code faster and more powerful. In; /// particular, we constant fold and DCE instructions as we go, to avoid adding; /// them to the worklist (this significantly speeds up instcombine on code where; /// many instructions are dead or constant). Additionally, if we find a branch; /// whose condition is a known constant, we only visit the reachable successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:172,Performance,optimiz,optimization,172,// Skip processing debug and pseudo intrinsics in InstCombine. Processing; // these call instructions consumes non-trivial amount of time and; // provides no value for the optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:146,Energy Efficiency,reduce,reduces,146,"// Remove instructions inside unreachable blocks. This prevents the; // instcombine code from having to deal with some bad special cases, and; // reduces use counts of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:174,Availability,down,down,174,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:302,Safety,avoid,avoiding,302,"// Once we've found all of the instructions to add to instcombine's worklist,; // add them in reverse order. This way instcombine will visit from the top; // of the function down. This jives well with the way that it adds all uses; // of instructions to the worklist after doing a transformation, thus avoiding; // some N^2 behavior in pathological cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:98,Deployability,pipeline,pipeline,98,// TODO: Only use LoopInfo when the option is set. This requires that the; // callers in the pass pipeline explicitly set the option.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:42,Deployability,update,updates,42,// Mark all the analyses that instcombine updates as preserved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp:18,Integrability,Rout,Routines,18,// Initialization Routines,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/InstCombine/InstructionCombining.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:37,Availability,error,error,37,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:618,Performance,scalab,scalable,618,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:43,Safety,detect,detector,43,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:526,Security,sanitiz,sanitizers,526,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:588,Security,sanitiz,sanitizer,588,"//===- AddressSanitizer.cpp - memory error detector -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of AddressSanitizer, an address basic correctness; // checker.; // Details of the algorithm:; // https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:42,Energy Efficiency,allocate,allocated,42,// The shadow memory space is dynamically allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:57,Testability,test,testing,57,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:73,Testability,benchmark,benchmarking,73,"// Optimization flags. Not user visible, used mostly for testing; // and benchmarking the tool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:111,Availability,avail,available,111,"// LongSize == 64; // Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:32,Energy Efficiency,efficient,efficient,32,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:83,Energy Efficiency,power,power,83,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:305,Energy Efficiency,efficient,efficient,305,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:318,Performance,load,load,318,"// OR-ing shadow offset if more efficient (at least on x86) if the offset; // is a power of two, but on ppc64 and loongarch64 we have to use add since; // the shadow offset is not necessarily 1/8-th of the address space. On; // SystemZ, we could OR the constant in a single instruction, but it's more; // efficient to load it once and use indexed addressing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Security,Access,AccessIsWrite,30,"// These arrays is indexed by AccessIsWrite, Experiment and log2(AccessSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:65,Security,Access,AccessSize,65,"// These arrays is indexed by AccessIsWrite, Experiment and log2(AccessSize).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:30,Security,Access,AccessIsWrite,30,// These arrays is indexed by AccessIsWrite and Experiment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:41,Availability,down,downside,41,// Enable aliases as they should have no downside with ODR indicators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:439,Performance,load,load,439,"// Stack poisoning does not play well with exception handling.; // When an exception is thrown, we essentially bypass the code; // that unpoisones the stack. This is why the run-time library has; // to intercept __cxa_throw (as well as longjmp, etc) and unpoison the entire; // stack in the interceptor. This however does not work inside the; // actual function which catches the exception. Most likely because the; // compiler hoists the load of the shadow value somewhere too high.; // This causes asan to report a non-existing bug on 453.povray.; // It sounds like an LLVM bug.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:115,Modifiability,variab,variable,115,"// If there are lifetime intrinsics which couldn't be traced back to an; // alloca, we may not know exactly when a variable enters scope, and; // therefore should ""fail safe"" by not poisoning them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:169,Safety,safe,safe,169,"// If there are lifetime intrinsics which couldn't be traced back to an; // alloca, we may not know exactly when a variable enters scope, and; // therefore should ""fail safe"" by not poisoning them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:194,Energy Efficiency,allocate,allocated,194,"// Arguments marked with the ""byval"" attribute are implicitly copied without; // using an alloca instruction. To produce redzones for those arguments, we; // copy them a second time into memory allocated with an alloca instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Usability,Resume,Resume,16,/// Collect all Resume instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Deploy,Deploy,3,"// Deploy and poison redzones around dynamic alloca call. To do this, we; // should replace this call with another one with changed parameters and; // replace all its uses with new address, so; // addr = alloca type, old_size, align; // is replaced by; // new_size = (old_size + additional_size) * sizeof(type); // tmp = alloca i8, new_size, max(align, 32); // addr = tmp + 32 (first 32 bytes are for the left redzone).; // Additional_size is added to make new memory allocation contain not only; // requested memory, but also left, partial and right redzones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:17,Performance,scalab,scalable,17,// FIXME: Handle scalable vectors instead of ignoring them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:71,Availability,error,errors,71,/// Collect lifetime intrinsic calls to check for use-after-scope; /// errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:53,Security,sanitiz,sanitizer,53,// Do not instrument rtti proxy symbols for function sanitizer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Safety,safe,safe,3,// safe allocas are not interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:14,Security,access,accesses,14,// Instrument accesses from different address spaces only for AMDGPU.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Security,access,accesses,16,// Treat memory accesses to promotable allocas as non-interesting since they; // will not cause memory violations. This greatly speeds up the instrumented; // executable at -O0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Availability,Mask,Masked,3,// Masked store has an initial operand for the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:23,Availability,Mask,Mask,23,// Use the popcount of Mask as the effective vector length.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:15,Modifiability,variab,variable,15,"// If a global variable does not have dynamic initialization we don't; // have to instrument it. However, if a global does not have initializer; // at all, we assume it has dynamic initializer (in other TU).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:44,Security,access,access,44,"// Instrument a 1-, 2-, 4-, 8-, or 16- byte access with one check; // if the data is properly aligned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:6,Safety,avoid,avoid,6,"// To avoid undefined behavior for extracting with out of range index, use; // the minimum of evl and element count as trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:245,Availability,mask,mask,245,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:83,Performance,optimiz,optimizations,83,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:253,Performance,optimiz,optimization,253,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:760,Performance,optimiz,optimization,760,"// Optimization experiments.; // The experiments can be used to evaluate potential optimizations that remove; // instrumentation (assess false negatives). Instead of completely removing; // some instrumentation, you set Exp to a non-zero value (mask of optimization; // experiments that want to remove instrumentation of this instruction).; // If Exp is non-zero, this pass will emit special calls into runtime; // (e.g. __asan_report_exp_load1 instead of __asan_report_load1). These calls; // make runtime terminate the program in a special way (with a different; // exit status). Then you run the new compiler on a buggy corpus, collect; // the special terminations (ideally, you don't see them at all -- no false; // negatives) and make the decision on the optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:58,Security,access,access,58,"// If initialization order checking is disabled, a simple access to a; // dynamically initialized global is always valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,Usability,simpl,simple,51,"// If initialization order checking is disabled, a simple access to a; // dynamically initialized global is always valid.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Modifiability,variab,variable,39,// A direct inbounds access to a stack variable is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:21,Security,access,access,21,// A direct inbounds access to a stack variable is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:137,Testability,benchmark,benchmarks,137,"// We use branch weights for the slow path check, to indicate that the slow; // path is rarely taken. This seems to be the case for SPEC benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:230,Security,access,access,230,"// Instrument unusual size or unusual alignment.; // We can not do it with a single check, so we do 1-byte check for the first; // and the last bytes. We call __asan_report_*_n(addr, real_size) to be able; // to report the actual access size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:63,Modifiability,variab,variables,63,"// The kernel uses explicit sections for mostly special global variables; // that we should not instrument. E.g. the kernel may rely on their layout; // without redzones, or remove them at link time (""discard.*""), etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:77,Integrability,rout,routines,77,// Do not instrument function pointers to initialization and termination; // routines: dynamic linker will not properly handle redzones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:414,Security,access,accesses,414,"// On COFF, if the section name contains '$', it is highly likely that the; // user is using section sorting to create an array of globals similar to; // the way initialization callbacks are registered in .init_array and; // .CRT$XCU. The ATL also registers things in .ATL$__[azm]. Adding redzones; // to such globals is counterproductive, because the intent is that they; // will form an array, and out-of-bounds accesses are expected.; // See https://github.com/google/sanitizers/issues/305; // and http://msdn.microsoft.com/en-US/en-en/library/bb918180(v=vs.120).aspx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:471,Security,sanitiz,sanitizers,471,"// On COFF, if the section name contains '$', it is highly likely that the; // user is using section sorting to create an array of globals similar to; // the way initialization callbacks are registered in .init_array and; // .CRT$XCU. The ATL also registers things in .ATL$__[azm]. Adding redzones; // to such globals is counterproductive, because the intent is that they; // will form an array, and out-of-bounds accesses are expected.; // See https://github.com/google/sanitizers/issues/305; // and http://msdn.microsoft.com/en-US/en-en/library/bb918180(v=vs.120).aspx",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:33,Security,sanitiz,sanitizers,33,"// See https://github.com/google/sanitizers/issues/32; // Constant CFString instances are compiled in the following way:; // -- the string buffer is emitted into; // __TEXT,__cstring,cstring_literals; // -- the constant NSConstantString structure referencing that buffer; // is placed into __DATA,__cfstring; // Therefore there's no point in placing redzones into __DATA,__cfstring.; // Moreover, it causes the linker to crash on OS X 10.7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:60,Deployability,upgrade,upgrade,60,// Make this IMAGE_COMDAT_SELECT_NODUPLICATES on COFF. Also upgrade private; // linkage to internal linkage so that a symbol table entry is emitted. This; // is necessary in order to create the comdat group.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:145,Energy Efficiency,power,power,145,"// The MSVC linker always inserts padding when linking incrementally. We; // cope with that by aligning each struct to its size, which must be a power; // of two.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new metadata globals. This is; // needed so that during LTO these variables stay alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:92,Performance,load,loaded,92,"// RegisteredFlag serves two purposes. First, we can pass it to dladdr(); // to look up the loaded image that contains it. Second, we can store in it; // whether registration has already occurred, to prevent duplicate; // registration.; //; // Common linkage ensures that there is only one global per shared library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:90,Modifiability,variab,variable,90,"// On recent Mach-O platforms, use a structure which binds the liveness of; // the global variable to the metadata struct. Keep the list of ""Liveness"" GV; // created to be added to llvm.compiler.used",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:122,Availability,alive,alive,122,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Modifiability,variab,variables,107,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:239,Security,expose,expose,239,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:246,Security,access,access,246,"// Update llvm.compiler.used, adding the new liveness globals. This is; // needed so that during LTO these variables stay alive. The alternative; // would be to have the linker handling the LTO symbols, but libLTO; // current API does not expose access to the section for each symbol.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:92,Performance,load,loaded,92,"// RegisteredFlag serves two purposes. First, we can pass it to dladdr(); // to look up the loaded image that contains it. Second, we can store in it; // whether registration has already occurred, to prevent duplicate; // registration.; //; // common linkage ensures that there is only one global per shared library.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:37,Modifiability,variab,variables,37,// This function replaces all global variables with new variables that have; // trailing redzones. It also creates a function that poisons; // redzones and inserts this function into llvm.global_ctors.; // Sets *CtorComdat to true if the global registration code emitted into the; // asan constructor is comdat-compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:56,Modifiability,variab,variables,56,// This function replaces all global variables with new variables that have; // trailing redzones. It also creates a function that poisons; // redzones and inserts this function into llvm.global_ctors.; // Sets *CtorComdat to true if the global registration code emitted into the; // asan constructor is comdat-compatible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:23,Modifiability,variab,variable,23,// Create a new global variable with enough space for a redzone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:107,Integrability,depend,dependence,107,"// Don't fold globals with redzones. ODR violation detector and redzone; // poisoning implicitly creates a dependence on the global's address, so it; // is no longer valid for it to be marked unnamed_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:51,Safety,detect,detector,51,"// Don't fold globals with redzones. ODR violation detector and redzone; // poisoning implicitly creates a dependence on the global's address, so it; // is no longer valid for it to be marked unnamed_addr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Safety,avoid,avoid,39,// Create local alias for NewGlobal to avoid crash on ODR between; // instrumented and non-instrumented libraries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:98,Safety,detect,detect,98,"// With local aliases, we need to provide another externally visible; // symbol __odr_asan_XXX to detect ODR violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:58,Safety,avoid,avoid,58,// Add instrumented globals to llvm.compiler.used list to avoid LTO from; // ConstantMerge'ing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Energy Efficiency,Reduce,Reduce,3,"// Reduce redzone size for small size objects, e.g. int, char[1]. MinRZ is; // at least 32 bytes, optimize when SizeInBytes is less than or equal to; // half of MinRZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:98,Performance,optimiz,optimize,98,"// Reduce redzone size for small size objects, e.g. int, char[1]. MinRZ is; // at least 32 bytes, optimize when SizeInBytes is less than or equal to; // half of MinRZ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:42,Performance,load,load,42,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __asan_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:294,Security,access,access,294,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __asan_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:53,Security,Sanitiz,SanitizeAddress,53,"// If needed, insert __asan_init before checking for SanitizeAddress attr.; // This function needs to be called even if the function body is not; // instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:16,Availability,mask,mask,16,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:190,Availability,mask,mask,190,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:162,Performance,load,load,162,"// If we have a mask, skip instrumentation if we've already; // instrumented the full object. But don't add to TempsToInstrument; // because we might get another load/store with a different mask.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:112,Security,sanitiz,sanitizers,112,"// We must unpoison the stack before NoReturn calls (throw, _exit, etc).; // See e.g. https://github.com/google/sanitizers/issues/37",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:78,Energy Efficiency,power,power,78,// Fake stack allocator (asan_fake_stack.h) has 11 size classes; // for every power of 2 from kMinStackMallocSize to kMaxAsanStackMallocSizeClass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Deployability,Update,Update,3,// Update SVD with information from lifetime intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:133,Availability,avail,available,133,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:326,Modifiability,variab,variable,326,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:214,Performance,optimiz,optimization-hostile,214,"// Don't do dynamic alloca or stack malloc if:; // 1) There is inline asm: too often it makes assumptions on which registers; // are available.; // 2) There is a returns_twice call (typically setjmp), which is; // optimization-hostile, and doesn't play well with introduced indirect; // register-relative calculation of local variable addresses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:3,Testability,assert,assert,3,// assert(ASan.UseAfterReturn == AsanDetectStackUseAfterReturnMode:Always); // void *FakeStack = __asan_stack_malloc_N(LocalStackSize);; // void *LocalStackBase = (FakeStack) ? FakeStack :; // alloca(LocalStackSize);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:193,Modifiability,variab,variable,193,"// It shouldn't matter whether we pass an `alloca` or a `ptrtoint` as the; // dbg.declare address opereand, but passing a `ptrtoint` seems to confuse; // later passes and can result in dropped variable coverage in debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:6,Availability,mask,mask,6,// As mask we must use most poisoned case: red zones and after scope.; // As bytes we can use either the same or just red zones only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:361,Modifiability,variab,variable,361,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:204,Safety,detect,detect,204,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:223,Security,access,accesses,223,"// Handling llvm.lifetime intrinsics for a given %alloca:; // (1) collect all llvm.lifetime.xxx(%size, %value) describing the alloca.; // (2) if %size is constant, poison memory for llvm.lifetime.end (to detect; // invalid accesses) and unpoison it for llvm.lifetime.start (the memory; // could be poisoned by previous llvm.lifetime.end instruction, as the; // variable may go in and out of scope several times, e.g. in loops).; // (3) if we poisoned at least one %alloca in a function,; // unpoison the whole stack frame at function exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:106,Energy Efficiency,allocate,allocated,106,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:154,Energy Efficiency,allocate,allocated,154,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:20,Modifiability,extend,extend,20,"// Since we need to extend alloca with additional memory to locate; // redzones, and OldSize is number of allocated blocks with; // ElementSize size, get allocated memory size in bytes by; // OldSize * ElementSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:120,Security,access,access,120,"// isSafeAccess returns true if Addr is always inbounds with respect to its; // base object. For example, it is a field access or an array access with; // constant inbounds index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:139,Security,access,access,139,"// isSafeAccess returns true if Addr is always inbounds with respect to its; // base object. For example, it is a field access or an array access with; // constant inbounds index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:46,Performance,scalab,scalable,46,// TODO: We can use vscale_range to convert a scalable value to an; // upper bound on the access size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:90,Security,access,access,90,// TODO: We can use vscale_range to convert a scalable value to an; // upper bound on the access size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp:39,Safety,safe,safety,39,// Three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/AddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:46,Safety,avoid,avoiding,46,// The set of blocks that are reachable while avoiding BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:47,Usability,clear,clearing,47,// Force the entry block to be instrumented by clearing the blocks it can; // infer coverage from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp:73,Integrability,depend,dependency,73,// Construct a graph where blocks are connected if there is a mutual; // dependency between them. This graph has a special property that it contains; // only paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BlockCoverageInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:190,Performance,load,load,190,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:43,Security,access,accessing,43,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:341,Security,access,access,341,"/// Gets the conditions under which memory accessing instructions will overflow.; ///; /// \p Ptr is the pointer that will be read/written, and \p InstVal is either; /// the result from the load or the value being stored. It is used to determine; /// the size of memory block that is touched.; ///; /// Returns the condition under which the access will overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:196,Performance,optimiz,optimization,196,"// three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned); //; // optimization: if Size >= 0 (signed), skip 1st check; // FIXME: add NSW/NUW here? -- we dont care if the subtraction overflows",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:39,Safety,safe,safety,39,"// three checks are required to ensure safety:; // . Offset >= 0 (since the offset is given from the base ptr); // . Size >= Offset (unsigned); // . Size - Offset >= NeededSize (unsigned); //; // optimization: if Size >= 0 (signed), skip 1st check; // FIXME: add NSW/NUW here? -- we dont care if the subtraction overflows",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:199,Availability,failure,failure,199,/// Adds run-time bounds checks to memory accessing instructions.; ///; /// \p Or is the condition that should guard the trap.; ///; /// \p GetTrapBB is a callable that returns the trap BB to use on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:42,Security,access,accessing,42,/// Adds run-time bounds checks to memory accessing instructions.; ///; /// \p Or is the condition that should guard the trap.; ///; /// \p GetTrapBB is a callable that returns the trap BB to use on failure.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp:61,Integrability,Depend,Depending,61,"// Create a trapping basic block on demand using a callback. Depending on; // flags, this will either create a single block for the entire function or; // will create a fresh block every time it is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/BoundsChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:10,Availability,error,error,10,// Ignore error here. Indirect calls are ignored if this fails.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp:3,Safety,Avoid,Avoid,3,// Avoid extra cost of running passes for BFI when the function doesn't have; // entry count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/CGProfile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:431,Energy Efficiency,reduce,reduces,431,"//===-- ControlHeightReduction.cpp - Control Height Reduction -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges conditional blocks of code and reduces the number of; // conditional branches in the hot paths based on profiles.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:99,Integrability,depend,dependent,99,// Subscopes.; // The instruction at which to insert the CHR conditional branch (and hoist; // the dependent condition values).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:136,Deployability,update,updated,136,"// Find out how many times region R is cloned. Note that if the parent; // of R is cloned, R is also cloned, but R's clone count is not updated; // from the clone of the parent. We need to accumlate all the counts; // from the ancestors to get the clone count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:42,Safety,avoid,avoid,42,// Guard against 0-to-0 branch weights to avoid a division-by-zero crash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:49,Integrability,depend,dependent,49,"// Returns the instruction at which to hoist the dependent condition values and; // insert the CHR branch for a region. This is the terminator branch in the; // entry block or the first select in the entry block, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:124,Testability,assert,asserted,124,// Pick the first select in Selects in the entry block. Note Selects is; // sorted in the instruction order within a block (asserted below).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:769,Integrability,depend,dependent,769,"// Check that any of the branch and the selects in the region could be; // hoisted above the the CHR branch insert point (the most dominating of; // them, either the branch (at the end of the first block) or the first; // select in the first block). If the branch can't be hoisted, drop the; // selects in the first blocks.; //; // For example, for the following scope/region with selects, we want to insert; // the merged branch right before the first select in the first/entry block by; // hoisting c1, c2, c3, and c4.; //; // // Branch insert point here.; // a = c1 ? b : c; // Select 1; // d = c2 ? e : f; // Select 2; // if (c3) { // Branch; // ...; // c4 = foo() // A call.; // g = c4 ? h : i; // Select 3; // }; //; // But suppose we can't hoist c4 because it's dependent on the preceding; // call. Then, we drop Select 3. Furthermore, if we can't hoist c2, we also drop; // Select 2. If we can't hoist c3, we drop Selects 1 & 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:16,Integrability,depend,dependence,16,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:109,Integrability,depend,depend,109,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Safety,Avoid,Avoid,3,// Avoid a data dependence from a select or a branch to a(nother); // select. Note no instruction can't data-depend on a branch (a branch; // instruction doesn't produce a value).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Deployability,Update,Update,3,// Update InsertPoint after potentially removing selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:38,Integrability,depend,depending,38,"// Determine whether to split a scope depending on the sets of the branch; // condition values of the previous region and the current region. We split; // (return true) it if 1) the condition values of the inner/lower scope can't be; // hoisted up to the outer/upper scope, or 2) the two sets of the condition; // values have an empty intersection (because the combined branch conditions; // won't probably lead to a simpler combined condition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:417,Usability,simpl,simpler,417,"// Determine whether to split a scope depending on the sets of the branch; // condition values of the previous region and the current region. We split; // (return true) it if 1) the condition values of the inner/lower scope can't be; // hoisted up to the outer/upper scope, or 2) the two sets of the condition; // values have an empty intersection (because the combined branch conditions; // won't probably lead to a simpler combined condition).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:70,Safety,avoid,avoid,70,"// If PrevConditionValues or ConditionValues is empty, don't split to avoid; // unnecessary splits at scopes with no branch/selects. If; // PrevConditionValues and ConditionValues don't intersect at all, split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:163,Integrability,depend,depend,163,// Put the biased selects in Unhoistables because they should stay where they; // are and constant-folded after CHR (in case one biased select or a branch; // can depend on another biased select.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:199,Safety,safe,safe,199,"// The trivial phi inserted by the previous CHR scope could replace a; // non-phi in HoistStops. Note that since this phi is at the exit of a; // previous CHR scope, which dominates this scope, it's safe to stop; // hoisting there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:456,Safety,safe,safe,456,"// We are already above the hoist point. Stop here. This may be necessary; // when multiple scopes would independently hoist the same; // instruction. Since an outer (dominating) scope would hoist it to its; // entry before an inner (dominated) scope would to its entry, the inner; // scope may see the instruction already hoisted, in which case it; // potentially wrong for the inner scope to hoist it and could cause bad; // IR (non-dominating def), but safe to skip hoisting it instead because; // it's already in a block that dominates the inner scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Integrability,depend,dependent,13,// Hoist the dependent condition values of the branches and the selects in the; // scope to the insert point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:160,Availability,alive,alive,160,// A helper for transformScopes. Insert a trivial phi at the scope exit block; // for a value that's defined in the scope but used outside it (meaning it's; // alive at the exit block).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Testability,Assert,Assert,3,// Assert that all the CHR regions of the scope have a biased branch or select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Testability,Assert,Assert,3,// Assert that all the condition values of the biased branches and selects have; // been hoisted to the pre-entry block or outside of the scope.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:13,Deployability,release,release,13,// Unused in release build.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:174,Availability,alive,alive,174,"// Insert a trivial phi at the exit block (where the CHR hot path and the; // cold path merges) for a value that's defined in the scope but used; // outside it (meaning it's alive at the exit block). We will add the; // incoming values for the CHR cold paths to it below. Without this, we'd; // miss updating phi's for such values unless there happens to already be a; // phi for that value there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:199,Deployability,update,updated,199,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:222,Deployability,update,updated,222,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:256,Deployability,update,update,256,"// Split the entry block of the first region. The new block becomes the new; // entry block of the first region. The old entry block becomes the block to; // insert the CHR branch into. Note DT gets updated. Since DT gets updated; // through the split, we update the entry of the first region after the split,; // and Region only points to the entry and the exit blocks, rather than; // keeping everything in a list or set, the blocks membership and the; // entry/exit blocks of the region are still valid after the split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:133,Deployability,update,update,133,// Clone the blocks in the scope (excluding the PreEntryBlock) to split into a; // hot path (originals) and a cold path (clones) and update the PHIs at the; // exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:142,Deployability,update,update,142,// A helper for transformScopes. Clone the blocks in the scope (excluding the; // PreEntryBlock) to split into a hot path and a cold path and update the PHIs; // at the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:74,Performance,optimiz,optimized,74,// Clone all the blocks. The original blocks will be the hot-path; // CHR-optimized code and the cloned blocks will be the original unoptimized; // code. This is so that the block pointers from the; // CHRScope/Region/RegionInfo can stay valid in pointing to the hot-path code; // which CHR should apply to.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:3,Deployability,Update,Update,3,// Update the cloned blocks/instructions to refer to themselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:179,Deployability,update,updated,179,// Add the cloned blocks to the PHIs of the exit blocks. ExitBlock is null for; // the top-level region but we don't need to add PHIs. The trivial PHIs; // inserted above will be updated here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:142,Safety,avoid,avoid,142,"// If Cond is an icmp and all users of V except for BranchOrSelect is a; // branch, negate the icmp predicate and swap the branch targets and avoid; // inserting an Xor to negate Cond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:22,Safety,avoid,avoid,22,// Use logical and to avoid propagating poison from later conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp:7,Testability,log,logical,7,// Use logical and to avoid propagating poison from later conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ControlHeightReduction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:991,Modifiability,variab,variables,991,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:903,Performance,perform,performs,903,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:553,Safety,detect,detect,553,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:705,Safety,detect,detect,705,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:507,Security,Sanitiz,Sanitizer,507,"//===- DataFlowSanitizer.cpp - dynamic data flow analysis -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of DataFlowSanitizer, a generalised dynamic data flow; /// analysis.; ///; /// Unlike other Sanitizer tools, this tool is not designed to detect a specific; /// class of bugs on its own. Instead, it provides a generic dynamic data flow; /// analysis framework to be used by clients to help detect application-specific; /// issues within their own code.; ///; /// The analysis is based on automatic propagation of data flow labels (also; /// known as taint labels) through a program as it performs computation.; ///; /// Argument and return value labels are passed through TLS variables; /// __dfsan_arg_tls and __dfsan_retval_tls.; ///; /// Each byte of application memory is backed by a shadow memory byte. The; /// shadow byte can represent up to 8 labels. On Linux/x86_64, memory is then; /// laid out as follows:; ///; /// +--------------------+ 0x800000000000 (top of memory); /// | application 3 |; /// +--------------------+ 0x700000000000; /// | invalid |; /// +--------------------+ 0x610000000000; /// | origin 1 |; /// +--------------------+ 0x600000000000; /// | application 2 |; /// +--------------------+ 0x510000000000; /// | shadow 1 |; /// +--------------------+ 0x500000000000; /// | invalid |; /// +--------------------+ 0x400000000000; /// | origin 3 |; /// +--------------------+ 0x300000000000; /// | shadow 3 |; /// +--------------------+ 0x200000000000; /// | origin 2 |; /// +--------------------+ 0x110000000000; /// | invalid |; /// +--------------------+ 0x100000000000; /// | shadow 2 |; /// +--------------------+ 0x010000000000; /// | application 1 |; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:19,Modifiability,variab,variables,19,// The size of TLS variables. These constants must be kept in sync with the ones; // in dfsan.cpp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:187,Performance,load,load,187,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:246,Performance,load,load,246,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:409,Performance,perform,performs,409,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:429,Security,access,access,429,"// The -dfsan-preserve-alignment flag controls whether this pass assumes that; // alignment requirements provided by the input IR are correct. For example,; // if the input IR contains a load with alignment 8, this flag will cause; // the shadow load to have alignment 16. This flag is disabled by default as; // we have unfortunately encountered too much code (including Clang itself;; // see PR14291) which performs misaligned access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:341,Integrability,message,message,341,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:561,Integrability,Wrap,WrapperKind,561,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:750,Integrability,wrap,wrapper,750,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:1061,Integrability,wrap,wrapper,1061,"// The ABI list files control how shadow parameters are passed. The pass treats; // every function labelled ""uninstrumented"" in the ABI list file as conforming; // to the ""native"" (i.e. unsanitized) ABI. Unless the ABI list contains; // additional annotations for those functions, a call to one of those functions; // will produce a warning message, as the labelling behaviour of the function is; // unknown. The other supported annotations for uninstrumented functions are; // ""functional"" and ""discard"", which are described below under; // DataFlowSanitizer::WrapperKind.; // Functions will often be labelled with both ""uninstrumented"" and one of; // ""functional"" or ""discard"". This will leave the function unchanged by this; // pass, and create a wrapper function that will call the original.; //; // Instrumented functions can also be annotated as ""force_zero_labels"", which; // will make all shadow and return values set zero labels.; // Functions should never be labelled with both ""force_zero_labels"" and; // ""uninstrumented"" or any of the unistrumented wrapper kinds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:75,Performance,load,load,75,// Controls whether the pass includes or ignores the labels of pointers in load; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:118,Performance,load,loads,118,"// Experimental feature that inserts callbacks for certain data events.; // Currently callbacks are only inserted for loads, stores, memory transfers; // (i.e. memcpy and memmove), and comparisons.; //; // If this flag is set to true, the user must provide definitions for the; // following callback functions:; // void __dfsan_load_callback(dfsan_label Label, void* addr);; // void __dfsan_store_callback(dfsan_label Label, void* addr);; // void __dfsan_mem_transfer_callback(dfsan_label *Start, size_t Len);; // void __dfsan_cmp_callback(dfsan_label CombinedLabel);",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:115,Performance,load,loads,115,"// Experimental feature that inserts callbacks for data reaching a function,; // either via function arguments and loads.; // This must be true for dfsan_set_reaches_function_callback() to have effect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:149,Performance,load,load,149,// Controls how to track origins.; // * 0: do not track origins.; // * 1: track origins at memory store operations.; // * 2: track origins at memory load and store operations.; // TODO: track callsites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Security,access,accessible,42,"/// This function does not write to (user-accessible) memory, and its return; /// value is unlabelled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Security,access,accessible,42,"/// This function does not write to (user-accessible) memory, and the label; /// of its return value is the union of the label of its arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:46,Integrability,wrap,wrapper,46,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:134,Integrability,wrap,wrap,134,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:285,Integrability,wrap,wrapped,285,"/// Instead of calling the function, a custom wrapper __dfsw_F is called,; /// where F is the name of the function. This function may wrap the; /// original function or provide its own implementation. WK_Custom uses an; /// extra pointer argument to return the shadow. This allows the wrapped; /// form of the function type to be expressed in C.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:71,Performance,load,loads,71,/// Advances \p OriginAddr to point to the next 32-bit origin and then loads; /// from it. Returns the origin's loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:112,Performance,load,loaded,112,/// Advances \p OriginAddr to point to the next 32-bit origin and then loads; /// from it. Returns the origin's loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:30,Performance,load,load,30,/// Returns whether the given load byte size is amenable to inlined; /// optimization patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:73,Performance,optimiz,optimization,73,/// Returns whether the given load byte size is amenable to inlined; /// optimization patterns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:146,Performance,cache,cache,146,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:226,Performance,cache,cache,226,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:253,Performance,Cache,CachedShadows,253,"/// Maps a value to its latest collapsed shadow value it was converted to in; /// terms of domination tree. When ClDebugNonzeroLabels is on, this cache is; /// used at a post process where CFG blocks are split. So it does not cache; /// BasicBlock like CachedShadows, but uses domination between values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,Performance,load,load,20,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.; ///; /// When tracking loads is enabled, the returned origin is a chain at the; /// current stack if the returned shadow is tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:270,Performance,load,loads,270,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.; ///; /// When tracking loads is enabled, the returned origin is a chain at the; /// current stack if the returned shadow is tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:89,Performance,load,load,89,"// If ClReachesFunctionCallbacks is enabled, insert a callback for each; // argument and load instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:21,Performance,load,loading,21,/// The fast path of loading shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:510,Energy Efficiency,reduce,reduce,510,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:74,Performance,load,load,74,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:340,Performance,load,load,340,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:439,Performance,load,load,439,"/// Because 4 contiguous bytes share one 4-byte origin, the most accurate load; /// is __dfsan_load_label_and_origin. This function returns the union of all; /// labels and the origin of the first taint label. However this is an; /// additional call with many instructions. To ensure common cases are fast,; /// checks if it is possible to load labels and origins without using the; /// callback function.; ///; /// When enabling tracking load instructions, we always use; /// __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:20,Performance,load,load,20,"/// Generates IR to load shadow and origin corresponding to bytes [\p; /// Addr, \p Addr + \p Size), where addr has alignment \p; /// InstAlignment, and take the union of each of those shadows. The returned; /// shadow always has primitive type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:291,Integrability,wrap,wrapped,291,"// This is a bit of a hack because TargetLibraryInfo is a function pass.; // The DFSan pass would need to be refactored to be function pass oriented; // (like MSan is) in order to fit together nicely with TargetLibraryInfo.; // We need this check to prevent them from being instrumented, or wrapped.; // Match on name and number of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:109,Modifiability,refactor,refactored,109,"// This is a bit of a hack because TargetLibraryInfo is a function pass.; // The DFSan pass would need to be refactored to be function pass oriented; // (like MSan is) in order to fit together nicely with TargetLibraryInfo.; // We need this check to prevent them from being instrumented, or wrapped.; // Match on name and number of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:221,Deployability,update,updated,221,"// Some parameters of the custom function being constructed are; // parameters of T. Record the mapping from parameters of T to; // parameters of the custom function, so that parameter attributes; // at call sites can be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Cache,Caches,3,// Caches the primitive shadow value that built the shadow value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:17,Performance,cache,cached,17,// Checks if the cached collapsed shadow value dominates Pos.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Cache,Caches,3,// Caches the converted primitive shadow value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:149,Safety,avoid,avoid,149,"// Try to change the name of the function in module inline asm. We only do; // this for specific asm directives, currently only "".symver"", to try to avoid; // corrupting asm which happens to contain the symbol name as a substring.; // Note that the substitution for .symver assumes that the versioned symbol; // also has an instrumented name.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:26,Integrability,wrap,wrapping,26,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:109,Integrability,wrap,wrapper,109,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:190,Integrability,wrap,wrapper,190,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:281,Integrability,wrap,wrapper,281,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:414,Performance,optimiz,optimize,414,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:303,Safety,avoid,avoid,303,"// If the function we are wrapping was ExternWeak, it may be null.; // The original code before calling this wrapper may have checked for null,; // but replacing with a known-to-not-be-null wrapper can break this check.; // When replacing uses of the extern weak function with the wrapper we try; // to avoid replacing uses in conditionals, but this is not perfect.; // In the case where we fail, and accidentally optimize out a null check; // for a extern weak function, add a check here to help identify the issue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:60,Integrability,wrap,wrappers,60,"// Give function aliases prefixes when necessary, and build wrappers where the; // instrumentedness is inconsistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:110,Integrability,wrap,wrapper,110,"// Non-instrumented alias of an instrumented function, or vice versa.; // Replace the alias with a native-ABI wrapper of the aliasee. The pass; // below will take care of instrumenting it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:117,Integrability,wrap,wrapper,117,"// First, change the ABI of every function in the module. ABI-listed; // functions keep their original ABI and get a wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:11,Integrability,wrap,wrapper,11,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Integrability,wrap,wrapper,39,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:148,Integrability,Wrap,WrapperKind,148,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:220,Integrability,wrap,wrapped,220,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:295,Integrability,wrap,wrapper,295,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:47,Usability,simpl,simply,47,"// Build a wrapper function for F. The wrapper simply calls F, and is; // added to FnsToInstrument so that any instrumentation according to its; // WrapperKind is done in the second pass below.; // If the function being wrapped has local linkage, then preserve the; // function's linkage in the wrapper function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:331,Integrability,wrap,wrapper,331,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:695,Integrability,wrap,wrapper,695,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:944,Integrability,wrap,wrapper,944,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:464,Performance,optimiz,optimized,464,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:417,Usability,simpl,simplify,417,"// Extern weak functions can sometimes be null at execution time.; // Code will sometimes check if an extern weak function is null.; // This could look something like:; // declare extern_weak i8 @my_func(i8); // br i1 icmp ne (i8 (i8)* @my_func, i8 (i8)* null), label %use_my_func,; // label %avoid_my_func; // The @""dfsw$my_func"" wrapper is never null, so if we replace this use; // in the comparison, the icmp will simplify to false and we have; // accidentally optimized away a null check that is necessary.; // This can lead to a crash when the null extern_weak my_func is called.; //; // To prevent (the most common pattern of) this problem,; // do not replace uses in comparisons with the wrapper.; // We definitely want to replace uses in call instructions.; // Other uses (e.g. store the function address somewhere) might be; // called or compared or both - this case may not be handled correctly.; // We will default to replacing with wrapper in cases we are unsure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Performance,load,loads,39,// Ensure IRB insertion point is after loads for shadow and origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:81,Availability,Mask,Mask,81,"// When alignment is >= 4, Addr must be aligned to 4, otherwise it is UB.; // So Mask is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:96,Energy Efficiency,reduce,reduce,96,"// When enabling tracking load instructions, we always use; // __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:26,Performance,load,load,26,"// When enabling tracking load instructions, we always use; // __dfsan_load_label_and_origin to reduce code size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:360,Energy Efficiency,efficient,efficient,360,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:504,Energy Efficiency,efficient,efficiently,504,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:39,Performance,load,load,39,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:152,Performance,load,load,152,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:373,Performance,load,load,373,"// * if Size == 1, it is sufficient to load its origin aligned at 4.; // * if Size == 2, we assume most cases Addr % 2 == 0, so it is sufficient to; // load its origin aligned at 4. If not, although origins may be lost, it; // should not happen very often.; // * if align >= 4, Addr must be aligned to 4, otherwise it is UB. When; // Size % 4 == 0, it is more efficient to load origins without callbacks.; // * Otherwise we use __dfsan_load_label_and_origin.; // This should ensure that common cases run efficiently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Load,3,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:162,Performance,optimiz,optimize,162,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:251,Performance,load,loaded,251,"// Load instructions in LLVM can have arbitrary byte sizes (e.g., 3, 12, 20); // but this function is only used in a subset of cases that make it possible; // to optimize the instrumentation.; //; // Specifically, when the shadow size in bytes (i.e., loaded bytes x shadow; // per byte) is either:; // - a multiple of 8 (common); // - equal to 4 (only for load32); //; // For the second case, we can fit the wide shadow in a 32-bit integer. In all; // other cases, we use a 64-bit integer to hold the wide shadow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:241,Testability,log,logN,241,"// First OR all the WideShadows (i.e., 64bit or 32bit shadow chunks) linearly;; // then OR individual shadows within the combined WideShadow by binary ORing.; // This is fewer instructions than ORing shadows individually, since it; // needs logN shift/or instructions (N being the bytes of the combined wide; // shadow).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:15,Performance,load,loads,15,// Non-escaped loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Load,3,// Load from constant addresses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:19,Performance,load,load,19,// Use callback to load if this is not an optimizable case for origin; // tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:42,Performance,optimiz,optimizable,42,// Use callback to load if this is not an optimizable case for origin; // tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:28,Performance,load,loading,28,// Other cases that support loading shadows or origins in a fast way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:46,Performance,load,load,46,"// When the byte size is small enough, we can load the shadow directly with; // just a few instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:23,Performance,load,load,23,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:95,Performance,load,loads,95,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:143,Performance,load,load,143,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:259,Performance,load,loads,259,"// When an application load is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:96,Performance,load,loads,96,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:144,Performance,load,load,144,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:260,Performance,load,loads,260,"// When an application store is atomic, increase atomic ordering between; // atomic application loads and stores to ensure happen-before order; load; // shadow data after application data; store zero shadow data before; // application data. This ensure shadow loads return either labels of the; // initial application data or zeros.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:322,Performance,load,loads,322,"// We do not need to track data through LandingPadInst.; //; // For the C++ exceptions, if a value is thrown, this value will be stored; // in a memory location provided by __cxa_allocate_exception(...) (on the; // throw side) or __cxa_begin_catch(...) (on the catch side).; // This memory will have a shadow, so with the loads and stores we will be; // able to propagate labels on data thrown through exceptions, without any; // special handling of the LandingPadInst.; //; // The second element in the pair result of the LandingPadInst is a; // register value, but it is for a type ID and should never be tainted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:12,Modifiability,variab,variable,12,// Adds non-variable argument shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:8,Modifiability,variab,variable,8,// Adds variable argument shadows.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:11,Modifiability,variab,variable,11,// Add non-variable argument origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:7,Modifiability,variab,variable,7,// Add variable argument origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:104,Integrability,wrap,wrapper,104,"// Don't try to handle invokes of custom functions, it's too complicated.; // Instead, invoke the dfsw$ wrapper, which will in turn call the __dfsw_; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:153,Integrability,wrap,wrapper,153,"// Don't try to handle invokes of custom functions, it's too complicated.; // Instead, invoke the dfsw$ wrapper, which will in turn call the __dfsw_; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:12,Modifiability,variab,variable,12,// Adds non-variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:8,Modifiability,variab,variable,8,// Adds variable arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Deployability,Update,Update,3,// Update the parameter attributes of the custom call instruction to; // zero extend the shadow parameters. This is required for targets; // which consider PrimitiveShadowTy an illegal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:78,Modifiability,extend,extend,78,// Update the parameter attributes of the custom call instruction to; // zero extend the shadow parameters. This is required for targets; // which consider PrimitiveShadowTy an illegal type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Loads,3,// Loads the return value shadow and origin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:37,Deployability,Release,Release,37,// Convert the call to have at least Release ordering to make sure; // the shadow operations aren't reordered after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:45,Integrability,wrap,wrappers,45,"// Calls to this function are synthesized in wrappers, and we shouldn't; // instrument them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:3,Performance,Load,Loads,3,// Loads the return value shadow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/DataFlowSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:3,Security,Checksum,Checksum,3,"// Checksum, produced by hash of EdgeDestinations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:25,Security,hash,hash,25,"// Checksum, produced by hash of EdgeDestinations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:41,Security,checksum,checksum,41,"// A function has a unique identifier, a checksum (we leave as zero) and a; // set of blocks and a map of edges between blocks. This is the only GCOV; // object users can construct, the blocks and lines will be rooted here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:103,Safety,avoid,avoid,103,// back() is a br instruction with a debug location; // equals to the one from NextAfterFork; // So to avoid to have two debug locs on two blocks just change it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather; // than later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:34,Performance,optimiz,optimization,34,"// For now, disable spanning tree optimization when fork or exec* is; // used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:11,Security,sanitiz,sanitizers,11,// Disable sanitizers to decrease size bloat. We don't expect; // sanitizers to catch interesting issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:66,Security,sanitiz,sanitizers,66,// Disable sanitizers to decrease size bloat. We don't expect; // sanitizers to catch interesting issues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:12,Security,checksum,checksum,12,// uint32_t checksum,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:6,Usability,simpl,simplify,6,"// To simplify code, we cap the number of file infos we write out to fit; // easily in a 32-bit signed integer. This gives consistent behavior between; // 32-bit and 64-bit systems without requiring (potentially very slow) 64-bit; // operations on 32-bit systems. It also seems unreasonable to try to handle; // more than 2 billion files.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp:60,Modifiability,variab,variable,60,// The index into the files structure is our loop induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/GCOVProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:46,Availability,error,error,46,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:52,Safety,detect,detector,52,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:39,Security,access,access,39,"//===- HWAddressSanitizer.cpp - memory access error detector --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of HWAddressSanitizer, an address basic correctness; /// checker based on tagged addressing.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:87,Security,access,accessed,87,// These flags allow to change the shadow mapping and control how shadow memory; // is accessed. The shadow mapping looks like:; // Shadow = (Mem >> scale) + offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:41,Safety,detect,detection,41,/// An instrumentation pass implementing detection of addressability bugs; /// using tagged pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:422,Security,access,access,422,"/// This struct defines the shadow mapping using the rule:; /// shadow = (mem >> Scale) + Offset.; /// If InGlobal is true, then; /// extern char __hwasan_shadow[];; /// shadow = (mem >> Scale) + &__hwasan_shadow; /// If InTls is true, then; /// extern char *__hwasan_tls;; /// shadow = (mem>>Scale) + align_up(__hwasan_shadow, kShadowBaseAlignment); ///; /// If WithFrameRecord is true, then __hwasan_tls will be used to access the; /// ring buffer for storing stack allocations on targets that support it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:92,Deployability,update,updated,92,"// DominatorTreeAnalysis, PostDominatorTreeAnalysis, and LoopAnalysis; // are incrementally updated throughout this pass whenever; // SplitBlockAndInsertIfThen is called.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:1064,Availability,failure,failure,1064,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:811,Integrability,depend,depends,811,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:1255,Integrability,depend,depend,1255,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:425,Performance,load,loader,425,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:486,Performance,load,loaded,486,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:369,Security,access,accessing,369,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:977,Security,access,accesses,977,"// Create a note that contains pointers to the list of global; // descriptors. Adding a note to the output file will cause the linker to; // create a PT_NOTE program header pointing to the note that we can use to; // find the descriptor list starting from the program headers. A function; // provided by the runtime initializes the shadow memory for the globals by; // accessing the descriptor list via the note. The dynamic loader needs to; // call this function whenever a library is loaded.; //; // The reason why we use a note for this instead of a more conventional; // approach of having a global constructor pass a descriptor list pointer to; // the runtime is because of an order of initialization problem. With; // constructors we can encounter the following problematic scenario:; //; // 1) library A depends on library B and also interposes one of B's symbols; // 2) B's constructors are called before A's (as required for correctness); // 3) during construction, B accesses one of its ""own"" globals (actually; // interposed by A) and triggers a HWASAN failure due to the initialization; // for A not having happened yet; //; // Even without interposition it is possible to run into similar situations in; // cases where two libraries mutually depend on each other.; //; // We only need one note per binary, so put everything for the note in a; // comdat. This needs to be a comdat with an .init_array section to prevent; // newer versions of lld from discarding the note.; //; // Create the note even if we aren't instrumenting globals. This ensures that; // binaries linked from object files with both instrumented and; // non-instrumented globals will end up with a note, even if a comdat from an; // object file with non-instrumented globals is selected. The note is harmless; // if the runtime doesn't support it, since it will just be ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:51,Energy Efficiency,reduce,reduce,51,// These platforms may prefer less; // inlining to reduce binary size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:221,Performance,load,load,221,"// An empty inline asm with input reg == output reg.; // An opaque no-op cast, basically.; // This prevents code bloat as a result of rematerializing trivial definitions; // such as constants or global addresses at every load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:15,Security,access,accesses,15,// Skip memory accesses inserted by another instrumentation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:84,Availability,mask,mask,84,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:155,Availability,mask,masks,155,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:395,Availability,mask,mask,395,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:400,Energy Efficiency,allocate,allocated,400,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:519,Security,sanitiz,sanitizers,519,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:552,Security,sanitiz,sanitizer,552,"// A list of 8-bit numbers that have at most one run of non-zero bits.; // x = x ^ (mask << 56) can be encoded as a single armv8 instruction for these; // masks.; // The list does not include the value 255, which is used for UAR.; //; // Because we are more likely to use earlier elements of this list than later; // ones, it is sorted in increasing order of probability of collision with a; // mask allocated (temporally) nearby. The program that generated this list; // can be found at:; // https://github.com/google/sanitizers/blob/master/hwaddress-sanitizer/sort_masks.py",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:14,Usability,clear,clear,14,// No need to clear the tag byte.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:17,Usability,simpl,simply,17,// Userspace can simply do OR (tag << PointerTagShift);,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:41,Security,sanitiz,sanitizers,41,// Android provides a fixed TLS slot for sanitizers. See TLS_SLOT_SANITIZER; // in Bionic's libc/private/bionic_tls.h.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:3,Deployability,Update,Update,3,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:108,Energy Efficiency,power,power,108,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:200,Integrability,wrap,wrap,200,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:238,Usability,simpl,simply,238,"// Update the ring buffer. Top byte of ThreadLong defines the size of the; // buffer in pages, it must be a power of two, and the start of the buffer; // must be aligned by twice that much. Therefore wrap around of the ring; // buffer is simply Addr &= ~((ThreadLong >> 56) << 12).; // The use of AShr instead of LShr is due to; // https://bugs.llvm.org/show_bug.cgi?id=39030; // Runtime library makes sure not to use the highest bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:298,Availability,mask,mask,298,"// Ideally, we want to calculate tagged stack base pointer, and rewrite all; // alloca addresses using that. Unfortunately, offsets are not known yet; // (unless we use ASan-style mega-alloca). Instead we keep the base tag in a; // temp, shift-OR it into each alloca address and xor with the retag mask.; // This generates one extra instruction per alloca use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:64,Modifiability,rewrite,rewrite,64,"// Ideally, we want to calculate tagged stack base pointer, and rewrite all; // alloca addresses using that. Unfortunately, offsets are not known yet; // (unless we use ASan-style mega-alloca). Instead we keep the base tag in a; // temp, shift-OR it into each alloca address and xor with the retag mask.; // This generates one extra instruction per alloca use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:62,Energy Efficiency,reduce,reduces,62,"// Set the lifetime intrinsic to cover the whole alloca. This reduces the; // set of assumptions we need to make about the lifetime. Without this we; // would need to ensure that we can track the lifetime pointer to a; // constant offset from the alloca, and would still need to change the; // size to include the extra alignment we use for the untagging to make; // the size consistent.; //; // The check for standard lifetime below makes sure that we have exactly; // one set of start / end in any execution (i.e. the ends are not; // reachable from each other), so this will not cause any problems.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:67,Testability,log,logically,67,"// Prepend ""tag_offset, N"" to the dwarf expression.; // Tag offset logically applies to the alloca pointer, and it makes sense; // to put it at the beginning of the expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:133,Safety,detect,detection,133,"// Don't allow globals to be tagged with something that looks like a; // short-granule tag, otherwise we lose inter-granule overflow detection, as; // the fast path shadow-vs-address check succeeds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:105,Integrability,wrap,wrapper,105,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:127,Integrability,wrap,wraps,127,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:386,Integrability,wrap,wrapper,386,"// We need to untag stack frames as we unwind past them. That is the job of; // the personality function wrapper, which either wraps an existing; // personality function or acts as a personality function on its own. Each; // function that has a personality function or that can be unwound past has; // its personality function changed to a thunk that calls the personality; // function wrapper in the runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp:92,Availability,avail,available,92,"// Fuchsia is always PIE, which means that the beginning of the address; // space is always available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/HWAddressSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:537,Availability,avail,available,537,"//===- IndirectCallPromotion.cpp - Optimizations based on value profiling -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that promotes indirect calls to; // conditional direct calls when the indirect-call value profile metadata is; // available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:35,Performance,Optimiz,Optimizations,35,"//===- IndirectCallPromotion.cpp - Optimizations based on value profiling -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that promotes indirect calls to; // conditional direct calls when the indirect-call value profile metadata is; // available.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:36,Performance,optimiz,optimization,36,// Set if the pass is called in LTO optimization. The difference for LTO mode; // is the pass won't prefix the source module name to the internal linkage; // symbols.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:66,Safety,avoid,avoids,66,"// Don't promote if the symbol is not defined in the module. This avoids; // creating a reference to a symbol that doesn't exist in the module; // This can happen when we compile with a sample profile collected from; // one binary but used for another, which may have profiled targets that; // aren't used in the new binary. We might have a declaration initially in; // the case where the symbol is globally dead in the binary and removed by; // ThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:87,Performance,perform,perform,87,// Traverse all the indirect-call callsite and get the value profile; // annotation to perform indirect-call promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:21,Deployability,update,update,21,// Otherwise we need update with the un-promoted records back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp:5,Integrability,wrap,wrapper,5,// A wrapper function that does the actual work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/IndirectCallPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:88,Modifiability,variab,variable,88,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:226,Modifiability,variab,variable,226,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:183,Security,hash,hash,183,// We need a global bitmap to tell if a function is executed. We also; // need a global variable to save the order of functions. We can use a; // fixed-size buffer that saves the MD5 hash of the function. We need; // a global variable to save the index into the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:21,Modifiability,variab,variables,21,// Create the global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:73,Deployability,update,update,73,// Generate the code sequence in the entry block of each function to; // update the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:97,Deployability,update,update,97,"// Check the bitmap, if it is already 1, do nothing.; // Otherwise, set the bit, grab the index, update the buffer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:11,Deployability,Update,UpdateOrderFileBB,11,"// Fill up UpdateOrderFileBB: grab the index, update the buffer!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:46,Deployability,update,update,46,"// Fill up UpdateOrderFileBB: grab the index, update the buffer!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp:14,Integrability,wrap,wrap,14,// We need to wrap around the index to fit it inside the buffer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrOrderFile.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:51,Deployability,release,release,51,"// TODO: Remove -debug-info-correlate in next LLVM release, in favor of; // -profile-correlate=debug-info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:144,Deployability,pipeline,pipeline,144,"// If the option is not specified, the default behavior about whether; // counter promotion is done depends on how instrumentaiton lowering; // pipeline is setup, i.e., the default value of true of this option; // does not mean the promotion will be done by default. Explicitly; // setting this option can override the default behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:100,Integrability,depend,depends,100,"// If the option is not specified, the default behavior about whether; // counter promotion is done depends on how instrumentaiton lowering; // pipeline is setup, i.e., the default value of true of this option; // does not mean the promotion will be done by default. Explicitly; // setting this option can override the default behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:65,Performance,load,load,65,"/// If runtime relocation is enabled, this maps functions to the load; /// instruction that produces the profile relocation bias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:21,Performance,load,load,21,// vector of counter load/store pairs to be register promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:29,Performance,load,loads,29,/// Register-promote counter loads and stores in loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:36,Deployability,update,update,36,/// Returns true if profile counter update register promotion is enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:37,Deployability,update,update,37,/// Replace instrprof.mcdc.tvbitmask.update with a shift and or instruction; /// using the index represented by the a temp value into a bitmap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:32,Deployability,update,update,32,/// Replace instrprof.mcdc.temp.update with a shift and or instruction using; /// the corresponding condition ID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:141,Modifiability,variab,variables,141,"/// Get the region counters for an increment, creating them if necessary.; ///; /// If the counter array doesn't yet exist, the profile data variables; /// referring to them will also be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:31,Testability,test,test,31,/// Compute the address of the test vector bitmap that this profiling; /// instruction acts on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:139,Modifiability,variab,variables,139,"/// Get the region bitmaps for an increment, creating them if necessary.; ///; /// If the bitmap array doesn't yet exist, the profile data variables; /// referring to them will also be created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:59,Energy Efficiency,allocate,allocated,59,/// Setup the sections into which counters and bitmaps are allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:27,Modifiability,variab,variable,27,/// Create INSTR_PROF_DATA variable for counters and bitmaps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:62,Modifiability,variab,variable,62,/// Emit runtime registration functions for each profile data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:25,Modifiability,variab,variables,25,/// Add uses of our data variables and runtime hook.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:92,Deployability,update,update,92,///; /// A helper class to promote one counter RMW operation in the loop; /// into register update.; ///; /// RWM update for the counter will be sinked out of the loop after; /// the transformation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:114,Deployability,update,update,114,///; /// A helper class to promote one counter RMW operation in the loop; /// into register update.; ///; /// RWM update for the counter will be sinked out of the loop after; /// the transformation.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Deployability,update,update,11,"// automic update currently can only be promoted across the current; // loop, not the whole loop nest.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:7,Deployability,update,update,7,// Now update the parent loop's candidate list:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:73,Deployability,update,updates,73,/// A helper class to do register promotion for all profile counter; /// updates in a loop.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:279,Safety,detect,detect,279,"// Skip if any of the ExitBlocks contains a ret instruction.; // This is to prevent dumping of incomplete profile -- if the; // the loop is a long running loop and dump is called in the middle; // of the loop, the result profile is incomplete.; // FIXME: add other heuristics to detect long running loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:36,Usability,guid,guide,36,"// If BFI is set, we will use it to guide the promotions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:67,Performance,perform,perform,67,// Check whether the loop satisfies the basic conditions needed to perform; // Counter Promotions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:58,Deployability,update,updates,58,// Do a post-order traversal of the loops so that counter updates can be; // iteratively hoisted outside the loop nest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:27,Safety,avoid,avoiding,27,// Improve compile time by avoiding linear scans when there is no work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:201,Modifiability,variab,variable,201,// We did not know how many value sites there would be inside; // the instrumented function. This is counting the number of instrumented; // target value sites to enter it as field in the profile data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:66,Modifiability,variab,variable,66,// Use a profile intrinsic to create the region counters and data variable.; // Also create the data variable based on the MCDCParams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:101,Modifiability,variab,variable,101,// Use a profile intrinsic to create the region counters and data variable.; // Also create the data variable based on the MCDCParams.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:33,Integrability,depend,depends,33,// TODO: Value profiling heavily depends on the data section which is omitted; // in lightweight mode. We need to move the value profile pointer to the; // Counter struct to get this working.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:29,Modifiability,variab,variable,29,// Compiler must define this variable when runtime counter relocation; // is being used. Runtime has a weak external reference that is used; // to check whether that's the case or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:103,Availability,error,errors,103,"// A definition that's weak (linkonce_odr) without being in a COMDAT; // section wouldn't lead to link errors, but it would lead to a dead; // data word from every TU but one. Putting it in COMDAT ensures there; // will be exactly one data slot in the link.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load Temp Val.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:35,Performance,load,load,35,"// Load Temp Val.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load profile bitmap byte.; // %mcdc.bits = load i8, ptr %4, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:46,Performance,load,load,46,"// Load profile bitmap byte.; // %mcdc.bits = load i8, ptr %4, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Perform,Perform,3,"// Perform logical OR of profile bitmap byte and shifted bit offset.; // %8 = or i8 %mcdc.bits, %7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Testability,log,logical,11,"// Perform logical OR of profile bitmap byte and shifted bit offset.; // %8 = or i8 %mcdc.bits, %7",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:13,Deployability,update,updated,13,"// Store the updated profile bitmap byte.; // store i8 %8, ptr %3, align 1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Load,Load,3,"// Load the MCDC temporary value from the stack.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:66,Performance,load,load,66,"// Load the MCDC temporary value from the stack.; // %mcdc.temp = load i32, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:8,Modifiability,extend,extend,8,// Zero-extend the evaluated condition boolean value (0 or 1) by 32bits.; // %1 = zext i1 %tobool to i32,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:96,Deployability,Update,Update,96,"// Shift the boolean value left (by the condition's ID) to form a bitmap.; // %2 = shl i32 %1, <Update->getCondID()>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Performance,Perform,Perform,3,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:48,Performance,load,loaded,48,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:11,Testability,log,logical,11,"// Perform logical OR of the bitmap against the loaded MCDC temporary value.; // %3 = or i32 %mcdc.temp, %2",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:13,Deployability,update,updated,13,"// Store the updated temporary value back to the stack.; // store i32 %3, ptr %mcdc.addr, align 4",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:32,Modifiability,variab,variable,32,/// Get the name of a profiling variable for a particular function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:39,Modifiability,variab,variables,39,// Conservatively returns true if data variables may be referenced by code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:117,Modifiability,variab,variable,117,// Prohibit function address recording if the function is both internal and; // COMDAT. This avoids the profile data variable referencing internal symbols; // in COMDAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:93,Safety,avoid,avoids,93,// Prohibit function address recording if the function is both internal and; // COMDAT. This avoids the profile data variable referencing internal symbols; // in COMDAT.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:270,Availability,avail,available,270,"// Check uses of this function for other than direct calls or invokes to it.; // Inline virtual functions have linkeOnceODR linkage. When a key method; // exists, the vtable will only be emitted in the TU where the key method; // is defined. In a TU where vtable is not available, the function won't; // be 'addresstaken'. If its address is not recorded here, the profile data; // with missing address may be picked by the linker leading to missing; // indirect call target info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:418,Deployability,update,update,418,"// PGO + ThinLTO + CFI cause duplicate symbols to be introduced due to some; // unfavorable interaction between the new alias and the alias renaming done; // in LowerTypeTests under ThinLTO. For comdat functions that would normally; // be deduplicated, but the renaming scheme ends up preventing renaming, since; // it creates unique names for each alias, resulting in duplicated symbols. In; // the future, we should update the CFI related passes to migrate these; // aliases to the same module as the jump-table they refer to will be defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:195,Safety,avoid,avoid,195,"// For comdat functions, an alias would need the same linkage as the original; // function and hidden visibility. There is no point in adding an alias with; // identical linkage an visibility to avoid introducing symbolic relocations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:40,Safety,avoid,avoid,40,// When possible use a private alias to avoid symbolic relocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:415,Safety,avoid,avoids,415,"// When the instrumented function is a COMDAT function, we cannot use a; // private alias. If we did, we would create reference to a local label in; // this function's section. If this version of the function isn't selected by; // the linker, then the metadata would introduce a reference to a discarded; // section. So, for COMDAT functions, we need to adjust the linkage of the; // alias. Using hidden visibility avoids a dynamic relocation and an entry in; // the dynamic symbol table.; //; // Note that this handles COMDAT functions with visibility other than Hidden,; // since that case is covered in shouldUsePublicSymbol()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:78,Deployability,upgrade,upgrade,78,"// COFF doesn't allow the comdat group leader to have private linkage, so; // upgrade private linkage to internal linkage to produce a symbol table; // entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:59,Modifiability,variab,variable,59,// Use internal rather than private linkage so the counter variable shows up; // in the symbol table when using debug info for correlation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:662,Availability,error,errors,662,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:504,Modifiability,variab,variable,504,"// Move the name variable to the right section. Place them in a COMDAT group; // if the associated function is a COMDAT. This will make sure that only one; // copy of counters of the COMDAT function will be emitted after linking. Keep; // in mind that this pass may run before the inliner, so we need to create a; // new comdat group for the counters and profiling data. If we use the comdat; // of the parent function, that will result in relocations against discarded; // sections.; //; // If the data variable is referenced by code, counters and data have to be; // in different comdats for COFF because the Visual C++ linker will report; // duplicate symbol errors if there are multiple external symbols with the; // same name marked IMAGE_COMDAT_SELECT_ASSOCIATIVE.; //; // For ELF, when not using COMDAT, put counters, data and values into a; // nodeduplicate COMDAT which is lowered to a zero-flag section group. This; // allows -z start-stop-gc to discard the entire group when the function is; // discarded.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:20,Modifiability,variab,variable,20,// Mark the counter variable as used so that it isn't optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:54,Performance,optimiz,optimized,54,// Mark the counter variable as used so that it isn't optimized out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:19,Modifiability,variab,variable,19,// Create the data variable (if it doesn't already exist).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:64,Modifiability,variab,variable,64,"// When debug information is correlated to profile data, a data variable; // is not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:18,Modifiability,variab,variable,18,// Return if data variable was already created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:12,Modifiability,Variab,Variable,12,// The Data Variable section is anchored to profile counters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate statically the array of pointers to value profile nodes for; // the current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:15,Modifiability,variab,variable,15,// Create data variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:15,Modifiability,variab,variable,15,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:153,Modifiability,variab,variable,153,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:193,Modifiability,variab,variable,193,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:227,Performance,optimiz,optimization,227,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:415,Security,hash,hash,415,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:526,Security,hash,hash,526,"// If the data variable is not referenced by code (if we don't emit; // @llvm.instrprof.value.profile, NS will be 0), and the counter keeps the; // data variable live under linker GC, the data variable can be private. This; // optimization applies to ELF.; //; // On COFF, a comdat leader cannot be local so we require DataReferencedByCode; // to be false.; //; // If profd is in a deduplicate comdat, NS==0 with a hash suffix guarantees; // that other copies must have the same CFG and cannot have value profiling.; // If no hash suffix, other profd copies may be referenced by code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:56,Performance,load,loaded,56,"// With binary profile correlation, profile data is not loaded into memory.; // profile data must reference profile counter with an absolute relocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:25,Modifiability,variab,variable,25,// Reference the counter variable with a label difference (link-time; // constant).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,// Mark the data variable as used so that it isn't stripped out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:82,Modifiability,variab,variables,82,"// Now that the linkage set by the FE has been passed to the data and counter; // variables, reset Name variable's linkage and visibility to private so that; // it can be removed later by the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:104,Modifiability,variab,variable,104,"// Now that the linkage set by the FE has been passed to the data and counter; // variables, reset Name variable's linkage and visibility to private so that; // it can be removed later by the compiler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:51,Availability,down,down,51,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:30,Energy Efficiency,reduce,reduce,30,"// On COFF, it's important to reduce the alignment down to 1 to prevent the; // linker from inserting padding before the start of the names section or; // between names entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:127,Modifiability,variab,variable,127,// We expect the linker to be invoked with -u<hook_var> flag for Linux; // in which case there is no need to emit the external variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:23,Modifiability,variab,variable,23,// Declare an external variable that will pull in the runtime initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:17,Modifiability,variab,variable,17,// Mark the user variable as used so that it isn't stripped out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:46,Performance,Optimiz,Optimizers,46,"// The metadata sections are parallel arrays. Optimizers (e.g.; // GlobalOpt/ConstantMerge) may not discard associated sections as a unit, so; // we conservatively retain all unconditionally in the compiler.; //; // On ELF and Mach-O, the linker can guarantee the associated sections will be; // retained or discarded as a unit, so llvm.compiler.used is sufficient.; // Similarly on COFF, if prof data is not referenced by code we use one comdat; // and ensure this GC property as well. Otherwise, we have to conservatively; // make all of the sections retained by the linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:26,Modifiability,variab,variable,26,// Create ProfileFileName variable. Don't don't this for the; // context-sensitive instrumentation lowering: This lowering is after; // LTO/ThinLTO linking. Pass PGOInstrumentationGenCreateVar should; // have already create the variable before LTO/ThinLTO linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp:228,Modifiability,variab,variable,228,// Create ProfileFileName variable. Don't don't this for the; // context-sensitive instrumentation lowering: This lowering is after; // LTO/ThinLTO linking. Pass PGOInstrumentationGenCreateVar should; // have already create the variable before LTO/ThinLTO linking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/InstrProfiling.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp:37,Availability,down,down,37,"// If I is IP, move the insert point down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/Instrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:3,Deployability,patch,patchable-function-prefix,3,"// patchable-function-prefix emits nops between the KCFI type identifier; // and the function start. As we don't know the size of the emitted nops,; // don't allow this attribute with generic lowering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:20,Security,hash,hash,20,// Get the expected hash value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:39,Security,hash,hash,39,// Emit a check and trap if the target hash doesn't match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:212,Security,hash,hash,212,"// ARM uses the least significant bit of the function pointer to select; // between ARM and Thumb modes for the callee. Instructions are always; // at least 16-bit aligned, so clear the LSB before we compute the hash; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp:176,Usability,clear,clear,176,"// ARM uses the least significant bit of the function pointer to select; // between ARM and Thumb modes for the callee. Instructions are always; // at least 16-bit aligned, so clear the LSB before we compute the hash; // location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/KCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:2115,Availability,error,error,2115," gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1754,Deployability,update,updates,1754,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3641,Deployability,update,update,3641,"rary.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6218,Energy Efficiency,allocate,allocates,6218,"int to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single pe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5114,Integrability,depend,depending,5114,"d. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The maj",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7176,Modifiability,variab,variables,7176,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7458,Modifiability,variab,variables,7458,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7656,Modifiability,variab,variables,7656,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:702,Performance,load,load,702,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1195,Performance,optimiz,optimizations,1195," https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3535,Performance,perform,performance,3535,"-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work v",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4078,Performance,load,load,4078,"se of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4118,Performance,load,load,4118,"se of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending o",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4278,Performance,load,load,4278,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4344,Performance,load,load,4344,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4390,Performance,load,load,4390,"ialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only ind",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4700,Performance,load,load,4700,"hadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4817,Performance,load,load,4817,"we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5682,Performance,perform,perform,5682,"after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:8020,Performance,scalab,scalable,8020,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:29,Safety,detect,detector,29,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:437,Safety,detect,detector,437,"//===- MemorySanitizer.cpp - detector of uninitialized reads --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; /// \file; /// This file is a part of MemorySanitizer, a detector of uninitialized; /// reads.; ///; /// The algorithm of the tool is similar to Memcheck; /// (http://goo.gl/QKbem). We associate a few shadow bits with every; /// byte of the application memory, poison the shadow of the malloc-ed; /// or alloca-ed memory, load the shadow bits on every memory read,; /// propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisone",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1726,Safety,avoid,avoids,1726,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3321,Safety,avoid,avoids,3321,"rameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happen",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3412,Safety,avoid,avoids,3412,"uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memory. Propagation of origins is basically a bunch of; /// ""select"" instructions that pick the origin of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3876,Safety,safe,safe,3876," of a dirty argument, if an; /// instruction has one.; ///; /// Every 4 aligned, consecutive bytes of application memory have one origin; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, alwa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:5750,Safety,safe,safe,5750,"after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origi",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7844,Safety,safe,safe,7844,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3933,Security,access,accessed,3933,"n; /// value associated with them. If these bytes contain uninitialized data; /// coming from 2 different allocations, the last store wins. Because of this,; /// MemorySanitizer reports can show unrelated origins, but this is unlikely in; /// practice.; ///; /// Origins are meaningless for fully initialized values, so MemorySanitizer; /// avoids storing origin to memory when a fully initialized value is stored.; /// This way it avoids needless overwriting origin of the 4-byte region on; /// a short (i.e. 1 byte) clean store, and it is also good for performance.; ///; /// Atomic handling.; ///; /// Ideally, every atomic store of application value should update the; /// corresponding shadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instru",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6309,Security,access,accesses,6309,"int to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single pe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6459,Security,access,accessed,6459,"s; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned wit",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6651,Security,access,accesses,6651,"/ The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6753,Security,access,accesses,6753,"bly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6895,Security,sanitiz,sanitizer,6895,"bly call, so that changes to the shadow memory will be seen by; /// other threads together with main memory initialization.; ///; /// KernelMemorySanitizer (KMSAN) implementation.; ///; /// The major differences between KMSAN and MSan instrumentation are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7990,Security,sanitiz,sanitizer,7990,"tion are:; /// - KMSAN always tracks the origins and implies msan-keep-going=true;; /// - KMSAN allocates shadow and origin memory for each page separately, so; /// there are no explicit accesses to shadow and origin in the; /// instrumentation.; /// Shadow and origin values for a particular X-byte memory location; /// (X=1,2,4,8) are accessed through pointers obtained via the; /// __msan_metadata_ptr_for_load_X(ptr); /// __msan_metadata_ptr_for_store_X(ptr); /// functions. The corresponding functions check that the X-byte accesses; /// are possible and returns the pointers to shadow and origin memory.; /// Arbitrary sized accesses are handled with:; /// __msan_metadata_ptr_for_load_n(ptr, size); /// __msan_metadata_ptr_for_store_n(ptr, size);; /// Note that the sanitizer code has to deal with how shadow/origin pairs; /// returned by the these functions are represented in different ABIs. In; /// the X86_64 ABI they are returned in RDX:RAX, and in the SystemZ ABI they; /// are written to memory pointed to by a hidden parameter.; /// - TLS variables are stored in a single per-task struct. A call to a; /// function __msan_get_context_state() returning a pointer to that struct; /// is inserted into every instrumented function before the entry block;; /// - __msan_warning() takes a 32-bit origin parameter;; /// - local variables are poisoned with __msan_poison_alloca() upon function; /// entry and unpoisoned with __msan_unpoison_alloca() before leaving the; /// function;; /// - the pass doesn't declare any global variables or add global constructors; /// to the translation unit.; ///; /// Also, KMSAN currently ignores uninitialized memory passed into inline asm; /// calls, making sure we're on the safe side wrt. possible false positives.; ///; /// KernelMemorySanitizer only supports X86_64 and SystemZ at the moment.; ///; //; // FIXME: This sanitizer does not yet handle scalable vectors; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4620,Testability,log,logic,4620,"hadow location in an atomic way. Unfortunately, atomic store; /// of two disjoint locations can not be done without severe slowdown.; ///; /// Therefore, we implement an approximation that may err on the safe side.; /// In this implementation, every atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The l",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:1686,Usability,simpl,simplifies,1686,"/ propagate the shadow bits through some of the arithmetic; /// instruction (including MOV), store the shadow bits on every memory; /// write, report a bug on some other instructions (e.g. JMP) if the; /// associated shadow is poisoned.; ///; /// But there are differences too. The first and the major one:; /// compiler instrumentation instead of binary instrumentation. This; /// gives us much better register allocation, possible compiler; /// optimizations and a fast start-up. But this brings the major issue; /// as well: msan needs to see all program events, including system; /// calls and reads/writes in system libraries, so we either need to; /// compile *everything* with msan or use a binary translation; /// component (e.g. DynamoRIO) to instrument pre-built libraries.; /// Another difference from Memcheck is that we use 8 shadow bits per; /// byte of application memory and use a direct shadow mapping. This; /// greatly simplifies the instrumentation code and avoids races on; /// shadow updates (Memcheck is single-threaded so races are not a; /// concern there. Memcheck uses 2 shadow bits per byte with a slow; /// path storage that uses 8 bits per byte).; ///; /// The default value of shadow is 0, which means ""clean"" (not poisoned).; ///; /// Every module initializer should call __msan_init to ensure that the; /// shadow memory is ready. On error, __msan_warning is called. Since; /// parameters and return values may be passed via registers, we have a; /// specialized thread-local shadow for return values; /// (__msan_retval_tls) and parameters (__msan_param_tls).; ///; /// Origin tracking.; ///; /// MemorySanitizer can track origins (allocation points) of all uninitialized; /// values. This behavior is controlled with a flag (msan-track-origins) and is; /// disabled by default.; ///; /// Origins are 4-byte values created and interpreted by the runtime library.; /// They are stored in a second shadow mapping, one 4-byte value for 4 bytes; /// of application memor",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:4912,Usability,simpl,simple,4912,"y atomically accessed location in the program; /// may only change from (partially) uninitialized to fully initialized, but; /// not the other way around. We load the shadow _after_ the application load,; /// and we store the shadow _before_ the app store. Also, we always store clean; /// shadow (if the application store is atomic). This way, if the store-load; /// pair constitutes a happens-before arc, shadow store and load are correctly; /// ordered such that the load will get either the value that was stored, or; /// some later value (which is always clean).; ///; /// This does not work very well with Compare-And-Swap (CAS) and; /// Read-Modify-Write (RMW) operations. To follow the above logic, CAS and RMW; /// must store the new shadow before the app operation, and load the shadow; /// after the app operation. Computers don't work this way. Current; /// implementation ignores the load aspect of CAS/RMW, always returning a clean; /// value. It implements the store part as a simple atomic store by storing a; /// clean shadow.; ///; /// Instrumenting inline assembly.; ///; /// For inline assembly code LLVM has little idea about which memory locations; /// become initialized depending on the arguments. It can be possible to figure; /// out which arguments are meant to point to inputs and outputs, but the; /// actual semantics can be only visible at runtime. In the Linux kernel it's; /// also possible that the arguments only indicate the offset for a base taken; /// from a segment register, so it's dangerous to treat any asm() arguments as; /// pointers. We take a conservative approach generating calls to; /// __msan_instrument_asm_store(ptr, size); /// , which defer the memory unpoisoning to the runtime library.; /// The latter can perform more complex address checks to figure out whether; /// it's safe to touch the shadow memory.; /// Like with atomic operations, we call __msan_instrument_asm_store() before; /// the assembly call, so that changes to the shadow memo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:168,Modifiability,variab,variables,168,"// When compiling the Linux kernel, we sometimes see false positives related to; // MSan being unable to understand that inline assembly calls may initialize; // local variables.; // This flag makes the compiler conservatively unpoison every memory location; // passed into an assembly call. Note that this may cause false positives.; // Because it's impossible to figure out the array sizes, we can only unpoison; // the first sizeof(type) bytes for each type* pointer.; // The instrumentation is only enabled in KMSAN builds, and only if; // -msan-handle-asm-conservative is on. This is done because we may want to; // quickly disable assembly instrumentation when it breaks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:80,Performance,load,load,80,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:126,Performance,load,load,126,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:259,Security,access,access,259,"// This flag controls whether we check the shadow of the address; // operand of load or store. Such bugs are very rare, since load from; // a garbage address typically results in SEGV, but still happen; // (e.g. only lower bits of address are garbage, or the access happens; // early at program startup where malloc-ed memory is more likely to; // be zeroed. As of 2012-08-28 this flag adds 20% slowdown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Safety,detect,detect,40,/// Instrument functions of a module to detect uninitialized reads.; ///; /// Instantiating MemorySanitizer inserts the msan runtime library API function; /// declarations into the module if they don't exist already. Instantiating; /// ensures the __msan_init function is in the list of global constructors for; /// the module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:67,Modifiability,variab,variables,67,///< Integer type with the size of a ptr in default AS.; // XxxTLS variables represent the per-thread state in MSan and per-task state; // in KMSAN.; // For the userspace these point to thread-local globals. In the kernel land; // they point to the members of a per-task struct obtained via a call to; // __msan_get_context_state().; /// Thread-local shadow storage for function parameters.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:36,Security,Access,AccessSize,36,// These arrays are indexed by log2(AccessSize).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:102,Deployability,update,updated,102,/// Run-time helper that records a store (or any event) of an; /// uninitialized value and returns an updated origin id encoding this info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:46,Modifiability,variab,variables,46,/// Functions for poisoning/unpoisoning local variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:25,Modifiability,variab,variables,25,// Create the global TLS variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:336,Safety,avoid,avoid,336,"/// A helper class that handles instrumentation of VarArg; /// functions on a particular platform.; ///; /// Implementations are expected to insert the instrumentation; /// necessary to propagate argument shadow through VarArg function; /// calls. Visit* methods are called during an InstVisitor pass over; /// the function, and should avoid creating new basic blocks. A new; /// instance of this class is created for each instrumented function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Performance,Scalab,Scalable,3,// Scalable types unconditionally take slowpaths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:65,Performance,Load,Load,65,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:98,Performance,load,load,98,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:284,Testability,test,test,284,"/// This class does all the work for a given function. Store and Load; /// instructions store and load corresponding shadow and origin; /// values. Most instructions propagate shadow from arguments to their; /// return values. Certain instructions (most importantly, BranchInst); /// test their argument shadow and print reports (with a runtime call) if it's; /// non-zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Performance,optimiz,optimized,49,"// Fallback to runtime check, which still can be optimized out later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Deployability,update,update,10,// Origin update with missing or the same debug location provides no; // additional value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Deployability,update,update,10,"// Insert update just before the check, so we call runtime only just; // before the report.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Availability,Recover,Recover,40,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:40,Safety,Recover,Recover,40,// FIXME: Insert UnreachableInst if !MS.Recover?; // This may invalidate some of the following checks and needs to be done; // at the very end.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Performance,optimiz,optimized,49,"// Fallback to runtime check, which still can be optimized out later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:15,Performance,Load,LoadInst,15,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:34,Performance,Load,Loads,34,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:123,Performance,load,load,123,"/// Instrument LoadInst; ///; /// Loads the corresponding shadow and (optionally) origin.; /// Optionally, checks that the load address is fully defined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:160,Availability,reliab,reliably,160,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:138,Safety,detect,detect,138,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:8,Testability,test,test,8,"// Only test the conditional argument of cmpxchg instruction.; // The other argument can potentially be uninitialized, but we can not; // detect this situation reliably without possible false positives.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:286,Modifiability,extend,extending,286,"/// Default propagation of shadow and/or origin.; ///; /// This class implements the general case of shadow propagation, used in all; /// cases where we don't know and/or don't care about what the operation; /// actually does. It converts all input shadow values to a common type; /// (extending or truncating as necessary), and bitwise OR's them.; ///; /// This is much cheaper than inserting checks (i.e. requiring inputs to be; /// fully initialized), and less prone to false positives.; ///; /// This class also implements the general case of origin propagation. For a; /// Nary operation, result origin is set to the origin of an argument that is; /// not entirely initialized. If there is more than one such arguments, the; /// rightmost of them is picked. It does not matter which one is picked if all; /// arguments are initialized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:35,Modifiability,extend,extending,35,"/// Cast between two shadow types, extending or truncating as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:72,Testability,test,tests,72,"/// Instrument signed relational comparisons.; ///; /// Handle sign bit tests: x<0, x>=0, x<=-1, x>-1 by propagating the highest; /// bit of the shadow. Everything else is delegated to handleShadowOr().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S0 and S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:387,Usability,simpl,simply,387,"/// Instrument llvm.memmove; ///; /// At this point we don't know if llvm.memmove will be inlined or not.; /// If we don't instrument it and it gets inlined,; /// our interceptor will not kick in and we will lose the memmove.; /// If we instrument the call here, but it does not get inlined,; /// we will memove the shadow twice: which is bad in case; /// of overlapping regions. So, we simply lower the intrinsic to a call.; ///; /// Similar situation exists for memcpy and memset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:356,Performance,optimiz,optimization,356,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:52,Safety,avoid,avoid,52,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:586,Safety,safe,safe,586,"/// Instrument memcpy; ///; /// Similar to memmove: avoid copying shadow twice. This is somewhat; /// unfortunate as it may slowdown small constant memcpys.; /// FIXME: consider doing manual inline for small constant sizes and proper; /// alignment.; ///; /// Note: This also handles memcpy.inline, which promises no calls to external; /// functions as an optimization. However, with instrumentation enabled this; /// is difficult to promise; additionally, we know that the MSan runtime; /// exists and provides __msan_memcpy(). Therefore, we assume that with; /// instrumentation it's safe to turn memcpy.inline into a call to; /// __msan_memcpy(). Should this be wrong, such as when implementing memcpy(); /// itself, instrumentation should be disabled with the no_sanitize attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:90,Usability,simpl,simple,90,"/// Handle vector store-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD store: writes memory,; /// has 1 pointer argument and 1 vector argument, returns void.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:18,Performance,load,load-like,18,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:101,Performance,load,load,101,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:89,Usability,simpl,simple,89,"/// Handle vector load-like intrinsics.; ///; /// Instrument intrinsics that look like a simple SIMD load: reads memory,; /// has 1 pointer argument, returns a vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:63,Performance,load,load,63,// We don't know the pointer alignment (could be unaligned SSE load!).; // Have to assume to worst case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:286,Security,access,access,286,"/// Handle (SIMD arithmetic)-like intrinsics.; ///; /// Instrument intrinsics with any number of arguments of the same type,; /// equal to the return type. The type should be simple (no aggregates or; /// pointers; vectors are fine).; /// Caller guarantees that this intrinsic does not access memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:175,Usability,simpl,simple,175,"/// Handle (SIMD arithmetic)-like intrinsics.; ///; /// Instrument intrinsics with any number of arguments of the same type,; /// equal to the return type. The type should be simple (no aggregates or; /// pointers; vectors are fine).; /// Caller guarantees that this intrinsic does not access memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:28,Performance,load,load,28,// This looks like a vector load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:32,Availability,mask,maskstore,32,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:42,Availability,mask,maskload,42,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:10,Safety,detect,detect,10,// FIXME: detect and handle SSE maskstore/maskload,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:171,Availability,avail,available,171,"// The first *NumUsedElements* elements of ConvertOp are converted to the; // same number of output elements. The rest of the output is copied from; // CopyOp, or (if not available) filled with zeroes.; // Combine shadow for elements of ConvertOp that are used in this operation,; // and insert a check.; // FIXME: consider propagating shadow of ConvertOp, at least in the case of; // int->any conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:82,Performance,perform,perform,82,"// If any of the S2 bits are poisoned, the whole thing is poisoned.; // Otherwise perform the same shift on S1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Energy Efficiency,reduce,reduce,21,// Instrument vector.reduce.or intrinsic.; // Valid (non-poisoned) set bits in the operand pull low the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:99,Availability,down,down,99,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Energy Efficiency,reduce,reduce,21,// Instrument vector.reduce.and intrinsic.; // Valid (non-poisoned) unset bits in the operand pull down the; // corresponding shadow bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:37,Performance,load,loaded,37,// Choose between PassThru's and the loaded value's origins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:21,Availability,mask,mask,21,"// If any bit of the mask operand is poisoned, then the whole thing is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:122,Integrability,depend,depending,122,"// Instrument pclmul intrinsics.; // These intrinsics operate either on odd or on even elements of the input; // vectors, depending on the constant in the 3rd argument, ignoring the rest.; // Replace the unused elements with copies of the used ones, ex:; // (0, 1, 2, 3) -> (0, 0, 2, 2) (even case); // or; // (0, 1, 2, 3) -> (1, 1, 3, 3) (odd case); // and then apply the usual shadow combining logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:396,Testability,log,logic,396,"// Instrument pclmul intrinsics.; // These intrinsics operate either on odd or on even elements of the input; // vectors, depending on the constant in the 3rd argument, ignoring the rest.; // Replace the unused elements with copies of the used ones, ex:; // (0, 1, 2, 3) -> (0, 0, 2, 2) (even case); // or; // (0, 1, 2, 3) -> (1, 1, 3, 3) (odd case); // and then apply the usual shadow combining logic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Modifiability,Variab,Variable,3,/* Variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Modifiability,Variab,Variable,3,/* Variable */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:37,Deployability,Release,Release,37,// Convert the call to have at least Release ordering to make sure; // the shadow operations aren't reordered after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:179,Performance,optimiz,optimized,179,"// We are going to insert code that relies on the fact that the callee; // will become a non-readonly function after it is instrumented by us. To; // prevent this code from being optimized out, mark that function; // non-readonly in advance.; // TODO: We can likely do better than dropping memory() completely here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:26,Performance,load,load,26,"// __sanitizer_unaligned_{load,store} functions may be called by users; // and always expects shadows in the TLS. So don't check them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:73,Performance,load,load,73,// ByVal requires some special handling as it's too big for a single; // load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:18,Modifiability,extend,extending,18,"// To avoid ""sign extending"" i1 to an arbitrary aggregate type, we just do; // an extra ""select"". This results in much more compact IR.; // Sa = select Sb, poisoned, (select b, Sc, Sd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:6,Safety,avoid,avoid,6,"// To avoid ""sign extending"" i1 to an arbitrary aggregate type, we just do; // an extra ""select"". This results in much more compact IR.; // Sa = select Sb, poisoned, (select b, Sc, Sd)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:194,Usability,simpl,simply,194,"// Sa = select Sb, [ (c^d) | Sc | Sd ], [ b ? Sc : Sd ]; // If Sb (condition is poisoned), look for bits in c and d that are equal; // and both unpoisoned.; // If !Sb (condition is unpoisoned), simply pick one of Sc and Sd.; // Cast arguments to shadow-compatible type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:49,Security,sanitiz,sanitizers,49,// Do nothing.; // See https://github.com/google/sanitizers/issues/504,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:54,Safety,avoid,avoid,54,// Here using VAArgOverflowSizeTLS as VAArgSizeTLS to avoid creation of; // a new class member i.e. it is the total size of all VarArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:7,Energy Efficiency,Power,PowerPC,7,"// For PowerPC, we need to deal with alignment of stack arguments -; // they are mostly aligned to 8 bytes, but vectors and i128 arrays; // are aligned to 16 bytes, byvals can be aligned to 8 or 16 bytes,; // For that reason, we compute current offset from stack pointer (which is; // always properly aligned), and offset for the first vararg, then subtract; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:54,Safety,avoid,avoid,54,// Here using VAArgOverflowSizeTLS as VAArgSizeTLS to avoid creation of; // a new class member i.e. it is the total size of all VarArgs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:334,Modifiability,extend,extended,334,"// ABI says: ""One of the simple integer types no more than 64 bits wide.; // ... If such an argument is shorter than 64 bits, replace it by a full; // 64-bit integer representing the same number, using sign or zero; // extension"". Shadow for an integer argument has the same type as the; // argument itself, so it can be sign or zero extended as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:25,Usability,simpl,simple,25,"// ABI says: ""One of the simple integer types no more than 64 bits wide.; // ... If such an argument is shorter than 64 bits, replace it by a full; // 64-bit integer representing the same number, using sign or zero; // extension"". Shadow for an integer argument has the same type as the; // argument itself, so it can be sign or zero extended as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:196,Modifiability,extend,extend,196,"// PoP says: ""A short floating-point datum requires only the; // left-most 32 bit positions of a floating-point register"".; // Therefore, in contrast to AK_GeneralPurpose and AK_Memory,; // don't extend shadow and don't mind the gap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:120,Usability,clear,clear,120,"// FIXME: This implementation limits OverflowOffset to kParamTLSSize, so we; // don't know real overflow size and can't clear shadow beyond kParamTLSSize.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp:3,Usability,Clear,Clear,3,// Clear out memory attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemorySanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:47,Security,access,access,47,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:426,Security,access,accesses,426,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:473,Security,access,access,473,"//===- MemProfiler.cpp - memory allocation and access profiler ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of MemProfiler. Memory accesses are instrumented; // to increment the access count held in a shadow memory location, or; // alternatively to call into the runtime. Memory intrinsic calls (memmove,; // memcpy, memset) are changed to call the memory profiling runtime version; // instead.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:26,Availability,down,down,26,// Scale from granularity down to shadow size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:106,Availability,mask,mask,106,// These flags allow to change the shadow mapping.; // The shadow mapping looks like; // Shadow = ((Mem & mask) >> scale) + offset,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:81,Availability,mask,mask,81,/// This struct defines the shadow mapping using the rule:; /// shadow = ((mem & mask) >> Scale) ADD DynamicShadowOffset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:52,Security,access,accesses,52,/// Instrument the code in module to profile memory accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:35,Security,access,access,35,"/// If it is an interesting memory access, populate information; /// about the access and return a InterestingMemoryAccess struct.; /// Otherwise return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:79,Security,access,access,79,"/// If it is an interesting memory access, populate information; /// about the access and return a InterestingMemoryAccess struct.; /// Otherwise return std::nullopt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:30,Security,Access,AccessIsWrite,30,// These arrays is indexed by AccessIsWrite,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:13,Availability,mask,mask,13,// (Shadow & mask) >> scale,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:25,Performance,load,load,25,// Do not instrument the load fetching the dynamic shadow address.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Availability,Mask,Masked,3,// Masked store has an initial operand for the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:33,Deployability,update,updates,33,// Do not instrument PGO counter updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:47,Modifiability,variab,variables,47,// Do not instrument accesses to LLVM internal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:21,Security,access,accesses,21,// Do not instrument accesses to LLVM internal variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Availability,Mask,Mask,3,"// Mask is constant false, so no instrumentation needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:33,Security,access,accesses,33,// Skip instrumentation of stack accesses unless requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:89,Deployability,update,update,89,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:13,Security,access,access,13,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:107,Security,access,access,107,"// Since the access counts will be accumulated across the entire allocation,; // we only update the shadow access count for the first location and thus; // don't need to worry about alignment and type size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:14,Modifiability,variab,variable,14,// Create the variable for the profile file name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:42,Performance,load,load,42,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __memprof_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:297,Security,access,access,297,"// For each NSObject descendant having a +load method, this method is invoked; // by the ObjC runtime before any of the static constructors is called.; // Therefore we need to instrument such methods with a call to __memprof_init; // at the beginning in order to initialize our runtime before any access to; // the shadow memory.; // We cannot just ignore these methods, because they may call other; // instrumented functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:190,Usability,GUID,GUID,190,"// Previously we used getIRPGOFuncName() here. If F is local linkage,; // getIRPGOFuncName() returns FuncName with prefix 'FileName;'. But; // llvm-profdata uses FuncName in dwarf to create GUID which doesn't; // contain FileName's prefix. It caused local linkage function can't; // find MemProfRecord. So we use getName() now.; // 'unique-internal-linkage-names' can make MemProf work better for local; // linkage function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:3,Safety,Detect,Detect,3,"// Detect if there are non-zero column numbers in the profile. If not,; // treat all column numbers as 0 when matching (i.e. ignore any non-zero; // columns in the IR). The profiled binary might have been built with; // column numbers disabled, for example.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:30,Security,hash,hash,30,// Build maps of the location hash to all profile data with that leaf location; // (allocation info and the callsites).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:53,Security,hash,hashes,53,// List of call stack ids computed from the location hashes on debug; // locations (leaf to inlined at root).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:41,Energy Efficiency,reduce,reduce,41,"// Only consider allocations via new, to reduce unnecessary metadata,; // since those are the only allocations that will be targeted initially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:243,Deployability,update,updated,243,"// Add callsite metadata for the instruction's location list so that; // it simpler later on to identify which part of the MIB contexts; // are from this particular instruction (including during inlining,; // when the callsite metdata will be updated appropriately).; // FIXME: can this be changed to strip out the matching stack; // context ids from the MIB contexts and not add any callsite; // metadata here to save space?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp:76,Usability,simpl,simpler,76,"// Add callsite metadata for the instruction's location list so that; // it simpler later on to identify which part of the MIB contexts; // are from this particular instruction (including during inlining,; // when the callsite metdata will be updated appropriately).; // FIXME: can this be changed to strip out the matching stack; // context ids from the MIB contexts and not add any callsite; // metadata here to save space?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/MemProfiler.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:1227,Energy Efficiency,reduce,reduce,1227,"rmation.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements PGO instrumentation using a minimum spanning tree based; // on the following paper:; // [1] Donald E. Knuth, Francis R. Stevenson. Optimal measurement of points; // for program frequency counts. BIT Numerical Mathematics 1973, Volume 13,; // Issue 3, pp 313-322; // The idea of the algorithm based on the fact that for each node (except for; // the entry and exit), the sum of incoming edge counts equals the sum of; // outgoing edge counts. The count of edge on spanning tree can be derived from; // those edges not on the spanning tree. Knuth proves this method instruments; // the minimum number of edges.; //; // The minimal spanning tree here is actually a maximum weight tree -- on-tree; // edges have higher frequencies (more likely to execute). The idea is to; // instrument those less frequently executed edges to reduce the runtime; // overhead of instrumented binaries.; //; // This file contains two passes:; // (1) Pass PGOInstrumentationGen which instruments the IR to generate edge; // count profile, and generates the instrumentation for indirect call; // profiling.; // (2) Pass PGOInstrumentationUse which reads the edge count profile and; // annotates the branch weights. It also reads the indirect call value; // profiling records and annotate the indirect call instructions.; //; // To get the precise counter information, These two passes need to invoke at; // the same compilation point (so they see the same IR). For pass; // PGOInstrumentationGen, the real work is done in instrumentOneFunc(). For; // pass PGOInstrumentationUse, the real work in done in class PGOUseFunc and; // the profile is opened in module level and passed to each PGOUseFunc instance.; // The shared code for PGOInstrumentationGen and PGOInstrumentationUse is put; // in class FuncPGOInstrumentation.; //; // Class PGO",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:93,Testability,test,testing,93,// Command line option to specify the file to read profile from. This is; // mainly used for testing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Command line option to control appending FunctionHash to the name of a COMDAT; // function. This is to avoid the hash mismatch caused by the preinliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:116,Security,hash,hash,116,// Command line option to control appending FunctionHash to the name of a COMDAT; // function. This is to avoid the hash mismatch caused by the preinliner.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:61,Security,hash,hash,61,// Command line option to enable/disable the warning about a hash mismatch in; // the profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:61,Security,hash,hash,61,"// Command line option to enable/disable the warning about a hash mismatch in; // the profile data for Comdat functions, which often turns out to be false; // positive due to the pre-instrumentation inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:30,Performance,optimiz,optimization,30,// Emit branch probability as optimization remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:19,Modifiability,variab,variable,19,// Create a COMDAT variable INSTR_PROF_RAW_VERSION_VAR to make the runtime; // aware this is an ir_level profile so it can set the version flag.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:108,Usability,simpl,simply,108,"/// The select instruction visitor plays three roles specified; /// by the mode. In \c VM_counting mode, it simply counts the number of; /// select instructions. In \c VM_instrument mode, it inserts code to count; /// the number times TrueValue of select is taken. In \c VM_annotate mode,; /// it reads the profile data and annotate the select instruction with metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:108,Modifiability,variab,variable,108,// Visit the IR stream and instrument all select instructions. \p; // Ind is a pointer to the counter index variable; \p TotalNC; // is the total number of counters; \p FNV is the pointer to the; // PGO function name var; \p FHash is the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:247,Security,hash,hash,247,// Visit the IR stream and instrument all select instructions. \p; // Ind is a pointer to the counter index variable; \p TotalNC; // is the total number of counters; \p FNV is the pointer to the; // PGO function name var; \p FHash is the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:31,Performance,perform,perform,31,// Visit \p SI instruction and perform tasks according to visit mode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Security,hash,hash,7,// CFG hash value for this function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:42,Availability,avail,available,42,// Return the auxiliary BB information if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:34,Security,hash,hash,34,// This should be done before CFG hash computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:39,Security,Hash,Hash,39,"// end anonymous namespace; // Compute Hash value for the CFG: the lower 32 bits are CRC32 of the index; // value of each BB in the CFG. The higher 32 bits are the CRC32 of the numbers; // of selects, indirect calls, mem ops and edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Security,Hash,Hash,3,// Hash format for context sensitive profile. Reserve 4 bits for other; // information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:19,Safety,safe,safely,19,// Check if we can safely rename this Comdat function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:278,Energy Efficiency,efficient,efficiently,278,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:255,Modifiability,refactor,refactoring,255,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:299,Modifiability,Variab,Variables,299,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:197,Security,hash,hashes,197,"// FIXME: Current only handle those Comdat groups that only containing one; // function.; // (1) For a Comdat group containing multiple functions, we need to have a; // unique postfix based on the hashes for each function. There is a; // non-trivial code refactoring to do this efficiently.; // (2) Variables can not be renamed, so we can not rename Comdat function in a; // group including global vars.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Availability,Avail,AvailableExternallyLinkage,7,"// For AvailableExternallyLinkage functions, change the linkage to; // LinkOnceODR and put them into comdat. This is because after renaming, there; // is no backup external copy available for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:178,Availability,avail,available,178,"// For AvailableExternallyLinkage functions, change the linkage to; // LinkOnceODR and put them into comdat. This is because after renaming, there; // is no backup external copy available for the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:29,Deployability,update,update,29,// Use a worklist as we will update the vector during the iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:52,Integrability,rout,routines,52,"// When generating value profiling calls on Windows routines that make use of; // handler funclets for exception processing an operand bundle needs to attached; // to the called function. This routine will set \p OpBundles to contain the; // funclet information, if any is needed, that should be placed on the generated; // value profiling call for the value profile candidate call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:193,Integrability,rout,routine,193,"// When generating value profiling calls on Windows routines that make use of; // handler funclets for exception processing an operand bundle needs to attached; // to the called function. This routine will set \p OpBundles to contain the; // funclet information, if any is needed, that should be placed on the generated; // value profiling call for the value profile candidate call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:144,Integrability,rout,routine,144,// Intrinsics or other instructions do not get funclet information from the; // front-end. Need to use the BlockColors that was computed by the routine; // colorEHFunclets to determine whether a funclet is needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather than; // later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:41,Security,hash,hash,41,"// llvm.instrprof.cover(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,Security,hash,hash,45,"// llvm.instrprof.timestamp(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:45,Security,hash,hash,45,"// llvm.instrprof.increment(i8* <name>, i64 <hash>, i32 <num-counters>,; // i32 <index>)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:22,Deployability,update,update,22,// Add an OutEdge and update the edge count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:21,Deployability,update,update,21,// Add an InEdge and update the edge count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:23,Security,hash,hash,23,// Return the function hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:42,Availability,avail,available,42,// Return the auxiliary BB information if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:63,Availability,error,error,63,// Find the Instrumented BB and set the value. Return false on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:109,Availability,error,error,109,// Visit all the edges and assign the count value for the instrumented; // edges and the BB. Return false on error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:26,Deployability,update,update,26,// Set the edge count and update the count of unknown edges for BBs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:215,Availability,error,errors,215,"// Read the profile from ProfileFileName and assign the value to the; // instrumented BB and the edges. This function also updates ProgramMaxCount.; // Return true if the profile are successfully read, and false on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:123,Deployability,update,updates,123,"// Read the profile from ProfileFileName and assign the value to the; // instrumented BB and the edges. This function also updates ProgramMaxCount.; // Return true if the profile are successfully read, and false on errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Energy Efficiency,efficient,efficient,7,"// For efficient traversal, it's better to start from the end as most; // of the instrumented edges are at the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Testability,Assert,Assert,3,// Assert every BB has a valid counter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:126,Modifiability,variab,variables,126,"// For the context-sensitve instrumentation, we should have a separated pass; // (before LTO/ThinLTO linking) to create these variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:7,Modifiability,variab,variable,7,// The variable in a comdat may be discarded by LTO. Ensure the declaration; // will be retained.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:106,Safety,avoid,avoid,106,// Split indirectbr critical edges here before computing the MST rather; // than later in getInstrBB() to avoid invalidating it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp:3,Usability,Clear,Clear,3,// Clear function attribute cold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOInstrumentation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:556,Availability,avail,available,556,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:30,Performance,Optimiz,Optimizations,30,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:422,Performance,optimiz,optimizes,422,"//===-- PGOMemOPSizeOpt.cpp - Optimizations based on value profiling ===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the transformation that optimizes memory intrinsics; // such as memcpy using the size value profile. When memory intrinsic size; // value profile metadata is available, a single memory intrinsic is expanded; // to a sequence of guarded specialized versions that are called with the; // hottest size(s), for later expansion into more optimal inline sequences.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:29,Performance,optimiz,optimize,29,// The minimum call count to optimize memory intrinsic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:51,Performance,optimiz,optimization,51,// Command line option to disable memory intrinsic optimization. The default is; // false. This is for debug purpose.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:28,Performance,optimiz,optimize,28,// The percent threshold to optimize memory intrinsic calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:34,Performance,optimiz,optimizing,34,// Maximum number of versions for optimizing memory intrinsic call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:7,Performance,perform,perform,7,// Not perform on constant length calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:3,Usability,Clear,Clear,3,// Clear the value profile data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp:21,Deployability,update,update,21,// Otherwise we need update with the un-promoted records back.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PGOMemOPSizeOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2292,Energy Efficiency,reduce,reduced,2292,"ducing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===---------------------------------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2533,Integrability,depend,dependent,2533,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2616,Integrability,depend,dependence,2616,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2148,Performance,optimiz,optimization,2148,"// state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:3045,Performance,optimiz,optimizer,3045,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:658,Security,sanitiz,sanitizer,658,"//===- PoisonChecking.cpp - -----------------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a transform pass which instruments IR such that poison semantics; // are made explicit. That is, it provides a (possibly partial) executable; // semantics for every instruction w.r.t. poison as specified in the LLVM; // LangRef. There are obvious parallels to the sanitizer tools, but this pass; // is focused purely on the semantics of LLVM IR, not any particular source; // language. If you're looking for something to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific inpu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1213,Security,validat,validates,1213,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements a transform pass which instruments IR such that poison semantics; // are made explicit. That is, it provides a (possibly partial) executable; // semantics for every instruction w.r.t. poison as specified in the LLVM; // LangRef. There are obvious parallels to the sanitizer tools, but this pass; // is focused purely on the semantics of LLVM IR, not any particular source; // language. If you're looking for something to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introdu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1886,Security,Validat,Validating,1886,"g; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all argu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:2367,Security,validat,validation,2367,"nstruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we consider the reloaded value to not be poisoned.; // - Poison propagation across function boundaries is not modeled. At the; // moment, all arguments and return values are assumed not to be poison.; // - Undef is not modeled. In particular, the optimizer's freedom to pick; // concrete values for undef bits so as to maximize potential for producing; // poison is not modeled.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:1803,Testability,test,testing,1803,"hing to see if your C/C++ contains; // UB, this is not it.; //; // The rewritten semantics of each instruction will include the following; // components:; //; // 1) The original instruction, unmodified.; // 2) A propagation rule which translates dynamic information about the poison; // state of each input to whether the dynamic output of the instruction; // produces poison.; // 3) A creation rule which validates any poison producing flags on the; // instruction itself (e.g. checks for overflow on nsw).; // 4) A check rule which traps (to a handler function) if this instruction must; // execute undefined behavior given the poison state of it's inputs.; //; // This is a must analysis based transform; that is, the resulting code may; // produce a false negative result (not report UB when actually exists; // according to the LangRef spec), but should never produce a false positive; // (report UB where it doesn't exist).; //; // Use cases for this pass include:; // - Understanding (and testing!) the implications of the definition of poison; // from the LangRef.; // - Validating the output of a IR fuzzer to ensure that all programs produced; // are well defined on the specific input used.; // - Finding/confirming poison specific miscompiles by checking the poison; // status of an input/IR pair is the same before and after an optimization; // transform.; // - Checking that a bugpoint reduction does not introduce UB which didn't; // exist in the original program being reduced.; //; // The major sources of inaccuracy are currently:; // - Most validation rules not yet implemented for instructions with poison; // relavant flags. At the moment, only nsw/nuw on add/sub are supported.; // - UB which is control dependent on a branch on poison is not yet; // reported. Currently, only data flow dependence is modeled.; // - Poison which is propagated through memory is not modeled. As such,; // storing poison to memory and then reloading it will cause a false negative; // as we conside",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:222,Testability,test,testing,222,"// Return false for unknwon values - this implements a non-strict mode where; // unhandled IR constructs are simply considered to never produce poison. At; // some point in the future, we probably want a ""strict mode"" for testing if; // nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:109,Usability,simpl,simply,109,"// Return false for unknwon values - this implements a non-strict mode where; // unhandled IR constructs are simply considered to never produce poison. At; // some point in the future, we probably want a ""strict mode"" for testing if; // nothing else.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:290,Availability,mask,mask,290,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:32,Integrability,depend,dependent,32,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:929,Performance,Scalab,Scalable,929,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp:697,Usability,clear,clear,697,"/* Major TODO Items:; - Control dependent poison UB; - Strict mode - (i.e. must analyze every operand); - Poison through memory; - Function ABIs; - Full coverage of intrinsics, etc.. (ouch). Instructions w/Unclear Semantics:; - shufflevector - It would seem reasonable for an out of bounds mask element; to produce poison, but the LangRef does not state.; - all binary ops w/vector operands - The likely interpretation would be that; any element overflowing should produce poison for the entire result, but; the LangRef does not state.; - Floating point binary ops w/fmf flags other than (nnan, noinfs). It seems; strange that only certian flags should be documented as producing poison. Cases of clear poison semantics not yet implemented:; - Exact flags on ashr/lshr produce poison; - NSW/NUW flags on shl produce poison; - Inbounds flag on getelementptr produce poison; - fptosi/fptoui (out of bounds input) produce poison; - Scalable vector types for insertelement/extractelement; - Floating point binary ops w/fmf nnan/noinfs flags produce poison; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/PoisonChecking.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:7,Security,Sanitiz,SanitizerBinaryMetadata,7,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:53,Security,sanitiz,sanitizers,53,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:406,Security,Sanitiz,SanitizerBinaryMetadata,406,"//===- SanitizerBinaryMetadata.cpp - binary analysis sanitizers metadata --===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of SanitizerBinaryMetadata.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:88,Usability,simpl,simply,88,"// The only instances of MetadataInfo are the constants above, so a set of; // them may simply store pointers to them. To deterministically generate code,; // we need to use a set with stable iteration order, such as SetVector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:391,Security,Sanitiz,SanitizerBinaryMetadata,391,"// Determines which set of metadata to collect for this instruction.; //; // Returns true if covered metadata is required to unambiguously interpret; // other metadata. For example, if we are interested in atomics metadata, any; // function with memory operations (atomic or not) requires covered metadata; // to determine if a memory operation is atomic or not in modules compiled; // with SanitizerBinaryMetadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:22,Integrability,depend,dependent,22,// Returns the target-dependent section name.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:23,Security,access,access,23,"// Returns true if the access to the address should be considered ""atomic"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:177,Security,Sanitiz,SanitizerBinaryMetadata,177,"// Covered metadata is always emitted if explicitly requested, otherwise only; // if some other metadata requires it to unambiguously interpret it for; // modules compiled with SanitizerBinaryMetadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:15,Availability,mask,mask,15,// The feature mask will be placed after the function size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:291,Modifiability,variab,variables,291,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:255,Safety,safe,safe,255,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:194,Security,Sanitiz,Sanitizer,194,"// There are no intrinsic functions that leak arguments.; // If the called function does not return, the current function; // does not return as well, so no possibility of use-after-return.; // Sanitizer function also don't leak or don't return.; // It's safe to both pass pointers to local variables to them; // and to tail-call them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:55,Safety,avoid,avoid,55,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:27,Security,access,accesses,27,"// Some compiler-generated accesses are known racy, to avoid false positives; // in data-race analysis pretend they're atomic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp:141,Availability,error,errors,141,"// Use ExternalWeak so that if all sections are discarded due to section; // garbage collection, the linker will not report undefined symbol errors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerBinaryMetadata.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:8,Security,Sanitiz,SanitizerCoverage,8,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:61,Security,sanitiz,sanitizers,61,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:442,Security,Sanitiz,Sanitizers,442,"//===-- SanitizerCoverage.cpp - coverage instrumentation for sanitizers ---===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Coverage instrumentation done on LLVM IR level, works with Sanitizers.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:31,Modifiability,variab,variable,31,"// If true, we create a global variable that contains PCs of all instrumented; // BBs, put this global into a named section, and pass this section's bounds; // to __sanitizer_cov_pcs_init.; // This way the coverage instrumentation does not need to acquire the PCs; // at run-time. Works with trace-pc-guard, inline-8bit-counters, and; // inline-bool-flag.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:142,Security,Sanitiz,Sanitizers,142,// GlobalsAA is considered stateless and does not get invalidated unless; // explicitly invalidated; PreservedAnalyses::none() is not enough. Sanitizers; // make changes that require GlobalsAA to be invalidated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:141,Availability,error,errors,141,"// Use ExternalWeak so that if all sections are discarded due to section; // garbage collection, the linker will not report undefined symbol errors.; // Windows defines the start/stop symbols in compiler-rt so no need for; // ExternalWeak.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:41,Modifiability,extend,extended,41,// Make sure smaller parameters are zero-extended to i64 if required by the; // target ABI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:3,Performance,Load,Loads,3,// Loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:25,Security,sanitiz,sanitizer,25,// Should not instrument sanitizer init functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:29,Deployability,configurat,configuration,29,// Don't instrument MSVC CRT configuration helpers. They may run before normal; // initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:29,Modifiability,config,configuration,29,// Don't instrument MSVC CRT configuration helpers. They may run before normal; // initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:55,Performance,Optimiz,Optimizers,55,"// sancov_pcs parallels the other metadata section(s). Optimizers (e.g.; // GlobalOpt/ConstantMerge) may not discard sancov_pcs and the other; // section(s) as a unit, so we conservatively retain all unconditionally in; // the compiler.; //; // With comdat (COFF/ELF), the linker can guarantee the associated sections; // will be retained or discarded as a unit, so llvm.compiler.used is; // sufficient. Otherwise, conservatively make all of them retained by the; // linker.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:142,Performance,cache,cache,142,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:168,Performance,Cache,CacheSize,168,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:215,Performance,cache,cache,215,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp:346,Performance,Cache,CacheSize,346,"// On every indirect call we call a run-time function; // __sanitizer_cov_indir_call* with two parameters:; // - callee address,; // - global cache array that contains CacheSize pointers (zero-initialized).; // The cache is used to speed up recording the caller-callee pairs.; // The address of the caller is passed implicitly via caller PC.; // CacheSize is encoded in the name of the run-time function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/SanitizerCoverage.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:691,Performance,Optimiz,Optimizations,691,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:35,Safety,detect,detector,35,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:430,Safety,detect,detector,430,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:718,Safety,avoid,avoid,718,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:677,Security,access,access,677,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:750,Security,access,accesses,750,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:562,Testability,test,test,562,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:610,Usability,simpl,simple,610,"//===-- ThreadSanitizer.cpp - race detector -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file is a part of ThreadSanitizer, a race detector.; //; // The tool is under development, for the details about previous versions see; // http://code.google.com/p/data-race-test; //; // The instrumentation phase is quite simple:; // - Insert calls to run-time library before every memory access.; // - Optimizations may apply to avoid instrumenting some of the accesses.; // - Insert calls at function entry/exit.; // The rest is handled by the run-time library.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:24,Integrability,wrap,wrapper,24,// Internal Instruction wrapper that contains more information about the; // Instruction from prior analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:22,Energy Efficiency,power,powers,22,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:3,Security,Access,Accesses,3,"// Accesses sizes are powers of two: 1, 2, 4, 8, 16.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:21,Security,access,accesses,21,// Do not instrument accesses from different address spaces; we cannot deal; // with them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,Availability,redundant,redundant,52,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:164,Modifiability,variab,variables,164,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:275,Performance,optimiz,optimizations,275,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:52,Safety,redund,redundant,52,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:29,Security,access,accesses,29,"// Instrumenting some of the accesses may be proven redundant.; // Currently handled:; // - read-before-write (within same BB, no calls between); // - not captured variables; //; // We do not handle some of the patterns that should not survive; // after the classic compiler optimizations.; // E.g. two reads from the same temp should be eliminated by CSE,; // two writes should be eliminated by DSE, etc.; //; // 'Local' is a vector of insns within the same BB (no calls between).; // 'All' is a vector of insns that will be instrumented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:30,Security,access,accesses,30,"// If we distinguish volatile accesses and if either the read or write; // is volatile, do not omit any instrumentation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:7,Modifiability,variab,variable,7,"// The variable is addressable but not captured, so it cannot be; // referenced from a different thread and participate in a data race; // (see llvm/Analysis/CaptureTracking.h for details).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:25,Integrability,synchroniz,synchronization,25,// TODO: Ask TTI whether synchronization scope is between threads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:38,Performance,load,loads,38,"// Traverse all instructions, collect loads/stores/returns, check for calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:123,Modifiability,variab,variables,123,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:25,Performance,load,loads,25,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,Security,access,accesses,68,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:181,Security,access,accesses,181,"// We have collected all loads and stores.; // FIXME: many of these accesses do not need to be checked for races; // (e.g. variables that do not escape, etc).; // Instrument memory accesses only if we want to report bugs in the function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:84,Integrability,synchroniz,synchronization,84,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:28,Security,access,accesses,28,// Instrument atomic memory accesses in any case (they can be used to; // implement synchronization).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:68,Security,access,accesses,68,// Instrument function entry/exit points if there were instrumented accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:541,Safety,avoid,avoid,541,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:254,Usability,simpl,simply,254,"// If a memset intrinsic gets inlined by the code gen, we will miss races on it.; // So, we either need to ensure the intrinsic is not inlined, or instrument it.; // We do not instrument memset/memmove/memcpy intrinsics (too complicated),; // instead we simply replace them with regular function calls, which are then; // intercepted by the run-time.; // Since tsan is running after everyone else, the calls should not be; // replaced back with intrinsics. If that becomes wrong at some point,; // we will need to call e.g. __tsan_memset to avoid the intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:155,Availability,avail,available,155,"// Both llvm and ThreadSanitizer atomic operations are based on C++11/C1x; // standards. For background see C++11 standard. A slightly older, publicly; // available draft of the standard (not entirely up-to-date, but close enough; // for casual browsing) is available here:; // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf; // The following page contains more background information:; // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp:258,Availability,avail,available,258,"// Both llvm and ThreadSanitizer atomic operations are based on C++11/C1x; // standards. For background see C++11 standard. A slightly older, publicly; // available draft of the standard (not entirely up-to-date, but close enough; // for casual browsing) is available here:; // http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf; // The following page contains more background information:; // http://www.hpl.hp.com/personal/Hans_Boehm/c++mm/",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ThreadSanitizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:6,Modifiability,plugin,plugin-based,6,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:59,Modifiability,Plugin,Plugin,59,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:83,Modifiability,plugin,plugin,83,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:193,Modifiability,plugin,plugin,193,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:400,Modifiability,plugin,plugin,400,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:468,Modifiability,Plugin,Plugins,468,"/// A plugin-based class that takes an arbitrary number of Plugin types.; /// Each plugin type must satisfy the following API:; /// 1) the constructor must take a `Function &f`. Typically, the plugin would; /// scan the function looking for candidates.; /// 2) contain a member function with the following signature and name:; /// void run(std::vector<CandidateInfo> &Candidates);; /// such that the plugin would append its result into the vector parameter.; ///; /// Plugins are defined in ValueProfilePlugins.inc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:13,Modifiability,Plugin,PluginChainFinal,13,/// The type PluginChainFinal is the final chain of plugins that will be used by; /// ValueProfileCollectorImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:52,Modifiability,plugin,plugins,52,/// The type PluginChainFinal is the final chain of plugins that will be used by; /// ValueProfileCollectorImpl.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:58,Modifiability,inherit,inherits,58,// end anonymous namespace; /// ValueProfileCollectorImpl inherits the API of PluginChainFinal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp:78,Modifiability,Plugin,PluginChainFinal,78,// end anonymous namespace; /// ValueProfileCollectorImpl inherits the API of PluginChainFinal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h:1182,Modifiability,plugin,plugin,1182,"/// Utility analysis that determines what values are worth profiling.; /// The actual logic is inside the ValueProfileCollectorImpl, whose job is to; /// populate the Candidates vector.; ///; /// Value profiling an expression means to track the values that this expression; /// takes at runtime and the frequency of each value.; /// It is important to distinguish between two sets of value profiles for a; /// particular expression:; /// 1) The set of values at the point of evaluation.; /// 2) The set of values at the point of use.; /// In some cases, the two sets are identical, but it's not unusual for the two; /// to differ.; ///; /// To elaborate more, consider this C code, and focus on the expression `nn`:; /// void foo(int nn, bool b) {; /// if (b) memcpy(x, y, nn);; /// }; /// The point of evaluation can be as early as the start of the function, and; /// let's say the value profile for `nn` is:; /// total=100; (value,freq) set = {(8,10), (32,50)}; /// The point of use is right before we call memcpy, and since we execute the; /// memcpy conditionally, the value profile of `nn` can be:; /// total=15; (value,freq) set = {(8,10), (4,5)}; ///; /// For this reason, a plugin is responsible for computing the insertion point; /// for each value to be profiled. The `CandidateInfo` structure encapsulates; /// all the information needed for each value profile site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h:86,Testability,log,logic,86,"/// Utility analysis that determines what values are worth profiling.; /// The actual logic is inside the ValueProfileCollectorImpl, whose job is to; /// populate the Candidates vector.; ///; /// Value profiling an expression means to track the values that this expression; /// takes at runtime and the frequency of each value.; /// It is important to distinguish between two sets of value profiles for a; /// particular expression:; /// 1) The set of values at the point of evaluation.; /// 2) The set of values at the point of use.; /// In some cases, the two sets are identical, but it's not unusual for the two; /// to differ.; ///; /// To elaborate more, consider this C code, and focus on the expression `nn`:; /// void foo(int nn, bool b) {; /// if (b) memcpy(x, y, nn);; /// }; /// The point of evaluation can be as early as the start of the function, and; /// let's say the value profile for `nn` is:; /// total=100; (value,freq) set = {(8,10), (32,50)}; /// The point of use is right before we call memcpy, and since we execute the; /// memcpy conditionally, the value profile of `nn` can be:; /// total=15; (value,freq) set = {(8,10), (4,5)}; ///; /// For this reason, a plugin is responsible for computing the insertion point; /// for each value to be profiled. The `CandidateInfo` structure encapsulates; /// all the information needed for each value profile site.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Instrumentation/ValueProfileCollector.h
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:65,Safety,avoid,avoids,65,// Remember to try and delete this function afterward. This both avoids; // re-walking the rest of the module and avoids dealing with any; // iterator invalidation issues while deleting functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:114,Safety,avoid,avoids,114,// Remember to try and delete this function afterward. This both avoids; // re-walking the rest of the module and avoids dealing with any; // iterator invalidation issues while deleting functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:13,Integrability,interface,interface,13,/// Main run interface method. We override here to avoid calling skipSCC().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp:51,Safety,avoid,avoid,51,/// Main run interface method. We override here to avoid calling skipSCC().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AlwaysInliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:1271,Modifiability,config,configured,1271,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:630,Performance,load,loaded,630,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:1014,Performance,load,loaded,1014,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:749,Usability,simpl,simplification,749,"//===- ArgumentPromotion.cpp - Promote by-reference arguments -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass promotes ""by reference"" arguments to be ""by value"" arguments. In; // practice, this means looking for internal functions that have pointer; // arguments. If it can prove, through the use of alias analysis, that an; // argument is *only* loaded, then it can pass the value into the function; // instead of the address of the value. This can cause recursive simplification; // of code and lead to the elimination of allocas (especially in C++ template; // code like the STL).; //; // This pass also handles aggregate arguments that are passed into a function,; // scalarizing them if the elements of the aggregate are only loaded. Note that; // by default it refuses to scalarize aggregates which would require passing in; // more than three operands to the function, because passing thousands of; // operands for a large array or structure is unprofitable! This limit can be; // configured or disabled, however.; //; // Note that this transformation could also be done for arguments that are only; // stored to (returning the value instead), but does not currently. This case; // would be best handled when and if LLVM begins supporting multiple return; // values from functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:41,Performance,load,load,41,/// A representative guaranteed-executed load or store instruction for use by; /// metadata transfer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:39,Performance,perform,performs,39,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:163,Safety,safe,safe,163,"/// DoPromotion - This method actually performs the promotion of the specified; /// arguments, and returns the new function. At this point, we know that it's; /// safe to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:93,Performance,load,loaded,93,"// Loop over all the callers of the function, transforming the call sites to; // pass in the loaded pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:45,Performance,load,loads,45,"// Loop over the operands, inserting GEP and loads in the caller as; // appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:155,Performance,load,loads,155,"// Only transfer poison-generating metadata if we also have; // !noundef.; // TODO: Without !noundef, we could merge this metadata across; // all promoted loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:118,Performance,load,loads,118,// Cleanup the code from the dead instructions: GEPs and BitCasts in between; // the original argument and its users: loads and stores. Retarget every; // user to the new created alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:36,Safety,safe,safe,36,"/// Determine that this argument is safe to promote, and find the argument; /// parts it can be promoted into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:57,Performance,load,loads,57,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:132,Performance,load,loaded,132,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:224,Performance,load,load,224,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:290,Performance,load,load,290,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:426,Performance,load,loads,426,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:508,Performance,load,loads,508,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:577,Performance,load,load,577,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:187,Safety,safe,safe,187,"// We can only promote this argument if all the uses are loads at known; // offsets.; //; // Promoting the argument causes it to be loaded in the caller; // unconditionally. This is only safe if we can prove that either the load; // would have happened in the callee anyway (ie, there is a load in the entry; // block) or the pointer passed in at every call site is guaranteed to be; // valid.; // In the former case, invalid loads can happen, but would have happened; // anyway, in the latter case, invalid loads won't happen. This prevents us; // from introducing an invalid load that wouldn't have happened in the; // original code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:42,Performance,load,load,42,"// An end user of a pointer argument is a load or store instruction.; // Returns std::nullopt if this load or store is not based on the argument.; // Return true if we can promote the instruction, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:102,Performance,load,load,102,"// An end user of a pointer argument is a load or store instruction.; // Returns std::nullopt if this load or store is not based on the argument.; // Return true if we can promote the instruction, false otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:24,Performance,scalab,scalable,24,// Don't try to promote scalable types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:28,Performance,load,loading,28,"// For now, we only support loading/storing one specific type at a given; // offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:79,Performance,load,load,79,"// If this instruction is not guaranteed to execute, and we haven't seen a; // load or store at this offset before (or it had lower alignment), then we; // need to remember that requirement.; // Note that skipping instructions of previously seen offsets is only; // correct because we only allow a single type for a given offset, which; // also means that the number of accessed bytes will be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:370,Security,access,accessed,370,"// If this instruction is not guaranteed to execute, and we haven't seen a; // load or store at this offset before (or it had lower alignment), then we; // need to remember that requirement.; // Note that skipping instructions of previously seen offsets is only; // correct because we only allow a single type for a given offset, which; // also means that the number of accessed bytes will be the same.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:12,Performance,load,loads,12,// Look for loads and stores that are guaranteed to execute on entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:19,Performance,load,loads,19,// Now look at all loads of the argument. Remember the load instructions; // for the aliasing check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:55,Performance,load,load,55,// Now look at all loads of the argument. Remember the load instructions; // for the aliasing check below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:90,Performance,load,load,90,"// If store instructions are allowed, the path from the entry of the function; // to each load may be not free of instructions that potentially invalidate; // the load, and this is an admissible situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:163,Performance,load,load,163,"// If store instructions are allowed, the path from the entry of the function; // to each load may be not free of instructions that potentially invalidate; // the load, and this is an admissible situation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:55,Performance,load,load,55,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:112,Performance,perform,perform,112,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:266,Performance,load,load,266,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:88,Safety,safe,safe,88,"// Okay, now we know that the argument is only used by load instructions, and; // it is safe to unconditionally perform all of them. Use alias analysis to; // check to see if the pointer is guaranteed to not be modified from entry of; // the function to each of the load instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:23,Performance,load,load,23,// Check to see if the load is invalidated from the start of the block to; // the load itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:82,Performance,load,load,82,// Check to see if the load is invalidated from the start of the block to; // the load itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:80,Performance,load,load,80,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:122,Performance,perform,perform,122,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:183,Performance,load,loading,183,"// Pointer is invalidated!; // Now check every path from the entry block to the load for transparency.; // To do this, we perform a depth first search on the inverse CFG from the; // loading block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:54,Performance,load,load,54,"// If the path from the entry of the function to each load is free of; // instructions that potentially invalidate the load, we can make the; // transformation!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:119,Performance,load,load,119,"// If the path from the entry of the function to each load is free of; // instructions that potentially invalidate the load, we can make the; // transformation!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:128,Safety,safe,safe,128,"/// PromoteArguments - This method checks the specified function to see if there; /// are any promotable arguments and if it is safe to promote the function (for; /// example, all callers are direct). If safe to promote some arguments, it; /// calls the DoPromotion method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:204,Safety,safe,safe,204,"/// PromoteArguments - This method checks the specified function to see if there; /// are any promotable arguments and if it is safe to promote the function (for; /// example, all callers are direct). If safe to promote some arguments, it; /// calls the DoPromotion method.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:9,Performance,perform,perform,9,// Don't perform argument promotion for naked functions; otherwise we can end; // up removing parameters that are seemingly 'not used' as they are referred; // to in the assembly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:95,Integrability,depend,depending,95,"// Don't transform functions that receive inallocas, as the transformation may; // not be safe depending on calling convention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:90,Safety,safe,safe,90,"// Don't transform functions that receive inallocas, as the transformation may; // not be safe depending on calling convention.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:45,Energy Efficiency,reduce,reduces,45,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:78,Safety,avoid,avoiding,78,// Replace sret attribute with noalias. This reduces register pressure by; // avoiding a register copy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:194,Deployability,update,updates,194,"// Directly substitute the functions in the call graph. Note that this; // requires the old function to be completely dead and completely; // replaced by the new function. It does no call graph updates, it merely; // swaps out the particular function mapped to a particular node in the; // graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp:9,Usability,clear,cleared,9,// We've cleared out analyses for deleted functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ArgumentPromotion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:389,Availability,down,down,389,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:306,Modifiability,evolve,evolved,306,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:322,Performance,perform,perform,322,"// TODO: Determine a good default value.; //; // In the LLVM-TS and SPEC2006, 32 seems to not induce compile time overheads; // (when run with the first 5 abstract attributes). The results also indicate; // that we never reach 32 iterations but always find a fixpoint sooner.; //; // This will become more evolved once we perform two interleaved fixpoint; // iterations: bottom-up and top-down.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:4,Testability,Log,Logic,4,/// Logic operators for the change status enum class.; ///; ///{,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:157,Integrability,depend,dependences,157,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:121,Safety,abort,abort,121,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:138,Safety,avoid,avoid,138,// Containers to remember the pointer infos and new copies while we are not; // sure that we can find all of them. If we abort we want to avoid spurious; // dependences and potential copies in the provided container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:99,Performance,optimiz,optimize,99,// A null pointer access can be undefined but any offset from null may; // be OK. We do not try to optimize the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Security,access,access,18,// A null pointer access can be undefined but any offset from null may; // be OK. We do not try to optimize the latter.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:76,Integrability,depend,dependences,76,// Only if we were successful collection all potential copies we record; // dependences (on non-fix AAPointerInfo AAs). We also only then modify the; // given PotentialCopies container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:348,Safety,avoid,avoid,348,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:290,Security,access,accessible,290,"// We know kernels (generally) cannot be called from within the module. Thus,; // for reachability we would need to step back from a kernel which would allow; // us to reach anything anyway. Even if a kernel is invoked from another; // kernel, values like allocas and shared memory are not accessible. We; // implicitly check for this situation to avoid costly lookups.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:261,Performance,perform,perform,261,"// If we can go arbitrarily backwards we will eventually reach an entry point; // that can reach ToI. Only if a set of blocks through which we cannot go is; // provided, or once we track internal functions not accessible from the; // outside, it makes sense to perform backwards analysis in the absence of a; // GoBackwardsCB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:210,Security,access,accessible,210,"// If we can go arbitrarily backwards we will eventually reach an entry point; // that can reach ToI. Only if a set of blocks through which we cannot go is; // provided, or once we track internal functions not accessible from the; // outside, it makes sense to perform backwards analysis in the absence of a; // GoBackwardsCB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Testability,Test,Test,3,// Test if the underlying call site operand is argument number u of the; // callback callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:128,Availability,avail,available,128,"// If no callbacks were found, or none used the underlying call site operand; // exclusively, use the direct callee argument if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:179,Usability,simpl,simplified,179,"// First check all callbacks provided by outside AAs. If any of them returns; // a non-null value that is different from the associated value, or; // std::nullopt, we assume it's simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:28,Usability,simpl,simplification,28,"// If no high-level/outside simplification occurred, use; // AAPotentialValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Energy Efficiency,allocate,allocated,31,"// The abstract attributes are allocated via the BumpPtrAllocator Allocator,; // thus we cannot delete them. We can, and want to, destruct them though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:20,Performance,cache,cache,20,// TODO: Maintain a cache of Values that are; // on the pathway from a Argument to a Instruction that would effect the; // liveness/return state etc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:165,Deployability,update,updates,165,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,Integrability,depend,dependent,30,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:65,Integrability,depend,dependence,65,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:102,Integrability,depend,dependence,102,"// For invalid AAs we can fix dependent AAs that have a required dependence,; // thereby folding long dependence chains in a single step without the need; // to run updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:13,Integrability,depend,dependences,13,// Check the dependences to fast track invalidation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:52,Integrability,depend,dependent,52,// Add all abstract attributes that are potentially dependent on one that; // changed to the work list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Update,Update,3,// Update all abstract attribute in the work list and record the ones that; // changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:97,Deployability,update,updates,97,// Use the InvalidAAs vector to propagate invalid states fast transitively; // without requiring updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:90,Integrability,depend,dependent,90,// Reset the work list and repopulate with the changed abstract attributes.; // Note that dependent ones are added above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:207,Integrability,depend,depending,207,"// Reset abstract arguments not settled in a sound fixpoint by now. This; // happens when we stopped the fixpoint iteration early. Note that only the; // ones marked as ""changed"" *and* the ones transitively depending on them; // need to be reverted to a pessimistic state. Others might not be in a; // fixpoint state but we can use the optimistic results for them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:193,Integrability,depend,dependent,193,"// If there is not already a fixpoint reached, we can now take the; // optimistic state. This is correct because we enforced a pessimistic one; // on abstract attributes that were transitively dependent on a changed one; // already above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:6,Safety,avoid,avoid,6,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:26,Testability,assert,assertion,26,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:135,Testability,assert,assertion,135,// To avoid triggering an assertion in the lazy call graph we will not delete; // any internal library functions. We should modify the assertion though and; // allow internals to be deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:30,Safety,avoid,avoid,30,// Delete stuff at the end to avoid invalid references and a nice order.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:41,Deployability,update,update,41,// If we plan to replace NewV we need to update it at this point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:9,Modifiability,rewrite,rewrite,9,"// If we rewrite a return and the new value is not an argument, strip the; // `returned` attribute as it is wrong now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the functions as requested during manifest.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:40,Deployability,update,update,40,// Use a new dependence vector for this update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:13,Integrability,depend,dependence,13,// Use a new dependence vector for this update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:58,Integrability,depend,dependence,58,"// Verify the stack was used properly, that is we pop the dependence vector we; // put there earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:34,Integrability,wrap,wrapper,34,// Move the COMDAT section to the wrapper.; // TODO: Check if we need to keep it for F as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:26,Integrability,wrap,wrapper,26,// Create the call in the wrapper.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:76,Modifiability,rewrite,rewrite,76,// Forbid the call site to cast the function return type. If we need to; // rewrite these functions we need to re-create a cast for the new call site; // (if the old had uses).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid var-arg functions for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid functions with complicated argument passing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Safety,Avoid,Avoid,3,// Avoid callbacks for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:36,Modifiability,rewrite,rewrites,36,// Deleted functions do not require rewrites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Patch,Patch,3,// Patch the pointer to LLVM function in debug info descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:20,Testability,assert,assert,20,// only used inside assert.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:44,Availability,repair,repair,44,// TODO: Exose the attribute set to the ACS repair callback,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:160,Performance,cache,cache,160,"// As we do not modify the function here we can remove the const; // withouth breaking implicit assumptions. At the end of the day, we could; // initialize the cache eagerly which would look the same to the users.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:138,Deployability,update,update,138,// Walk all instructions to find interesting instructions that might be; // queried by abstract attributes during their initialization or update.; // This has to happen before we create attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:184,Performance,cache,cache,184,// To allow easy access to all instructions in a function with a given; // opcode we store them in the InfoCache. As not all opcodes are interesting; // to concrete attributes we only cache the ones that are as identified in; // the following switch.; // Note: There are no concrete attributes now so this is initially empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:17,Security,access,access,17,// To allow easy access to all instructions in a function with a given; // opcode we store them in the InfoCache. As not all opcodes are interesting; // to concrete attributes we only cache the ones that are as identified in; // the following switch.; // Note: There are no concrete attributes now so this is initially empty.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:49,Performance,load,loads,49,// The alignment of a pointer is interesting for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Energy Efficiency,allocate,allocated,31,"// The instruction vectors are allocated using a BumpPtrAllocator, we need to; // manually destroy them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Deployability,update,update,27,"// If we are outside of an update, thus before the actual fixpoint iteration; // started (= when we create AAs), we do not track dependences because we will; // put all AAs into the initial worklist anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:129,Integrability,depend,dependences,129,"// If we are outside of an update, thus before the actual fixpoint iteration; // started (= when we create AAs), we do not track dependences because we will; // put all AAs into the initial worklist anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:78,Safety,detect,detection,78,// Check for dead BasicBlocks in every function.; // We need dead instruction detection because we do not want to deal with; // broken IR in which SSA rules do not apply.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Usability,simpl,simplified,27,// Every function might be simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:80,Integrability,interface,interface,80,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:27,Usability,simpl,simplified,27,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:136,Usability,simpl,simplification,136,// Every argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:65,Usability,simpl,simplify,65,// TODO: Even if the callee is not known now we might be able to simplify; // the call/callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:84,Integrability,interface,interface,84,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:31,Usability,simpl,simplified,31,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:140,Usability,simpl,simplification,140,// Call site argument might be simplified. We have to go through the; // Attributor interface though as outside AAs can register custom; // simplification callbacks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:56,Performance,cache,cache,56,// Create an Attributor and initially empty information cache that is filled; // while we identify default attribute opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:18,Integrability,wrap,wrappers,18,// Create shallow wrappers for all functions that are not IPO amendable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:135,Integrability,interface,interface,135,"// Internalize non-exact functions; // TODO: for now we eagerly internalize functions without calculating the; // cost, we need a cost interface to determine whether internalizing; // a function is ""beneficial""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Deployability,Update,Update,3,// Update call graph,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:105,Performance,cache,cache,105,// Populate the Attributor with abstract attribute opportunities in the; // function and the information cache with IR information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:56,Performance,cache,cache,56,// Create an Attributor and initially empty information cache that is filled; // while we identify default attribute opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:105,Performance,cache,cache,105,// Populate the Attributor with abstract attribute opportunities in the; // function and the information cache with IR information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp:3,Performance,Cache,CachedOnly,3,/* CachedOnly */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Attributor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Integrability,depend,dependence,14,// Only track dependence if we are going to use the assumed info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:25,Integrability,bridg,bridge,25,/// This function is the bridge between argument position and the call base; /// context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,"// If possible, use the hasAssumedIRAttr interface.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:49,Security,Access,Access,49,// namespace AA; /// Helper for AA::PointerInfo::Access DenseMap/Set usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,Access,Access,32,/// Helper for AA::PointerInfo::Access DenseMap/Set usage ignoring everythign; /// but the instruction,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Security,Access,Access,14,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:86,Security,access,access,86,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:186,Security,Access,Access,186,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:347,Security,access,access,347,"/// Add a new Access to the state at offset \p Offset and with size \p Size.; /// The access is associated with \p I, writes \p Content (if anything), and; /// is of kind \p Kind. If an Access already exists for the same \p I and same; /// \p RemoteI, the two are combined, potentially losing information about; /// offset and size. The resulting access must now be moved from its original; /// OffsetBin to the bin for its new offset.; ///; /// \Returns CHANGED, if the state changed, UNCHANGED otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,Access,Access,42,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:87,Security,Access,Access,87,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:181,Security,Access,Access,181,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:228,Security,Access,Access,228,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:277,Security,access,accesses,277,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:520,Security,access,accesses,520,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:575,Security,Access,Access,575,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:651,Security,Access,Access,651,"// Every memory instruction results in an Access object. We maintain a list of; // all Access objects that we own, along with the following maps:; //; // - OffsetBins: RangeTy -> { Access }; // - RemoteIMap: RemoteI x LocalI -> Access; //; // A RemoteI is any instruction that accesses memory. RemoteI is different; // from LocalI if and only if LocalI is a call; then RemoteI is some; // instruction in the callgraph starting from LocalI. Multiple paths in the; // callgraph from LocalI to RemoteI may produce multiple accesses, but these; // are all combined into a single Access object. This may result in loss of; // information in RangeTy in the Access object.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,access,23,"// Check if we have an access for this instruction, if not, simply add it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:60,Usability,simpl,simply,60,"// Check if we have an access for this instruction, if not, simply add it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Deployability,update,update,61,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Security,Access,Access,19,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:44,Security,Access,Access,44,"// Combine the new Access with the existing Access, and then update the; // mapping in the offset bins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,// Ranges that are in the old access but not the new access need to be removed; // from the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,// Ranges that are in the old access but not the new access need to be removed; // from the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,// Ranges that are in the new access but not the old access need to be added; // to the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,// Ranges that are in the new access but not the old access need to be added; // to the offset bins.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Performance,load,load,108,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:262,Performance,load,load,262,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:286,Performance,load,load,286,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:339,Performance,load,load,339,"// If the function is not ending in aligned barriers, we need the stores to; // be in aligned barriers. The load being in one is not sufficient since the; // store might be executed by a thread that disappears after, causing the; // aligned barrier guarding the load to unblock and the load to read a value; // that has no CFG path to the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:341,Security,access,access,341,"// Helper to determine if we need to consider threading, which we cannot; // right now. However, if the function is (assumed) nosync or the thread; // executing all instructions is the main thread only we can ignore; // threading. Also, thread-local objects do not require threading reasoning.; // Finally, we can ignore threading if either access is executed in an; // aligned region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:126,Safety,avoid,avoid,126,"// Helper to determine if the access is executed by the same thread as the; // given instruction, for now it is sufficient to avoid any potential; // threading effects as we cannot deal with them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:30,Security,access,access,30,"// Helper to determine if the access is executed by the same thread as the; // given instruction, for now it is sufficient to avoid any potential; // threading effects as we cannot deal with them anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,accesses,10,// Set of accesses/instructions that will overwrite the result and are; // therefore blockers in the reachability traversal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:51,Security,access,accesses,51,// If the object has kernel lifetime we can ignore accesses only reachable; // by other kernels. For now we only skip accesses *in* other kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:118,Security,access,accesses,118,// If the object has kernel lifetime we can ignore accesses only reachable; // by other kernels. For now we only skip accesses *in* other kernels.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Security,access,accesses,28,// Track if all interesting accesses are in the same `nosync` function as; // the given instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:55,Security,access,access,55,// Helper to determine if we can skip a specific write access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:20,Integrability,depend,dependences,20,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:48,Integrability,depend,dependences,48,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:148,Security,access,access,148,"// Check read (RAW) dependences and write (WAR) dependences as necessary.; // If we successfully excluded all effects we are interested in, the; // access can be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:39,Security,access,access,39,"// If the instruction cannot reach the access, the former does not; // interfere with what the access reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:95,Security,access,access,95,"// If the instruction cannot reach the access, the former does not; // interfere with what the access reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:47,Security,access,access,47,"// If the instruction cannot be reach from the access, the latter does not; // interfere with what the instruction reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:505,Deployability,update,updated,505,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Security,access,access,53,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:185,Security,access,access,185,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:442,Security,access,access,442,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:636,Security,access,access,636,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:699,Security,access,access,699,"// If we still might be affected by the write of the access but there are; // dominating writes in the function of the instruction; // (HasBeenWrittenTo), we can try to reason that the access is overwritten; // by them. This would have happend above if they are all in the same; // function, so we only check the inter-procedural case. Effectively, we; // want to show that there is no call after the dominting write that might; // reach the access, and when it returns reach the instruction with the; // updated value. To this end, we iterate all call sites, check if they; // might reach the instruction without going through another access; // (ExclusionSet) and at the same time might reach the access. However,; // that is all part of AAInterFnReachability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,Security,access,access,62,"// Without going backwards in the call tree, can we reach the access; // from the least dominating write. Do not allow to pass the instruction; // itself either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,accesses,32,// Run the user callback on all accesses we cannot skip and return if; // that succeeded for all or not.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,accesses,15,// Combine the accesses bin by bin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,accesses,15,// Combine the accesses bin by bin.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,Security,access,access,17,/// Deal with an access and signal if it was handled successfully.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Security,access,access,19,// Add the element access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:141,Deployability,update,updated,141,"/// If the indices to \p GEP can be traced to constants, incorporate all; /// of these into \p UsrOI.; ///; /// \return true iff \p UsrOI is updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,Variab,VariableOffsets,14,"// Each VI in VariableOffsets has a set of potential constant values. Every; // combination of elements, picked one each from these sets, is separately; // added to the original set of offsets, thus resulting in more offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Usability,simpl,simply,16,"// One does not simply walk into a map and assign a reference to a possibly; // new location. That can cause an invalidation before the assignment; // happens, like so:; //; // OffsetInfoMap[Usr] = OffsetInfoMap[CurPtr]; /* bad idea! */; //; // The RHS is a reference that may be invalidated by an insertion caused by; // the LHS. So we ensure that the side-effect of the LHS happens first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,access,32,"// Note the order here, the Usr access might change the map, CurPtr is; // already in it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:32,Security,access,access,32,"// Note the order here, the Usr access might change the map, CurPtr is; // already in it though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:35,Integrability,depend,dependent,35,"// Check if the PHI operand is not dependent on the PHI itself. Every; // recurrence is a cyclic net of PHIs in the data flow, and has an; // equivalent Cycle in the control flow. One of those PHIs must be in the; // header of that control flow Cycle. This is independent of the choice of; // Cycles reported by CycleInfo. It is sufficient to check the PHIs in; // every Cycle header; if such a node is marked unknown, this will; // eventually propagate through the whole net of PHIs in the recurrence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,"// If the access is to a pointer that may or may not be the associated; // value, e.g. due to a PHI, we cannot assume it will be read.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:35,Performance,load,load,35,// Check if the assumption and the load are executed together without; // memory modification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:56,Performance,load,load,56,// Check if we found an assumption associated with this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,"// If the access is to a pointer that may or may not be the associated; // value, e.g. due to a PHI, we cannot assume it will be written.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:141,Security,access,accessed,141,"// We handle memory intrinsics explicitly, at least the first (=; // destination) and second (=source) arguments as we know how they are; // accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Deployability,update,updateImpl,28,/// See Abstract Attribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:116,Safety,avoid,avoid,116,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,"// We need to follow common pointer manipulation uses to the accesses they; // feed into. We can try to be smart to avoid looking through things we do not; // like for now, e.g., non-inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:74,Integrability,depend,dependences,74,// As long as we only use known information there is no need to track; // dependences here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:305,Deployability,update,update,305,"// If we know all call sites and all are known no-recurse, we are done.; // If all known call sites, which might not be all that exist, are known; // to be no-recurse, we are not done but we can continue to assume; // no-recurse. If one of the call sites we have not visited will become; // live, another update is triggered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).; // through a pointer (i.e. also branches etc.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,"// If we reach here, we know we have an instruction; // that accesses memory through a pointer operand,; // for which getPointerOperand() should give it to us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Security,access,access,12,// A memory access through a pointer is considered UB; // only if the pointer has constant null value.; // TODO: Expand it to not only check constant values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Security,access,access,12,// A memory access using constant null pointer is only considered UB; // if null pointer is _not_ defined for the target platform.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:38,Usability,simpl,simplified,38,"// If current argument is known to be simplified to null pointer and the; // corresponding argument position is known to have nonnull attribute,; // the argument is poison. Furthermore, if the argument is poison and; // the position is known to have noundef attriubte, this callsite is; // considered UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:127,Usability,Simpl,Simplified,127,"// Here, we handle three cases.; // (1) Not having a value means it is dead. (we can replace the value; // with undef); // (2) Simplified to undef. The argument violate noundef attriubte.; // (3) Simplified to null pointer where known to be nonnull.; // The argument is a poison value and violate noundef attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:196,Usability,Simpl,Simplified,196,"// Here, we handle three cases.; // (1) Not having a value means it is dead. (we can replace the value; // with undef); // (2) Simplified to undef. The argument violate noundef attriubte.; // (3) Simplified to null pointer where known to be nonnull.; // The argument is a poison value and violate noundef attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Usability,simpl,simplified,80,"// Either we stopped and the appropriate action was taken,; // or we got back a simplified return value to continue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:290,Usability,simpl,simplified,290,"// Check if a return instruction always cause UB or not; // Note: It is guaranteed that the returned position of the anchor; // scope has noundef attribute when this is called.; // We also ensure the return position is not ""assumed dead""; // because the returned value was then potentially simplified to; // `undef` in AAReturnedValues without removing the `noundef`; // attribute yet.; // When the returned position has noundef attriubte, UB occurs in the; // following cases.; // (1) Returned value is known to be undef.; // (2) The value is known to be a null pointer and the returned; // position has nonnull attribute (because the returned value is; // poison).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:235,Testability,test,test,235,"// In simple words, if an instruction is not in the assumed to _not_; // cause UB, then it is assumed UB (that includes those; // in the KnownUBInsts set). The rest is boilerplate; // is to ensure that it is one of the instructions we test; // for UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:6,Usability,simpl,simple,6,"// In simple words, if an instruction is not in the assumed to _not_; // cause UB, then it is assumed UB (that includes those; // in the KnownUBInsts set). The rest is boilerplate; // is to ensure that it is one of the instructions we test; // for UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:843,Deployability,update,updateImpl,843,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:1173,Deployability,update,update,1173,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Integrability,depend,depends,43,"/// Note: The correctness of this analysis depends on the fact that the; /// following 2 sets will stop changing after some point.; /// ""Change"" here means that their size changes.; /// The size of each set is monotonically increasing; /// (we only add items to them) and it is upper bounded by the number of; /// instructions in the processed function (we can never save more; /// elements in either set than this number). Hence, at some point,; /// they will stop increasing.; /// Consequently, at some point, both sets will have stopped; /// changing, effectively making the analysis reach a fixpoint.; /// Note: These 2 sets are disjoint and an instruction can be considered; /// one of 3 things:; /// 1) Known to cause UB (AAUndefinedBehavior could prove it) and put it in; /// the KnownUBInsts set.; /// 2) Assumed to cause UB (in every updateImpl, AAUndefinedBehavior; /// has a reason to assume it).; /// 3) Assumed to not cause UB. very other instruction - AAUndefinedBehavior; /// could not find a reason to assume or prove that it can cause UB,; /// hence it assumes it doesn't. We have a set for these instructions; /// so that we don't reprocess them in every update.; /// Note however that instructions in this set may cause UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Deployability,update,updates,23,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Integrability,depend,depends,89,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:301,Usability,simpl,simplified,301,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:476,Usability,simpl,simplified,476,"// Should be called on updates in which if we're processing an instruction; // \p I that depends on a value \p V, one of the following has to happen:; // - If the value is assumed, then stop.; // - If the value is known but undef, then consider it UB.; // - Otherwise, do specific processing with the simplified value.; // We return std::nullopt in the first 2 cases to signify that an appropriate; // action was taken and the caller should stop.; // Otherwise, we return the simplified value that the caller should; // use for specific processing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Integrability,depend,depend,9,// Don't depend on assumed values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:28,Testability,test,tested,28,"// If it is known (which we tested above) but it doesn't have a value,; // then we can assume `undef` and hence the instruction is UB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Availability,avail,available,37,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:204,Safety,detect,detect,204,"// If either SCEV or LoopInfo is not available for the function then we assume; // any cycle to be unbounded cycle.; // We use scc_iterator which uses Tarjan algorithm to find all the maximal; // SCCs.To detect if there's a cycle, we only need to find the maximal ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Security,hash,hash,16,/// Precomputed hash for this RQI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:83,Performance,cache,cache,83,/// Constructor replacement to ensure unique and stable sets are used for the; /// cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Performance,cache,cache,37,// Remove the temporary RQI from the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:11,Integrability,depend,depend,11,"// We only depend on liveness. DeadEdges is all we care about, check if any; // of them changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:79,Deployability,update,update,79,// Set of assumed dead blocks we used in the last query. If any changes we; // update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:78,Deployability,update,update,78,// Set of assumed dead edges we used in the last query. If any changes we; // update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:205,Deployability,update,updateImpl,205,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Integrability,synchroniz,synchronization,68,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:145,Integrability,synchroniz,synchronization,145,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:314,Integrability,synchroniz,synchronization,314,"// We have to make sure no-alias on the argument does not break; // synchronization when this is a callback argument, see also [1] below.; // If synchronization cannot be affected, we delegate to the base updateImpl; // function, otherwise we give up for now.; // If the function is no-sync, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:55,Integrability,synchroniz,synchronization,55,"// If the argument is read-only, no-alias cannot break synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Integrability,synchroniz,synchronization,80,"// If the argument is never passed through callbacks, no-alias cannot break; // synchronization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:53,Integrability,synchroniz,synchronization,53,"// TODO: add no-alias but make sure it doesn't break synchronization by; // introducing fake uses. See:; // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,; // International Workshop on OpenMP 2018,; // http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:121,Performance,Optimiz,Optimizations,121,"// TODO: add no-alias but make sure it doesn't break synchronization by; // introducing fake uses. See:; // [1] Compiler Optimizations for OpenMP, J. Doerfert and H. Finkel,; // International Workshop on OpenMP 2018,; // http://compilers.cs.uni-saarland.de/people/doerfert/par_opt18.pdf",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:59,Security,access,accesses,59,// If the argument is readnone we are done as there are no accesses via the; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:180,Deployability,update,update,180,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Integrability,depend,dependence,22,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Integrability,depend,dependent,89,// Explicitly set the dependence class to required because we want a long; // chain of N dependent instructions to be considered live as soon as one is; // without going through N update cycles. This is not required for; // correctness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:157,Performance,cache,cached,157,// If we are collecting assumes to be deleted we are in the manifest stage.; // It's problematic to collect the potential copies again now so we use the; // cached ones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Modifiability,Rewrite,Rewrite,9,// TODO: Rewrite the signature to return void?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:162,Performance,perform,performance,162,// We assume that all of BB is (probably) live now and if there are calls to; // internal functions we will assume that those are now live as well. This; // is a performance optimization for blocks with calls to a lot of internal; // functions. It can however cause dead functions to be treated as live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:174,Performance,optimiz,optimization,174,// We assume that all of BB is (probably) live now and if there are calls to; // internal functions we will assume that those are now live as well. This; // is a performance optimization for blocks with calls to a lot of internal; // functions. It can however cause dead functions to be treated as live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:114,Deployability,update,update,114,// Copy and clear the list of instructions we need to explore from. It is; // refilled with instructions the next update has to look at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Usability,clear,clear,12,// Copy and clear the list of instructions we need to explore from. It is; // refilled with instructions the next update has to look at.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,access,accessed,42,/// }; /// Helper function for collecting accessed bytes in must-be-executed-context,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:216,Availability,down,down,216,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:194,Usability,simpl,simply,194,"// If something was stripped but there is circular reasoning we look; // for the offset. If it is positive we basically decrease the; // dereferenceable bytes in a circular loop now, which will simply; // drive them down to the known value in a very slow way which we; // can accelerate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:61,Security,access,accesses,61,// We need to follow common pointer manipulation uses to the accesses they; // feed into.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:74,Integrability,depend,dependences,74,// As long as we only use known information there is no need to track; // dependences here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:99,Energy Efficiency,power,power,99,"// BasePointerAddr + Offset = Alignment * Q for some integer Q.; // So we can say that the maximum power of two which is a divisor of; // gcd(Offset, Alignment) is an alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:159,Safety,avoid,avoid,159,// TODO: Provide a helper to determine the implied ABI alignment and check in; // the existing manifest method and a new one for AAAlignImpl that value; // to avoid making the alignment explicit if it did not improve.; /// See AbstractAttribute::getDeducedAttributes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:99,Energy Efficiency,power,power,99,"// BasePointerAddr + Offset = Alignment * Q for some integer Q.; // So we can say that the maximum power of two which is a divisor of; // gcd(Offset, Alignment) is an alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:85,Integrability,depend,dependence,85,// We only take known information from the argument; // so we do not need to track a dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:174,Performance,load,loading,174,"// A function cannot capture state in memory if it only reads memory, it can; // however return/throw state and the state might be influenced by the; // pointer value, e.g., loading from a returned pointer might reveal a bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,update,27,/// Check the use \p U and update \p State accordingly. Return true if we; /// should continue to update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:98,Deployability,update,update,98,/// Check the use \p U and update \p State accordingly. Return true if we; /// should continue to update the state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:31,Testability,log,logic,31,"// For now we only use special logic for call sites. However, the tracker; // itself knows about a lot of other non-capturing cases already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,"/// Update \p State according to \p CapturedInMem, \p CapturedInInt, and; /// \p CapturedInRet, then return true if we should continue updating the; /// state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Usability,Simpl,Simplify,43,// namespace; /// ------------------ Value Simplify Attribute ----------------------------,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:136,Usability,Simpl,SimplifiedValue,136,/// Helper function for querying AAValueSimplify and updating candidate.; /// \param IRP The value position we are trying to unify with SimplifiedValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Integrability,synchroniz,synchronization,36,"// TODO: We probably need to verify synchronization is not an issue, e.g.,; // there is no race by not copying a constant byval.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Safety,avoid,avoids,108,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:127,Usability,simpl,simplified,127,"// Simplify the argument operand explicitly and check if the result is; // valid in the current scope. This avoids refering to simplified values; // in other functions, e.g., we don't want to say a an argument in a; // static function is actually an argument in a different function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Usability,simpl,simplified,88,// We queried AAValueSimplify for the returned values so they will be; // replaced if a simplified form was found. Nothing to do here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Deployability,update,update,36,"// If a candidate was found in this update, return CHANGED.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Safety,avoid,avoid,19,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:25,Usability,simpl,simplification,25,// TODO: We should avoid simplification duplication to begin with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Energy Efficiency,allocate,allocates,18,/// The call that allocates the memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Modifiability,rewrite,rewrite,22,/// The status wrt. a rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:39,Deployability,release,release,39,// Ensure we call the destructor so we release any memory allocated in the; // sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,Energy Efficiency,allocate,allocated,58,// Ensure we call the destructor so we release any memory allocated in the; // sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:171,Usability,simpl,simply,171,"// Initialize the alloca with the same value as used by the allocation; // function. We can skip undef as the initial value of an alloc is; // undef, and the memset would simply end up being DSEd.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:21,Deployability,update,update,21,// Flag to ensure we update our deallocation information at most once per; // updateImpl call and only if we use the free check reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:78,Deployability,update,updateImpl,78,// Flag to ensure we update our deallocation information at most once per; // updateImpl call and only if we use the free check reasoning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,accessible,23,"// If the stack is not accessible by other threads, the ""must-free"" logic; // doesn't apply as the pointer could be shared and needs to be places in; // ""shareable"" memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Testability,log,logic,68,"// If the stack is not accessible by other threads, the ""must-free"" logic; // doesn't apply as the pointer could be shared and needs to be places in; // ""shareable"" memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Deployability,update,update,14,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:65,Integrability,depend,depending,65,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:95,Performance,perform,perform,95,// The actual update starts here. We look at all allocations and depending on; // their status perform the appropriate check(s).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:116,Usability,clear,clear,116,"/// Identify the type we can chose for a private copy of the underlying; /// argument. std::nullopt means it is not clear yet, nullptr means there is; /// none.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Testability,stub,stub,89,/// Return a privatizable type that encloses both T0 and T1.; /// TODO: This is merely a stub for now as we should manage a mapping as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:77,Modifiability,rewrite,rewrite,77,"// If this is a byval argument and we know all the call sites (so we can; // rewrite them), there is no need to check them explicitly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:385,Deployability,patch,patch,385,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:122,Safety,safe,safe,122,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:241,Security,access,accesses,241,"// Make sure the associated call site argument has the same type at all call; // sites and it is an allocation we know is safe to privatize, for now that; // means we only allow alloca instructions.; // TODO: We can additionally analyze the accesses in the callee to create; // the type from that information instead. That is a little more; // involved and will be done in a follow up patch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Integrability,depend,dependence,7,// The dependence is optional so we don't give up once we give up on the; // alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Safety,Avoid,Avoid,3,// Avoid arguments with padding for now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,rewrite,rewrite,14,// Register a rewrite of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:37,Performance,load,loads,37,"// Traverse the type, build GEPs and loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:103,Performance,load,loads,103,// Query AAAlign attribute for alignment of associated argument to; // determine the best alignment of loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Availability,repair,repair,15,// Callback to repair the associated function. A new alloca is placed at the; // beginning and initialized with the values passed through arguments. The; // new alloca replaces the use of the old pointer argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Availability,repair,repair,15,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:108,Performance,load,loaded,108,// Callback to repair a call site of the associated function. The elements; // of the privatizable type are loaded prior to the call and passed to the; // new function version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Performance,load,load,42,"// When no alignment is specified for the load instruction,; // natural alignment is assumed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Modifiability,rewrite,rewrite,14,// Register a rewrite of the argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear existing attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:70,Modifiability,variab,variable,70,/// Return true if users of \p UserI might access the underlying; /// variable/location described by \p U and should therefore be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Security,access,access,43,/// Return true if users of \p UserI might access the underlying; /// variable/location described by \p U and should therefore be analyzed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,/// Update the state according to the effect of use \p U in \p UserI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Clear,Clear,3,// Clear conflicting writable attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,access,10,// Remove access kind modifiers if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:73,Safety,avoid,avoid,73,"// First, check the function scope. We take the known information and we avoid; // work if the assumed information implies the current assumed information for; // this attribute. This is a valid for all but byval arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:57,Performance,perform,perform,57,"// Droppable users, e.g., llvm::assume does not actually perform any action.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Performance,load,loaded,7,"// The loaded value is unrelated to the pointer argument, no need to; // follow the users of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:97,Performance,load,load,97,"// The loaded value is unrelated to the pointer argument, no need to; // follow the users of the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Performance,Load,Loads,3,// Loads cause the NO_READS property to disappear.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:23,Security,access,access,23,// Adjust the possible access behavior based on the information on the; // argument.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:22,Energy Efficiency,allocate,allocated,22,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Security,Access,AccessSets,7,"// The AccessSets are allocated via a BumpPtrAllocator, we call; // the destructor manually.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:236,Performance,perform,performance,236,// For internal functions we ignore `argmemonly` and; // `inaccessiblememorargmemonly` as we might break it via interprocedural; // constant propagation. It is unclear if this is the best way but it is; // unlikely this will cause real performance problems. If we are deriving; // attributes for the anchor function we even remove the attribute in; // addition to ignoring it.; // TODO: A better way to handle this would be to add ~NO_GLOBAL_MEM /; // MemoryEffects::Other as a possible location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:89,Security,access,access,89,// If we give up and indicate a pessimistic fixpoint this instruction will; // become an access for all potential access kinds:; // TODO: Add pointers for argmemonly and globals to improve the results of; // checkForAllAccessesToMemoryKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:114,Security,access,access,114,// If we give up and indicate a pessimistic fixpoint this instruction will; // become an access for all potential access kinds:; // TODO: Add pointers for argmemonly and globals to improve the results of; // checkForAllAccessesToMemoryKind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:106,Security,access,accesses,106,/// Helper struct to tie together an instruction that has a read or write; /// effect with the pointer it accesses (if any).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:36,Security,access,access,36,/// The instruction that caused the access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:29,Security,access,accessed,29,"/// The base pointer that is accessed, or null if unknown.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Security,access,access,16,/// The kind of access (read/write/read+write).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:109,Security,access,accesses,109,"/// Mapping from *single* memory location kinds, e.g., LOCAL_MEM with the; /// value of NO_LOCAL_MEM, to the accesses encountered for this memory kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:92,Deployability,update,update,92,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:54,Security,access,access,54,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Security,Access,AccessedLoc,76,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:113,Security,access,access,113,/// Categorize the pointer arguments of CB that might access memory in; /// AccessedLoc and update the state and access map accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:47,Security,access,accessed,47,/// Return the kind(s) of location that may be accessed by \p V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:15,Security,access,access,15,/// Return the access kind as determined by \p I.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:4,Deployability,Update,Update,4,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:85,Security,access,access,85,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:143,Security,access,access,143,/// Update the state \p State and the AccessKind2Accesses given that \p I is; /// an access of kind \p AK to a \p MLK memory location with the access; /// pointer \p Ptr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:94,Deployability,update,update,94,"/// Determine the underlying locations kinds for \p Ptr, e.g., globals or; /// arguments, and update the state and access map accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:115,Security,access,access,115,"/// Determine the underlying locations kinds for \p Ptr, e.g., globals or; /// arguments, and update the state and access map accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Energy Efficiency,allocate,allocate,12,/// Used to allocate access sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:21,Security,access,access,21,/// Used to allocate access sets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:46,Security,access,accesses,46,// TODO: recognize the TBAA used for constant accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Security,access,accesses,10,// Filter accesses to constant (GPU) memory if we have an AS at the access; // site or the object is known to actually have the associated AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:68,Security,access,access,68,// Filter accesses to constant (GPU) memory if we have an AS at the access; // site or the object is known to actually have the associated AS.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:65,Performance,perform,performed,65,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:270,Security,access,accessing,270,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:334,Security,access,accesses,334,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:392,Security,access,accesses,392,"// TODO: For now we do not treat byval arguments as local copies performed; // on the call edge, though, we should. To make that happen we need to; // teach various passes, e.g., DSE, about the copy effect of a byval. That; // would also allow us to mark functions only accessing byval arguments as; // readnone again, arguably their accesses have no effect outside of the; // function, like accesses to allocas.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:26,Security,access,accessed,26,// Categorize potentially accessed pointer arguments as if there was an; // access instruction with them as pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Security,access,access,76,// Categorize potentially accessed pointer arguments as if there was an; // access instruction with them as pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:42,Security,access,access,42,// First check if we assume any memory is access is visible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:43,Security,access,accessed,43,// Now handle global memory if it might be accessed. This is slightly tricky; // as NO_GLOBAL_MEM has multiple bits set.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:45,Security,access,accessed,45,// Now handle argument memory if it might be accessed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(Attributor &A).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:76,Modifiability,variab,variable,76,"// TODO: Make SCEV use Attributor assumption.; // We may be able to bound a variable range via assumptions in; // Attributor. ex.) If x is assumed to be in [1, 3] and y is known to; // evolve to x^2 + x, then we can say that y is in [2, 12].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:185,Modifiability,evolve,evolve,185,"// TODO: Make SCEV use Attributor assumption.; // We may be able to bound a variable range via assumptions in; // Attributor. ex.) If x is assumed to be in [1, 3] and y is known to; // evolve to x^2 + x, then we can say that y is in [2, 12].",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Integrability,Bridg,BridgeCallBaseContext,3,/* BridgeCallBaseContext */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Integrability,Bridg,BridgeCallBaseContext,3,/* BridgeCallBaseContext */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Performance,load,load,14,"// If it is a load instruction with range metadata, use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Deployability,update,update,88,// We can work with PHI and select instruction as we traverse their operands; // during update.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operand first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operand first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:88,Modifiability,evolve,evolves,88,"// Catch circular reasoning in a pessimistic way for now.; // TODO: Check how the range evolves and if we stripped anything, see also; // AADereferenceable or AAAlign for similar situations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:14,Performance,load,load,14,"// If it is a load instruction with range metadata, use the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Safety,Avoid,Avoid,3,// Avoid recursion when the caller is computing constant values for this; // IRP itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:20,Usability,simpl,simplified,20,// A position whose simplified value does not have any value is; // considered to be dead. We don't manifest noundef in such positions for; // the same reason above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:12,Usability,simpl,simple,12,// The most simple case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:97,Usability,simpl,simplified,97,/// Helper struct to tie a value+context pair together with the scope for; /// which this is the simplified version.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:3,Usability,Simpl,Simplify,3,// Simplify the operands first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:17,Integrability,depend,depends,17,"// The new value depends on the predicate, true for != and false for ==.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:16,Usability,simpl,simplify,16,"// We could not simplify the condition, assume both values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:19,Performance,load,loads,19,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:122,Performance,load,load,122,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:10,Usability,simpl,simplify,10,// Do not simplify loads that are only used in llvm.assume if we cannot also; // remove all stores that may feed into the load. The reason is that the; // assume is probably worth something as long as the stores are around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:41,Integrability,interface,interface,41,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:64,Usability,simpl,simplify,64,// We won't bother with the InstSimplify interface if we didn't simplify any; // operand ourselves.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:71,Integrability,depend,dependence,71,// If we actually used liveness information so we have to record a; // dependence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:402,Deployability,update,updated,402,"/// Propagates assumption information from parent functions to all of their; /// successors. An assumption can be propagated if the containing function; /// dominates the called function.; ///; /// We start with a ""known"" set of assumptions already valid for the associated; /// function and an ""assumed"" set that initially contains all possible; /// assumptions. The assumed set is inter-procedurally updated by narrowing its; /// contents as concrete values are known. The concrete values are seeded by the; /// first nodes that are either entries into the call graph, or contains no; /// assumptions. Each node is updated as the intersection of the assumed state; /// with all of its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:617,Deployability,update,updated,617,"/// Propagates assumption information from parent functions to all of their; /// successors. An assumption can be propagated if the containing function; /// dominates the called function.; ///; /// We start with a ""known"" set of assumptions already valid for the associated; /// function and an ""assumed"" set that initially contains all possible; /// assumptions. The assumed set is inter-procedurally updated by narrowing its; /// contents as concrete values are known. The concrete values are seeded by the; /// first nodes that are either entries into the call graph, or contains no; /// assumptions. Each node is updated as the intersection of the assumed state; /// with all of its predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:27,Deployability,update,updateImpl,27,/// See AbstractAttribute::updateImpl(...).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:31,Testability,log,logic,31,"// For now we only use special logic for call sites. However, the tracker; // itself knows about a lot of other non-capturing cases already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:7,Usability,simpl,simplification,7,"// Use simplification to find potential callees, if !callees was present,; // fallback to that set if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Usability,simpl,simplification,9,"// Check simplification result, prune known UB callees, also restrict it to; // the !callees set, if present.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:58,Usability,simpl,simply,58,// It doesn't matter if we can't check all uses as we can simply; // conservatively ignore those that can not be visited.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Modifiability,rewrite,rewrite,80,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite call site argument for now because it will need to; // rewrite the function signature of the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:81,Modifiability,rewrite,rewrite,81,// TODO: we don't rewrite call site argument for now because it will need to; // rewrite the function signature of the callee.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Deployability,update,update,9,// TODO: update check for malloc like calls,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:62,Energy Efficiency,reduce,reduce,62,"// For zero sized allocations, we give up.; // Since we can't reduce further",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:9,Modifiability,refactor,refactor,9,// TODO: refactor this to be part of multiple bin case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:18,Modifiability,rewrite,rewrite,18,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp:80,Modifiability,rewrite,rewrite,80,// TODO: we don't rewrite function argument for now because it will need to; // rewrite the function signature and all call sites,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/AttributorAttributes.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp:408,Safety,AVOID,AVOIDABLE,408,"//===- BarrierNoopPass.cpp - A barrier pass for the pass manager ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // NOTE: DO NOT USE THIS IF AVOIDABLE; //; // This pass is a nonce pass intended to allow manipulation of the implicitly; // nesting pass manager. For example, it can be used to cause a CGSCC pass; // manager to be closed prior to running a new collection of function passes.; //; // FIXME: This is a huge HACK. This should be removed when the pass manager's; // nesting is made explicit instead of implicit.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp:200,Usability,clear,clear,200,/// A nonce module pass used to place a barrier in a pass manager.; ///; /// There is no mechanism for ending a CGSCC pass manager once one is started.; /// This prevents extension points from having clear deterministic ordering; /// when they are phrased as non-module passes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BarrierNoopPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp:37,Safety,avoid,avoid,37,// Set linkage as ExternalLinkage to avoid erasing unreachable functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/BlockExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:406,Modifiability,variab,variable,406,"/// To enable interprocedural analysis, we assign LLVM values to the following; /// groups. The register group represents SSA registers, the return group; /// represents the return values of functions, and the memory group represents; /// in-memory values. An LLVM Value can technically be in more than one group.; /// It's necessary to distinguish these groups so we can, for example, track a; /// global variable separately from the value stored at its location.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:95,Testability,test,testing,95,"/// Comparator for sorting the functions set. We want to keep the order; /// deterministic for testing, etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:378,Energy Efficiency,efficient,efficiently,378,"/// Holds functions indicating the possible targets of call sites. This set; /// is empty for lattice values in the undefined, overdefined, and untracked; /// states. The maximum size of the set is controlled by; /// MaxFunctionsPerValue. Since most LLVM values are expected to be in; /// uninteresting states (i.e., overdefined), CVPLatticeVal objects should be; /// small and efficiently copyable.; // FIXME: This could be a TinyPtrVector and/or merge with LatticeState.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:268,Modifiability,variab,variables,268,"/// The custom lattice function used by the generic sparse propagation solver.; /// It handles merging lattice values and computing new lattice values for; /// constants, arguments, values returned from trackable functions, and values; /// located in trackable global variables. It also computes the lattice values; /// that change as a result of executing instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:176,Usability,simpl,simply,176,"/// Merge the two given lattice values. The interesting cases are merging two; /// FunctionSet values and a FunctionSet value with an Undefined value. For; /// these cases, we simply union the function sets. If the size of the union; /// is greater than the maximum functions we track, the merged value is; /// overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:167,Performance,optimiz,optimization,167,"/// Compute a new lattice value for the given constant. The constant, after; /// stripping any pointer casts, should be a Function. We ignore null; /// pointers as an optimization, since calling these values is undefined; /// behavior.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:38,Deployability,update,update,38,"// Void return, No need to create and update CVPLattice state as no one; // can use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:65,Performance,perform,perform,65,"// Inform the solver that the called function is executable, and perform; // the merges for the arguments and return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:38,Deployability,update,update,38,"// Void return, No need to create and update CVPLattice state as no one can; // use it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:82,Modifiability,variab,variable,82,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:206,Modifiability,variab,variable,206,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:11,Performance,load,load,11,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:60,Performance,load,load,60,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:127,Performance,load,loaded,127,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:171,Performance,load,loaded,171,"/// Handle load instructions. If the pointer operand of the load is a global; /// variable, we attempt to track the value. The loaded value state is the; /// merge of the loaded value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:84,Modifiability,variab,variable,84,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:136,Modifiability,variab,variable,136,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:211,Modifiability,variab,variable,211,"/// Handle store instructions. If the pointer operand of the store is a; /// global variable, we attempt to track the value. The global variable state; /// is the merge of the stored value state with the global variable state.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp:3,Usability,Simpl,Simply,3,// Simply bail if this instruction has no user.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CalledValuePropagation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:678,Availability,avail,available,678,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:755,Availability,avail,available,755,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:405,Integrability,interface,interface,405,"//===- ConstantMerge.cpp - Merge duplicate global constants ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the interface to a pass that merges duplicate global; // constants together into a single constant that is shared. This is useful; // because some passes (ie TraceValues) insert a lot of string constants into; // the program, regardless of whether or not an existing string is available.; //; // Algorithm: ConstantMerge is designed to build up a map of available constants; // and eliminate duplicates when it is initialized.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:28,Modifiability,variab,variables,28,// Don't touch thread-local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:127,Performance,perform,perform,127,"// This transformation is legal for weak ODR globals in the sense it; // doesn't change semantics, but we really don't want to perform it; // anyway; it's likely to pessimize code generation, and some tools; // (like the Darwin linker in cases involving CFString) don't expect it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp:91,Safety,avoid,avoid,91,"// Now that we have figured out which replacements must be made, do them all; // now. This avoid invalidating the pointers in CMap, which are unneeded; // now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ConstantMerge.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp:62,Testability,stub,stub,62,// Take over the existing function. The frontend emits a weak stub so that the; // linker knows about the symbol; this pass replaces the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/CrossDSOCFI.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:51,Safety,safe,safe,51,"// Okay, we know we can transform this function if safe. Scan its body; // looking for calls marked musttail or calls to llvm.vastart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:275,Performance,load,load,275,"// We cannot change the arguments if this TU does not define the function or; // if the linker may choose a function body from another TU, even if the; // nominal linkage indicates that other copies of the function have the same; // semantics. In the below example, the dead load from %p may not have been; // eliminated from the linker-chosen copy of f, so replacing %p with poison; // in callers may introduce undefined behavior.; //; // define linkonce_odr void @f(i32* %p) {; // %v = load i32 %p; // ret void; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:488,Performance,load,load,488,"// We cannot change the arguments if this TU does not define the function or; // if the linker may choose a function body from another TU, even if the; // nominal linkage indicates that other copies of the function have the same; // semantics. In the below example, the dead load from %p may not have been; // eliminated from the linker-chosen copy of f, so replacing %p with poison; // in callers may introduce undefined behavior.; //; // define linkonce_odr void @f(i32* %p) {; // %v = load i32 %p; // ret void; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:95,Availability,alive,alive,95,"// Functions with local linkage should already have been handled, except if; // they are fully alive (e.g., called indirectly) and except for the fragile; // (variadic) ones. In these cases, we may still be able to improve their; // statically known call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:93,Availability,alive,alive,93,"/// Looks at a single use of an argument or return value and determines if it; /// should be alive or not. Adds this use to MaybeLiveUses if it causes the; /// used value to become MaybeLive.; ///; /// RetValNum is the return value number to use when this use is used in a; /// return instruction. This is used in the recursion, you should always leave; /// it at 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,Integrability,depend,depending,21,"// We might be live, depending on the liveness of Use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:21,Integrability,depend,depending,21,"// We might be live, depending on the liveness of Use. If any; // sub-value is live, then the entire value is considered live. This; // is a conservative choice, and better tracking is possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:76,Integrability,depend,depends,76,"// The use we are examining is inserted into an aggregate. Our liveness; // depends on all uses of that aggregate, but if it is used as a return; // value, only index at which we were inserted counts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:298,Availability,alive,alive,298,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:4,Performance,Perform,Performs,4,"/// Performs the initial survey of the specified function, checking out whether; /// it uses any of its incoming arguments or whether any callers use the return; /// value. This fills in the LiveValues set and Uses map.; ///; /// We consider arguments of non-internal functions to be intrinsically alive as; /// well as arguments to functions which have their ""address taken"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:3,Usability,Clear,Clear,3,// Clear the vector again for the next iteration.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:29,Integrability,depend,depending,29,"/// Marks the liveness of RA depending on L. If L is MaybeLive, it also takes; /// all uses in MaybeLiveUses and records them in Uses, such that RA will be; /// marked live if any use in MaybeLiveUses gets marked live later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,Availability,alive,alive,31,"/// Mark the given Function as alive, meaning that it cannot be changed in any; /// way. Additionally, mark any values that are used as this function's; /// parameters or by its return values (according to Uses) live as well.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:38,Availability,alive,alive,38,// Remember which arguments are still alive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:695,Integrability,depend,depending,695,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:970,Performance,perform,performance,970,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:372,Usability,clear,clear,372,"// If there is a function with a live 'returned' argument but a dead return; // value, then there are two possible actions:; // 1) Eliminate the return value and take off the 'returned' attribute on the; // argument.; // 2) Retain the 'returned' attribute and treat the return value (but not the; // entire function) as live so that it is not eliminated.; //; // It's not clear in the general case which option is more profitable because,; // even in the absence of explicit uses of the return value, code generation; // is free to use the 'returned' attribute to do things like eliding; // save/restores of registers across calls. Whether this happens is target and; // ABI-specific as well as depending on the amount of register pressure, so; // there's no good way for an IR-level pass to figure this out.; //; // Fortunately, the only places where 'returned' is currently generated by; // the FE are places where 'returned' is basically free and almost always a; // performance win, so the second option can just be used always for now.; //; // This should be revisited if 'returned' is ever applied more liberally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:40,Availability,down,down,40,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:30,Energy Efficiency,Reduce,Reduce,30,// More than one return type? Reduce it down to size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:27,Usability,simpl,simple,27,"// One return type? Just a simple value then, but only if we didn't use to; // return a struct with that simple value before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:105,Usability,simpl,simple,105,"// One return type? Just a simple value then, but only if we didn't use to; // return a struct with that simple value before.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:126,Availability,alive,alive,126,"// Loop over those operands, corresponding to the normal arguments to the; // original function, and add those that are still alive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:177,Availability,alive,alive,177,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:258,Usability,clear,clearly,258,"// If the return type has changed, then get rid of 'returned' on the; // call site. The alternative is to make all 'returned' attributes on; // call sites keep the return value alive just like 'returned'; // attributes on function declaration, but it's less clearly a win and; // this is not an expected case anyway",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:57,Modifiability,rewrite,rewrite,57,// If we change the return value of the function we must rewrite any return; // instructions. Check this now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:31,Usability,simpl,simple,31,"// We are now only returning a simple value, so just return the; // extracted value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:232,Safety,safe,safe,232,"// If either the return value(s) or argument(s) are removed, then probably the; // function does not follow standard calling conventions anymore. Hence, add; // DW_CC_nocall to DISubroutineType to inform debugger that it may not be safe; // to call this function or try to interpret the return value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp:20,Usability,simpl,simple,20,"// First pass: Do a simple check to see if any functions can have their ""...""; // removed. We can do this if they never call va_start. This loop cannot be; // fused with the next loop, because deleting a function invalidates; // information computed while surveying other functions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/DeadArgumentElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:423,Availability,avail,available,423,"//===- ElimAvailExtern.cpp - DCE unreachable internal functions -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transform is designed to eliminate available external global; // definitions from the program, turning them into declarations.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:297,Deployability,update,updated,297,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:492,Deployability,pipeline,pipeline,492,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:181,Testability,test,tests,181,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:334,Usability,GUID,GUID,334,"/// Create a copy of the thinlto import, mark it local, and redirect direct; /// calls to the copy. Only direct calls are replaced, so that e.g. indirect; /// call function pointer tests would use the global identity of the function.; ///; /// Currently, Value Profiling (""VP"") MD_prof data isn't updated to refer to the; /// clone's GUID (which will be different, because the name and linkage is; /// different), under the assumption that the last consumer of this data is; /// upstream the pipeline (e.g. ICP).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:24,Availability,avail,available,24,// Drop initializers of available externally global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:52,Modifiability,variab,variables,52,// Drop initializers of available externally global variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp:22,Availability,avail,available,22,// Drop the bodies of available externally functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ElimAvailExtern.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, just give all GlobalValues ExternalLinkage. A trickier; // implementation could figure out which GlobalValues are actually; // referenced by the Named set, and which GlobalValues in the rest of; // the module are referenced by the NamedSet, and get away with leaving; // more internal and private things internal and private. But for now,; // be conservative and simple.; // Visit the GlobalVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp:382,Usability,simpl,simple,382,"// For simplicity, just give all GlobalValues ExternalLinkage. A trickier; // implementation could figure out which GlobalValues are actually; // referenced by the Named set, and which GlobalValues in the rest of; // the module are referenced by the NamedSet, and get away with leaving; // more internal and private things internal and private. But for now,; // be conservative and simple.; // Visit the GlobalVariables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/ExtractGV.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:10,Security,access,accesses,10,// Ignore accesses to known-invariant or local memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:416,Performance,optimiz,optimized,416,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:23,Security,access,access,23,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:662,Security,access,access,662,"/// Returns the memory access attribute for function F using AAR for AA results,; /// where SCCNodes is the current SCC.; ///; /// If ThisBody is true, this function may examine the function body and will; /// return a result pertaining to this copy of the function. If it is false, the; /// result will be based only on AA results for the function declaration; it; /// will be assumed that some other (perhaps less optimized) version of the; /// function may be selected at link time.; ///; /// The return value is split into two parts: Memory effects that always apply,; /// and additional memory effects that apply if any of the functions in the SCC; /// can access argmem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:24,Security,access,accessed,24,// Additional locations accessed if the SCC accesses argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:44,Security,access,accesses,44,// Additional locations accessed if the SCC accesses argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:75,Safety,Detect,Detect,75,"// Some instructions can be ignored even if they read or write memory.; // Detect these now, skipping to the next instruction if one is found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:212,Integrability,depend,depending,212,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:174,Security,access,accesses,174,"// We can optimistically ignore calls to functions in the same SCC, with; // two caveats:; // * Calls with operand bundles may have additional effects.; // * Argument memory accesses may imply additional effects depending on; // what the argument location is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:48,Security,access,accessed,48,// Keep track of which additional locations are accessed if the SCC; // turns out to access argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:85,Security,access,access,85,// Keep track of which additional locations are accessed if the SCC; // turns out to access argmem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:23,Security,access,access,23,"// If the call doesn't access memory, we're done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:190,Performance,optimiz,optimizations,190,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:247,Performance,optimiz,optimized,247,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:140,Security,access,access,140,// A pseudo probe call shouldn't change any function attribute since it; // doesn't translate to a real instruction. It comes with a memory access; // tag to prevent itself being removed by optimizations and not block; // other instructions being optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:15,Security,access,accesses,15,"// If the call accesses captured memory (currently part of ""other"") and; // an argument is captured (currently not tracked), then it may also; // access argument memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:146,Security,access,access,146,"// If the call accesses captured memory (currently part of ""other"") and; // an argument is captured (currently not tracked), then it may also; // access argument memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:93,Security,access,access,93,"// Check whether all pointer arguments point to local memory, and; // ignore calls that only access local memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:70,Security,access,accessed,70,"// If no location is known, conservatively assume anything can be; // accessed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:27,Security,access,access,27,// Volatile operations may access inaccessible memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:14,Security,access,accesses,14,"// If the SCC accesses argmem, add recursive accesses resulting from that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:45,Security,access,accesses,45,"// If the SCC accesses argmem, add recursive accesses resulting from that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1288,Availability,Avail,AvailableExternally,1288,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1493,Availability,Avail,AvailableExternally,1493,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:1726,Availability,Avail,AvailableExternally,1726,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:2094,Performance,optimiz,optimize,2094,"linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and already captured by their callers so we; /// ignore these for now. If they become relevant to optimize in the; /// future this can be revisited.; /// 5. Otherwise, go conservative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:468,Testability,assert,assert,468,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:232,Usability,GUID,GUID,232,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:279,Usability,guid,guid,279,"/// At this point, prevailing symbols have been resolved. The following leads; /// to returning a conservative result:; /// - Multiple instances with local linkage. Normally local linkage would be; /// unique per module; /// as the GUID includes the module path. We could have a guid alias if; /// there wasn't any distinguishing path when each file was compiled, but; /// that should be rare so we'll punt on those.; /// These next 2 cases should not happen and will assert:; /// - Multiple instances with external linkage. This should be caught in; /// symbol resolution; /// - Non-existent FunctionSummary for Aliasee. This presents a hole in our; /// knowledge meaning we have to go conservative.; /// Otherwise, we calculate attributes for a function as:; /// 1. If we have a local linkage, take its attributes. If there's somehow; /// multiple, bail and go conservative.; /// 2. If we have an external/WeakODR/LinkOnceODR linkage check that it is; /// prevailing, take its attributes.; /// 3. If we have a Weak/LinkOnce linkage the copies can have semantic; /// differences. However, if the prevailing copy is known it will be used; /// so take its attributes. If the prevailing copy is in a native file; /// all IR copies will be dead and propagation will go conservative.; /// 4. AvailableExternally summaries without a prevailing copy are known to; /// occur in a couple of circumstances:; /// a. An internal function gets imported due to its caller getting; /// imported, it becomes AvailableExternally but no prevailing; /// definition exists. Because it has to get imported along with its; /// caller the attributes will be captured by propagating on its; /// caller.; /// b. C++11 [temp.explicit]p10 can generate AvailableExternally; /// definitions of explicitly instanced template declarations; /// for inlining which are ultimately dropped from the TU. Since this; /// is localized to the TU the attributes will have already made it to; /// the callers.; /// These are edge cases and a",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:57,Usability,simpl,simply,57,"// If the callee can save a copy into other memory, then simply; // scanning uses of the call is insufficient. We have no way; // of tracking copies of the pointer through memory to see; // if a reloaded copy is written to, thus we must give up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:7,Security,access,accessors,7,// The accessors used on call site here do the right thing for calls and; // invokes with operand bundles.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:14,Performance,load,load,14,// A volatile load has side effects beyond what readonly can be relied; // upon.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:268,Modifiability,enhance,enhanced,268,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:280,Testability,test,testing,280,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:351,Usability,simpl,simple,351,"// For an argument attribute to transfer from a callsite to the parent, the; // call must be guaranteed to execute every time the parent is called.; // Conservatively, just check for calls in the entry block that are guaranteed; // to execute.; // TODO: This could be enhanced by testing if the callsite post-dominates the; // entry block or by doing simple forward walks or backward walks to the; // callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:81,Deployability,update,update,81,"// Otherwise, remove potentially conflicting attribute, add the new one,; // and update statistics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:163,Integrability,depend,dependent,163,"// Can we determine that it's readonly/readnone/writeonly without doing; // an SCC? Note that we don't allow any calls at all here, or else our; // result will be dependent on the iteration order through the; // functions in the SCC.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:13,Security,access,access,13,// Infer the access attributes given the new nocapture one,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Testability,Test,Tests,4,"/// Tests whether a function is ""malloc-like"".; ///; /// A function is ""malloc-like"" if it returns either null or a pointer that; /// doesn't alias any other pointer visible to the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Modifiability,Extend,Extend,3,// Extend the analysis by looking upwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Testability,Test,Tests,4,"/// Tests whether this function is known to not return null.; ///; /// Requires that the function returns a pointer.; ///; /// Returns true if it believes the function will not return a null, and sets; /// \p Speculative based on whether the returned conclusion is a speculative; /// conclusion due to SCC calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Modifiability,Extend,Extend,3,// Extend the analysis by looking upwards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:9,Performance,perform,perform,9,// TODO: perform context-sensitive analysis?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:55,Performance,perform,performs,55,/// Collects a set of attribute inference requests and performs them all in one; /// go on a single SCC Node. Inference involves scanning function bodies; /// looking for instructions that violate attribute assumptions.; /// As soon as all the bodies are fine we are free to set the attribute.; /// Customization of inference for individual attributes is performed by; /// providing a handful of predicates for each attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:355,Performance,perform,performed,355,/// Collects a set of attribute inference requests and performs them all in one; /// go on a single SCC Node. Inference involves scanning function bodies; /// looking for instructions that violate attribute assumptions.; /// As soon as all the bodies are fine we are free to set the attribute.; /// Customization of inference for individual attributes is performed by; /// providing a handful of predicates for each attribute.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:119,Performance,optimiz,optimization,119,"/// Returns true if this function does not have to be handled.; /// General intent for this predicate is to provide an optimization; /// for functions that do not need this attribute inference at all; /// (say, for functions that already have the attribute).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:4,Performance,Perform,Perform,4,/// Perform all the requested attribute inference actions according to the; /// attribute predicates stored before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:243,Integrability,synchroniz,synchronizing,243,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:334,Safety,risk,risk,334,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:327,Usability,simpl,simply,327,"// Return true if this is an atomic which has an ordering stronger than; // unordered. Note that this is different than the predicate we use in; // Attributor. Here we chose to be conservative and consider monotonic; // operations potentially synchronizing. We generally don't do much with; // monotonic operations, so this is simply risk reduction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:16,Integrability,synchroniz,synchronize,16,// Volatile may synchronize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:25,Integrability,synchroniz,synchronize,25,// An ordered atomic may synchronize. (See comment about on monotonic.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Performance,Perform,Perform,3,// Perform all the requested attribute inference actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:257,Integrability,depend,depending,257,// Request to infer nounwind attribute for all the functions in the SCC if; // every callsite within the SCC is not throwing (except for calls to; // functions within the SCC). Note that nounwind attribute suffers from; // derefinement - results may change depending on how functions are; // optimized. Thus it can be inferred only from exact definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:292,Performance,optimiz,optimized,292,// Request to infer nounwind attribute for all the functions in the SCC if; // every callsite within the SCC is not throwing (except for calls to; // functions within the SCC). Note that nounwind attribute suffers from; // derefinement - results may change depending on how functions are; // optimized. Thus it can be inferred only from exact definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:281,Integrability,depend,depending,281,// Request to infer nofree attribute for all the functions in the SCC if; // every callsite within the SCC does not directly or indirectly free; // memory (except for calls to functions within the SCC). Note that nofree; // attribute suffers from derefinement - results may change depending on; // how functions are optimized. Thus it can be inferred only from exact; // definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:316,Performance,optimiz,optimized,316,// Request to infer nofree attribute for all the functions in the SCC if; // every callsite within the SCC does not directly or indirectly free; // memory (except for calls to functions within the SCC). Note that nofree; // attribute suffers from derefinement - results may change depending on; // how functions are optimized. Thus it can be inferred only from exact; // definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:3,Performance,Perform,Perform,3,// Perform all the requested attribute inference actions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:113,Safety,detect,detects,113,"// If all of the calls in F are identifiable and are to norecurse functions, F; // is norecurse. This check also detects self-recursion as F is not currently; // marked norecurse, so any called from F to F will not be marked norecurse.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:42,Performance,optimiz,optimize,42,// Treat any function we're trying not to optimize as if it were an; // indirect call and omit it from the node set used below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:152,Integrability,rout,routines,152,"// Track whether any functions in this SCC have an unknown call edge.; // Note: if this is ever a performance hit, we can common it with; // subsequent routines which also do scans over the instructions of the; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:98,Performance,perform,performance,98,"// Track whether any functions in this SCC have an unknown call edge.; // Note: if this is ever a performance hit, we can common it with; // subsequent routines which also do scans over the instructions of the; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:254,Usability,simpl,simply,254,"// Finally, infer the maximal set of attributes from the ones we've inferred; // above. This is handling the cases where one attribute on a signature; // implies another, but for implementation reasons the inference rule for; // the later is missing (or simply less sophisticated).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:136,Performance,optimiz,optimization,136,"// Skip non-recursive functions if requested.; // Only infer argument attributes for non-recursive functions, because; // it can affect optimization behavior in conjunction with noalias.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:72,Safety,avoid,avoid,72,// We check the preconditions for the function prior to calling this to avoid; // the cost of building up a reversible post-order list. We assert them here; // to make sure none of the invariants this relies on were violated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:139,Testability,assert,assert,139,// We check the preconditions for the function prior to calling this to avoid; // the cost of building up a reversible post-order list. We assert them here; // to make sure none of the invariants this relies on were violated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:459,Safety,detect,detects,459,"// If F is internal and all of its uses are calls from a non-recursive; // functions, then none of its calls could in fact recurse without going; // through a function marked norecurse, and so we can mark this function too; // as norecurse. Note that the uses must actually be calls -- otherwise; // a pointer to this function could be returned from a norecurse function but; // this function could be recursively (indirectly) called. Note that this; // also detects if F is directly recursive as F is not yet marked as; // a norecurse function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:264,Safety,detect,detection,264,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:178,Usability,simpl,simpler,178,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp:499,Usability,clear,clearly,499,"// We only have a post-order SCC traversal (because SCCs are inherently; // discovered in post-order), so we accumulate them in a vector and then walk; // it in reverse. This is simpler than using the RPO iterator infrastructure; // because we need to combine SCC detection and the PO walk of the call; // graph. We can also cheat egregiously because we're primarily interested in; // synthesizing norecurse and so we can only save the singular SCCs as SCCs; // with multiple functions in them will clearly be recursive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:41,Performance,tune,tuned,41,// FIXME: This multiplier was not really tuned up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:14,Testability,test,testing,14,/// Used when testing importing from distributed indexes via opt; // -function-import.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Performance,Load,Load,3,// Load lazily a module from \p FileName in \p Context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:18,Performance,load,loaded,18,"// Metadata isn't loaded until functions are imported, to minimize; // the memory overhead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:96,Security,hash,hash,96,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:91,Usability,GUID,GUID,91,"// Ignore any callees that aren't actually functions. This could happen; // in the case of GUID hash collisions. It could also happen in theory; // for SamplePGO profiles collected on old versions of the code after; // renaming, since we synthesize edges to any inlined callees appearing; // in the profile.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:181,Availability,failure,failure,181,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:503,Energy Efficiency,reduce,reduce,503,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:426,Performance,optimiz,optimized,426,"/// Given a list of possible callee implementation for a call site, select one; /// that fits the \p Threshold. If none are found, the Reason will give the last; /// reason for the failure (last, in the order of CalleeSummaryList entries).; ///; /// FIXME: select ""best"" instead of first that fits. But what is ""best""?; /// - The smallest: more likely to be inlined.; /// - The one with the least outgoing edges (already well optimized).; /// - One from a module already being imported from in order to reduce the; /// number of source modules parsed/linked.; /// - One that has PGO data attached.; /// - [insert you fancy metric here]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:202,Availability,avail,available,202,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:401,Availability,avail,available,401,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:470,Availability,error,error,470,"// We should not skip import if the module contains a non-prevailing; // definition with interposable linkage type. This is required for; // correctness in the situation where there is a prevailing def available; // for import and marked read-only. In this case, the non-prevailing def; // will be converted to a declaration, while the prevailing one becomes; // internal, thus no definitions will be available for linking. In order to; // prevent undefined symbol link error, the prevailing definition must be; // imported.; // FIXME: Consider adding a check that the suitable prevailing definition; // exists and marked read-only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:22,Modifiability,variab,variable,22,"// If this is a local variable, make sure we import the copy; // in the caller's module. The only time a local variable can; // share an entry in the index is if there is a local with the same name; // in another module that had the same source file name (in a different; // directory), where each was compiled in their own directory so there; // was not distinguishing path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:111,Modifiability,variab,variable,111,"// If this is a local variable, make sure we import the copy; // in the caller's module. The only time a local variable can; // share an entry in the index is if there is a local with the same name; // in another module that had the same source file name (in a different; // directory), where each was compiled in their own directory so there; // was not distinguishing path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:301,Modifiability,refactor,refactor,301,"// Functions could be referenced by global vars - e.g. a vtable; but we; // don't currently imagine a reason those would be imported here, rather; // than as part of the logic deciding which functions to import (i.e.; // based on profile information). Should we decide to handle them here,; // we can refactor accordingly at that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:170,Testability,log,logic,170,"// Functions could be referenced by global vars - e.g. a vtable; but we; // don't currently imagine a reason those would be imported here, rather; // than as part of the logic deciding which functions to import (i.e.; // based on profile information). Should we decide to handle them here,; // we can refactor accordingly at that time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:8,Deployability,update,update,8,// Only update stat and exports if we haven't already imported this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:72,Modifiability,variab,variable,72,// Only update stat and exports if we haven't already imported this; // variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:159,Energy Efficiency,efficient,efficient,159,"// Any references made by this variable will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:31,Modifiability,variab,variable,31,"// Any references made by this variable will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:6,Modifiability,variab,variable,6,// If variable is not writeonly we attempt to recursively analyze; // its references in order to import referenced constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:95,Availability,avail,available,95,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:727,Availability,avail,avail-extern-to-local,727,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:251,Performance,optimiz,optimizations,251,"/// We will prefer importing the prevailing candidate, if not, we'll; /// still pick the first available candidate. The reason we want to make; /// sure we do import the prevailing candidate is because the goal of; /// workload-awareness is to enable optimizations specializing the call; /// graph of that workload. Suppose a function is already defined in the; /// module, but it's not the prevailing variant. Suppose also we do not; /// inline it (in fact, if it were interposable, we can't inline it),; /// but we could specialize it to the workload in other ways. However,; /// the linker would drop it in the favor of the prevailing copy.; /// Instead, by importing the prevailing variant (assuming also the use; /// of `-avail-extern-to-local`), we keep the specialization. We could; /// alteranatively make the non-prevailing variant local, but the; /// prevailing one is also the one for which we would have previously; /// collected profiles, making it preferrable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:142,Safety,safe,safely,142,// FIXME: Consider not skipping import if the module contains; // a non-prevailing def with interposable linkage. The prevailing copy; // can safely be imported (see shouldImportGlobal()).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update with new larger threshold.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:144,Availability,failure,failure,144,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:137,Deployability,update,update,137,// Update with new larger threshold if this was a retry (otherwise; // we would have already inserted with NewThreshold above). Also; // update failure info if requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:40,Usability,GUID,GUID,40,// We previously decided to import this GUID definition if it was already; // inserted in the set of imports from the exporting module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:165,Energy Efficiency,efficient,efficient,165,"// Any calls/references made by this function will be marked exported; // later, in ComputeCrossModuleImport, after import decisions are; // complete, which is more efficient than adding them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:132,Availability,down,down,132,"// Worklist contains the list of function imported in this module, for which; // we will analyse the callees and may import further down the callgraph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:123,Safety,avoid,avoided,123,// FIXME: Change the GVSummaryMapTy to hold ValueInfo instead of GUID; // so this map look up (and possibly others) can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:65,Usability,GUID,GUID,65,// FIXME: Change the GVSummaryMapTy to hold ValueInfo instead of GUID; // so this map look up (and possibly others) can be avoided.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:26,Modifiability,variab,variables,26,// Skip import for global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:19,Usability,GUID,GUIDs,19,"// Checks that all GUIDs of read/writeonly vars we see in export lists; // are also in the import lists. Otherwise we my face linker undefs,; // because readonly and writeonly vars are internalized in their; // source modules. The exception would be if it has a linkage type indicating; // that there may have been a copy existing in the importing module (e.g.; // linkonce_odr). In that case we cannot accurately do this checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:219,Energy Efficiency,efficient,efficient,219,"// When computing imports we only added the variables and functions being; // imported to the export list. We also need to mark any references and calls; // they make as exported as well. We do this here, as it is more efficient; // since we may import the same values multiple times into different modules; // during the import computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:44,Modifiability,variab,variables,44,"// When computing imports we only added the variables and functions being; // imported to the export list. We also need to mark any references and calls; // they make as exported as well. We do this here, as it is more efficient; // since we may import the same values multiple times into different modules; // during the import computation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:35,Modifiability,variab,variables,35,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:106,Modifiability,variab,variable,106,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:156,Modifiability,variab,variables,156,"// Export referenced functions and variables. We don't export/promote; // objects referenced by writeonly variable initializer, because; // we convert such variables initializers to ""zeroinitializer"".; // See processGlobalForThinLTO.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:217,Energy Efficiency,efficient,efficient,217,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:234,Safety,avoid,avoid,234,"// Prune list computed above to only include values defined in the exporting; // module. We do this after the above insertion since we may hit the same; // ref/call target multiple times in above loop, and it is more efficient to; // avoid a set lookup each time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:148,Usability,GUID,GUID,148,/// Compute all the imports for the given module using the Index.; ///; /// \p isPrevailing is a callback that will be called with a global value's GUID; /// and summary and should return whether the module corresponding to the; /// summary contains the linker-prevailing copy of that value.; ///; /// \p ImportList will be populated with a map that can be passed to; /// FunctionImporter::importFunctions() above (see description there).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:58,Usability,GUID,GUID,58,// Collect the list of functions this module defines.; // GUID -> Summary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:92,Testability,test,testing,92,/// Mark all external summaries in \p Index for import into the given module.; /// Used for testing the case of distributed builds using a distributed index.; ///; /// \p ImportList will be populated with a map that can be passed to; /// FunctionImporter::importFunctions() above (see description there).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:174,Usability,GUID,GUID,174,"// For SamplePGO, the indirect call targets for local functions will; // have its original name annotated in profile. We try to find the; // corresponding PGOFuncName as the GUID, and fix up the edges; // accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Update,Update,3,// Update the edge to point directly to the correct GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:52,Usability,GUID,GUID,52,// Update the edge to point directly to the correct GUID.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:90,Modifiability,variab,variable,90,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:254,Modifiability,variab,variable,254,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:375,Modifiability,variab,variable,375,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:34,Usability,GUID,GUID,34,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:52,Usability,GUID,GUID,52,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:306,Usability,GUID,GUID,306,"// The mapping from OriginalId to GUID may return a GUID; // that corresponds to a static variable. Filter it out here.; // This can happen when; // 1) There is a call to a library function which is not defined; // in the index.; // 2) There is a static variable with the OriginalGUID identical; // to the GUID of the library function in 1);; // When this happens the static variable in 2) will be found,; // which needs to be filtered out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:65,Testability,test,tests,65,"// Don't do anything when nothing is live, this is friendly with tests.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:17,Deployability,update,update,17,// Still need to update indirect calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:248,Availability,down,downstreams,248,"// We only keep live symbols that are known to be non-prevailing if any are; // available_externally, linkonceodr, weakodr. Those symbols are discarded; // later in the EliminateAvailableExternally pass and setting them to; // not-live could break downstreams users of liveness information (PR36483); // or limit optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:313,Performance,optimiz,optimization,313,"// We only keep live symbols that are known to be non-prevailing if any are; // available_externally, linkonceodr, weakodr. Those symbols are discarded; // later in the EliminateAvailableExternally pass and setting them to; // not-live could break downstreams users of liveness information (PR36483); // or limit optimization opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:123,Usability,simpl,simply,123,"// Check for a non-prevailing def that has interposable linkage; // (e.g. non-odr weak or linkonce). In that case we can't simply; // convert to available_externally, since it would lose the; // interposable property and possibly get inlined. Simply drop; // the definition in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:243,Usability,Simpl,Simply,243,"// Check for a non-prevailing def that has interposable linkage; // (e.g. non-odr weak or linkonce). In that case we can't simply; // convert to available_externally, since it would lose the; // interposable property and possibly get inlined. Simply drop; // the definition in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:111,Usability,simpl,simplicity,111,"// If an alias references a GlobalValue in a non-prevailing comdat, change; // it to available_externally. For simplicity we only handle GlobalValue and; // ConstantExpr with a base object. ConstantExpr without a base object is; // unlikely used in a COMDAT.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:146,Availability,avail,available,146,"// It may be the case that GV is on a chain of an ifunc, its alias and; // subsequent aliases. In this case, the summary for the value is not; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:92,Security,access,access,92,// Must have been promoted (possibly conservatively). Find original; // name so that we can access the correct summary and see if it can; // be internalized again.; // FIXME: Eventually we should control promotion instead of promoting; // and internalizing again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:46,Performance,load,loading,46,"// If modules were created with lazy metadata loading, materialize it; // now, before linking it (otherwise this will be a noop).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Deployability,Upgrade,Upgrade,3,// Upgrade debug info after we're done materializing all the globals and we; // have loaded all the required metadata!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:85,Performance,load,loaded,85,// Upgrade debug info after we're done materializing all the globals and we; // have loaded all the required metadata!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:81,Testability,test,testing,81,"// If requested, simply import all functions in the index. This is used; // when testing distributed backend handling via the opt tool, when; // we have distributed indexes containing exactly the summaries to import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:17,Usability,simpl,simply,17,"// If requested, simply import all functions in the index. This is used; // when testing distributed backend handling via the opt tool, when; // we have distributed indexes containing exactly the summaries to import.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:61,Integrability,interface,interface,61,"// Conservatively mark all internal values as promoted. This interface is; // only used when doing importing via the function importing pass. The pass; // is only enabled when testing importing via the 'opt' tool, which does; // not do the ThinLink that would normally determine what values to promote.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:176,Testability,test,testing,176,"// Conservatively mark all internal values as promoted. This interface is; // only used when doing importing via the function importing pass. The pass; // is only enabled when testing importing via the 'opt' tool, which does; // not do the ThinLink that would normally determine what values to promote.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:3,Performance,Perform,Perform,3,// Perform the import now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:2,Usability,Clear,ClearDSOLocalOnDeclarations,2,/*ClearDSOLocalOnDeclarations=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:37,Availability,Error,Errors,37,// FIXME: Probably need to propagate Errors through the pass manager.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:135,Availability,avail,available,135,"// This is only used for testing the function import pass via opt, where we; // don't have prevailing information from the LTO context available, so just; // conservatively assume everything is prevailing (which is fine for the very; // limited use of prevailing checking in this pass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp:25,Testability,test,testing,25,"// This is only used for testing the function import pass via opt, where we; // don't have prevailing information from the LTO context available, so just; // conservatively assume everything is prevailing (which is fine for the very; // limited use of prevailing checking in this pass).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionImport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Performance,Cache,Cache,3,// Cache the iterator before visiting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:157,Energy Efficiency,reduce,reduced,157,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:778,Modifiability,variab,variables,778,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:815,Modifiability,variab,variables,815,"// To support specializing recursive functions, it is important to propagate; // constant arguments because after a first iteration of specialisation, a; // reduced example may look like this:; //; // define internal void @RecursiveFn(i32* arg1) {; // %temp = alloca i32, align 4; // store i32 2 i32* %temp, align 4; // call void @RecursiveFn.1(i32* nonnull %temp); // ret void; // }; //; // Before a next iteration, we need to propagate the constant like so; // which allows further specialization in next iterations.; //; // @funcspec.arg = internal constant i32 2; //; // define internal void @someFunc(i32* arg1) {; // call void @otherFunc(i32* nonnull @funcspec.arg); // ret void; // }; //; // See if there are any new constant values for the callers of \p F via; // stack variables and promote them to global variables.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:127,Performance,optimiz,optimization,127,// ssa_copy intrinsics are introduced by the SCCP solver. These intrinsics; // interfere with the promoteConstantStackValues() optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:17,Availability,down,down,17,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:9,Safety,safe,safe,9,"// It is safe to down cast from int64_t, NumInsts is always positive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Deployability,Update,Update,3,// Update the known call sites to call the clone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:3,Deployability,Update,Update,3,"// Update the rest of the call sites - these are the recursive calls, calls; // to discarded specialisations and calls that may match a specialisation; // after the solver runs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:56,Modifiability,rewrite,rewrite,56,"// Existing specialisation. Add the call to the list to rewrite, unless; // it's a recursive call. A specialisation, generated because of a; // recursive call may end up as not the best specialisation for all; // the cloned instances of this call, which result from specialising; // functions. Hence we don't rewrite the call directly, but match it with; // the best specialisation once all specialisations are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:309,Modifiability,rewrite,rewrite,309,"// Existing specialisation. Add the call to the list to rewrite, unless; // it's a recursive call. A specialisation, generated because of a; // recursive call may end up as not the best specialisation for all; // the cloned instances of this call, which result from specialising; // functions. Hence we don't rewrite the call directly, but match it with; // the best specialisation once all specialisations are known.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:11,Performance,latency,latency,11,// Minimum latency savings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:12,Performance,optimiz,optimizing,12,"// If we're optimizing the function for size, we shouldn't specialize it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:424,Performance,perform,performing,424,"// Get the cost of inlining the called function at this call site. Note; // that this is only an estimate. The called function may eventually; // change in a way that leads to it not being inlined here, even though; // inlining looks profitable now. For example, one of its called; // functions may be inlined into it, making the called function too large; // to be inlined into this call site.; //; // We apply a boost for performing indirect call promotion by increasing; // the default threshold by the threshold for indirect calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp:88,Modifiability,variab,variable,88,"// Don't specialize on (anything derived from) the address of a non-constant; // global variable, unless explicitly enabled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/FunctionSpecialization.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:554,Availability,alive,alive,554,"//===-- GlobalDCE.cpp - DCE unreachable internal functions ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transform is designed to eliminate unreachable internal globals from the; // program. It uses an aggressive algorithm, searching out globals that are; // known to be alive. After it finds all of the globals which are needed, it; // deletes whatever is left over. This allows it to delete recursive chunks of; // the program which are unreachable.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:40,Integrability,depend,depends,40,/// Compute the set of GlobalValue that depends from V.; /// The recursion stops as soon as a GlobalValue is met.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Safety,Avoid,Avoid,3,// Avoid walking the whole tree of a big ConstantExprs multiple times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:164,Safety,safe,safe,164,"// If the type corresponding to the vtable is private to this translation; // unit, we know that we can see all virtual functions which might use it,; // so VFE is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:16,Performance,load,load,16,"// type.checked.load with a non-constant offset, so assume every entry; // in every matching vtable is used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:136,Performance,optimiz,optimization,136,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:192,Performance,load,loads,192,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:205,Security,access,accesses,205,"// If the Virtual Function Elim module flag is present and set to zero, then; // the vcall_visibility metadata was inserted for another optimization (WPD); // and we may not have type checked loads on all accesses to the vtable.; // Don't attempt VFE in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:461,Availability,alive,alive,461,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:52,Modifiability,variab,variables,52,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:133,Modifiability,variab,variables,133,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:264,Modifiability,variab,variables,264,"// The algorithm first computes the set L of global variables that are; // trivially live. Then it walks the initialization of these variables to; // compute the globals used to initialize them, which effectively builds a; // directed graph where nodes are global variables, and an edge from A to B; // means B is used to initialize A. Finally, it propagates the liveness; // information through the graph starting from the nodes in L. Nodes note; // marked as alive are discarded.; // Remove empty functions from the global ctors list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:7,Integrability,depend,dependencies,7,"// Add dependencies between virtual call sites and the virtual functions they; // might call, if we have that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:18,Integrability,depend,dependencies,18,// Compute direct dependencies of aliases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:18,Integrability,depend,dependencies,18,// Compute direct dependencies of ifuncs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:76,Integrability,depend,dependencies,76,// Propagate liveness from collected Global Values through the computed; // dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:52,Availability,Alive,AliveGlobals,52,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:132,Availability,alive,alive,132,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:196,Modifiability,variab,variables,196,"// Now that all globals which are needed are in the AliveGlobals set, we loop; // through the program, deleting those which are not alive.; //; // The first pass is to drop initializers of global variables which are dead.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:123,Safety,safe,safe,123,"// Virtual functions might still be referenced by one or more vtables,; // but if we've proven them to be unused then it's safe to replace the; // virtual function pointers with null, allowing us to remove the; // function itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:3,Safety,Detect,Detect,3,"// Detect vfuncs that are referenced as ""relative pointers"" which are used; // in Swift vtables, i.e. entries in the form of:; //; // i32 trunc (i64 sub (i64 ptrtoint @f, i64 ptrtoint ...)) to i32); //; // In this case, replace the whole ""sub"" expression with constant 0 to; // avoid leaving a weird sub(0, symbol) expression behind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:278,Safety,avoid,avoid,278,"// Detect vfuncs that are referenced as ""relative pointers"" which are used; // in Swift vtables, i.e. entries in the form of:; //; // i32 trunc (i64 sub (i64 ptrtoint @f, i64 ptrtoint ...)) to i32); //; // In this case, replace the whole ""sub"" expression with constant 0 to; // avoid leaving a weird sub(0, symbol) expression behind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp:32,Deployability,release,released,32,// Make sure that all memory is released,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalDCE.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Modifiability,Variab,Variables,39,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:418,Modifiability,variab,variables,418,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:541,Modifiability,variab,variables,541,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:23,Performance,Optimiz,Optimize,23,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:404,Usability,simpl,simple,404,"//===- GlobalOpt.cpp - Optimize Global Variables --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms simple global variables that never have their address; // taken. If obviously true, it marks read/write globals as constant, deletes; // variables only stored to, etc.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:19,Modifiability,variab,variable,19,"/// Is this global variable possibly used by a leak checker as a root? If so,; /// we might not really want to eliminate the stores to it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Modifiability,variab,variable,12,"// A global variable is a root if it is a pointer, or could plausibly contain; // a pointer. There are two challenges; one is that we could have a struct; // the has an inner member which is a pointer. We recurse through the type to; // detect these (up to a point). The other is that we may actually be a union; // of a pointer and another type, and so our LLVM type is an integer which; // gets converted into a pointer, or our type is an [i8 x #] with a pointer; // potentially contained here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:237,Safety,detect,detect,237,"// A global variable is a root if it is a pointer, or could plausibly contain; // a pointer. There are two challenges; one is that we could have a struct; // the has an inner member which is a pointer. We recurse through the type to; // detect these (up to a point). The other is that we may actually be a union; // of a pointer and another type, and so our LLVM type is an integer which; // gets converted into a pointer, or our type is an [i8 x #] with a pointer; // potentially contained here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:89,Safety,safe,safe,89,"/// Given a value that is stored to a global but never read, determine whether; /// it's safe to remove the store and the chain of computation that feeds the; /// store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:162,Energy Efficiency,allocate,allocated,162,/// This GV is a pointer root. Loop over all users of the global and clean up; /// any that obviously don't assign the global a value that isn't dynamically; /// allocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:380,Availability,down,down,380,"// A brief explanation of leak checkers. The goal is to find bugs where; // pointers are forgotten, causing an accumulating growth in memory; // usage over time. The common strategy for leak checkers is to explicitly; // allow the memory pointed to by globals at exit. This is popular because it; // also solves another problem where the main thread of a C++ program may shut; // down before other threads that are still expecting to use those globals. To; // handle that case, we expect the program may create a singleton and never; // destroy it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Energy Efficiency,allocate,allocated,46,// Constants can't be pointers to dynamically allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:5,Performance,load,load,5,"// A load from a uniform value is always the same, regardless of any; // applied offset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:81,Performance,load,loads,81,"/// Part of the global at a specific offset, which is only accessed through; /// loads and stores with the given type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:59,Security,access,accessed,59,"/// Part of the global at a specific offset, which is only accessed through; /// loads and stores with the given type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Security,access,accesses,39,// TODO: We currently require that all accesses at a given offset must; // use the same type. This could be relaxed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Scalab,Scalable,3,// Scalable types not currently supported.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Modifiability,variab,variable,35,/// Copy over the debug info for a variable to its SRA replacements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable ends before start of fragment, ignore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable fits in (not greater than) the fragment,; // does not need fragment expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:11,Modifiability,variab,variable,11,"// Current variable does not fit in single fragment,; // emit a fragment expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:69,Modifiability,variab,variable,69,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:294,Modifiability,variab,variable,294,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:4,Performance,Perform,Perform,4,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:114,Performance,optimiz,optimizations,114,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:253,Safety,safe,safe,253,/// Perform scalar replacement of aggregates on the specified global variable.; /// This opens the door for other optimizations by exposing the behavior of the; /// program in a more fine-grained way. We have determined that this; /// transformation is safe already. We return the first global variable we; /// insert so that the caller can reprocess it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:9,Performance,perform,perform,9,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:104,Performance,load,loaded,104,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:160,Performance,optimiz,optimized,160,"// Don't perform SRA if we would have to split into many globals. Ignore; // parts that are either only loaded or only stored, because we expect them; // to be optimized away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:8,Security,access,accesses,8,"// Some accesses go beyond the end of the global, don't bother.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:129,Integrability,depend,depend,129,"// Calculate the known alignment of the field. If the original aggregate; // had 256 byte alignment for example, something might depend on that:; // propagate info to each field.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:36,Modifiability,variab,variable,36,// Copy over the debug info for the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Deployability,Update,Update,3,// Update the pointer operand and recalculate alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:149,Safety,avoid,avoid,149,/// Return true if all users of the specified value will trap if the value is; /// dynamically null. PHIs keeps track of any phi nodes we've seen to avoid; /// reprocessing them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:198,Modifiability,variab,variable,198,// This and only this kind of non-signed ICmpInst is to be replaced with; // the comparing of the value of the created global init bool later in; // optimizeGlobalAddressOfAllocation for the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:149,Performance,optimiz,optimizeGlobalAddressOfAllocation,149,// This and only this kind of non-signed ICmpInst is to be replaced with; // the comparing of the value of the created global init bool later in; // optimizeGlobalAddressOfAllocation for the global variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Performance,load,loads,35,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:66,Performance,load,loaded,66,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:140,Performance,load,loaded,140,"/// Return true if all uses of any loads from GV will trap if the loaded value; /// is null. Note that this also permits comparisons of the loaded value; /// against null, as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:44,Modifiability,variab,variable,44,/// Get all the loads/store uses for global variable \p GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Performance,load,loads,16,/// Get all the loads/store uses for global variable \p GV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:99,Performance,load,loaded,99,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:135,Performance,load,loaded,135,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:234,Performance,optimiz,optimize,234,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:252,Performance,load,load,252,"/// The specified global has only one non-null value stored into it. If there; /// are uses of the loaded value that would trap if the loaded value is; /// dynamically null, then we know that they cannot be reachable with a null; /// optimize away the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:23,Performance,load,loads,23,// Replace all uses of loads with uses of uses of the stored value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Performance,load,loads,45,// If we were able to delete all uses of the loads,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:75,Performance,load,loaded,75,// If we get here we could have other crazy uses that are transitively; // loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,loads,26,"// If we nuked all of the loads, then none of the stores are needed either,; // nor is the global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:39,Safety,avoid,avoid,39,// Advance UI to the next non-I use to avoid invalidating it!; // Instructions could multiply use V.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Modifiability,variab,variable,45,"/// This function takes the specified global variable, and transforms the; /// program as if it always contained the result of the specified malloc.; /// Because it is always the result of the specified malloc, there is no reason; /// to actually DO the malloc. Instead, turn the malloc into a global, and any; /// loads of GV as uses of the new global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:315,Performance,load,loads,315,"/// This function takes the specified global variable, and transforms the; /// program as if it always contained the result of the specified malloc.; /// Because it is always the result of the specified malloc, there is no reason; /// to actually DO the malloc. Instead, turn the malloc into a global, and any; /// loads of GV as uses of the new global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:55,Energy Efficiency,allocate,allocated,55,"// Create the new global variable. The contents of the allocated memory is; // undefined initially, so initialize with an undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:25,Modifiability,variab,variable,25,"// Create the new global variable. The contents of the allocated memory is; // undefined initially, so initialize with an undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Deployability,Update,Update,3,// Update users of the allocation to use the new global instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:20,Performance,optimiz,optimizations,20,"// To further other optimizations, loop over all users of NewGV and try to; // constant prop them. This will promote GEP instructions with constant; // indices into GEP constant-exprs, which will allow global-opt to hack on it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:103,Usability,simpl,simple,103,"/// Scan the use-list of GV checking to make sure that there are no complex uses; /// of GV. We permit simple things like dereferencing the pointer, but not; /// storing through the address, unless it is to the specified global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:154,Energy Efficiency,allocate,allocated,154,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:208,Safety,avoid,avoids,208,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:235,Security,access,accessing,235,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:259,Security,expose,exposes,259,"/// If we have a global that is only initialized with a fixed size allocation; /// try to transform the program to use global memory instead of heap; /// allocated memory. This eliminates dynamic allocation, avoids an indirection; /// accessing the data, and exposes the resultant global to further GlobalOpt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Performance,optimiz,optimize,12,"// We can't optimize this global unless all uses of it are *known* to be; // of the malloc value, not of the null initializer value (consider a use; // that compares the global's value against zero to see if the malloc has; // been reached). To do this, we check to see if all uses of the global; // would trap if the global were null: this proves that they must all; // happen after the malloc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:12,Performance,optimiz,optimize,12,"// We can't optimize this if the malloc itself is used in a complex way,; // for example, being stored into multiple globals. This allows the; // malloc to be stored into the specified global, loaded, gep, icmp'd.; // These are all things we could transform to using the global for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:193,Performance,load,loaded,193,"// We can't optimize this if the malloc itself is used in a complex way,; // for example, being stored into multiple globals. This allows the; // malloc to be stored into the specified global, loaded, gep, icmp'd.; // These are all things we could transform to using the global for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Performance,optimiz,optimize,10,// Try to optimize globals based on the knowledge that only one value (besides; // its initializer) is ever stored to the global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:137,Performance,optimiz,optimize,137,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:167,Performance,load,loaded,167,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:197,Performance,load,loads,197,"// If we are dealing with a pointer global that is initialized to null and; // only has one (non-null) value stored into it, then we can optimize any; // users of the loaded value (often calls and loads) that would trap if the; // value was null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize away any trapping uses of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loaded,42,// Optimize away any trapping uses of the loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:271,Performance,optimiz,optimizations,271,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:231,Security,expose,exposes,231,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:27,Usability,learn,learned,27,"/// At this point, we have learned that the only two values ever stored into GV; /// are its initializer and OtherVal. See if we can shrink the global into a; /// boolean and select between the two values whenever it is used. This exposes; /// the values to other scalar optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:127,Performance,optimiz,optimization,127,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:347,Performance,load,loads,347,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:226,Usability,simpl,simplification,226,"// If GVElType is already i1, it is already shrunk. If the type of the GV is; // an FP value, pointer or vector, don't do this optimization because a select; // between them is very expensive and unlikely to lead to later; // simplification. In these cases, we typically end up with ""cond ? v1 : v2""; // where v1 and v2 both require constant pool loads, a big loss.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:62,Performance,load,load,62,"// Walk the use list of the global seeing if all the uses are load or store.; // If there is anything else, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:261,Integrability,depend,depending,261,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:55,Modifiability,variab,variable,55,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:126,Modifiability,variab,variable,126,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:45,Performance,optimiz,optimized,45,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:98,Performance,optimiz,optimization,98,"// It is expected that the address of global optimized variable is on; // top of the stack. After optimization, value of that variable will; // be ether 0 for initial value or 1 for other value. The following; // expression should return constant integer value depending on the; // value at global object address:; // val * (ValOther - ValInit) + ValInit:; // DW_OP_deref DW_OP_constu <ValMinus>; // DW_OP_mul DW_OP_constu <ValInit> DW_OP_plus DW_OP_stack_value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:40,Performance,load,loaded,40,// Only do this if we weren't storing a loaded value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loaded,42,"// Otherwise, we are storing a previously loaded copy. To do this,; // change the copy from copying the original value to just copying the; // bool.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:113,Performance,load,load,113,"// If we've already replaced the input, StoredVal will be a cast or; // select instruction. If not, it will be a load of the original; // global.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Performance,load,load,16,"// Insert a new load, to preserve the saved value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:14,Performance,load,load,14,// Change the load into a load of bool then a select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,load,26,// Change the load into a load of bool then a select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:61,Modifiability,inherit,inherit,61,"// Since LI is split into two instructions, NLI and NSI both inherit the; // same DebugLoc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:37,Modifiability,variab,variable,37,// Retain the name of the old global variable. People who are debugging their; // programs may expect these variables to be named the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:108,Modifiability,variab,variables,108,// Retain the name of the old global variable. People who are debugging their; // programs may expect these variables to be named the same.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:429,Usability,simpl,simply,429,"// Find all uses of GV. We expect them all to be in F, and if we can't; // identify any of the uses we bail out.; //; // On each of these uses, identify if the memory that GV points to is; // used/required/live at the start of the function. If it is not, for example; // if the first thing the function does is store to the GV, the GV can; // possibly be demoted.; //; // We don't do an exhaustive search for memory operations - simply look; // through bitcasts as they're quite common and benign.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:106,Integrability,depend,depend,106,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:42,Performance,load,loads,42,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:207,Performance,load,load,207,// We have identified all uses of GV into loads and stores. Now check if all; // of them are known not to depend on the value of the global at the function; // entry point. We do this by ensuring that every load is dominated by at; // least one store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:478,Energy Efficiency,power,powerful,478,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:274,Performance,load,load,274,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:487,Performance,optimiz,optimization,487,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:70,Testability,test,tests,70,"// The below check is quadratic. Check we're not going to do too many tests.; // FIXME: Even though this will always have worst-case quadratic time, we; // could put effort into minimizing the average time by putting stores that; // have been shown to dominate at least one load at the beginning of the; // Stores array, making subsequent dominance checks more likely to succeed; // early.; //; // The threshold here is fairly large because global->local demotion is a; // very powerful optimization should it fire.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:7,Performance,load,load,7,// The load is only dominated by the store if DomTree says so; // and the number of bits loaded in L is less than or equal to; // the number of bits stored in S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:89,Performance,load,loaded,89,// The load is only dominated by the store if DomTree says so; // and the number of bits loaded in L is less than or equal to; // the number of bits stored in S.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:24,Integrability,depend,dependences,24,"// All loads have known dependences inside F, so the global can be localized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:7,Performance,load,loads,7,"// All loads have known dependences inside F, so the global can be localized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:16,Modifiability,variab,variable,16,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:68,Performance,load,loads,68,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:85,Performance,load,loads,85,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:103,Performance,load,load,103,"// For a global variable with one store, if the store dominates any loads,; // those loads will always load the stored value (as opposed to the; // initializer), even in the presence of recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:18,Performance,optimiz,optimization,18,"// We can do this optimization for non-constants in nosync + norecurse; // functions, but globals used in exactly one norecurse functions are already; // promoted to an alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:34,Performance,load,loads,34,// Only compute DT if we have any loads to examine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:33,Modifiability,variab,variable,33,"/// Analyze the specified global variable and optimize; /// it if possible. If we make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Performance,optimiz,optimize,46,"/// Analyze the specified global variable and optimize; /// it if possible. If we make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:52,Security,access,accessing,52,"// If this is a first class global and has only one accessing function and; // this function is non-recursive, we replace the global with a local alloca; // in this function.; //; // NOTE: It doesn't make sense to promote non-single-value types since we; // are just replacing static memory to stack memory.; //; // If the global is in different address space, don't bring it to stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Performance,load,loaded,26,"// If the global is never loaded (but may be stored to), it is dead.; // Delete it now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:187,Modifiability,variab,variable,187,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:71,Performance,load,loads,71,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:173,Security,access,access,173,// Don't actually mark a global constant if it's atomic because atomic loads; // are implemented by a trivial cmpxchg in some edge-cases and that usually; // requires write access to the variable even if it's not actually changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Usability,simpl,simplifiable,26,// Clean up any obviously simplifiable users now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:49,Performance,optimiz,optimize,49,// Fall through to the next check; see if we can optimize further.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:26,Usability,simpl,simplifiable,26,// Clean up any obviously simplifiable users now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Performance,optimiz,optimize,10,// Try to optimize globals based on the knowledge that only one value; // (besides its initializer) is ever stored to the global.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:35,Performance,load,loads,35,"// Try to forward the store to any loads. If we have more than one store, we; // may have a store of the initializer between StoredOnceStore and a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:147,Performance,load,load,147,"// Try to forward the store to any loads. If we have more than one store, we; // may have a store of the initializer between StoredOnceStore and a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:95,Performance,optimiz,optimization,95,"// Otherwise, if the global was not a boolean, we can shrink it to be a; // boolean. Skip this optimization for AS that doesn't allow an initializer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:33,Modifiability,variab,variable,33,"/// Analyze the specified global variable and optimize it if possible. If we; /// make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:46,Performance,optimiz,optimize,46,"/// Analyze the specified global variable and optimize it if possible. If we; /// make a change, return true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:20,Performance,optimiz,optimizations,20,// Do more involved optimizations if the global is internal.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:196,Performance,perform,performance,196,"/// Return true if this is a calling convention that we'd like to change. The; /// idea here is that we don't want to mess with the convention if the user; /// explicitly requested something with performance implications like coldcc,; /// GHC, or anyregcc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:214,Integrability,depend,dependent,214,"// Skip over intrinsics since they won't remain as function calls.; // Important to do this check before the linkage check below so we; // won't bail out on debug intrinsics, possibly making the generated; // code dependent on the presence of debug info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:9,Performance,perform,perform,9,// Don't perform global opt pass on naked functions; we don't want fast; // calling conventions for naked functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:424,Testability,log,logic,424,"// LLVM's definition of dominance allows instructions that are cyclic; // in unreachable blocks, e.g.:; // %pat = select i1 %condition, @global, i16* %pat; // because any instruction dominates an instruction in a block that's; // not reachable from entry.; // So, remove unreachable blocks from the function, because a) there's; // no point in analyzing them and b) GlobalOpt should otherwise grow; // some more complicated logic to break these cycles.; // Notify the analysis manager that we've modified the function's CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:115,Performance,optimiz,optimizations,115,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:48,Safety,safe,safely,48,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:150,Safety,safe,safe,150,"// If we have an inalloca parameter that we can safely remove the; // inalloca attribute from, do so. This unlocks optimizations that; // wouldn't be safe in the presence of inalloca.; // FIXME: We should also hoist alloca affected by this to the entry; // block if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:60,Testability,test,testing,60,// Change the calling convention to coldcc if either stress testing is; // enabled or the target would like to use coldcc on functions which are; // cold at all call sites and the callers contain no other non coldcc; // calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:64,Safety,safe,safe,64,"// The function is not used by a trampoline intrinsic, so it is safe; // to remove the 'nest' attribute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:10,Modifiability,variab,variables,10,// Global variables without names cannot be referenced outside this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Usability,Simpl,Simplify,3,// Simplify the initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:15,Security,access,access,15,/// An easy to access representation of llvm.used and llvm.compiler.used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:63,Usability,simpl,simplify,63,"// If the alias is externally visible, we may still be able to simplify it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:254,Security,access,access,254,"// We can't trivially replace the alias with the aliasee if the aliasee is; // non-trivial in some way. We also can't replace the alias with the aliasee; // if the aliasee may be preemptible at runtime. On ELF, a non-preemptible; // alias can be used to access the definition as if preemption did not; // happen.; // TODO: Try to handle non-zero GEPs of local aliasees.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:140,Performance,optimiz,optimization,140,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:173,Usability,simpl,simplified,173,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:204,Usability,simpl,simply,204,/// Returns whether the given function is an empty C++ destructor and can; /// therefore be eliminated.; /// Note that we assume that other optimization passes have already simplified; /// the code so we simply check for 'ret'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:513,Availability,failure,failure,513,"/// Itanium C++ ABI p3.3.5:; ///; /// After constructing a global (or local static) object, that will require; /// destruction on exit, a termination function is registered as follows:; ///; /// extern ""C"" int __cxa_atexit ( void (*f)(void *), void *p, void *d );; ///; /// This registration, e.g. __cxa_atexit(f,p,d), is intended to cause the; /// call f(p) when DSO d is unloaded, before all such termination calls; /// registered before this one. It returns zero if registration is; /// successful, nonzero on failure.; // This pass will look for calls to __cxa_atexit where the function is trivial; // and remove them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize global_ctors list.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:3,Performance,Optimiz,Optimize,3,// Optimize non-address-taken globals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp:19,Usability,clear,clear,19,// We made sure to clear analyses for deleted functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalOpt.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:32,Modifiability,variab,variable,32,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:634,Performance,optimiz,optimization,634,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:664,Security,integrity,integrity,664,"//===- GlobalSplit.cpp - global variable splitter -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass uses inrange annotations on GEP indices to split globals where; // beneficial. Clang currently attaches these annotations to references to; // virtual table globals under the Itanium ABI for the benefit of the; // whole-program virtual call optimization and control flow integrity passes.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:111,Performance,load,loads,111,"// Verify that each user of the global is an inrange getelementptr constant.; // From this it follows that any loads from or stores to that global must use; // a pointer derived from an inrange getelementptr constant, which is; // sufficient to allow us to apply the splitting transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:316,Modifiability,variab,variables,316,"// Type metadata may be attached one byte after the end of the vtable, for; // classes without virtual methods in Itanium ABI. AFAIK, it is never; // attached to the first byte of a vtable. Subtract one to get the right; // slice.; // This is making an assumption that vtable groups are the only kinds of; // global variables that !type metadata can be attached to, and that they; // are either Itanium ABI vtable groups or contain a single vtable (i.e.; // Microsoft ABI vtables).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:87,Performance,load,load,87,"// First, see if the module uses either of the llvm.type.test or; // llvm.type.checked.load intrinsics, which indicates that splitting globals; // may be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp:57,Testability,test,test,57,"// First, see if the module uses either of the llvm.type.test or; // llvm.type.checked.load intrinsics, which indicates that splitting globals; // may be beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/GlobalSplit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:1041,Safety,safe,safe,1041,"//===- HotColdSplitting.cpp -- Outline Cold Regions -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// The goal of hot/cold splitting is to improve the memory locality of code.; /// The splitting pass does this by identifying cold blocks and moving them into; /// separate functions.; ///; /// When the splitting pass finds a cold block (referred to as ""the sink""), it; /// grows a maximal cold region around that block. The maximal region contains; /// all blocks (post-)dominated by the sink [*]. In theory, these blocks are as; /// cold as the sink. Once a region is found, it's split out of the original; /// function provided it's profitable to do so.; ///; /// [*] In practice, there is some added complexity because some blocks are not; /// safe to extract.; ///; /// TODO: Use the PM to get domtrees, and preserve BFI/BPI.; /// TODO: Reorder outlined functions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:83,Security,sanitiz,sanitizer,83,"// The block is cold if it calls/invokes a cold function. However, do not; // mark sanitizer traps as cold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:23,Safety,safe,safe,23,/// Check whether it's safe to outline \p BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:15,Safety,unsafe,unsafe,15,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:338,Safety,safe,safe,338,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:233,Usability,Resume,Resumes,233,"// EH pads are unsafe to outline because doing so breaks EH type tables. It; // follows that invoke instructions cannot be extracted, because CodeExtractor; // requires unwind destinations to be within the extraction region.; //; // Resumes that are not reachable from a cleanup landing pad are considered to; // be unreachable. It’s not safe to split them out either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:92,Deployability,Update,UpdateEntryCount,92,"/// Mark \p F cold. Based on this assumption, also optimize it for minimum size.; /// If \p UpdateEntryCount is true (set when this is a new split function and; /// module has profile data), set entry count to 0 to ensure treated as cold.; /// Return true if the function is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,Performance,optimiz,optimize,51,"/// Mark \p F cold. Based on this assumption, also optimize it for minimum size.; /// If \p UpdateEntryCount is true (set when this is a new split function and; /// module has profile data), set entry count to 0 to ensure treated as cold.; /// Return true if the function is changed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:81,Performance,optimiz,optimization,81,// Returns false if the function should not be considered for hot-cold split; // optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:68,Modifiability,coupling,coupling,68,// Sum up the code size costs of non-terminator instructions. Tight coupling; // with \ref getOutliningPenalty is needed to model the costs of terminators.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:29,Deployability,update,update,29,// TODO: Pass BFI and BPI to update profile information.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Performance,Perform,Perform,3,// Perform a simple cost/benefit analysis to decide whether or not to permit; // splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:13,Usability,simpl,simple,13,// Perform a simple cost/benefit analysis to decide whether or not to permit; // splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Deployability,Update,Update,3,// Update the suggested entry point.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:49,Performance,perform,performs,49,"// Set up an RPO traversal. Experimentally, this performs better (outlines; // more) than a PO traversal, because we prevent region overlap by keeping; // the first region to contain a block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:35,Energy Efficiency,reduce,reduces,35,// Calculate domtrees lazily. This reduces compile-time significantly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:79,Energy Efficiency,reduce,reduces,79,"// Calculate BFI lazily (it's only used to query ProfileSummaryInfo). This; // reduces compile-time significantly. TODO: When we *do* use BFI, we should; // be able to salvage its domtrees instead of recomputing them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Performance,Cache,Cache,3,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:51,Safety,avoid,avoid,51,// Cache and recycle the CodeExtractor analysis to avoid O(n^2) compile-time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp:3,Safety,Detect,Detect,3,// Detect inherently cold functions and mark them as such.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/HotColdSplitting.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:168,Safety,avoid,avoid,168,// We only infer things using the prototype and the name; we don't need; // definitions. This ensures libfuncs are annotated and also allows our; // CGSCC inference to avoid needing to duplicate the inference from other; // attribute logic on all calls to declarations (as declarations aren't; // explicitly visited by CGSCC passes in the new pass manager.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:234,Testability,log,logic,234,// We only infer things using the prototype and the name; we don't need; // definitions. This ensures libfuncs are annotated and also allows our; // CGSCC inference to avoid needing to duplicate the inference from other; // attribute logic on all calls to declarations (as declarations aren't; // explicitly visited by CGSCC passes in the new pass manager.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp:70,Usability,clear,clear,70,"// Otherwise, we may have changed fundamental function attributes, so clear; // out all the passes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/InferFunctionAttrs.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:119,Deployability,pipeline,pipeline,119,"/// A flag for test, so we can print the content of the advisor when running it; /// as part of the default (e.g. -O3) pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:15,Testability,test,test,15,"/// A flag for test, so we can print the content of the advisor when running it; /// as part of the default (e.g. -O3) pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:85,Testability,test,test,85,"// It should still be possible to run the inliner as a stand-alone SCC pass,; // for test scenarios. In that case, we default to the; // DefaultInlineAdvisor, which doesn't need to keep state between SCC pass; // runs. It also uses just the default InlineParams.; // In this case, we need to use the provided FAM, which is valid for the; // duration of the inliner pass, and thus the lifetime of the owned advisor.; // The one we would get from the MAM can be invalidated as a result of the; // inliner's activity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:358,Safety,avoid,avoid,358,"// We use a single common worklist for calls across the entire SCC. We; // process these in-order and append new calls introduced during inlining to; // the end. The PriorityInlineOrder is optional here, in which the smaller; // callee would have a higher priority to inline.; //; // Note that this particular order of processing is actually critical to; // avoid very bad behaviors. Consider *highly connected* call graphs where; // each function contains a small amount of code and a couple of calls to; // other functions. Because the LLVM inliner is fundamentally a bottom-up; // inliner, it can handle gracefully the fact that these all appear to be; // reasonable inlining candidates as it will flatten things until they become; // too big to inline, and then move on and flatten another batch.; //; // However, when processing call edges *within* an SCC we cannot rely on this; // bottom-up behavior. As a consequence, with heavily connected *SCCs* of; // functions we can end up incrementally inlining N calls into each of; // N functions because each incremental inlining decision looks good and we; // don't have a topological ordering to prevent explosions.; //; // To compensate for this, we don't process transitive edges made immediate; // by inlining until we've done one pass of inlining across the entire SCC.; // Large, highly connected SCCs still lead to some amount of code bloat in; // this model, but it is uniformly spread across all the functions in the SCC; // and eventually they all become too large to inline, rather than; // incrementally maknig a single function grow in a super linear fashion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:47,Availability,down,down,47,// We want to generally process call sites top-down in order for; // simplifications stemming from replacing the call with the returned value; // after inlining to be visible to subsequent inlining decisions.; // FIXME: Using instructions sequence is a really bad way to do this.; // Instead we should do an actual RPO walk of the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:69,Usability,simpl,simplifications,69,// We want to generally process call sites top-down in order for; // simplifications stemming from replacing the call with the returned value; // after inlining to be visible to subsequent inlining decisions.; // FIXME: Using instructions sequence is a really bad way to do this.; // Instead we should do an actual RPO walk of the function body.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:21,Modifiability,variab,variable,21,// Capture updatable variable for the current SCC.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:147,Safety,avoid,avoid,147,"// When inlining a callee produces new call sites, we want to keep track of; // the fact that they were inlined from the callee. This allows us to avoid; // infinite inlining in some obscure cases. To represent this, we use an; // index into the InlineHistory vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:162,Usability,simpl,simplified,162,// Track a set vector of inlined callees so that we can augment the caller; // with all of their edges in the call graph before pruning out the ones that; // got simplified away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:144,Deployability,update,updates,144,// Track the dead functions to delete once finished with inlining calls. We; // defer deleting these to make it easier to handle the call graph updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:59,Performance,cache,cache,59,// Loop forward over all of the calls. Note that we cannot cache the size as; // inlining can introduce new calls that need to be processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:138,Deployability,update,update,138,// Now process as many calls as we have within this caller in the sequence.; // We bail out as soon as the caller has to change so we can update the; // call graph and prepare the context of that new caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:86,Integrability,rout,routine,86,// Setup the data structure used to plumb customization into the; // `InlineFunction` routine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:509,Performance,perform,performance,509,"// Continually inlining through an SCC can result in huge compile; // times and bloated code since we arbitrarily stop at some point; // when the inliner decides it's not profitable to inline anymore.; // We attempt to mitigate this by making these calls exponentially; // more expensive.; // This doesn't apply to calls in the same SCC since if we do; // inline through the SCC the function will end up being; // self-recursive which the inliner bails out on, and inlining; // within an SCC is necessary for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:194,Energy Efficiency,reduce,reduce,194,"// For local functions or discardable functions without comdats, check; // whether this makes the callee trivially dead. In that case, we can drop; // the body of the function eagerly which may reduce the number of callers; // of other functions to one, changing inline cost thresholds. Non-local; // discardable functions with comdats are checked later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:154,Availability,error,error,154,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:104,Deployability,update,updates,104,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:22,Performance,queue,queue,22,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:3,Usability,Clear,Clear,3,"// Clear the body and queue the function itself for deletion when we; // finish inlining and call graph updates.; // Note that after this point, it is an error to do anything other; // than use the callee's address or delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:383,Deployability,update,update,383,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:399,Deployability,update,update,399,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:307,Testability,log,logic,307,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:145,Usability,simpl,simplification,145,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:190,Usability,simpl,simplification,190,"// At this point, since we have made changes we have at least removed; // a call instruction. However, in the process we do some incremental; // simplification of the surrounding code. This simplification can; // essentially do all of the same things as a function pass and we can; // re-use the exact same logic for updating the call graph to reflect the; // change.; // Inside the update, we also update the FunctionAnalysisManager in the; // proxy for this particular SCC. We do this as the SCC may have changed and; // as we're going to mutate this particular function we want to make sure; // the proxy is in place to forward any invalidation events.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:687,Energy Efficiency,efficient,efficient,687,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:1220,Energy Efficiency,efficient,efficient,1220,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:90,Safety,risk,risk,90,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:475,Safety,avoid,avoid,475,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:656,Safety,avoid,avoided,656,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:149,Security,expose,expose,149,"// If this causes an SCC to split apart into multiple smaller SCCs, there; // is a subtle risk we need to prepare for. Other transformations may; // expose an ""infinite inlining"" opportunity later, and because of the SCC; // mutation, we will revisit this function and potentially re-inline. If we; // do, and that re-inlining also has the potentially to mutate the SCC; // structure, the infinite inlining problem can manifest through infinite; // SCC splits and merges. To avoid this, we capture the originating caller; // node and the SCC containing the call edge. This is a slight over; // approximation of the possible inlining decisions that must be avoided,; // but is relatively efficient to store. We use C != OldC to know when; // a new SCC is generated and the original SCC may be generated via merge; // in later iterations.; //; // It is also possible that even if no new SCC is generated; // (i.e., C == OldC), the original SCC could be split and then merged; // into the same one as itself. and the original SCC will be added into; // UR.CWorklist again, we want to catch such cases too.; //; // FIXME: This seems like a very heavyweight way of retaining the inline; // history, we should look for a more efficient way of tracking it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:108,Performance,cache,cached,108,"// Get the necessary information out of the call graph and nuke the; // function there. Also, clear out any cached analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:94,Usability,clear,clear,94,"// Get the necessary information out of the call graph and nuke the; // function there. Also, clear out any cached analyses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:10,Deployability,update,updated,10,"// If the updated SCC was the one containing the deleted function, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:67,Usability,clear,clear,67,"// If the updated SCC was the one containing the deleted function, clear it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:32,Deployability,update,update,32,"// Even if we change the IR, we update the core CGSCC data structures and so; // can preserve the proxy to the function analysis manager.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:117,Performance,optimiz,optimized,117,"// Run the inliner first. The theory is that we are walking bottom-up and so; // the callees have already been fully optimized, and we want to inline them; // into the callers so that our optimizations can reflect that.; // For PreLinkThinLTO pass, we disable hot-caller heuristic for sample PGO; // because it makes profile annotation in the backend inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:188,Performance,optimiz,optimizations,188,"// Run the inliner first. The theory is that we are walking bottom-up and so; // the callees have already been fully optimized, and we want to inline them; // into the callers so that our optimizations can reflect that.; // For PreLinkThinLTO pass, we disable hot-caller heuristic for sample PGO; // because it makes profile annotation in the backend inaccurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:21,Deployability,pipeline,pipeline,21,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:271,Deployability,pipeline,pipeline,271,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:6,Integrability,wrap,wrap,6,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:409,Integrability,wrap,wrapper,409,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:83,Safety,detect,detect,83,"// We wrap the CGSCC pipeline in a devirtualization repeater. This will try; // to detect when we devirtualize indirect calls and iterate the SCC passes; // in that case to try and catch knock-on inlining or function attrs; // opportunities. Then we add it to the module pipeline by walking the SCCs; // in postorder (or bottom-up).; // If MaxDevirtIterations is 0, we just don't use the devirtualization; // wrapper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:45,Integrability,wrap,wrapper,45,// Print some info about passes added to the wrapper. This is however; // incomplete as InlineAdvisorAnalysis part isn't included (which also depends; // on Params and Mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp:142,Integrability,depend,depends,142,// Print some info about passes added to the wrapper. This is however; // incomplete as InlineAdvisorAnalysis part isn't included (which also depends; // on Params and Mode).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Inliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:429,Modifiability,variab,variables,429,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:483,Modifiability,variab,variable,483,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:732,Safety,safe,safe,732,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:878,Safety,safe,safe,878,"//===-- Internalize.cpp - Mark functions internal -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass loops over all of the functions and variables in the input module.; // If the function or variable does not need to be preserved according to the; // client supplied callback, it is marked as internal.; //; // This transformation would not be legal in a regular compilation, but it gets; // extra information from the linker about what is safe.; //; // For example: Internalizing a function with external linkage. Only if we are; // told it is only used from within this module, it is safe to do it.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:13,Performance,load,load,13,// Helper to load an API list to preserve from file and expose it as a functor; // for internalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:56,Security,expose,expose,56,// Helper to load an API list to preserve from file and expose it as a functor; // for internalization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:31,Performance,load,loaded,31,// Contains the set of symbols loaded from file,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:3,Performance,Load,Load,3,// Load the APIFile...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:3,Availability,Avail,Available,3,"// Available externally is really just a ""declaration with a body"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:48,Modifiability,variab,variables,48,"// As the name suggests, externally initialized variables need preserving as; // they would be initialized elsewhere externally.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:125,Integrability,depend,dependencies,125,"// If a comdat with one member is not externally visible, we can drop it.; // Otherwise, the comdat can be used to establish dependencies among the; // group of sections. Thus we have to keep the comdat but switch it to; // nodeduplicate.; // Note: nodeduplicate is not necessary for COFF. wasm doesn't support; // nodeduplicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:56,Deployability,update,update,56,"// If GV is part of a comdat and is externally visible, update the comdat size; // and keep track of its comdat so that we don't internalize any of its members.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp:19,Modifiability,variab,variables,19,// Mark all global variables with initializers that are not in the api as; // internal as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/Internalize.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:29,Testability,test,test,29,// This is a debug option to test small pieces of code to ensure that outlining; // works correctly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:80,Safety,avoid,avoid,80,/// Tracker counting backwards from the highest unsigned value possible to; /// avoid conflicting with the GVNs of assigned values. We start at -3 since; /// -2 and -1 are assigned by the DenseMap.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite the BranchInsts in the incoming blocks to \p PHIBlock that are found; /// in \p Included to branch to BasicBlock \p Replace if they currently branch; /// to the BasicBlock \p Find. This is used to fix up the incoming basic blocks; /// when PHINodes are included in outlined regions.; ///; /// \param PHIBlock - The BasicBlock containing the PHINodes that need to be; /// checked.; /// \param Find - The successor block to be replaced.; /// \param Replace - The new succesor block to branch to.; /// \param Included - The set of blocks about to be outlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:305,Modifiability,variab,variable,305,"// We iterate over the instructions in the region, if we find a PHINode, we; // check if there are predecessors outside of the region, if there are,; // we ignore this region since we are unable to handle the severing of the; // phi node right now.; // TODO: Handle extraneous inputs for PHINodes through variable number of; // inputs, similar to how outputs are handled.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:96,Deployability,update,updated,96,"// If there was a PHINode with an incoming block outside the region,; // make sure is correctly updated in the newly split block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:73,Deployability,update,updated,73,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:167,Deployability,update,updated,167,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:284,Deployability,update,updated,284,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:355,Deployability,update,update,355,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:666,Deployability,update,update,666,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:265,Testability,log,logic,265,"// Make sure PHINode references to the block we are merging into are; // updated to be incoming blocks from the predecessor to the current block.; // NOTE: If this is updated such that the outlined block can have more than; // one incoming block to a PHINode, this logic will have to updated; // to handle multiple precessors instead.; // We only need to update this if the outlined section contains a PHINode, if; // it does not, then the incoming block was never changed in the first place.; // On the other hand, if PrevBB has no predecessors, it means that all; // incoming blocks to the first block are contained in the region, and there; // will be nothing to update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:20,Performance,optimiz,optimized,20,/* Outlined code is optimized code by definition. */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:21,Modifiability,variab,variables,21,// Don't add any new variables to the subprogram.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:50,Deployability,Update,Update,50,// Loop info metadata may contain line locations. Update them to have no; // value in the new subprogram since the outlined code could be from; // several locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:4,Testability,Test,Test,4,"/// Test whether \p CurrentExitFromRegion contains any PhiNodes that should be; /// considered outputs. A PHINodes is an output when more than one incoming; /// value has been marked by the CodeExtractor as an output.; ///; /// \param CurrentExitFromRegion [in] - The block to analyze.; /// \param PotentialExitsFromRegion [in] - The potential exit blocks from the; /// region.; /// \param RegionBlocks [in] - The basic blocks in the region.; /// \param Outputs [in, out] - The existing outputs for the region, we may add; /// PHINodes to this as we find that they replace output values.; /// \param OutputsReplacedByPHINode [out] - A set containing outputs that are; /// totally replaced by a PHINode.; /// \param OutputsWithNonPhiUses [out] - A set containing outputs that are used; /// in PHINodes, but have other uses, and should still be considered outputs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:233,Security,hash,hash,233,"/// Encode \p PND as an integer for easy lookup based on the argument location,; /// the parent BasicBlock canonical numbering, and the canonical numbering of; /// the values stored in the PHINode.; ///; /// \param PND - The data to hash.; /// \returns The hash code of \p PND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:257,Security,hash,hash,257,"/// Encode \p PND as an integer for easy lookup based on the argument location,; /// the parent BasicBlock canonical numbering, and the canonical numbering of; /// the values stored in the PHINode.; ///; /// \param PND - The data to hash.; /// \returns The hash code of \p PND.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:96,Security,hash,hash,96,"/// Create a special GVN for PHINodes that will be used outside of; /// the region. We create a hash code based on the Canonical number of the; /// parent BasicBlock, the canonical numbering of the values stored in the; /// PHINode and the aggregate argument location. This is used to find whether; /// this PHINode type has been given a canonical numbering already. If not, we; /// assign it a value and store it for later use. The value is returned to; /// identify different output schemes for the set of regions.; ///; /// \param Region - The region that \p PN is an output for.; /// \param PN - The PHINode we are analyzing.; /// \param Blocks - The blocks for the region we are analyzing.; /// \param AggArgIdx - The argument \p PN will be stored into.; /// \returns An optional holding the assigned canonical number, or std::nullopt; /// if there is some attribute of the PHINode blocking it from being used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:85,Security,hash,hash,85,// Find the incoming block and use the canonical numbering as well to define; // the hash for the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:179,Security,hash,hash,179,"// Now that we have the GVNs for the incoming values, we are going to combine; // them with the GVN of the incoming bock, and the output location of the; // PHINode to generate a hash value representing this instance of the PHINode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:9,Energy Efficiency,Adapt,Adapt,9,// TODO: Adapt to the extra input from the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:9,Modifiability,Adapt,Adapt,9,// TODO: Adapt to the extra input from the PHINode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:344,Integrability,depend,dependent,344,"// Values outside the region can be combined into PHINode when we; // have multiple exits. We collect both of these into a list to identify; // which values are being used in the PHINode. Each list identifies a; // different PHINode, and a different output. We store the PHINode as it's; // own canonical value. These canonical values are also dependent on the; // output argument it is saved to.; // If two PHINodes have the same canonical values, but different aggregate; // argument locations, then they will have distinct Canonical Values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:198,Usability,simpl,simply,198,"// If the arguments are the same size, there are not values that need to be; // made into an argument, the argument ordering has not been change, or; // different output registers to handle. We can simply replace the called; // function in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:87,Usability,simpl,simply,87,"// If we found the mapping from the extracted function to the overall; // function, we simply add it to the argument list. We use the same; // value, it just needs to honor the new order of arguments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:27,Usability,simpl,simply,27,"// If it is a constant, we simply add it to the argument list as a value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:39,Usability,simpl,simply,39,"// The argument is an input, so we can simply replace it with the overall; // argument value",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:60,Performance,perform,performs,60,"/// It is possible that there is a basic block that already performs the same; /// stores. This returns a duplicate block, if it exists; ///; /// \param OutputBBs [in] the blocks we are looking for a duplicate of.; /// \param OutputStoreBBs [in] The existing output blocks.; /// \returns an optional value with the number output block if there is a match.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:77,Testability,stub,stub,77,// Move the return value to the final block instead of the original exit; // stub.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:24,Performance,load,load,24,"// Each output incurs a load after the call, so we add that to the cost.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:53,Performance,load,loading,53,"// For each argument, we must add an instruction for loading the argument; // out of the register and into a value inside of the newly outlined function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:36,Performance,load,loaded,36,// Each argument needs to either be loaded into a register or onto the stack.; // Some arguments will only be loaded into the stack once the argument; // registers are filled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:110,Performance,load,loaded,110,// Each argument needs to either be loaded into a register or onto the stack.; // Some arguments will only be loaded into the stack once the argument; // registers are filled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:11,Performance,load,load,11,// For and load instructions following the call,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp:111,Safety,avoid,avoid,111,// Creating OutlinableGroups for each SimilarityCandidate to be used in; // each of the following for loops to avoid making an allocator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/IROutliner.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:390,Integrability,wrap,wrapper,390,"//===- LoopExtractor.cpp - Extract each loop into a new function ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // A pass wrapper around the ExtractLoop() scalar transformation to extract each; // top-level loop into its own new function. If the loop is the ONLY loop in a; // given function, it is not touched. This is a pass most useful for debugging; // via bugpoint.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:105,Integrability,wrap,wrapper,105,"// If the loop is in LoopSimplify form, then extract it only if this function; // is more than a minimal wrapper around the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp:31,Availability,avail,available,31,"// If LoopSimplify form is not available, stay out of trouble.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LoopExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:441,Testability,test,test,441,"//===- LowerTypeTests.cpp - type metadata lowering pass -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass lowers type metadata and calls to the llvm.type.test intrinsic.; // It also ensures that globals are properly laid out for the; // llvm.icall.branch.funnel intrinsic.; // See http://llvm.org/docs/TypeMetadata.html for more information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:157,Availability,mask,mask,157,"// Normalize each offset against the minimum observed offset, and compute; // the bitwise OR of each of the offsets. The number of trailing zeros; // in the mask gives us the log2 of the alignment of all offsets, which; // allows us to compress the bitset by only storing one bit per aligned; // address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Deployability,update,update,140,"// This index belongs to an existing fragment. Copy the elements of the; // old fragment into this one and clear the old fragment. We don't update; // the fragment map just yet, this ensures that any further references to; // indices from the old fragment in this fragment do not insert any more; // indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:107,Usability,clear,clear,107,"// This index belongs to an existing fragment. Copy the elements of the; // old fragment into this one and clear the old fragment. We don't update; // the fragment map just yet, this ensures that any further references to; // indices from the old fragment in this fragment do not insert any more; // indices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update the fragment map to point our object indices to this fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:306,Energy Efficiency,reduce,reduce,306,"/// A POD-like structure that we use to store a global reference together with; /// its metadata types. In this pass we frequently need to query the set of; /// metadata types referenced by a global, which at the IR level is an expensive; /// operation involving a map lookup; this data structure helps to reduce the; /// number of times we need to do this lookup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:380,Modifiability,variab,variables,380,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:163,Safety,avoid,avoid,163,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:199,Safety,avoid,avoid,199,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:310,Safety,avoid,avoid,310,"// The users of this class want to replace all function references except; // for aliases and llvm.used/llvm.compiler.used with references to a jump; // table. We avoid replacing aliases in order to avoid introducing a double; // indirection (or an alias pointing to a declaration in ThinLTO mode), and; // we avoid replacing llvm.used/llvm.compiler.used because these global; // variables describe properties of the global, not the jump table (besides,; // offseted references to the jump table in llvm.used are invalid).; // Unfortunately, LLVM doesn't have a ""RAUW except for these (possibly; // indirect) users"", so what we do is save the list of globals referenced by; // llvm.used/llvm.compiler.used and aliases, erase the used lists, let RAUW; // replace the aliasees and then set them back to their original values at; // the end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:64,Testability,test,test,64,// Set when the client has invoked this to simply drop all type test assume; // sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:43,Usability,simpl,simply,43,// Set when the client has invoked this to simply drop all type test assume; // sequences.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:9,Modifiability,variab,variable,9,// Cache variable used by hasBranchTargetEnforcement().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Performance,Cache,Cache,3,// Cache variable used by hasBranchTargetEnforcement().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:203,Deployability,pipeline,pipeline,203,"// Mapping from type identifiers to the call sites that test them, as well as; // whether the type identifier needs to be exported to ThinLTO backends as; // part of the regular LTO phase of the ThinLTO pipeline (see exportTypeId).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:56,Testability,test,test,56,"// Mapping from type identifiers to the call sites that test them, as well as; // whether the type identifier needs to be exported to ThinLTO backends as; // part of the regular LTO phase of the ThinLTO pipeline (see exportTypeId).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:47,Testability,test,tests,47,"/// This structure describes how to lower type tests for a particular type; /// identifier. It is either built directly from the global analysis (during; /// regular LTO or the regular LTO phase of ThinLTO), or indirectly using type; /// identifier summaries and external symbol references (in ThinLTO backends).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:33,Testability,test,test,33,/// ByteArray: the byte array to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:23,Availability,mask,mask,23,/// ByteArray: the bit mask to apply to bytes loaded from the byte array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:46,Performance,load,loaded,46,/// ByteArray: the bit mask to apply to bytes loaded from the byte array.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:20,Availability,mask,mask,20,/// Inline: the bit mask to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:28,Testability,test,test,28,/// Inline: the bit mask to test the address against.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:91,Testability,test,testing,91,// Lower the module using the action and summary passed as command line; // arguments. For testing purposes only.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:12,Testability,test,test,12,/// Build a test that bit BitOffset mod sizeof(Bits)*8 is set in; /// Bits. This pattern matches to the bt instruction on x86.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:50,Availability,mask,masks,50,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:184,Availability,mask,mask,184,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:131,Energy Efficiency,allocate,allocateByteArrays,131,"// Create globals to stand in for byte arrays and masks. These never actually; // get initialized, we RAUW and erase them later in allocateByteArrays() once; // we know the offset and mask to use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:157,Testability,test,test,157,// Create an alias instead of RAUW'ing the gep directly. On x86 this ensures; // that the pc-relative displacement is folded into the lea instead of the; // test instruction getting another displacement.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:12,Testability,test,test,12,"/// Build a test that bit BitOffset is set in the type identifier that was; /// lowered to TIL, which must be either an Inline or a ByteArray.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:56,Performance,load,load,56,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:48,Safety,avoid,avoid,48,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:68,Testability,test,testing,68,"// If the bit set is sufficiently small, we can avoid a load by bit testing; // a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:162,Security,secur,security,162,"// Each use of the byte array uses a different alias. This makes the; // backend less likely to reuse previously computed byte array addresses,; // improving the security of the CFI mechanism based on this pass.; // This won't work when importing because TheByteArray is external.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:22,Testability,test,test,22,/// Lower a llvm.type.test call to its implementation. Returns the value to; /// replace the call with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:146,Performance,perform,performing,146,"// We need to check that the offset both falls within our range and is; // suitably aligned. We can check both properties at the same time by; // performing a right rotate by log2(alignment) followed by an integer; // comparison against the bitset size. The rotate will move the lower; // order bits that need to be zero into the higher order bits of the; // result, causing the comparison to fail if they are nonzero. The rotate; // also conveniently gives us a bit offset to use during the load from; // the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:492,Performance,load,load,492,"// We need to check that the offset both falls within our range and is; // suitably aligned. We can check both properties at the same time by; // performing a right rotate by log2(alignment) followed by an integer; // comparison against the bitset size. The rotate will move the lower; // order bits that need to be zero into the higher order bits of the; // result, causing the comparison to fail if they are nonzero. The rotate; // also conveniently gives us a bit offset to use during the load from; // the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:31,Testability,test,testing,31,"// If the bit set is all ones, testing against it is unnecessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:82,Testability,test,test,82,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:152,Testability,test,test,152,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:196,Usability,simpl,simpler,196,"// See if the intrinsic is used in the following common pattern:; // br(llvm.type.test(...), thenbb, elsebb); // where nothing happens between the type test and the br.; // If so, create slightly simpler IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update phis in Else resulting from InitialBB being split,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:61,Performance,load,load,61,"// Now that we know that the offset is in range and aligned, load the; // appropriate bit from the bitset.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:127,Performance,load,loaded,127,"// The value we want is 0 if we came directly from the initial block; // (having failed the range or alignment checks), or the loaded bit if; // we came from the block in which we loaded it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:180,Performance,load,loaded,180,"// The value we want is 0 if we came directly from the initial block; // (having failed the range or alignment checks), or the loaded bit if; // we came from the block in which we loaded it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:127,Testability,test,test,127,"/// Given a disjoint set of type identifiers and globals, lay out the globals,; /// build the bit sets and lower the llvm.type.test calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:294,Energy Efficiency,power,power,294,// Build a new global with the combined contents of the referenced globals.; // This global is a struct whose even-indexed elements contain the original; // contents of the referenced globals and whose odd-indexed elements contain; // any padding required to align the next element to the next power of 2 plus; // any additional padding required to meet its alignment requirements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:192,Performance,perform,performance,192,// Experiments of different caps with Chromium on both x64 and ARM64; // have shown that the 32-byte cap generates the smallest binary on; // both platforms while different caps yield similar performance.; // (see https://lists.llvm.org/pipermail/llvm-dev/2018-July/124694.html),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:167,Testability,test,test,167,"/// Export the given type identifier so that ThinLTO backends may import it.; /// Type identifiers are exported by adding coarse-grained information about how; /// to test the type identifier to the summary, and creating symbols in the; /// object file (aliases and absolute symbols) containing fine-grained; /// information about the type identifier.; ///; /// Returns a pointer to the location in which to store the bitmask, if; /// applicable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:164,Performance,optimiz,optimizations,164,"// If this is a local unpromoted type, which doesn't have a metadata string,; // treat as Unknown and delay lowering, so that we can still utilize it for; // later optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:59,Deployability,update,update,59,// ThinLTO backend: the function F has a jump table entry; update this module; // accordingly. isJumpTableCanonical describes the type of the jump table entry.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:32,Testability,test,test,32,// Lower each call to llvm.type.test for this type identifier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:855,Energy Efficiency,power,power-of-two,855,"// In Armv6-M, this sequence will generate a branch without corrupting; // any registers. We use two stack words; in the second, we construct the; // address we'll pop into pc, and the first is used to save and restore; // r0 which we use as a temporary register.; //; // To support position-independent use cases, the offset of the target; // function is stored as a relative offset (which will expand into an; // R_ARM_REL32 relocation in ELF, and presumably the equivalent in other; // object file types), and added to pc after we load it. (The alternative; // B.W is automatically pc-relative.); //; // There are five 16-bit Thumb instructions here, so the .balign 4 adds a; // sixth halfword of padding, and then the offset consumes a further 4; // bytes, for a total of 16, which is very convenient since entries in; // this jump table need to have power-of-two size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:534,Performance,load,load,534,"// In Armv6-M, this sequence will generate a branch without corrupting; // any registers. We use two stack words; in the second, we construct the; // address we'll pop into pc, and the first is used to save and restore; // r0 which we use as a temporary register.; //; // To support position-independent use cases, the offset of the target; // function is stored as a relative offset (which will expand into an; // R_ARM_REL32 relocation in ELF, and presumably the equivalent in other; // object file types), and added to pc after we load it. (The alternative; // B.W is automatically pc-relative.); //; // There are five 16-bit Thumb instructions here, so the .balign 4 adds a; // sixth halfword of padding, and then the offset consumes a further 4; // bytes, for a total of 16, which is very convenient since entries in; // this jump table need to have power-of-two size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:133,Integrability,depend,dependently,133,"/// Given a disjoint set of type identifiers and functions, build the bit sets; /// and lower the llvm.type.test calls, architecture dependently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:108,Testability,test,test,108,"/// Given a disjoint set of type identifiers and functions, build the bit sets; /// and lower the llvm.type.test calls, architecture dependently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:29,Deployability,update,update,29,"// For phi nodes, we need to update the incoming value for all operands; // with the same predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:70,Testability,test,test,70,// Each jump table must be either ARM or Thumb as a whole for the bit-test math; // to work. Pick one that matches the majority of members to minimize interop; // veneers inserted by the linker.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:7,Testability,stub,stubs,7,// PLT stubs are always ARM.; // FIXME: This is the wrong heuristic for non-canonical jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:88,Safety,safe,safely,88,"// Check if all entries have the NoUnwind attribute.; // If all entries have it, we can safely mark the; // cfi.jumptable as NoUnwind, otherwise, direct calls; // to the jump table will not handle exceptions properly",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:102,Safety,avoid,avoid,102,"// When -mbranch-protection= is used, the inline asm adds a BTI. Suppress BTI; // for the function to avoid double BTI. This is a no-op without; // -mbranch-protection=.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,Safety,avoid,avoid,103,"// When -fcf-protection= is used, the inline asm adds an ENDBR. Suppress ENDBR; // for the function to avoid double ENDBR. This is a no-op without; // -fcf-protection=.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:146,Testability,test,test,146,"/// Given a disjoint set of type identifiers and functions, build a jump table; /// for the functions, build the bit sets and lower the llvm.type.test calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:1842,Energy Efficiency,power,power,1842,"itset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find a better way to represent the jumptable in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:289,Integrability,depend,depend,289,"// Unlike the global bitset builder, the function bitset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:1929,Usability,simpl,simple,1929,"itset builder cannot; // re-arrange functions in a particular order and base its calculations on the; // layout of the functions' entry points, as we have no idea how large a; // particular function will end up being (the size could even depend on what; // this pass does!) Instead, we build a jump table, which is a block of code; // consisting of one branch instruction for each of the functions in the bit; // set that branches to the target function, and redirect any taken function; // addresses to the corresponding jump table entry. In the object file's; // symbol table, the symbols for the target functions also refer to the jump; // table entries, so that addresses taken outside the module will pass any; // verification done inside the module.; //; // In more concrete terms, suppose we have three functions f, g, h which are; // of the same type, and a function foo that returns their addresses:; //; // f:; // mov 0, %eax; // ret; //; // g:; // mov 1, %eax; // ret; //; // h:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // We output the jump table as module-level inline asm string. The end result; // will (conceptually) look like this:; //; // f = .cfi.jumptable; // g = .cfi.jumptable + 4; // h = .cfi.jumptable + 8; // .cfi.jumptable:; // jmp f.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp g.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; // jmp h.cfi ; 5 bytes; // int3 ; 1 byte; // int3 ; 1 byte; // int3 ; 1 byte; //; // f.cfi:; // mov 0, %eax; // ret; //; // g.cfi:; // mov 1, %eax; // ret; //; // h.cfi:; // mov 2, %eax; // ret; //; // foo:; // mov f, %eax; // mov g, %edx; // mov h, %ecx; // ret; //; // Because the addresses of f, g, h are evenly spaced at a power of 2, in the; // normal case the check can be carried out using the same kind of simple; // arithmetic that we normally use for globals.; // FIXME: find a better way to represent the jumptable in the IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:11,Usability,simpl,simple,11,// Build a simple layout based on the regular layout of jump tables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Testability,test,test,140,"/// Assign a dummy layout using an incrementing counter, tag each function; /// with its index represented as metadata, and lower each type test to an; /// integer range comparison. During generation of the indirect function call; /// table in the backend, it will assign the given indexes.; /// Note: Dynamic linking is not supported, as the WebAssembly ABI has not yet; /// been finalized.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:49,Safety,avoid,avoid,49,"// Skip functions that are not address taken, to avoid bloating the table",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:19,Testability,test,tests,19,/// Lower all type tests in this module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:103,Availability,error,errors,103,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:63,Testability,test,testing,63,"// Handle the command-line summary arguments. This code is for testing; // purposes only, so we handle errors directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:24,Safety,avoid,avoid,24,// Save unique users to avoid processing operand replacement; // more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:60,Testability,test,test,60,// Find and erase llvm.assume intrinsics for this llvm.type.test call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:112,Usability,Simpl,Simply,112,"// If the assume was merged with another assume, we might have a use on a; // phi (which will feed the assume). Simply replace the use on the phi; // with ""true"" and leave the merged assume.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:124,Performance,perform,performing,124,"// Normally we'd have already removed all @llvm.public.type.test calls,; // except for in the case where we originally were performing ThinLTO but; // decided not to in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:60,Testability,test,test,60,"// Normally we'd have already removed all @llvm.public.type.test calls,; // except for in the case where we originally were performing ThinLTO but; // decided not to in the backend.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:231,Availability,error,error,231,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:63,Performance,perform,perform,63,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:140,Testability,test,tests,140,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:271,Usability,simpl,simply,271,"// If only some of the modules were split, we cannot correctly perform; // this transformation. We already checked for the presense of type tests; // with partially split modules during the thin link, and would have emitted; // an error if any were found, so here we can simply return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:74,Energy Efficiency,efficient,efficiently,74,// Verify the type metadata and build a few data structures to let us; // efficiently enumerate the type identifiers associated with a global:; // a list of GlobalTypeMembers (a GlobalObject stored alongside a vector; // of associated type metadata) and a mapping from type identifiers to their; // list of GlobalTypeMembers and last observed index in the list of globals.; // The indices will be used later to deterministically order the list of type; // identifiers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:3,Deployability,Update,Update,3,// Update the linkage for extern_weak declarations when a definition; // exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:126,Deployability,update,updated,126,"// TODO: The logic here checks only that the function is address taken,; // not that the address takers are live. This can be updated to check; // their liveness and emit fewer jumptable entries once monolithic LTO; // builds also emit summaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:13,Testability,log,logic,13,"// TODO: The logic here checks only that the function is address taken,; // not that the address takers are live. This can be updated to check; // their liveness and emit fewer jumptable entries once monolithic LTO; // builds also emit summaries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:242,Modifiability,rewrite,rewrite,242,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:154,Performance,optimiz,optimization,154,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp:16,Testability,test,test,16,"// If this type test is only used by llvm.assume instructions, it; // was used for whole program devirtualization, and is being kept; // for use by other optimization passes. We do not need or want to; // lower it here. We also don't want to rewrite any associated globals; // unnecessarily. These will be removed by a subsequent LTT invocation; // with the DropTypeTests flag set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/LowerTypeTests.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:487,Performance,optimiz,optimization,487,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:670,Performance,perform,performed,670,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:864,Performance,perform,performed,864,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:687,Security,expose,expose,687,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:475,Usability,guid,guided,475,"//==-- MemProfContextDisambiguation.cpp - Disambiguate contexts -------------=//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements support for context disambiguation of allocation; // calls for profile guided heap optimization. Specifically, it uses Memprof; // profiles which indicate context specific allocation behavior (currently; // distinguishing cold vs hot memory allocations). Cloning is performed to; // expose the cold allocation call contexts, and the allocation calls are; // subsequently annotated with an attribute for later transformation.; //; // The transformations can be performed either directly on IR (regular LTO), or; // on a ThinLTO index (and later applied to the IR during the ThinLTO backend).; // Both types of LTO operate on a the same base graph representation, which; // uses CRTP to support either IR or Index formats.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:85,Integrability,interface,interfaces,85,// Indicate we are linking with an allocator that supports hot/cold operator; // new interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:362,Deployability,update,updated,362,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:761,Deployability,update,update,761,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:465,Performance,perform,performed,465,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:794,Performance,perform,performed,794,"/// CRTP base for graphs built from either IR or ThinLTO summary index.; ///; /// The graph represents the call contexts in all memprof metadata on allocation; /// calls, with nodes for the allocations themselves, as well as for the calls; /// in each context. The graph is initially built from the allocation memprof; /// metadata (or summary) MIBs. It is then updated to match calls with callsite; /// metadata onto the nodes, updating it to reflect any inlining performed on; /// those calls.; ///; /// Each MIB (representing an allocation's call context with allocation; /// behavior) is assigned a unique context id during the graph build. The edges; /// and nodes in the graph are decorated with the context ids they carry. This; /// is used to correctly update the graph when cloning is performed so that we; /// can uniquify the context for a single (possibly cloned) allocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:24,Performance,perform,perform,24,/// Main entry point to perform analysis and transformations on graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Performance,Perform,Perform,4,/// Perform cloning on the graph necessary to uniquely identify the allocation; /// behavior of an allocation based on its context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,Energy Efficiency,efficient,efficient,112,// Edges to all callees in the profiled call stacks.; // TODO: Should this be a map (from Callee node) for more efficient lookup?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:112,Energy Efficiency,efficient,efficient,112,// Edges to all callers in the profiled call stacks.; // TODO: Should this be a map (from Caller node) for more efficient lookup?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:162,Performance,perform,performed,162,"/// Matches all callsite metadata (or summary) to the nodes created for; /// allocation memprof MIB metadata, synthesizing new nodes to reflect any; /// inlining performed on those callsite instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update graph to conservatively handle any callsite stack nodes that target; /// multiple different callee target functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:316,Deployability,update,updateStackNodes,316,"/// Assigns the given Node to calls at or inlined into the location with; /// the Node's stack id, after post order traversing and processing its; /// caller nodes. Uses the call information recorded in the given; /// StackIdToMatchingCalls map, and creates new nodes for inlined sequences; /// as needed. Called by updateStackNodes which sets up the given; /// StackIdToMatchingCalls map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:103,Deployability,update,updates,103,"/// Connect the NewNode to OrigNode's callees if TowardsCallee is true,; /// else to its callers. Also updates OrigNode's edges to remove any context; /// ids moved to the newly created edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:346,Deployability,update,updated,346,"/// Returns true if the given call targets the callee of the given edge, or if; /// we were able to identify the call chain through intermediate tail calls.; /// In the latter case new context nodes are added to the graph for the; /// identified tail calls, and their synthesized nodes are added to; /// TailCallToContextNodeMap. The EdgeIter is updated in either case to the; /// next element after the input position (either incremented or updated after; /// removing the old edge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:442,Deployability,update,updated,442,"/// Returns true if the given call targets the callee of the given edge, or if; /// we were able to identify the call chain through intermediate tail calls.; /// In the latter case new context nodes are added to the graph for the; /// identified tail calls, and their synthesized nodes are added to; /// TailCallToContextNodeMap. The EdgeIter is updated in either case to the; /// next element after the input position (either incremented or updated after; /// removing the old edge).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update the allocation call to record type of allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:49,Energy Efficiency,allocate,allocated,49,/// Update the allocation call to record type of allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Deployability,Update,Update,4,/// Update non-allocation call to invoke (possibly cloned) function; /// CalleeFunc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:128,Performance,optimiz,optimized,128,"/// Returns the alloction type of the intersection of the contexts of two; /// nodes (based on their provided context id sets), optimized for the case; /// when Node1Ids is smaller than Node2Ids.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:136,Deployability,update,updates,136,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:202,Deployability,update,updated,202,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:80,Performance,perform,performing,80,"/// Create a clone of Edge's callee and move Edge to that new callee node,; /// performing the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:127,Deployability,update,updates,127,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:193,Deployability,update,updated,193,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:66,Performance,perform,performing,66,"/// Change the callee of Edge to existing callee clone NewCallee, performing; /// the necessary context id and allocation type updates.; /// If callee's caller edge iterator is supplied, it is updated when removing; /// the edge from that list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:16,Performance,perform,perform,16,"/// Recursively perform cloning on the graph for the given Node and its; /// callers, in order to uniquely identify the allocation behavior of an; /// allocation given its context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:4,Performance,Perform,Perform,4,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:12,Safety,sanity check,sanity checks,12,/// Perform sanity checks on graph when requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:45,Safety,safe,safe,45,"// Now that we are done with the graph it is safe to add the new; // CallsiteInfo structs to the function summary vectors. The graph nodes; // point into locations within these vectors, so we don't want to add them; // any earlier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:24,Deployability,update,updated,24,// Alloc type should be updated as we add in the MIBs. We should assert; // afterwards that it is not still None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:65,Testability,assert,assert,65,// Alloc type should be updated as we add in the MIBs. We should assert; // afterwards that it is not still None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update alloc type and context ids for this MIB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:14,Deployability,update,update,14,// Now add or update nodes for each stack id in alloc's context.; // Later when processing the stack ids on non-alloc callsites we will adjust; // for any inlining in the context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:122,Safety,detect,detecting,122,"// Look for recursion (direct recursion should have been collapsed by; // module summary analysis, here we should just be detecting mutual; // recursion). Mark these nodes so we don't try to clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:15,Deployability,update,update,15,// Recursively update context ids sets along caller edges.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:71,Deployability,update,update,71,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:124,Testability,log,logic,124,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:109,Usability,simpl,simplifies,109,"// Update ids on the allocation nodes before calling the recursive; // update along caller edges, since this simplifies the logic during; // that traversal.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:133,Deployability,update,update,133,"// Remove any matching context ids from Edge, return set that were found and; // removed, these are the new edge's context ids. Also update the remaining; // (not found ids).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:42,Deployability,update,update,42,"// If this node's stack id is in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.; // Ignore this node if it is for an allocation or we didn't record any; // stack id lists ending at it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:14,Usability,simpl,simple,14,"// Handle the simple case first. A single call with a single stack id.; // In this case there is no need to create any new context nodes, simply; // assign the context node for stack id to this Call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:138,Usability,simpl,simply,138,"// Handle the simple case first. A single call with a single stack id.; // In this case there is no need to create any new context nodes, simply; // assign the context node for stack id to this Call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Deployability,update,updates,79,// Connect to callees of innermost stack frame in inlined call chain.; // This updates context ids for FirstNode's callee's to reflect those; // moved to NewNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Deployability,update,updates,79,// Connect to callers of outermost stack frame in inlined call chain.; // This updates context ids for FirstNode's caller's to reflect those; // moved to NewNode.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:148,Performance,perform,performed,148,"// Map of stack id to all calls with that as the last (outermost caller); // callsite id that has a context node (some might not due to pruning; // performed during matching of the allocation profile contexts).; // The CallContextInfo contains the Call and a list of its stack ids with; // ContextNodes, the function containing Call, and the set of context ids; // the analysis will eventually identify for use in any new node created; // for that callsite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:243,Performance,Perform,Perform,243,"// First make a pass through all stack ids that correspond to a call,; // as identified in the above loop. Compute the context ids corresponding to; // each of these calls when they correspond to multiple stack ids due to; // due to inlining. Perform any duplication of context ids required when; // there is more than one call with the same stack ids. Their (possibly newly; // duplicated) context ids are saved in the StackIdToMatchingCalls map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update the context ids, which is the intersection of the ids along; // all edges in the sequence.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:139,Modifiability,extend,extend,139,"// If some of this call's stack ids did not have corresponding nodes (due; // to pruning), don't include any context ids for contexts that extend; // beyond these nodes. Otherwise we would be matching part of unrelated /; // not fully matching stack contexts. To do this, subtract any context ids; // found in caller nodes of the last node found above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:391,Security,access,access,391,"// If we don't have duplicate context ids, then we can assign all the; // context ids computed for the original node sequence to this call.; // If there are duplicate calls with the same stack ids then we synthesize; // new context ids that are duplicates of the originals. These are; // assigned to SavedContextIds, which is a reference into the map entry; // for this call, allowing us to access these ids later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update saved last node's context ids to remove those that are; // assigned to other calls, so that it is ready for the next call at; // this stack id.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:192,Deployability,update,update,192,"// Now perform a post-order traversal over the graph, starting with the; // allocation nodes, essentially processing nodes from callers to callees.; // For any that contains an id in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:7,Performance,perform,perform,7,"// Now perform a post-order traversal over the graph, starting with the; // allocation nodes, essentially processing nodes from callers to callees.; // For any that contains an id in the map, update the graph to contain new; // nodes representing any inlining at interior callsites. Note we move the; // associated context ids over to the new nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:283,Performance,optimiz,optimization,283,"// We should only add the prevailing nodes. Otherwise we may try to clone; // in a weak copy that won't be linked (and may be different than the; // prevailing version).; // We only keep the memprof summary on the prevailing copy now when; // building the combined index, as a space optimization, however don't; // rely on this optimization. The linker doesn't resolve local linkage; // values so don't check whether those are prevailing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:328,Performance,optimiz,optimization,328,"// We should only add the prevailing nodes. Otherwise we may try to clone; // in a weak copy that won't be linked (and may be different than the; // prevailing version).; // We only keep the memprof summary on the prevailing copy now when; // building the combined index, as a space optimization, however don't; // rely on this optimization. The linker doesn't resolve local linkage; // values so don't check whether those are prevailing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:244,Performance,perform,perform,244,"// Look for and workaround callsites that call multiple functions.; // This can happen for indirect calls, which needs better handling, and in; // more rare cases (e.g. macro expansion).; // TODO: To fix this for indirect calls we will want to perform speculative; // devirtualization using either the normal PGO info with ICP, or using the; // information in the profiled MemProf contexts. We can do this prior to; // this transformation for regular LTO, and for ThinLTO we can simulate that; // effect in the summary and perform the actual speculative devirtualization; // while cloning in the ThinLTO backend.; // Keep track of the new nodes synthesized for discovered tail calls missing; // from the profiled contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:523,Performance,perform,perform,523,"// Look for and workaround callsites that call multiple functions.; // This can happen for indirect calls, which needs better handling, and in; // more rare cases (e.g. macro expansion).; // TODO: To fix this for indirect calls we will want to perform speculative; // devirtualization using either the normal PGO info with ICP, or using the; // information in the profiled MemProf contexts. We can do this prior to; // this transformation for regular LTO, and for ThinLTO we can simulate that; // effect in the summary and perform the actual speculative devirtualization; // while cloning in the ThinLTO backend.; // Keep track of the new nodes synthesized for discovered tail calls missing; // from the profiled contexts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:122,Testability,assert,assert,122,"// Work around by setting Node to have a null call, so it gets; // skipped during cloning. Otherwise assignFunctions will assert; // because its data structures are not designed to handle this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:59,Deployability,update,update,59,"// If there is already an edge between these nodes, simply update it and; // return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:52,Usability,simpl,simply,52,"// If there is already an edge between these nodes, simply update it and; // return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:275,Performance,perform,perform,275,"// Look for tail calls in this function, and check if they either call the; // profiled callee directly, or indirectly (via a recursive search).; // Only succeed if there is a single unique tail call chain found between the; // profiled caller and callee, otherwise we could perform incorrect cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:47,Availability,avail,available,47,// StackIds is empty (we don't have debug info available in the index for; // these callsites),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:275,Performance,perform,perform,275,"// Look for tail calls in this function, and check if they either call the; // profiled callee directly, or indirectly (via a recursive search).; // Only succeed if there is a single unique tail call chain found between the; // profiled caller and callee, otherwise we could perform incorrect cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:17,Deployability,update,update,17,// Don't need to update Edge's context ids since we are simply reconnecting; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:56,Usability,simpl,simply,56,// Don't need to update Edge's context ids since we are simply reconnecting; // it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update context ids / alloc type on corresponding edge to NewCallee.; // There is a chance this may not exist if we are reusing an existing; // clone, specifically during function assignment, where we would have; // removed none type edges after creating the clone. If we can't find; // a corresponding edge there, fall through to the cloning below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:163,Usability,simpl,simply,163,// Don't clone if doing so will not disambiguate any alloc types amongst; // caller edges (including the callee edges that would be cloned).; // Otherwise we will simply move all edges to the clone.; //; // First check if by cloning we will disambiguate the caller allocation; // type from node's allocation type. Query allocTypeToUse so that we don't; // bother cloning to distinguish NotCold+Cold from NotCold. Note that; // neither of these should be None type.; //; // Then check if by cloning node at least one of the callee edges will be; // disambiguated by splitting out different context ids.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that no alloc types on clone or its edges are None.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:43,Deployability,update,updateAllocationCall,43,"// We assign the allocation type later (in updateAllocationCall), just add; // an entry for it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:40,Deployability,update,updateCall,40,"// We assign the clone number later (in updateCall), just add an entry for; // it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update caller node to call function version CalleeFunc, by recording the; // assignment in CallsiteToCalleeFuncCloneMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:232,Deployability,update,update,232,"// First locate which copy of OrigFunc to clone again. If a caller; // of this callsite clone was already assigned to call a particular; // function clone, we need to redirect all of those callers to the; // new function clone, and update their other callees within this; // function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:143,Deployability,update,update,143,"// If no caller callsites were already assigned to a clone of this; // function, we can simply assign this clone to the new func clone; // and update all callers to it, then skip to the next clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:88,Usability,simpl,simply,88,"// If no caller callsites were already assigned to a clone of this; // function, we can simply assign this clone to the new func clone; // and update all callers to it, then skip to the next clone.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:64,Performance,perform,perform,64,// We subsequently fall through to later handling that; // will perform any additional cloning required for; // callers that were calling other function clones.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:389,Deployability,update,update,389,"// If we are cloning a function that was already assigned to some; // callers, then essentially we are creating new callsite clones; // of the other callsites in that function that are reached by those; // callers. Clone the other callees of the current callsite's caller; // that were already assigned to PreviousAssignedFuncClone; // accordingly. This is important since we subsequently update the; // calls from the nodes in the graph and their assignments to callee; // functions recorded in CallsiteToCalleeFuncCloneMap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,"// Update NewClone with the new Call clone of this callsite's Call; // created for the new function clone created earlier.; // Recall that we have already ensured when building the graph; // that each caller can only call callsites within the same; // function, so we are guaranteed that Callee Call is in the; // current OrigFunc.; // CallMap is set up as indexed by original Call at clone 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:37,Performance,perform,perform,37,// Fall through to handling below to perform the recording of the; // function for this callsite clone. This enables handling of cases; // where the callers were assigned to different clones of a function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:56,Availability,avail,available,56,"// First we need to confirm that this function clone is available; // for use by this callsite node clone.; //; // While FuncCloneToCurNodeCloneMap is built only for this Node and; // its callsite clones, one of those callsite clones X could have; // been assigned to the same function clone called by Edge's caller; // - if Edge's caller calls another callsite within Node's original; // function, and that callsite has another caller reaching clone X.; // We need to clone Node again in this case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Detect,Detect,3,"// Detect when we have multiple callers of this callsite that; // have already been assigned to specific, and different, clones; // of OrigFunc (due to other unrelated callsites in Func they; // reach via call contexts). Is this Clone of callsite Node; // assigned to a different clone of OrigFunc? If so, clone Node; // again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:129,Availability,avail,available,129,// Find first function in FuncClonesToCallMap without an assigned; // clone of this callsite Node. We should always have one; // available at this point due to the earlier cloning when the; // FuncClonesToCallMap size was smaller than the clone number.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update callers to record function version called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:29,Deployability,update,update,29,"// Skip if either no call to update, or if we ended up with no context ids; // (we moved all edges onto other clones).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:60,Deployability,update,update,60,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:154,Deployability,update,update,154,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Performs,3,"// Performs DFS traversal starting from allocation nodes to update calls to; // reflect cloning decisions recorded earlier. For regular LTO this will; // update the actual calls in the IR to call the appropriate function clone; // (and add attributes to allocation calls), whereas for ThinLTO the decisions; // are recorded in the summary entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:47,Usability,GUID,GUID,47,"// FIXME: Ideally we would retain the original GUID in some fashion on the; // function (e.g. as metadata), but for now do our best to locate the; // summary without that information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:90,Safety,avoid,avoids,90,"// See if theFn was internalized, by checking index directly with; // original name (this avoids the name adjustment done by getGUID() for; // internal symbols).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:61,Performance,perform,performed,61,// Now query with the original name before any promotion was performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:79,Availability,down,down,79,"// Could be a promoted local imported from another module. We need to pass; // down more info here to find the original module id. For now, try with; // the OrigName which might have been stored in the OidGuidMap in the; // index. This would not work if there were same-named locals in multiple; // modules, however.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:17,Performance,perform,performed,17,"// If we already performed cloning of this function, confirm that the; // requested number of clones matches (the thin link should ensure the; // number of clones for each constituent callsite is consistent within; // each function), before returning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Perform,3,// Perform cloning if not yet done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update the calls per the summary info.; // Save orig name since it gets updated in the first iteration; // below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:75,Deployability,update,updated,75,// Update the calls per the summary info.; // Save orig name since it gets updated in the first iteration; // below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that the MIB stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:34,Usability,simpl,simply,34,"// If this is a direct recursion, simply skip the duplicate; // entries, to be consistent with how the summary ids were; // generated during ModuleSummaryAnalysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Performance,Perform,Perform,3,// Perform cloning if not yet done.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Deployability,Update,Update,3,// Update the allocation types per the summary info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:3,Safety,Sanity check,Sanity check,3,// Sanity check that the stack ids match between the summary and; // instruction metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:456,Integrability,depend,dependences,456,"// TODO: If/when other types of memprof cloning are enabled beyond just for; // hot and cold, we will need to change this to individually control the; // AllocationType passed to addStackNodesForMIB during CCG construction.; // Note that we specifically check this after applying imports above, so that; // the option isn't needed to be passed to distributed ThinLTO backend; // clang processes, which won't necessarily have visibility into the linker; // dependences. Instead the information is communicated from the LTO link to; // the backends via the combined summary index.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:166,Deployability,pipeline,pipeline,166,"// The MemProfImportSummary should only be used for testing ThinLTO; // distributed backend handling via opt, in which case we don't have a; // summary from the pass pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp:52,Testability,test,testing,52,"// The MemProfImportSummary should only be used for testing ThinLTO; // distributed backend handling via opt, in which case we don't have a; // summary from the pass pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MemProfContextDisambiguation.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1112,Performance,perform,perform,1112,"under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass looks for equivalent functions that are mergable and folds them.; //; // Order relation is defined on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave tw",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1430,Performance,optimiz,optimization,1430,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3514,Safety,detect,detect,3514," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1446,Security,hash,hash,1446,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1560,Security,hash,hash,1560,"d on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1571,Security,hash,hash,1571,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1693,Security,hash,hash,1693,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1704,Security,hash,hash,1704,"unction is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1839,Security,hash,hash,1839," and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:1403,Testability,log,log,1403,"--------------------------===//; //; // This pass looks for equivalent functions that are mergable and folds them.; //; // Order relation is defined on set of functions. It was made through; // special function comparison procedure that returns; // 0 when functions are equal,; // -1 when Left function is less than right function, and; // 1 for opposite case. We need total-ordering, so we need to maintain; // four properties on the functions set:; // a <= a (reflexivity); // if a <= b and b <= a then a = b (antisymmetry); // if a <= b and b <= c then a <= c (transitivity).; // for all a and b: a <= b or b <= a (totality).; //; // Comparison iterates through each instruction in each basic block.; // Functions are kept on binary tree. For each new function F we perform; // lookup in binary tree.; // In practice it works the following way:; // -- We define Function* container class with custom ""operator<"" (FunctionPtr).; // -- ""FunctionPtr"" instances are stored in std::set collection, so every; // std::set::insert operation will give you result in log(N) time.; //; // As an optimization, a hash of the function structure is calculated first, and; // two functions are only compared if they have the same hash. This hash is; // cheap to compute, and has the property that if function F == G according to; // the comparison function, then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual fu",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3448,Testability,test,test-suite,3448," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:2818,Usability,learn,learn,2818," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3291,Usability,Simpl,Simplest,3291," then hash(F) == hash(G). This consistency property; // is critical to ensuring all possible merging opportunities are exploited.; // Collisions in the hash affect the speed of the pass but not the correctness; // or determinism of the resulting transformation.; //; // When a match is found the functions are folded. If both functions are; // overridable, we move the functionality into a new internal function and; // leave two overridable thunks to it.; //; //===----------------------------------------------------------------------===//; //; // Future work:; //; // * virtual functions.; //; // Many functions have their address taken by the virtual function table for; // the object they belong to. However, as long as it's only used for a lookup; // and call, this is irrelevant, and we'd like to fold such functions.; //; // * be smarter about bitcasts.; //; // In order to fold functions, we will sometimes add either bitcast instructions; // or bitcast constant expressions. Unfortunately, this can confound further; // analysis since the two functions differ where one has a bitcast and the; // other doesn't. We should learn to look through bitcasts.; //; // * Compare complex types with pointer types inside.; // * Compare cross-reference cases.; // * Compare complex expressions.; //; // All the three issues above could be described as ability to prove that; // fA == fB == fC == fE == fF == fG in example below:; //; // void fA() {; // fB();; // }; // void fB() {; // fA();; // }; //; // void fE() {; // fF();; // }; // void fF() {; // fG();; // }; // void fG() {; // fE();; // }; //; // Simplest cross-reference case (fA <--> fB) was implemented in previous; // versions of MergeFunctions, though it presented only in two function pairs; // in test-suite (that counts >50k functions); // Though possibility to detect complex cross-referencing (e.g.: A->B->C->D->A); // could cover much more cases.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:12,Security,hash,hash,12,"// Note the hash is recalculated potentially multiple times, but it is cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:18,Security,hash,hashes,18,"// Order first by hashes, then full function comparison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:11,Performance,queue,queue,11,/// A work queue of functions that may have been modified and should be; /// analyzed again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:42,Performance,queue,queue,42,/// Remove a Function from the FnTree and queue it up for a second sweep of; /// analysis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:80,Performance,queue,queue,80,/// Find the functions that use this Value and remove them from FnTree and; /// queue the functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:21,Usability,simpl,simple,21,"/// Replace G with a simple tail call to bitcast(F). Also (unless; /// MergeFunctionsPDI holds) replace direct uses of G with bitcast(F),; /// delete G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:111,Energy Efficiency,efficient,efficient,111,/// The set of all distinct functions. Use the insert() and remove() methods; /// to modify it. The map allows efficient lookup and deferring of Functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:106,Deployability,update,updated,106,"// Map functions to the iterators of the FunctionNode which contains them; // in the FnTree. This must be updated carefully whenever the FnTree is; // modified, i.e. in insert(), remove(), and replaceFunctionInTree(), to avoid; // dangling iterators into FnTree. The invariant that preserves this is that; // there is exactly one mapping F -> FN for each FunctionNode FN in FnTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:221,Safety,avoid,avoid,221,"// Map functions to the iterators of the FunctionNode which contains them; // in the FnTree. This must be updated carefully whenever the FnTree is; // modified, i.e. in insert(), remove(), and replaceFunctionInTree(), to avoid; // dangling iterators into FnTree. The invariant that preserves this is that; // there is exactly one mapping F -> FN for each FunctionNode FN in FnTree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:48,Availability,failure,failure,48,"// If F1 <= F2, then F2 >= F1, otherwise report failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:43,Security,hash,hash,43,"// All functions in the module, ordered by hash. Functions with a unique; // hash value are easily eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:77,Security,hash,hash,77,"// All functions in the module, ordered by hash. Functions with a unique; // hash value are easily eliminated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:10,Security,hash,hash,10,"// If the hash value matches the previous value or the next one, we must; // consider merging it. Otherwise it is dropped and never considered again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:78,Usability,simpl,simpler,78,"// Helper for writeThunk,; // Selects proper bitcast operation,; // but a bit simpler then CastInst::getCastOpcode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:3,Energy Efficiency,Reduce,Reduce,3,// Reduce G to its entry block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp:20,Usability,simpl,simple,20,"// Replace G with a simple tail call to bitcast(F). Also (unless; // MergeFunctionsPDI holds) replace direct uses of G with bitcast(F),; // delete G. Under MergeFunctionsPDI, we use G itself for creating; // the thunk as we preserve the debug info (and associated instructions); // from G's entry block pertaining to G's incoming arguments which are; // passed on as corresponding arguments in the call that G makes to F.; // For better debugability, under MergeFunctionsPDI, we do not modify G's; // call sites to point to F even when within the same translation unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/IPO/MergeFunctions.cpp
