id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:36,Security,access,access,36,// MSSA determined that CI does not access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Deployability,Update,Update,3,"// Update the MemoryAccess equivalence table to say that From is equal to To,; // and return true if this is different from what already existed in the table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:53,Deployability,update,updates,53,"// If this is a phi, we have to handle memory member updates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:96,Integrability,depend,depend,96,"// Determine if a instruction is cycle-free. That means the values in the; // instruction don't depend on any expressions that can change value as a result; // of the instruction. For example, a non-cycle free instruction would be v =; // phi(0, v+1).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,Simpl,SimplifyPhiNode,29,// We match the semantics of SimplifyPhiNode from InstructionSimplify here.; // See if all arguments are the same.; // We track if any were undef because they need special handling.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,Integrability,depend,dependent,107,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:145,Integrability,depend,dependent,145,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:442,Modifiability,variab,variable,442,"// In LLVM's non-standard representation of phi nodes, it's possible to have; // phi nodes with cycles (IE dependent on other phis that are .... dependent; // on the original phi node), especially in weird CFG's where some arguments; // are unreachable, or uninitialized along certain paths. This can cause; // infinite loops during evaluation. We work around this by not trying to; // really evaluate them independently, but instead using a variable; // expression to say if one is equivalent to the other.; // We also special case undef/poison, so that if we have an undef, we can't; // use the common value unless it dominates the phi block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:9,Usability,simpl,simplify,9,"// Can't simplify to something that comes later in the iteration.; // Otherwise, when and if it changes congruence class, we will never catch; // up. We will always be a class behind it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Safety,Avoid,Avoid,3,// Avoid processing the same info twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:27,Integrability,depend,depend,27,"// This condition does not depend on predicates, no need to add users",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:39,Usability,simpl,simplifyCmpInst,39,// Create expression will take care of simplifyCmpInst,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,Integrability,depend,depend,33,// Touch all the predicates that depend on this instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:42,Deployability,update,updated,42,"// Touch the instructions that need to be updated after a congruence class has a; // leader change, and mark changed values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:13,Testability,assert,assertion,13,"// Given our assertion, hitting this part must mean; // !OldClass->memory_empty()",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:82,Testability,test,testing,82,"// NOTE: If this ends up to slow, we can maintain a dual structure for; // member testing/insertion, or keep things mostly sorted, and sort only; // here, or use SparseBitVector or ....",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:70,Deployability,update,updates,70,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:292,Deployability,update,updated,292,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:382,Deployability,update,updated,382,"// Move a MemoryAccess, currently in OldClass, to NewClass, including updates to; // the memory members, etc for the move.; //; // The invariants of this function are:; //; // - I must be moving to NewClass from OldClass; // - The StoreCount of OldClass and NewClass is expected to have been updated; // for I already if it is a store.; // - The OldClass memory leader has not been updated yet if I was the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Deployability,Update,Update,67,"// Move a value, currently in OldClass, to be part of NewClass; // Update OldClass and NewClass for the move (including changing leaders, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:110,Performance,load,load,110,"// Okay, so when do we want to make a store a leader of a class?; // If we have a store defined by an earlier load, we want the earlier load; // to lead the class.; // If we have a store defined by something else, we want the store to lead; // the class so everything else gets the ""something else"" as a value.; // If we have a store as the single member of the class, we want the store; // as the leader",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:136,Performance,load,load,136,"// Okay, so when do we want to make a store a leader of a class?; // If we have a store defined by an earlier load, we want the earlier load; // to lead the class.; // If we have a store defined by something else, we want the store to lead; // the class so everything else gets the ""something else"" as a value.; // If we have a store as the single member of the class, we want the store; // as the leader",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:3,Performance,Perform,Perform,3,// Perform congruence finding on a given value numbering expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:17,Modifiability,variab,variables,17,// Constants and variables should always be made the leader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:118,Performance,load,loads,118,"// If we changed the class of the store, we want to ensure nothing finds the; // old store expression. In particular, loads do not compare against stored; // value, so they will find old store expressions (and associated class; // mappings) if we leave them in the table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:170,Integrability,depend,depend,170,"// We've made an edge reachable to an existing block, which may; // impact predicates. Otherwise, only mark the phi nodes as touched, as; // they are the only thing that depend on new edges. Anything using their; // values will get propagated to if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:67,Integrability,depend,dependency,67,"// Did not use simplification result, no need to add the extra; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:15,Usability,simpl,simplification,15,"// Did not use simplification result, no need to add the extra; // dependency.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:39,Safety,safe,safe,39,"// Return true if this operand will be safe to use for phi of ops.; //; // The reason some operands are unsafe is that we are not trying to recursively; // translate everything back through phi nodes. We actually expect some lookups; // of expressions to fail. In particular, a lookup where the expression cannot; // exist in the predecessor. This is true even if the expression, as shown, can; // be determined to be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:104,Safety,unsafe,unsafe,104,"// Return true if this operand will be safe to use for phi of ops.; //; // The reason some operands are unsafe is that we are not trying to recursively; // translate everything back through phi nodes. We actually expect some lookups; // of expressions to fail. In particular, a lookup where the expression cannot; // exist in the predecessor. This is true even if the expression, as shown, can; // be determined to be constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:49,Performance,load,load,49,"// When we hit an instruction that reads memory (load, call, etc), we must; // consider any store that may happen in the loop. For now, we assume the; // worst: there is a store in the loop that alias with this read.; // The case where the load is outside the loop is already covered by the; // dominator check above.; // TODO: relax this condition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:240,Performance,load,load,240,"// When we hit an instruction that reads memory (load, call, etc), we must; // consider any store that may happen in the loop. For now, we assume the; // worst: there is a store in the loop that alias with this read.; // The case where the load is outside the loop is already covered by the; // dominator check above.; // TODO: relax this condition",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:26,Safety,unsafe,unsafe,26,// Stop now if we find an unsafe operand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Performance,load,load,92,"// TODO: We don't do phi translation on memory accesses because it's; // complicated. For a load, we'd need to be able to simulate a new memoryuse,; // which we don't have a good way of doing ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:47,Security,access,accesses,47,"// TODO: We don't do phi translation on memory accesses because it's; // complicated. For a load, we'd need to be able to simulate a new memoryuse,; // which we don't have a good way of doing ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:174,Safety,abort,abort,174,"// No point in doing this for one-operand phis.; // Since all PHIs for operands must be in the same block, then they must; // have the same number of operands so we can just abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:43,Safety,safe,safe,43,"// If we phi-translated the op, it must be safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:91,Availability,down,down,91,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:40,Safety,safe,safe,40,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:179,Safety,unsafe,unsafe,179,"// FIXME: For those things that are not safe we could generate; // expressions all the way down, and see if this comes out to a; // constant. For anything where that is true, and unsafe, we should; // have made a phi-of-ops (or value numbered it equivalent to something); // for the pieces already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:52,Integrability,rout,routine,52,"// The algorithm initially places the values of the routine in the TOP; // congruence class. The leader of TOP is the undetermined value `poison`.; // When the algorithm has finished, values still in TOP are unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:391,Security,access,access,391,"// Note that even though we use the live on entry def as a representative; // MemoryAccess, it is *not* the same as the actual live on entry def. We; // have no real equivalent to poison for MemoryAccesses, and so we really; // should be checking whether the MemoryAccess is top if we want to know if it; // is equivalent to everything. Otherwise, what this really signifies is that; // the access ""it reaches all the way back to the beginning of the function""; // Initialize all other instructions to be in TOP class.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:107,Security,access,access,107,"// and now check if all the elements are equal.; // Sadly, we can't use std::equals since these are random access iterators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:63,Performance,perform,performing,63,"// Value number a single instruction, symbolically evaluating, performing; // congruence finding, and updating mappings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:192,Integrability,rout,routine,192,"// This is not perfect, but as we're just verifying here, we can live with; // the loss of precision. The real solution would be that of doing strongly; // connected component finding in this routine, and it's probably not worth; // the complexity for the time being. So, we just keep a set of visited; // MemoryAccess and return true when we hit a cycle.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:225,Testability,test,testing,225,"// Verify the that the memory equivalence table makes sense relative to the; // congruence classes. Note that this checking is not perfect, and is currently; // subject to very rare false negatives. It is only useful for; // testing/debugging.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:189,Deployability,update,updated,189,"// Anything equivalent in the MemoryAccess table should be in the same; // congruence class.; // Filter out the unreachable and trivially dead entries, because they may; // never have been updated if the instructions were not processed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:151,Performance,load,loads,151,"// Verify that for each store expression in the expression to class mapping,; // only the latest appears, and multiple ones do not appear.; // Because loads do not use the stored value when doing equality with stores,; // if we don't erase the old store expressions from the table, a load can find; // a no-longer valid StoreExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:284,Performance,load,load,284,"// Verify that for each store expression in the expression to class mapping,; // only the latest appears, and multiple ones do not appear.; // Because loads do not use the stored value when doing equality with stores,; // if we don't erase the old store expressions from the table, a load can find; // a no-longer valid StoreExpression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:92,Security,hash,hash,92,"// This is the only use of this, and it's not worth defining a complicated; // densemapinfo hash/equality function for it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:47,Performance,load,loads,47,// Make sure a version that will conflict with loads is not already there,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:46,Security,hash,hash,46,"// Count number of instructions for sizing of hash tables, and come; // up with a global dfs numbering for instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:276,Performance,perform,performing,276,"// Note: We want ideal RPO traversal of the blocks, which is not quite the; // same as dominator tree order, particularly with regard whether backedges; // get visited first or second, given a block with multiple successors.; // If we visit in the wrong order, we will end up performing N times as many; // iterations.; // The dominator tree does guarantee that, for a given dom tree node, it's; // parent must occur before it in the RPO ordering. Thus, we only need to sort; // the siblings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:76,Availability,avail,available,76,"// If it's a store, use the leader of the value operand, if it's always; // available, or the value operand. TODO: We could do dominance checks to; // find a dominating leader, but not worth it ATM.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:108,Performance,load,loads,108,"// This function converts the set of members for a congruence class from values,; // to the set of defs for loads and stores, with associated DFS info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of having; // to update as many def-use and use-def chains. Start after the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of having; // to update as many def-use and use-def chains. Start after the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:29,Usability,simpl,simplifycfg,29,// Now insert something that simplifycfg will turn into an unreachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:63,Integrability,depend,dependencies,63,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:33,Safety,avoid,avoid,33,// We save the actual erasing to avoid invalidating memory; // dependencies until we are done with everything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:65,Availability,avail,available,65,"// Given a value and a basic block we are trying to see if it is available in,; // see if the value has a leader available in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:113,Availability,avail,available,113,"// Given a value and a basic block we are trying to see if it is available in,; // see if the value has a leader available in that block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:48,Availability,avail,available,48,// Anything that isn't an instruction is always available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:127,Availability,avail,available,127,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:567,Performance,perform,perform,567,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:746,Testability,log,log,746,"// This is a non-standard eliminator. The normal way to eliminate is; // to walk the dominator tree in order, keeping track of available; // values, and eliminating them. However, this is mildly; // pointless. It requires doing lookups on every instruction,; // regardless of whether we will ever eliminate it. For; // instructions part of most singleton congruence classes, we know we; // will never eliminate them.; // Instead, this eliminator looks at the congruence classes directly, sorts; // them into a DFS ordering of the dominator tree, and then we just; // perform elimination straight on the sets by walking the congruence; // class member uses in order, and eliminate the ones dominated by the; // last member. This is worst case O(E log E) where E = number of; // instructions in a single congruence class. In theory, this is all; // instructions. In practice, it is much faster, as most instructions are; // either in singleton congruence classes or can't possibly be eliminated; // anyway (if there are no overlapping DFS ranges in class).; // When we find something not dominated, it becomes the new leader; // for elimination purposes.; // TODO: If we wanted to be faster, We could remove any members with no; // overlapping ranges while sorting, as we will never eliminate anything; // with those members, as they don't dominate anything else in our set.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:97,Deployability,update,updated,97,"// Since we are going to walk the domtree anyway, and we can't guarantee the; // DFS numbers are updated, we compute some ourselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:38,Availability,avail,available,38,"// If this is a leader that is always available, and it's a; // constant or has no equivalences, just replace everything with; // it. We then update the congruence class with whatever members; // are left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:142,Deployability,update,update,142,"// If this is a leader that is always available, and it's a; // constant or has no equivalences, just replace everything with; // it. We then update the congruence class with whatever members; // are left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:220,Integrability,synchroniz,synchronize,220,"// First, we see if we are out of scope or empty. If so,; // and there equivalences, we try to replace the top of; // stack with equivalences (if it's on the stack, it must; // not have been eliminated yet).; // Then we synchronize to our current scope, by; // popping until we are back within a DFS scope that; // dominates the current member.; // Then, what happens depends on a few factors; // If the stack is now empty, we need to push; // If we have a constant or a local equivalence we want to; // start using, we also push.; // Otherwise, we walk along, processing members who are; // dominated by this scope, and eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:368,Integrability,depend,depends,368,"// First, we see if we are out of scope or empty. If so,; // and there equivalences, we try to replace the top of; // stack with equivalences (if it's on the stack, it must; // not have been eliminated yet).; // Then we synchronize to our current scope, by; // popping until we are back within a DFS scope that; // dominates the current member.; // Then, what happens depends on a few factors; // If the stack is now empty, we need to push; // If we have a constant or a local equivalence we want to; // start using, we also push.; // Otherwise, we walk along, processing members who are; // dominated by this scope, and eliminate them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:89,Availability,down,downstreams,89,"// Even if the instruction is removed, we still need to update; // flags/metadata due to downstreams users of the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:56,Deployability,update,update,56,"// Even if the instruction is removed, we still need to update; // flags/metadata due to downstreams users of the leader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Deployability,patch,patching,58,"// If we replaced something in an instruction, handle the patching of; // metadata. Skip this if we are replacing predicateinfo with its; // original operand, as we already know we can just drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:20,Availability,alive,alive,20,// It's about to be alive again.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:18,Performance,load,load,18,"// We already did load elimination, so nothing to do here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:252,Usability,simpl,simplify,252,"// This function provides global ranking of operations so that we can place them; // in a canonical order. Note that rank alone is not necessarily enough for a; // complete ordering, as constants all have the same rank. However, generally,; // we will simplify an operation with all constants so that it doesn't matter; // what order they appear in.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:244,Modifiability,inherit,inheritance,244,"// Prefer constants to undef to anything else; // Undef is a constant, have to check it first.; // Prefer poison to undef as it's less defined.; // Prefer smaller constants to constantexprs; // Note that the order here matters because of class inheritance",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp:58,Modifiability,rewrite,rewrite,58,"// Because we only care about a total ordering, and don't rewrite expressions; // in this order, we order by rank, which will give a strict weak ordering to; // everything but constants, and then we order by pointer address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/NewGVN.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2741,Deployability,Patch,Patches,2741,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:946,Integrability,wrap,wrapped,946,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1133,Integrability,rout,routine,1133,"art of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1224,Integrability,rout,routine,1224,"tion.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; /",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:502,Modifiability,variab,variable,502,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:549,Modifiability,Rewrite,RewriteStatepointsForGC,549,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:785,Modifiability,Rewrite,RewriteStatepointsForGC,785,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1866,Performance,optimiz,optimizer,1866,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1939,Performance,optimiz,optimization,1939,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:38,Safety,Safe,Safepoints,38,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:408,Safety,safe,safepoints,408,"//===- PlaceSafepoints.cpp - Place GC Safepoints --------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1652,Safety,avoid,avoid,1652,"he call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1914,Safety,avoid,avoid,1914,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2279,Safety,safe,safepoints,2279,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2335,Safety,safe,safepoint,2335,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2405,Safety,safe,safepoint,2405,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2431,Safety,safe,safepoint,2431,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2491,Safety,safe,safepoint,2491,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:2675,Safety,safe,safepoints,2675,"he stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any call which may need to; // reach a safepoint during the execution of the callee function.; // - Backedge safepoint polls and entry safepoint polls to ensure that; // executing code reaches a safepoint poll in a finite amount of time.; //; // We do not currently support return statepoints, but adding them would not; // be hard. They are not required for correctness - entry safepoints are an; // alternative - but some GCs may prefer them. Patches welcome.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:1279,Testability,log,logic,1279,"-------------------------------------------------------------------===//; //; // Place garbage collection safepoints at appropriate locations in the IR. This; // does not make relocation semantics or variable liveness explicit. That's; // done by RewriteStatepointsForGC.; //; // Terminology:; // - A call is said to be ""parseable"" if there is a stack map generated for the; // return PC of the call. A runtime can determine where values listed in the; // deopt arguments and (after RewriteStatepointsForGC) gc arguments are located; // on the stack when the code is suspended inside such a call. Every parse; // point is represented by a call wrapped in an gc.statepoint intrinsic.; // - A ""poll"" is an explicit check in the generated code to determine if the; // runtime needs the generated code to cooperate by calling a helper routine; // and thus suspending its execution at a known state. The call to the helper; // routine will be parseable. The (gc & runtime specific) logic of a poll is; // assumed to be provided in a function of the name ""gc.safepoint_poll"".; //; // We aim to insert polls such that running code can quickly be brought to a; // well defined state for inspection by the collector. In the current; // implementation, this is done via the insertion of poll sites at method entry; // and the backedge of most loops. We try to avoid inserting more polls than; // are necessary to ensure a finite period between poll sites. This is not; // because the poll itself is expensive in the generated code; it's not. Polls; // do tend to impact the optimizer itself in negative ways; we'd like to avoid; // perturbing the optimization of the method as much as we can.; //; // We also need to make most call sites parseable. The callee might execute a; // poll (or otherwise be inspected by the GC). If so, the entire stack; // (including the suspended frame of the current method) must be parseable.; //; // This pass will insert:; // - Call parse points (""call safepoints"") for any cal",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:27,Safety,avoid,avoid,27,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:41,Safety,safe,safepoints,41,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:81,Security,validat,validation,81,"// Ignore opportunities to avoid placing safepoints on backedges, useful for; // validation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:122,Safety,safe,safepoints,122,"/// How narrow does the trip count of a loop have to be to have to be considered; /// ""counted""? Counted loops do not get safepoints at backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:223,Performance,optimiz,optimizes,223,"// If true, split the backedge of a loop when placing the safepoint, otherwise; // split the latch block itself. Both are useful to support for; // experimentation, but in practice, it looks like splitting the backedge; // optimizes better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,Safety,safe,safepoint,58,"// If true, split the backedge of a loop when placing the safepoint, otherwise; // split the latch block itself. Both are useful to support for; // experimentation, but in practice, it looks like splitting the backedge; // optimizes better.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:109,Safety,safe,safepoint,109,/// An analysis pass whose purpose is to identify each of the backedges in; /// the function which require a safepoint poll to be inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:90,Integrability,depend,dependent,90,/// True unless we're running spp-no-calls in which case we need to disable; /// the call-dependent placement opts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:247,Deployability,pipeline,pipeline,247,"// Loop through all loop latches (branches controlling backedges). We need; // to place a safepoint on every backedge (potentially).; // Note: In common usage, there will be only one edge due to LoopSimplify; // having run sometime earlier in the pipeline, but this code must be correct; // w.r.t. loops with multiple backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:90,Safety,safe,safepoint,90,"// Loop through all loop latches (branches controlling backedges). We need; // to place a safepoint on every backedge (potentially).; // Note: In common usage, there will be only one edge due to LoopSimplify; // having run sometime earlier in the pipeline, but this code must be correct; // w.r.t. loops with multiple backedges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:120,Performance,optimiz,optimizer,120,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:58,Safety,safe,safepoint,58,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:148,Safety,avoid,avoiding,148,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:188,Safety,safe,safepoint,188,"// Make a policy decision about whether this loop needs a safepoint or; // not. Note that this is about unburdening the optimizer in loops, not; // avoiding the runtime cost of the actual safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:176,Safety,safe,safepoint,176,"// Note: This is only semantically legal since we won't do any further; // IPO or inlining before the actual call insertion.. If we hadn't, we; // might latter loose this call safepoint.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:397,Modifiability,variab,variables,397,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:161,Performance,perform,performance,161,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:221,Performance,optimiz,optimize,221,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:118,Safety,safe,safepoint,118,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:250,Safety,Safe,Safepoint,250,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:370,Safety,safe,safepoint,370,"// TODO: We can create an inner loop which runs a finite number of; // iterations with an outer loop which contains a safepoint. This would; // not help runtime performance that much, but it might help our ability to; // optimize the inner loop.; // Safepoint insertion would involve creating a new basic block (as the; // target of the current backedge) which does the safepoint (of all live; // variables) and branches to the true header",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:60,Safety,avoid,avoid,60,"// This is a declaration, nothing to do. Must exit early to avoid crash in; // dom tree calculation",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:39,Safety,safe,safepoint,39,"// Given we're inlining this inside of safepoint poll insertion, this; // doesn't make any sense. Note that we do make any contained calls; // parseable after we inline a poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Safety,safe,safepoint,23,// STEP 1 - Insert the safepoint polling locations. We do not need to; // actually insert parse points yet. That will be done for all polls and; // calls in a single pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:103,Energy Efficiency,schedul,scheduling,103,// Construct a pass manager to run the LoopPass backedge logic. We; // need the pass manager to handle scheduling all the loop passes; // appropriately. Doing this by hand is painful and just not worth messing; // with for the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:57,Testability,log,logic,57,// Construct a pass manager to run the LoopPass backedge logic. We; // need the pass manager to handle scheduling all the loop passes; // appropriately. Doing this by hand is painful and just not worth messing; // with for the moment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:108,Testability,test,test,108,// We need the order of list to be stable so that naming ends up stable; // when we split edges. This makes test cases much easier to write.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:203,Testability,test,test,203,"// We can sometimes end up with duplicate poll locations. This happens if; // a single loop is visited more than once. The fact this happens seems; // wrong, but it does happen for the split-backedge.ll test case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:206,Performance,optimiz,optimize,206,"// Split the backedge of the loop and insert the poll within that new; // basic block. This creates a loop with two latches per original; // latch (which is non-ideal), but this appears to be easier to; // optimize in practice than inserting the poll immediately before the; // latch test.; // Since this is a latch, at least one of the successors must dominate; // it. Its possible that we have a) duplicate edges to the same header; // and b) edges to distinct loop headers. We need to insert pools on; // each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:284,Testability,test,test,284,"// Split the backedge of the loop and insert the poll within that new; // basic block. This creates a loop with two latches per original; // latch (which is non-ideal), but this appears to be easier to; // optimize in practice than inserting the poll immediately before the; // latch test.; // Since this is a latch, at least one of the successors must dominate; // it. Its possible that we have a) duplicate edges to the same header; // and b) edges to distinct loop headers. We need to insert pools on; // each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:98,Safety,safe,safepoint,98,"// TODO: else we should assert that there was, in fact, a policy choice to; // not insert a entry safepoint poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:24,Testability,assert,assert,24,"// TODO: else we should assert that there was, in fact, a policy choice to; // not insert a entry safepoint poll.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:44,Safety,safe,safepoint,44,"// Now that we've identified all the needed safepoint poll locations, insert; // safepoint polls themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:81,Safety,safe,safepoint,81,"// Now that we've identified all the needed safepoint poll locations, insert; // safepoint polls themselves.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:57,Safety,safe,safepoint,57,/// Returns true if this loop is known to contain a call safepoint which; /// must unconditionally execute on any iteration of the loop which returns; /// to the loop header via an edge from Pred. Returns a conservative correct; /// answer; i.e. false is always valid.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:638,Performance,cache,cache,638,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:87,Safety,safe,safepoint,87,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:673,Safety,avoid,avoid,673,"// In general, we're looking for any cut of the graph which ensures; // there's a call safepoint along every edge between Header and Pred.; // For the moment, we look only for the 'cuts' that consist of a single call; // instruction in a block which is dominated by the Header and dominates the; // loop latch (Pred) block. Somewhat surprisingly, walking the entire chain; // of such dominating blocks gets substantially more occurrences than just; // checking the Pred and Header blocks themselves. This may be due to the; // density of loop exit conditions caused by range and null checks.; // TODO: structure this as an analysis pass, cache the result for subloops,; // avoid dom tree recalculations",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:32,Safety,safe,safepoint,32,"// Note: Technically, needing a safepoint isn't quite the right; // condition here. We should instead be checking if the target method; // has an; // unconditional poll. In practice, this is only a theoretical concern; // since we don't have any methods with conditional-only safepoint; // polls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:276,Safety,safe,safepoint,276,"// Note: Technically, needing a safepoint isn't quite the right; // condition here. We should instead be checking if the target method; // has an; // unconditional poll. In practice, this is only a theoretical concern; // since we don't have any methods with conditional-only safepoint; // polls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:108,Security,expose,expose,108,"// This returns an exact expression only. TODO: We really only need an; // upper bound here, but SE doesn't expose that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:29,Safety,safe,safepoint,29,/// Returns true if an entry safepoint is not required before this callsite in; /// the caller function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:11,Integrability,wrap,wrap,11,// The can wrap an actual call which may grow the stack by an unbounded; // amount or run forever.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:179,Performance,optimiz,optimizer,179,"// Most LLVM intrinsics are things which do not expand to actual calls, or; // at least if they do, are leaf functions that cause only finite stack; // growth. In particular, the optimizer likes to form things like memsets; // out of stores in the original IR. Another important example is; // llvm.localescape which must occur in the entry block. Inserting a; // safepoint before it is not legal since it could push the localescape; // out of the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:364,Safety,safe,safepoint,364,"// Most LLVM intrinsics are things which do not expand to actual calls, or; // at least if they do, are leaf functions that cause only finite stack; // growth. In particular, the optimizer likes to form things like memsets; // out of stores in the original IR. Another important example is; // llvm.localescape which must occur in the entry block. Inserting a; // safepoint before it is not legal since it could push the localescape; // out of the entry block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Safety,safe,safepoint,23,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:124,Safety,safe,safepoints,124,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:232,Safety,safe,safepoint,232,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:452,Safety,detect,detect,452,"// We need to ensure a safepoint poll occurs before any 'real' call. The; // easiest way to ensure finite execution between safepoints in the face of; // recursive and mutually recursive functions is to enforce that each take; // a safepoint. Additionally, we need to ensure a poll before any call; // which can grow the stack by an unbounded amount. This isn't required; // for GC semantics per se, but is a common requirement for languages; // which detect stack overflow via guard pages and then throw exceptions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:65,Safety,safe,safepoint,65,/// Returns true if this function should be rewritten to include safepoint; /// polls and parseable call sites. The main point of this function is to be; /// an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:188,Testability,log,logic,188,/// Returns true if this function should be rewritten to include safepoint; /// polls and parseable call sites. The main point of this function is to be; /// an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:12,Safety,safe,safepoint,12,"// Insert a safepoint poll immediately before the given instruction. Does; // not handle the parsability of state at the runtime call, that's the; // callers job.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:14,Safety,safe,safepoint,14,"// Inline the safepoint poll implementation - this will get all the branch,; // control flow, etc.. Most importantly, it will introduce the actual slow; // path call - where we need to insert a safepoint (parsepoint).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:194,Safety,safe,safepoint,194,"// Inline the safepoint poll implementation - this will get all the branch,; // control flow, etc.. Most importantly, it will introduce the actual slow; // path call - where we need to insert a safepoint (parsepoint).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:23,Deployability,release,release-asserts,23,// suppress warning in release-asserts; // Check post-conditions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:31,Testability,assert,asserts,31,// suppress warning in release-asserts; // Check post-conditions,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:201,Safety,safe,safepoint,201,// Record the fact we need a parsable state at the runtime call contained in; // the poll function. This is required so that the runtime knows how to; // parse the last frame when we actually take the safepoint (i.e. execute; // the slow path),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:6,Safety,safe,safepoint,6,// No safepoint needed or wanted,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp:45,Testability,assert,assert,45,// These are likely runtime calls. Should we assert that via calling; // convention or something?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/PlaceSafepoints.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:233,Integrability,rout,routine,233,/// Return true if I is an instruction with the FastMathFlags that are needed; /// for general reassociation set. This is not the same as testing; /// Instruction::isAssociative() because it includes operations like fsub.; /// (This routine is only intended to be called for floating-point operations.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:138,Testability,test,testing,138,/// Return true if I is an instruction with the FastMathFlags that are needed; /// for general reassociation set. This is not the same as testing; /// Instruction::isAssociative() because it includes operations like fsub.; /// (This routine is only intended to be called for floating-point operations.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:19,Safety,safe,safe,19,// FIXME: It's not safe to lower a unary FNeg into a FMul by -1.0.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:473,Integrability,rout,routine,473,"/// Add the extra weight 'RHS' to the existing weight 'LHS',; /// reducing the combined weight using any special properties of the operation.; /// The existing weight LHS represents the computation X op X op ... op X where; /// X occurs LHS times. The combined weight represents X op X op ... op X with; /// X occurring LHS + RHS times. If op is ""Xor"" for example then the combined; /// operation is equivalent to X if LHS + RHS is odd, or 0 if LHS + RHS is even;; /// the routine returns 1 in LHS in the first case, and 0 in LHS in the second.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:364,Energy Efficiency,reduce,reduce,364,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:209,Integrability,wrap,wraps,209,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:414,Integrability,wrap,wrapping,414,"// If we were working with infinite precision arithmetic then the combined; // weight would be LHS + RHS. But we are using finite precision arithmetic,; // and the APInt sum LHS + RHS may not be correct if it wraps (it is correct; // for nilpotent operations and addition, but not for idempotent operations; // and multiplication), so it is important to correctly reduce the combined; // weight back into range if wrapping would be wrong.; // If RHS is zero then the weight didn't change.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:140,Integrability,wrap,wrapping,140,"// Idempotent means X op X === X, so any non-zero weight is equivalent to a; // weight of 1. Keeping weights at zero or one also means that wrapping is; // not a problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:36,Energy Efficiency,reduce,reduce,36,"// Nilpotent means X op X === 0, so reduce weights modulo 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:9,Energy Efficiency,Reduce,Reduce,9,// TODO: Reduce the weight by exploiting nsw/nuw?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:356,Energy Efficiency,reduce,reduced,356,"// If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth; // can be replaced with W-CM. That's because x^W=x^(W-CM) for every Bitwidth; // bit number x, since either x is odd in which case x^CM = 1, or x is even in; // which case both x^W and x^(W - CM) are zero. By subtracting off multiples; // of CM like this weights can always be reduced to the range [0, CM+Bitwidth); // which by a happy accident means that they can always be represented using; // Bitwidth bits.; // TODO: Reduce the weight by exploiting nsw/nuw? (Could do much better than; // the Carmichael number).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:501,Energy Efficiency,Reduce,Reduce,501,"// If CM is the Carmichael number then a weight W satisfying W >= CM+Bitwidth; // can be replaced with W-CM. That's because x^W=x^(W-CM) for every Bitwidth; // bit number x, since either x is odd in which case x^CM = 1, or x is even in; // which case both x^W and x^(W - CM) are zero. By subtracting off multiples; // of CM like this weights can always be reduced to the range [0, CM+Bitwidth); // which by a happy accident means that they can always be represented using; // Bitwidth bits.; // TODO: Reduce the weight by exploiting nsw/nuw? (Could do much better than; // the Carmichael number).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:6,Safety,avoid,avoid,6,// To avoid problems with overflow do everything the same as above but using; // a larger type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:547,Integrability,rout,routine,547,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:751,Integrability,rout,routine,751,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2100,Integrability,rout,routine,2100,"the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2460,Integrability,rout,routine,2460,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3143,Integrability,rout,routine,3143,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:873,Modifiability,Rewrite,RewriteExprTree,873,"/// Given an associative binary expression, return the leaf; /// nodes in Ops along with their weights (how many times the leaf occurs). The; /// original expression is the same as; /// (Ops[0].first op Ops[0].first op ... Ops[0].first) <- Ops[0].second times; /// op; /// (Ops[1].first op Ops[1].first op ... Ops[1].first) <- Ops[1].second times; /// op; /// ...; /// op; /// (Ops[N].first op Ops[N].first op ... Ops[N].first) <- Ops[N].second times; ///; /// Note that the values Ops[0].first, ..., Ops[N].first are all distinct.; ///; /// This routine may modify the function, in which case it returns 'true'. The; /// changes it makes may well be destructive, changing the value computed by 'I'; /// to something completely different. Thus if the routine returns 'true' then; /// you MUST either replace I with a new expression computed from the Ops array,; /// or use RewriteExprTree to put the values back in.; ///; /// A leaf node is either not a binary operation of the same kind as the root; /// node 'I' (i.e. is not a binary operator at all, or is, but with a different; /// opcode), or is the same kind of binary operator but has a use which either; /// does not belong to the expression, or does belong to the expression but is; /// a leaf node. Every leaf node has at least one use that is a non-leaf node; /// of the expression, while for non-leaf nodes (except for the root 'I') every; /// use is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:2411,Modifiability,Rewrite,RewriteExprTree,2411,"se is a non-leaf node of the expression.; ///; /// For example:; /// expression graph node names; ///; /// + | I; /// / \ |; /// + + | A, B; /// / \ / \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// The leaf nodes are C, E, F and G. The Ops array will contain (maybe not in; /// that order) (C, 1), (E, 1), (F, 2), (G, 2).; ///; /// The expression is maximal: if some instruction is a binary operator of the; /// same kind as 'I', and all of its uses are non-leaf nodes of the expression,; /// then the instruction also belongs to the expression, is not a leaf node of; /// it, and its operands also belong to the expression (but may be leaf nodes).; ///; /// NOTE: This routine will set operands of non-leaf non-root nodes to undef in; /// order to ensure that every non-root node in the expression has *exactly one*; /// use by a non-leaf node of the expression. This destruction means that the; /// caller MUST either replace 'I' with a new expression or use something like; /// RewriteExprTree to put the values back in if the routine indicates that it; /// made a change by returning 'true'.; ///; /// In the above example either the right operand of A or the left operand of B; /// will be replaced by undef. If it is B's operand then this gives:; ///; /// + | I; /// / \ |; /// + + | A, B - operand of B replaced with undef; /// / \ \ |; /// * + * | C, D, E; /// / \ / \ / \ |; /// + * | F, G; ///; /// Note that such undef operands can only be reached by passing through 'I'.; /// For example, if you visit operands recursively starting from a leaf node; /// then you will never see such an undef operand unless you get back to 'I',; /// which requires passing through a phi node.; ///; /// Note that this routine may also mutate binary operators of the wrong type; /// that have all uses inside the expression (i.e. only used by non-leaf nodes; /// of the expression) if it can turn them into binary operators of the right; /// type and thus make the expression bigger.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,Safety,safe,safe,77,"// This value has uses not accounted for by the expression, so it is; // not safe to modify. Mark it as being a leaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Deployability,Update,Update,3,// Update the number of paths to the leaf.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:89,Safety,safe,safe,89,// If we still have uses that are not accounted for by the expression; // then it is not safe to modify the value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:181,Safety,safe,safely,181,"// At this point we have a value which, first of all, is not a binary; // expression of the right kind, and secondly, is only used inside the; // expression. This means that it can safely be modified. See if we; // can usefully morph it into an expression of the right kind.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:246,Security,expose,exposed,246,"// If this is a multiply expression, turn any internal negations into; // multiplies by -1 so they can be reassociated. Add any users of the; // newly created multiplication by -1 to the redo list, so any; // reassociation opportunities that are exposed will be reassociated; // further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:186,Energy Efficiency,reduce,reduces,186,"// For nilpotent operations or addition there may be no operands, for example; // because the expression was ""X xor X"" or consisted of 2^Bitwidth additions:; // in both cases the weight reduces to 0 causing the value to be skipped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:75,Performance,optimiz,optimized,75,"/// Now that the operands for this expression tree are; /// linearized and optimized, emit them in-order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:621,Availability,avail,available,621,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Performance,optimiz,optimizations,13,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:507,Usability,clear,clear,507,"// Since our optimizations should never increase the number of operations, the; // new expression can usually be written reusing the existing binary operators; // from the original expression tree, without creating any new instructions,; // though the rewritten expression may have a completely different topology.; // We take care to not change anything if the new expression will be the same; // as the original. If more than trivial changes (like commuting operands); // were made then we are obliged to clear out any optional subclass data like; // nsw flags.; /// NodesToRewrite - Nodes from the original expression available for writing; /// the new expression into.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:446,Performance,optimiz,optimization,446,"/// NotRewritable - The operands being written will be the leaves of the new; /// expression and must not be used as inner nodes (via NodesToRewrite) by; /// mistake. Inner nodes are always reassociable, and usually leaves are not; /// (if they were they would have been incorporated into the expression and so; /// would not be leaves), so most of the time there is no danger of this. But; /// in rare cases a leaf may become reassociable if an optimization kills uses; /// of it, or it may momentarily become reassociable during rewriting (below); /// due it being removed as an operand of one of its uses. Ensure that misuse; /// of leaf nodes as inner nodes cannot occur by remembering all of the future; /// leaves and refusing to reuse any of them as inner nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:134,Usability,clear,clearing,134,"// ExpressionChangedStart - Non-null if the rewritten expression differs from; // the original in some non-trivial way, requiring the clearing of optional; // flags. Flags are cleared from the operator in ExpressionChangedStart up to; // ExpressionChangedEnd inclusive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:176,Usability,clear,cleared,176,"// ExpressionChangedStart - Non-null if the rewritten expression differs from; // the original in some non-trivial way, requiring the clearing of optional; // flags. Flags are cleared from the operator in ExpressionChangedStart up to; // ExpressionChangedEnd inclusive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:117,Modifiability,rewrite,rewrite,117,// Now deal with the left-hand side. If this is already an operation node; // from the original expression then just rewrite the rest of the expression; // into it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:137,Performance,optimiz,optimizers,137,"// Otherwise, grab a spare node from the original expression and use that as; // the left-hand side. If there are no nodes left then the optimizers made; // an expression with more nodes than the original! This usually means that; // they did something stupid but it might mean that the problem was just too; // hard (finding the mimimal number of multiplications needed to realize a; // multiplication expression is NP-complete). Whatever the reason, smart or; // stupid, create a new node if there are none left.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:48,Usability,clear,clear,48,"// If the expression changed non-trivially then clear out all subclass data; // starting from the operator specified in ExpressionChanged, and compactify; // the operators to just before the expression root to guarantee that the; // expression tree is dominated by all of Ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:480,Security,expose,exposed,480,"/// Insert instructions before the instruction pointed to by BI,; /// that computes the negative version of the value specified. The negative; /// version of the value is returned, and BI is left pointing at the instruction; /// that should be processed next by the reassociation pass.; /// Also add intermediate instructions to the redo list that are modified while; /// pushing the negates through adds. These will be revisited to see if; /// additional opportunities have been exposed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:20,Security,expose,expose,20,"// We are trying to expose opportunity for reassociation. One of the things; // that we want to do to achieve this is to push a negation as deep into an; // expression chain as possible, to expose the add instructions. In practice,; // this means that we turn this:; // X = -(A+12+C+D) into X = -A + -12 + -C + -D = -12 + -A + -C + -D; // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate; // the constants. We assume that instcombine will clean up the mess later if; // we introduce tons of unnecessary negation instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:190,Security,expose,expose,190,"// We are trying to expose opportunity for reassociation. One of the things; // that we want to do to achieve this is to push a negation as deep into an; // expression chain as possible, to expose the add instructions. In practice,; // this means that we turn this:; // X = -(A+12+C+D) into X = -A + -12 + -C + -D = -12 + -A + -C + -D; // so that later, a: Y = 12+X could get reassociated with the -12 to eliminate; // the constants. We assume that instcombine will clean up the mess later if; // we introduce tons of unnecessary negation instructions.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:84,Security,expose,expose,84,// Add the intermediate negates to the redo list as processing them later; // could expose more reassociating opportunities.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:12,Safety,safe,safely,12,// We can't safely propagate a vector zero constant with poison/undef lanes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:34,Performance,load,load,34,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:110,Performance,load,load,110,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:189,Performance,load,load,189,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:281,Performance,load,load,281,"// See if this `or` looks like an load widening reduction, i.e. that it; // consists of an `or`/`shl`/`zext`/`load` nodes only. Note that we don't; // ensure that the pattern is *really* a load widening reduction,; // we do not ensure that it can really be replaced with a widened load,; // only that it mostly looks like one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:41,Performance,load,load,41,// Node is certainly not part of an `or` load reduction.; // Only process instructions we have never processed before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Performance,load,load,13,"// Perfect, `load` node means we've reached an edge of the graph.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,Safety,safe,safely,10,"// We can safely preserve the nuw flag in all cases. It's also safe to turn a; // nuw nsw shl into a nuw nsw mul. However, nsw in isolation requires special; // handling. It can be preserved as long as we're not left shifting by; // bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:63,Safety,safe,safe,63,"// We can safely preserve the nuw flag in all cases. It's also safe to turn a; // nuw nsw shl into a nuw nsw mul. However, nsw in isolation requires special; // handling. It can be preserved as long as we're not left shifting by; // bitwidth - 1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:129,Energy Efficiency,reduce,reduced,129,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:85,Performance,optimiz,optimizes,85,"/// Optimize a series of operands to an 'and', 'or', or 'xor' instruction.; /// This optimizes based on identities. If it can be reduced to a single Value,; /// it is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:103,Usability,simpl,simplify,103,"// Scan the operand lists looking for X and ~X pairs, along with X,X pairs.; // If we find any, we can simplify the expression. X&~X == 0, X|~X == -1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:22,Performance,Optimiz,OptimizeXor,22,"// Helper function of OptimizeXor(). It tries to simplify ""Opnd1 ^ ConstOpnd""; // into ""R ^ C"", where C would be 0, and R is a symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively; otherwise, false is returned,; // and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,Usability,simpl,simplify,49,"// Helper function of OptimizeXor(). It tries to simplify ""Opnd1 ^ ConstOpnd""; // into ""R ^ C"", where C would be 0, and R is a symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively; otherwise, false is returned,; // and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:22,Performance,Optimiz,OptimizeXor,22,"// Helper function of OptimizeXor(). It tries to simplify; // ""Opnd1 ^ Opnd2 ^ ConstOpnd"" into ""R ^ C"", where C would be 0, and R is a; // symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively (If the entire expression is; // evaluated to a constant, the Res is set to NULL); otherwise, false is; // returned, and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:49,Usability,simpl,simplify,49,"// Helper function of OptimizeXor(). It tries to simplify; // ""Opnd1 ^ Opnd2 ^ ConstOpnd"" into ""R ^ C"", where C would be 0, and R is a; // symbolic value.; //; // If it was successful, true is returned, and the ""R"" and ""C"" is returned; // via ""Res"" and ""ConstOpnd"", respectively (If the entire expression is; // evaluated to a constant, the Res is set to NULL); otherwise, false is; // returned, and both ""Res"" and ""ConstOpnd"" remain unchanged.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:72,Energy Efficiency,reduce,reduced,72,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'xor' instruction. If it can be reduced; /// to a single Value, it is returned, otherwise the Ops list is mutated as; /// necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:487,Security,expose,expose,487,"// Step 2: Sort the Xor-Operands in a way such that the operands containing; // the same symbolic value cluster together. For instance, the input operand; // sequence (""x | 123"", ""y & 456"", ""x & 789"") will be sorted into:; // (""x | 123"", ""x & 789"", ""y & 456"").; //; // The purpose is twofold:; // 1) Cluster together the operands sharing the same symbolic-value.; // 2) Operand having smaller symbolic-value-rank is permuted earlier, which; // could potentially shorten crital path, and expose more loop-invariants.; // Note that values' rank are basically defined in RPO order (FIXME).; // So, if Rank(X) < Rank(Y) < Rank(Z), it means X is defined earlier; // than Y which is defined earlier than Z. Permute ""x | 1"", ""Y & 2"",; // ""z"" in the order of X-Y-Z is better than any other orders.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:17,Usability,simpl,simplifying,17,"// Step 3.1: Try simplifying ""CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:90,Usability,simpl,simplify,90,"// step 3.2: When previous and current operands share the same symbolic; // value, try to simplify ""PrevOpnd ^ CurrOpnd ^ ConstOpnd""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:113,Energy Efficiency,reduce,reduced,113,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:69,Performance,optimiz,optimizes,69,"/// Optimize a series of operands to an 'add' instruction. This; /// optimizes based on identities. If it can be reduced to a single Value, it; /// is returned, otherwise the Ops list is mutated as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:81,Usability,simpl,simplify,81,"// Scan the operand lists looking for X and -X pairs. If we find any, we; // can simplify expressions like X+-X == 0 and X+~X ==-1. While we're at it,; // scan for any; // duplicates. We want to canonicalize Y+Y+Y+Z -> 3*Y+Z.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:41,Performance,optimiz,optimize,41,"// Now that we have inserted a multiply, optimize it. This allows us to; // handle cases that require multiple factoring steps, such as this:; // (X*2) + (X*2) + (X*2) -> (X*2)*3 -> X*6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,Energy Efficiency,reduce,reduces,193,"// Scan the operand list, checking to see if there are any common factors; // between operands. Consider something like A*A+A*B*C+D. We would like to; // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.; // To efficiently find this, we count the number of times a factor occurs; // for any ADD operands that are MULs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:234,Energy Efficiency,efficient,efficiently,234,"// Scan the operand list, checking to see if there are any common factors; // between operands. Consider something like A*A+A*B*C+D. We would like to; // reassociate this to A*(A+B*C)+D, which reduces the number of multiplies.; // To efficiently find this, we count the number of times a factor occurs; // for any ADD operands that are MULs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:42,Safety,avoid,avoid,42,"// Keep track of each multiply we see, to avoid triggering on (X*4)+(X*4); // where they are actually the same multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:43,Performance,optimiz,optimize,43,"// Now that we have inserted the add tree, optimize it. This allows us to; // handle cases that require multiple factoring steps, such as this:; // A*A*B + A*A*C --> A*(A*B+A*C) --> A*(A*(B+C))",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:31,Energy Efficiency,power,power,31,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:156,Energy Efficiency,power,powers,156,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:255,Energy Efficiency,power,power,255,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:406,Energy Efficiency,power,power,406,"/// Build up a vector of value/power pairs factoring a product.; ///; /// Given a series of multiplication operands, build a vector of factors and; /// the powers each is raised to when forming the final product. Sort them in; /// the order of descending power.; ///; /// (x*x) -> [(x, 2)]; /// ((x*x)*x) -> [(x, 3)]; /// ((((x*y)*x)*y)*x) -> [(x, 3), (y, 2)]; ///; /// \returns Whether any factors have a power greater than one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:97,Energy Efficiency,power,powers,97,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:56,Usability,simpl,simplifying,56,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:107,Usability,simpl,simplifiable,107,"// FIXME: Have Ops be (ValueEntry, Multiplicity) pairs, simplifying this.; // Compute the sum of powers of simplifiable factors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:13,Usability,simpl,simplification,13,// Track for simplification all factors which occur 2 or more times.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:50,Energy Efficiency,power,powers,50,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:15,Usability,simpl,simplify,15,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:64,Usability,simpl,simplifiable,64,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:156,Usability,simpl,simplification,156,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:237,Usability,simpl,simplify,237,"// We can only simplify factors if the sum of the powers of our simplifiable; // factors is 4 or higher. When that is the case, we will *always* have; // a simplification. This is an important invariant to prevent cyclicly; // trying to simplify already minimal formations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:18,Usability,simpl,simplifiable,18,"// Now gather the simplifiable factors, removing them from Ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:45,Energy Efficiency,reduce,reduced,45,// None of the adjustments above should have reduced the sum of factor powers; // below our mininum of '4'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:71,Energy Efficiency,power,powers,71,// None of the adjustments above should have reduced the sum of factor powers; // below our mininum of '4'.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:118,Energy Efficiency,power,powers,118,"/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...; ///; /// Given a vector of values raised to various powers, where no two values are; /// equal and the powers are sorted in decreasing order, compute the minimal; /// DAG of multiplies to compute the final product, and return that product; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:169,Energy Efficiency,power,powers,169,"/// Build a minimal multiplication DAG for (a^x)*(b^y)*(c^z)*...; ///; /// Given a vector of values raised to various powers, where no two values are; /// equal and the powers are sorted in decreasing order, compute the minimal; /// DAG of multiplies to compute the final product, and return that product; /// value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:60,Energy Efficiency,power,power,60,// We want to multiply across all the factors with the same power so that; // we can raise them to that power as a single entity. Build a mini tree; // for that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:104,Energy Efficiency,power,power,104,// We want to multiply across all the factors with the same power so that; // we can raise them to that power as a single entity. Build a mini tree; // for that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:119,Energy Efficiency,power,power,119,// Reset the base value of the first factor to the new expression tree.; // We'll remove all the factors with the same power in a second pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:29,Energy Efficiency,power,powers,29,// Unique factors with equal powers -- we've folded them into the first one's; // base.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:59,Energy Efficiency,power,power,59,"// Iteratively collect the base of each factor with an add power into the; // outer product, and halve each power in preparation for squaring the; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:108,Energy Efficiency,power,power,108,"// Iteratively collect the base of each factor with an add power into the; // outer product, and halve each power in preparation for squaring the; // expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:15,Performance,optimiz,optimize,15,"// We can only optimize the multiplies when there is a chain of more than; // three, such that a balanced tree might require fewer total multiplies.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:55,Performance,perform,performed,55,// The reassociate transformation for FP operations is performed only; // if unsafe algebra is permitted by FastMathFlags. Propagate those flags; // to the newly generated operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:77,Safety,unsafe,unsafe,77,// The reassociate transformation for FP operations is performed only; // if unsafe algebra is permitted by FastMathFlags. Propagate those flags; // to the newly generated operations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:59,Performance,optimiz,optimize,59,"// Now that we have the linearized expression tree, try to optimize it.; // Start by folding any constants that we found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Performance,Optimiz,Optimize,3,// Optimize its operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Safety,Detect,Detect,3,// Detect self-referential nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:109,Performance,optimiz,optimization,109,"// If this is a node in an expression tree, climb to the expression root; // and add that since that's where optimization actually happens.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:16,Performance,optimiz,optimize,16,/// Inspect and optimize the given instruction. Note that erasing; /// instructions is not allowed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:99,Security,expose,expose,99,"// Commute binary operators, to canonicalize the order of their operands.; // This can potentially expose more CSE opportunities, and makes writing other; // transformations simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:174,Usability,simpl,simpler,174,"// Commute binary operators, to canonicalize the order of their operands.; // This can potentially expose more CSE opportunities, and makes writing other; // transformations simpler.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:9,Performance,optimiz,optimize,9,// Don't optimize floating-point instructions unless they have the; // appropriate FastMathFlags for reassociation enabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:229,Performance,optimiz,optimized,229,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:359,Performance,optimiz,optimized,359,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:146,Usability,Simpl,SimplifyCFG,146,"// Do not reassociate boolean (i1) expressions. We want to preserve the; // original order of evaluation for short-circuited comparisons that; // SimplifyCFG has folded to AND/OR expressions. If the expression; // is not further optimized, it is likely to be transformed back to a; // short-circuited form for code gen, and the source order may have been; // optimized for the most likely conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:21,Usability,simpl,simplified,21,"// If the negate was simplified, revisit the users to see if we can; // reassociate further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:21,Usability,simpl,simplified,21,"// If the negate was simplified, revisit the users to see if we can; // reassociate further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:110,Safety,avoid,avoid,110,"// If this is an interior node of a reassociable tree, ignore it until we; // get to the root of the tree, to avoid N^2 analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:73,Performance,optimiz,optimize,73,"// Now that we have the expression tree in a convenient; // sorted form, optimize it globally if possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:24,Usability,simpl,simplified,24,"// This expression tree simplified to something that isn't a tree,; // eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:24,Usability,simpl,simplified,24,"// This expression tree simplified to something that isn't a tree,; // eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:208,Integrability,depend,dependences,208,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:453,Integrability,depend,dependent,453,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:193,Safety,avoid,avoid,193,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:400,Safety,avoid,avoid,400,"// With the CSE-driven heuristic, we are about to slap two values at the; // beginning of the expression whereas they could live very late in the CFG.; // When using the CSE-local heuristic we avoid creating dependences from; // completely unrelated part of the CFG by limiting the expression; // reordering on the values that live in the first seen basic block.; // The main idea is that we want to avoid forming expressions that would; // become loop dependent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:400,Availability,down,down,400,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:32,Integrability,depend,dependencies,32,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:304,Integrability,depend,dependencies,304,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:841,Integrability,depend,dependent,841,"// The value is free of any CFG dependencies.; // Do as if it lives in the entry block.; //; // We do this to make sure all the values falling on this path are; // seen through the same anchor point. The rationale is these values; // can be combined together to from a sub expression free of any CFG; // dependencies so we want them to stay together.; // We could be cleverer and postpone the anchor down to the first; // anchored value, but that's likely complicated to get right.; // E.g., we wouldn't want to do that if that means being stuck in a; // loop.; //; // For instance, we wouldn't want to change:; // res = arg1 op arg2 op arg3 op ... op loop_val1 op loop_val2 ...; // into; // res = loop_val1 op arg1 op arg2 op arg3 op ... op loop_val2 ...; // Because all the sub expressions with arg2..N would be stuck between; // two loop dependent values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:195,Security,expose,expose,195,"// By construction, the operands are sorted in reverse order of their; // topological order.; // So we tend to form (sub) expressions with values that are close to; // each other.; //; // Now to expose more CSE opportunities we want to expose the pair of; // operands that occur the most (as statically computed in; // BuildPairMap.) as the first sub-expression.; //; // If two pairs occur as many times, we pick the one with the; // lowest rank, meaning the one with both operands appearing first in; // the topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:236,Security,expose,expose,236,"// By construction, the operands are sorted in reverse order of their; // topological order.; // So we tend to form (sub) expressions with values that are close to; // each other.; //; // Now to expose more CSE opportunities we want to expose the pair of; // operands that occur the most (as statically computed in; // BuildPairMap.) as the first sub-expression.; //; // If two pairs occur as many times, we pick the one with the; // lowest rank, meaning the one with both operands appearing first in; // the topological order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:27,Performance,optimiz,optimized,27,"// Now that we ordered and optimized the expressions, splat them back into; // the expression tree, removing any unneeded nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:359,Deployability,pipeline,pipeline,359,"// Build the pair map before running reassociate.; // Technically this would be more accurate if we did it after one round; // of reassociation, but in practice it doesn't seem to help much on; // real-world code, so don't waste the compile time running reassociate; // twice.; // If a user wants, they could expicitly run reassociate twice in their; // pass pipeline for further potential gains.; // It might also be possible to update the pair map during runtime, but the; // overhead of that may be large if there's many reassociable chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:430,Deployability,update,update,430,"// Build the pair map before running reassociate.; // Technically this would be more accurate if we did it after one round; // of reassociation, but in practice it doesn't seem to help much on; // real-world code, so don't waste the compile time running reassociate; // twice.; // If a user wants, they could expicitly run reassociate twice in their; // pass pipeline for further potential gains.; // It might also be possible to update the pair map during runtime, but the; // overhead of that may be large if there's many reassociable chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:3,Performance,Optimiz,Optimize,3,// Optimize every instruction in the basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp:10,Integrability,interface,interface,10,// Public interface to the Reassociate pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reassociate.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:519,Performance,load,loads,519,"//===- Reg2Mem.cpp - Convert registers to allocas -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file demotes all registers to memory references. It is intended to be; // the inverse of PromoteMemoryToRegister. By converting to loads, the only; // values live across basic blocks are allocas and loads before phi nodes.; // It is intended that this should make CFG hacking much easier.; // To make later hacking easier, the entry block is split into two, such that; // all introduced allocas and nothing else are in the entry block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:587,Performance,load,loads,587,"//===- Reg2Mem.cpp - Convert registers to allocas -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file demotes all registers to memory references. It is intended to be; // the inverse of PromoteMemoryToRegister. By converting to loads, the only; // values live across basic blocks are allocas and loads before phi nodes.; // It is intended that this should make CFG hacking much easier.; // To make later hacking easier, the entry block is split into two, such that; // all introduced allocas and nothing else are in the entry block.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:77,Safety,safe,safe,77,"// Find first non-alloca instruction and create insertion point. This is; // safe if block is well-formed: it always have terminator, otherwise; // we'll get and assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp:162,Testability,assert,assertion,162,"// Find first non-alloca instruction and create insertion point. This is; // safe if block is well-formed: it always have terminator, otherwise; // we'll get and assertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Reg2Mem.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:7,Modifiability,Rewrite,RewriteStatepointsForGC,7,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:383,Modifiability,Rewrite,Rewrite,383,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:456,Performance,perform,performed,456,"//===- RewriteStatepointsForGC.cpp - Make GC relocations explicit ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Rewrite call/invoke instructions so as to make potential relocations; // performed by the garbage collector explicit in the IR.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:20,Modifiability,Rewrite,RewriteStatepointsForGC,20,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:158,Modifiability,Rewrite,RewriteStatepointsForGC,158,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:232,Modifiability,Rewrite,RewriteStatepointsForGC,232,"/// The IR fed into RewriteStatepointsForGC may have had attributes and; /// metadata implying dereferenceability that are no longer valid/correct after; /// RewriteStatepointsForGC has run. This is because semantically, after; /// RewriteStatepointsForGC runs, all calls to gc.statepoint ""free"" the entire; /// heap. stripNonValidData (conservatively) restores; /// correctness by erasing all attributes in the module that externally imply; /// dereferenceability. Similar reasoning also applies to the noalias; /// attributes and metadata. gc.statepoint can touch the entire heap including; /// noalias objects.; /// Apart from attributes and metadata, we also remove instructions that imply; /// constant physical memory: llvm.invariant.start.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:29,Modifiability,rewrite,rewrite,29,// Policy choice says not to rewrite - the most common reason is that we're; // compiling code without a GCStrategy.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:21,Testability,assert,asserts,21,"// stripNonValidData asserts that shouldRewriteStatepointsIn; // returns true for at least one function in the module. Since at least; // one function changed, we know that the precondition is satisfied.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:549,Deployability,update,update,549,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:28,Performance,cache,cache,28,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:220,Performance,cache,caches,220,"// The type of the internal cache used inside the findBasePointers family; // of functions. From the callers perspective, this is an opaque type and; // should not be inspected.; //; // In the actual implementation this caches two relations:; // - The base relation itself (i.e. this pointer is based on that one); // - The base defining value relation (i.e. before base_phi insertion); // Generally, after the execution of a full findBasePointer call, only the; // base relation will remain. Internally, we add a mixture of the two; // types, then update all the second type to the first type",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:51,Safety,safe,safepoint,51,/// The set of values known to be live across this safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:186,Testability,assert,assert,186,// Return true if this type is one which a) is a gc pointer or contains a GC; // pointer and b) is of a type this code expects to encounter as a live value.; // (The insertion code will assert that a type which matches (a) and not (b); // is not encountered.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:62,Testability,assert,assert,62,// We partially support vectors of gc pointers. The code will assert if it; // can't handle something.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:186,Testability,assert,assertions,186,// Returns true if this is a type which a) is a gc pointer or contains a GC; // pointer and b) is of a type which the code doesn't expect (i.e. first class; // aggregates). Used to trip assertions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:111,Performance,perform,performed,111,// Conservatively identifies any definitions which might be live at the; // given instruction. The analysis is performed immediately before the; // given instruction. Values defined by that instruction are not considered; // live. Values used by that instruction are considered live.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:4,Performance,Cache,Caches,4,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:91,Performance,cache,cache,91,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Testability,assert,asserts,48,/// Caches the IsKnownBase flag for a value and asserts that it wasn't present; /// in the cache before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:169,Performance,optimiz,optimization,169,"/// Return a base defining value for the 'Index' element of the given vector; /// instruction 'I'. If Index is null, returns a BDV for the entire vector; /// 'I'. As an optimization, this method will try to determine when the; /// element is known to already be a base pointer. If this can be established,; /// the second value in the returned pair will be true. Note that either a; /// vector or a pointer typed value can be returned. For the former, the; /// vector returned is a BDV (and possibly a base) of the entire vector 'I'.; /// If the later, the return pointer is a BDV (or possibly a base) for the; /// particular element in 'I'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:245,Performance,optimiz,optimizations,245,"// We don't know whether this vector contains entirely base pointers or; // not. To be conservatively correct, we treat it as a BDV and will; // duplicate code as needed to construct a parallel vector of bases.; // TODO: There a number of local optimizations which could be applied here; // for particular sufflevector patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Usability,simpl,simple,137,"/// Helper function for findBasePointer - Will return a value which either a); /// defines the base pointer for the input, b) blocks the simple search; /// (i.e. a PHI or Select of two derived pointers), or c) involves a change; /// from pointer to vector type or back.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:307,Performance,optimiz,optimizer,307,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:445,Safety,avoid,avoid,445,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:600,Testability,test,test,600,"// We assume that objects with a constant base (e.g. a global) can't move; // and don't need to be reported to the collector because they are always; // live. Besides global references, all kinds of constants (e.g. undef,; // constant expressions, null pointers) can be introduced by the inliner or; // the optimizer, especially on dynamically dead paths.; // Here we treat all of them as having single null base. By doing this we; // trying to avoid problems reporting various conflicts in a form of; // ""phi (const1, const2)"" or ""phi (const, regular gc ptr)"".; // See constant.ll file for relevant test cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:250,Performance,optimiz,optimizer,250,// inttoptrs in an integral address space are currently ill-defined. We; // treat them as defining base pointers here for consistency with the; // constant rule above and because we don't really have a better semantic; // to give them. Note that the optimizer is always free to insert undefined; // behavior on dynamically dead paths as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Usability,simpl,simply,84,"// If we find a cast instruction here, it means we've found a cast which is; // not simply a pointer cast (i.e. an inttoptr). We don't know how to; // handle int->ptr conversion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Performance,load,loaded,13,// The value loaded is an gc base itself,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Safety,safe,safepoint,13,"// Rerunning safepoint insertion after safepoints are already; // inserted is not supported. It could probably be made to work,; // but why are you doing this? There's no good reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:39,Safety,safe,safepoints,39,"// Rerunning safepoint insertion after safepoints are already; // inserted is not supported. It could probably be made to work,; // but why are you doing this? There's no good reason.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Modifiability,extend,extended,41,"// Currently, this mechanism hasn't been extended to work with gcroot.; // There's no reason it couldn't be, but I haven't thought about the; // implications much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:43,Performance,load,load,43,"// A CAS is effectively a atomic store and load combined under a; // predicate. From the perspective of base pointers, we just treat it; // like a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:147,Performance,load,load,147,"// A CAS is effectively a atomic store and load combined under a; // predicate. From the perspective of base pointers, we just treat it; // like a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:123,Performance,load,load,123,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:200,Performance,load,load,200,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:108,Usability,simpl,simply,108,"// The aggregate ops. Aggregates can either be in the heap or on the; // stack, but in either case, this is simply a field load. As a result,; // this is a defining definition of the base just like a load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:155,Testability,test,test,155,// Note: There a lot of obvious peephole cases here. This are deliberately; // handled after the main base pointer inference algorithm to make writing; // test cases to exercise that code easier.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,Availability,avail,available,14,// Only a BDV available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:194,Availability,reliab,reliable,194,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:244,Availability,failure,failure,244,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:110,Usability,simpl,simply,110,"/// For a given value or instruction, figure out what base ptr its derived from.; /// For gc objects, this is simply itself. On success, returns a value which is; /// the base pointer. (This is reliable and can be used for relocation.) On; /// failure, returns nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:738,Usability,simpl,simpler,738,"// Here's the rough algorithm:; // - For every SSA value, construct a mapping to either an actual base; // pointer or a PHI which obscures the base pointer.; // - Construct a mapping from PHI to unknown TOP state. Use an; // optimistic algorithm to propagate base pointer information. Lattice; // looks like:; // UNKNOWN; // b1 b2 b3 b4; // CONFLICT; // When algorithm terminates, all PHIs will either have a single concrete; // base or be in a conflict state.; // - For every conflict, insert a dummy PHI node without arguments. Add; // these to the base[Instruction] = BasePtr mapping. For every; // non-conflict, add the actual base.; // - For every conflict, add arguments for the base[a] of each input; // arguments.; //; // Note: A simpler form of this would be to add the conflict form of all; // PHIs without running the optimistic algorithm. This would be; // analogous to pessimistic data flow and would likely lead to an; // overall worse solution.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:77,Safety,safe,safely,77,"// Known bases won't need new instructions introduced and can be; // ignored safely. However, this can only be done when InVal and Base; // are both scalar or both vector. Otherwise, we need to find a; // correct BDV for InVal, by creating an entry in the lattice; // (States).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache the fact V is it's own base for later usage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:122,Performance,cache,cached,122,// Return a phi state for a base defining value. We'll generate a new; // base state for known bases and expect to find a cached state otherwise.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:1115,Performance,optimiz,optimized,1115,"// Even though we have identified a concrete base (or a conflict) for all live; // pointers at this point, there are cases where the base is of an; // incompatible type compared to the original instruction. We conservatively; // mark those as conflicts to ensure that corresponding BDVs will be generated; // in the next steps.; // this is a rather explicit check for all cases where we should mark the; // state as a conflict to force the latter stages of the algorithm to emit; // the BDVs.; // TODO: in many cases the instructions emited for the conflicting states; // will be identical to the I itself (if the I's operate on their BDVs; // themselves). We should exploit this, but can't do it here since it would; // break the invariant about the BDVs not being known to be a base.; // TODO: the code also does not handle constants at all - the algorithm relies; // on all constants having the same BDV and therefore constant-only insns; // will never be in conflict, but this check is ignored here. If the; // constant conflicts will be to BDVs themselves, they will be identical; // instructions and will get optimized away (as in the above TODO)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:49,Safety,safe,safe,49,"// We're only changing values in this loop, thus safe to keep iterators.; // Since this is computing a fixed point, the order of visit does not; // effect the result. TODO: We could use a worklist here and make this run; // much faster.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:89,Testability,assert,asserts,89,// since we do the conflict marking as part of the fixpoint iteration this; // loop only asserts that invariants are met,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:99,Integrability,depend,dependency,99,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:69,Safety,avoid,avoid,69,// Insert Phis for all conflicts; // TODO: adjust naming patterns to avoid this order of iteration dependency,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:87,Safety,predict,predictable,87,// Fixup all the inputs of the new PHIs. Visit order needs to be; // deterministic and predictable because we're naming newly created; // instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Testability,assert,assert,19,// In essence this assert states: the only way two values; // incoming from the same basic block may be different is by; // being different bitcasts of the same value. A cleanup; // that remains TODO is changing findBaseOrBDV to return an; // llvm::Value of the correct type (and still remain pure).; // This will remove the need to add bitcasts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache all of our results so we can cheaply reuse them; // NOTE: This is actually two caches: one of the base defining value; // relation and one of the base pointer relation! FIXME,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:88,Performance,cache,caches,88,// Cache all of our results so we can cheaply reuse them; // NOTE: This is actually two caches: one of the base defining value; // relation and one of the base pointer relation! FIXME,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:131,Integrability,rout,routine,131,"// For a set of live pointers (base and/or derived), identify the base; // pointer of the object which they are derived from. This routine will; // mutate the IR graph as needed to make the 'base' pointer live at the; // definition site of 'derived'. This ensures that any use of 'derived' can; // also use 'base'. This may involve the insertion of a number of; // additional PHI nodes.; //; // preconditions: live is a set of pointer type Values; //; // side effects: may insert PHI nodes into the existing CFG, will preserve; // CFG, will not remove or mutate any existing nodes; //; // post condition: PointerToBase contains one (derived, base) pair for every; // pointer in live. Note that derived can be equal to base if the original; // pointer was a base pointer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:76,Performance,optimiz,optimization,76,"// We assume that all pointers passed to deopt are base pointers; as an; // optimization, we can use this to avoid seperately materializing the base; // pointer graph. This is only relevant since we're very conservative about; // generating new conflict nodes during base pointer insertion. If we were; // smarter there, this would be irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:109,Safety,avoid,avoid,109,"// We assume that all pointers passed to deopt are base pointers; as an; // optimization, we can use this to avoid seperately materializing the base; // pointer graph. This is only relevant since we're very conservative about; // generating new conflict nodes during base pointer insertion. If we were; // smarter there, this would be irrelevant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:13,Deployability,update,updated,13,"/// Given an updated version of the dataflow liveness results, update the; /// liveset and base pointer maps for the call site CS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:63,Deployability,update,update,63,"/// Given an updated version of the dataflow liveness results, update the; /// liveset and base pointer maps for the call site CS.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Usability,simpl,simply,48,"// TODO-PERF: reuse the original liveness, then simply run the dataflow; // again. The old values are still live and will help it stabilize quickly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:99,Deployability,update,update,99,// If it is not first instruction in the chain then it uses previously; // cloned value. We should update it to use cloned value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,Assert,Assert,3,// Assert that cloned instruction does not use any instructions from; // this chain other than LastClonedValue,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,Assert,Assert,3,// Assert that the cloned instruction does not use the RootOfChain; // or the AlternateLiveBase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:48,Safety,safe,safely,48,// Now that 'Ret' has unique predecessor we can safely remove all phi nodes; // from it,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,Safety,safe,safely,25,"// At this point, we can safely insert a gc.relocate or gc.result as the first; // instruction in Ret if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:264,Performance,optimiz,optimization,264,"// List of all function attributes which must be stripped when lowering from; // abstract machine model to physical machine model. Essentially, these are; // all the effects a safepoint might have which we ignored in the abstract; // machine model for purposes of optimization. We have to strip these on; // both function declarations and call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:176,Safety,safe,safepoint,176,"// List of all function attributes which must be stripped when lowering from; // abstract machine model to physical machine model. Essentially, these are; // all the effects a safepoint might have which we ignored in the abstract; // machine model for purposes of optimization. We have to strip these on; // both function declarations and call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:114,Safety,safe,safepoint,114,// Create new attribute set containing only attributes which can be transferred; // from the original call to the safepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:168,Safety,avoid,avoid,168,// The memory intrinsics do not have a 1:1 correspondence of the original; // call arguments to the produced statepoint. Do not transfer the argument; // attributes to avoid putting them on incorrect arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:129,Modifiability,variab,variables,129,/// Helper function to place all gc relocates necessary for the given; /// statepoint.; /// Inputs:; /// liveVariables - list of variables to be relocated.; /// basePtrs - base pointers.; /// statepointToken - statepoint instruction to which relocates should be; /// bound.; /// Builder - Llvm IR builder to be used to construct new calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:127,Performance,cache,cached,127,// Lazily populated map from input types to the canonicalized form mentioned; // in the comment above. This should probably be cached somewhere more; // broadly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:80,Safety,avoid,avoids,80,/// This struct is used to defer RAUWs and `eraseFromParent` s. Using this; /// avoids having to worry about keeping around dangling pointers to Values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:42,Integrability,interface,interface,42,// FIXME: Calls have a *really* confusing interface around attributes; // with values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:175,Availability,avail,available,175,// Then go ahead and use the builder do actually do the inserts. We insert; // immediately before the previous instruction under the assumption that all; // arguments will be available here. We can't insert afterwards since we may; // be replacing a terminator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:809,Availability,avail,available,809,"// Unordered atomic memcpy and memmove intrinsics which are not explicitly; // marked as ""gc-leaf-function"" should be lowered in a GC parseable way.; // Specifically, these calls should be lowered to the; // __llvm_{memcpy|memmove}_element_unordered_atomic_safepoint symbols.; // Similarly to __llvm_deoptimize we want to resolve this now, since the; // verifier does not allow taking the address of an intrinsic function.; //; // Moreover we need to shuffle the arguments for the call in order to; // accommodate GC. The underlying source and destination objects might be; // relocated during copy operation should the GC occur. To relocate the; // derived source and destination pointers the implementation of the; // intrinsic should know the corresponding base pointers.; //; // To make the base pointers available pass them explicitly as arguments:; // memcpy(dest_derived, source_derived, ...) =>; // memcpy(dest_base, dest_offset, source_base, source_offset, ...)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Optimiz,Optimizations,3,"// Optimizations in unreachable code might substitute the real pointer; // with undef, poison or null-derived constant. Return null base for; // them to be consistent with the handling in the main algorithm in; // findBaseDefiningValue.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Integrability,wrap,wrapping,12,"// If we're wrapping an @llvm.experimental.deoptimize in a statepoint, we; // transform the tail-call like structure to a call to a void function; // followed by unreachable to get better codegen.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:102,Safety,safe,safepoint,102,"// We cannot RAUW or delete CS.getInstruction() because it could be in the; // live set of some other safepoint, in which case that safepoint's; // PartiallyConstructedSafepointRecord will hold a raw pointer to this; // llvm::Instruction. Instead, we defer the replacement and deletion to; // after the live sets have been made explicit in the IR, and we no longer; // have raw pointers to worry about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:132,Safety,safe,safepoint,132,"// We cannot RAUW or delete CS.getInstruction() because it could be in the; // live set of some other safepoint, in which case that safepoint's; // PartiallyConstructedSafepointRecord will hold a raw pointer to this; // llvm::Instruction. Instead, we defer the replacement and deletion to; // after the live sets have been made explicit in the IR, and we no longer; // have raw pointers to worry about.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:47,Modifiability,variab,variable,47,"// Second, create a gc.relocate for every live variable",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:127,Safety,safe,safepoint,127,// Replace an existing gc.statepoint with a new one and a set of gc.relocates; // which make the relocations happening at this safepoint explicit.; //; // WARNING: Does not do any fixup to adjust users of the original live; // values. That's the callers responsibility.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:25,Energy Efficiency,efficient,efficient,25,// Convert to vector for efficient cross referencing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:297,Security,validat,validation,297,"// Helper function for the relocationViaAlloca.; //; // It receives iterator to the statepoint gc relocates and emits a store to the; // assigned location (via allocaMap) for the each one of them. It adds the; // visited values into the visitedLiveValues set, which we will later use them; // for validation checking.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:26,Deployability,update,update,26,/// Do all the relocation update via allocas and mem2reg,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:273,Deployability,Update,Update,273,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:469,Deployability,update,update,469,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:182,Performance,load,load,182,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:248,Performance,perform,performance,248,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:496,Performance,load,load,496,// The next two loops are part of the same conceptual operation. We need to; // insert a store to the alloca after the original def and at each; // redefinition. We need to insert a load before each use. These are split; // into distinct loops for performance reasons.; // Update gc pointer after each statepoint: either store a relocated value or; // null (if no relocated value was found for this gc pointer and it is not a; // gc_result). This must happen before we update the statepoint with load of; // alloca otherwise we lose the link between statepoint and old def.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Deployability,Update,Update,3,// Update use with load allocas and add store for gc_relocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Performance,load,load,19,// Update use with load allocas and add store for gc_relocated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:83,Deployability,update,update,83,// We pre-record the uses of allocas so that we dont have to worry about; // later update that changes the user information..,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:200,Integrability,depend,dependent,200,"// If the def has a ConstantExpr use, then the def is either a; // ConstantExpr use itself or null. In either case; // (recursively in the first, directly in the second), the oop; // it is ultimately dependent on is null and this particular; // use does not need to be fixed up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:69,Performance,load,load,69,"// Emit store for the initial gc value. Store must be inserted after load,; // otherwise store will be in alloca's use list and an extra load will be; // inserted before it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Performance,load,load,137,"// Emit store for the initial gc value. Store must be inserted after load,; // otherwise store will be in alloca's use list and an extra load will be; // inserted before it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:211,Safety,safe,safepoints,211,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:152,Testability,test,tests,152,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:197,Testability,test,testing,197,/// Implement a unique function which doesn't require we sort the input; /// vector. Doing so has the effect of changing the output of a couple of; /// tests in ways which make them less useful in testing fused safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Safety,safe,safepoints,12,// For call safepoints insert dummy calls right after safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:54,Safety,safe,safepoint,54,// For call safepoints insert dummy calls right after safepoint,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:14,Safety,safe,safepooints,14,// For invoke safepooints insert dummy calls both in normal and; // exceptional destination blocks,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:204,Usability,simpl,simple,204,"// Helper function for the ""rematerializeLiveValues"". It walks use chain; // starting from the ""CurrentValue"" until it reaches the root of the chain, i.e.; // the base or a value it cannot process. Only ""simple"" values are processed; // (currently it is GEP's and casts). The returned root is examined by the; // callers of findRematerializableChainToBasePointer. Fills ""ChainToBase"" array; // with all visited values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:117,Performance,optimiz,optimization,117,"// TODO: We can also account for cases when we will be able to remove some; // of the rematerialized values by later optimization passes. I.e if; // we rematerialized several intersecting chains. Or if original values; // don't have any uses besides this statepoint.; // Ok, there is a candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:228,Safety,avoid,avoid,228,"// Current rematerialization algorithm is very simple: we rematerialize; // immediately before EVERY use, even if there are several uses in same; // block or if use is local to Cand Def. The reason is that this allows; // us to avoid recomputing liveness without complicated analysis:; // - If we did not eliminate all uses of original Candidate, we do not; // know exaclty in what BBs it is still live.; // - If we rematerialize once per BB, we need to find proper insertion; // place (first use in block, but after Def) and analyze if there is; // statepoint between uses in the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:47,Usability,simpl,simple,47,"// Current rematerialization algorithm is very simple: we rematerialize; // immediately before EVERY use, even if there are several uses in same; // block or if use is local to Cand Def. The reason is that this allows; // us to avoid recomputing liveness without complicated analysis:; // - If we did not eliminate all uses of original Candidate, we do not; // know exaclty in what BBs it is still live.; // - If we rematerialize once per BB, we need to find proper insertion; // place (first use in block, but after Def) and analyze if there is; // statepoint between uses in the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Security,Validat,Validate,3,// Validate the input,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Safety,safe,safepoint,84,// Insert a dummy call with all of the deopt operands we'll need for the; // actual safepoint insertion as arguments. This ensures reference operands; // in the deopt argument list are considered live through the safepoint (and; // thus makes sure they get relocated.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:213,Safety,safe,safepoint,213,// Insert a dummy call with all of the deopt operands we'll need for the; // actual safepoint insertion as arguments. This ensures reference operands; // in the deopt argument list are considered live through the safepoint (and; // thus makes sure they get relocated.),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Safety,safe,safepoint,41,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:118,Safety,safe,safepoint,118,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:219,Safety,safe,safepoint,219,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:280,Safety,safe,safepoint,280,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:346,Safety,safe,safepoint,346,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:433,Safety,safe,safepoint,433,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:26,Testability,log,logic,26,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:133,Usability,simpl,simplest,133,// The base phi insertion logic (for any safepoint) may have inserted new; // instructions which are now live at some safepoint. The simplest such; // example is:; // loop:; // phi a <-- will be a new base_phi here; // safepoint 1 <-- that needs to be live here; // gep a + 1; // safepoint 2; // br loop; // We insert some dummy calls after each safepoint to definitely hold live; // the base pointers which were identified for that safepoint. We'll then; // ask liveness for _every_ base inserted to see what is now live. Then we; // remove the dummy calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:41,Modifiability,variab,variables,41,"// It is possible that non-constant live variables have a constant base. For; // example, a GEP with a variable offset from a global. In this case we can; // remove it from the liveset. We already don't add constants to the liveset; // because we assume they won't move at runtime and the GC doesn't need to be; // informed about them. The same reasoning applies if the base is constant.; // Note that the relocation placement code relies on this filtering for; // correctness as it expects the base to be in the liveset, which isn't true; // if the base is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:103,Modifiability,variab,variable,103,"// It is possible that non-constant live variables have a constant base. For; // example, a GEP with a variable offset from a global. In this case we can; // remove it from the liveset. We already don't add constants to the liveset; // because we assume they won't move at runtime and the GC doesn't need to be; // informed about them. The same reasoning applies if the base is constant.; // Note that the relocation placement code relies on this filtering for; // correctness as it expects the base to be in the liveset, which isn't true; // if the base is constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:15,Energy Efficiency,reduce,reduce,15,"// In order to reduce live set of statepoint we might choose to rematerialize; // some values instead of relocating them. This is purely an optimization and; // does not influence correctness.; // First try rematerialization at uses, then after statepoints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:140,Performance,optimiz,optimization,140,"// In order to reduce live set of statepoint we might choose to rematerialize; // some values instead of relocating them. This is purely an optimization and; // does not influence correctness.; // First try rematerialization at uses, then after statepoints.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:19,Safety,safe,safely,19,"// We need this to safely RAUW and delete call or invoke return values that; // may themselves be live over a statepoint. For details, please see usage in; // makeStatepointExplicitImpl.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:120,Deployability,update,update,120,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:88,Modifiability,variab,variables,88,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:194,Modifiability,variab,variables,194,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:329,Modifiability,variab,variable,329,"// Now run through and replace the existing statepoints with new ones with; // the live variables listed. We do not yet update uses of the values being; // relocated. We have references to live variables that need to; // survive to the last iteration of this loop. (By construction, the; // previous statepoint can not be a live variable, thus we can and remove; // the old statepoint calls as we go.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:113,Integrability,wrap,wrapped,113,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:230,Safety,avoid,avoid,230,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:207,Usability,Clear,Clear,207,"// These live sets may contain state Value pointers, since we replaced calls; // with operand bundles with calls wrapped in gc.statepoint, and some of; // those calls may have been def'ing live gc pointers. Clear these out to; // avoid accidentally using them.; //; // TODO: We should create a separate data structure that does not contain; // these live sets, and migrate to using that data structure from this point; // onward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:42,Modifiability,variab,variables,42,// Do all the fixups of the original live variables to their relocated selves,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:283,Deployability,update,updated,283,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:137,Safety,safe,safepoint,137,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:12,Usability,simpl,simply,12,"// We can't simply save the live set from the original insertion. One of; // the live values might be the result of a call which needs a safepoint.; // That Value* no longer exists and we need to use the new gc_result.; // Thankfully, the live set is embedded in the statepoint (and updated), so; // we just grab that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:72,Performance,perform,performing,72,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:17,Security,validat,validation,17,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:241,Testability,test,test,241,// Do some basic validation checking on our liveness results before; // performing relocation. Relocation can and will turn mistakes in liveness; // results into non-sensical code which is must harder to debug.; // TODO: It would be nice to test consistency as well,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Security,Validat,Validation,3,// Validation check,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:52,Integrability,depend,depends,52,"// Intrinsics are very delicate. Lowering sometimes depends the presence; // of certain attributes for correctness, but we may have also inferred; // additional ones in the abstract machine model which need stripped. This; // assumes that the attributes defined in Intrinsic.td are conservatively; // correct for both physical and abstract model.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:75,Performance,Optimiz,Optimizations,75,/// Certain metadata on instructions are invalid after running RS4GC.; /// Optimizations that run after RS4GC can incorrectly use this metadata to; /// optimize functions. We drop such metadata on the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:152,Performance,optimiz,optimize,152,/// Certain metadata on instructions are invalid after running RS4GC.; /// Optimizations that run after RS4GC can incorrectly use this metadata to; /// optimize functions. We drop such metadata on the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:213,Modifiability,Rewrite,RewriteStatepointsForGC,213,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:52,Performance,load,loads,52,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:550,Performance,load,load,550,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:571,Performance,load,load,571,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:637,Performance,load,load,637,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:833,Performance,load,loads,833,"// These are the attributes that are still valid on loads and stores after; // RS4GC.; // The metadata implying dereferenceability and noalias are (conservatively); // dropped. This is because semantically, after RewriteStatepointsForGC runs,; // all calls to gc.statepoint ""free"" the entire heap. Also, gc.statepoint can; // touch the entire heap including noalias objects. Note: The reasoning is; // same as stripping the dereferenceability and noalias attributes that are; // analogous to the metadata counterparts.; // We also drop the invariant.load metadata on the load because that metadata; // implies the address operand to the load points to memory that is never; // changed once it became dereferenceable. This is no longer true after RS4GC.; // Similar reasoning applies to invariant.group metadata, which applies to; // loads within a group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:78,Safety,avoid,avoid,78,// Set of invariantstart instructions that we need to remove.; // Use this to avoid invalidating the instruction iterator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:147,Modifiability,Rewrite,RewriteStatepointsForGC,147,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:303,Performance,optimiz,optimizer,303,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:325,Performance,load,load,325,"// invariant.start on memory location implies that the referenced memory; // location is constant and unchanging. This is no longer true after; // RewriteStatepointsForGC runs because there can be calls to gc.statepoint; // which frees the entire heap and the presence of invariant.start allows; // the optimizer to sink the load of a memory location past a statepoint,; // which is incorrect.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:140,Performance,cache,cache,140,"/// Looks up the GC strategy for a given function, returning null if the; /// function doesn't have a GC tag. The strategy is stored in the cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:141,Testability,log,logic,141,/// Returns true if this function should be rewritten by this pass. The main; /// point of this function is as an extension point for custom logic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:287,Performance,optimiz,optimizer,287,// Normally it's up to the frontend to make sure that non-leaf calls also; // have proper deopt state if it is required. We make an exception for; // element atomic memcpy/memmove intrinsics here. Unlike other intrinsics; // these are non-leaf by default. They might be generated by the optimizer; // which doesn't know how to produce a proper deopt state. So if we see a; // non-leaf memcpy/memmove without deopt state just treat it as a leaf; // copy and don't produce a statepoint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:120,Testability,test,testing,120,// Delete any unreachable statepoints so that we don't have unrewritten; // statepoints surviving this pass. This makes testing easier and the; // resulting IR less confusing to human readers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:487,Availability,avail,available,487,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:588,Energy Efficiency,schedul,scheduler,588,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:691,Modifiability,extend,extend,691,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:81,Safety,avoid,avoid,81,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:230,Safety,safe,safepoints,230,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:947,Safety,safe,safer,947,"// Before we start introducing relocations, we want to tweak the IR a bit to; // avoid unfortunate code generation effects. The main example is that we; // want to try to make sure the comparison feeding a branch is after any; // safepoints. Otherwise, we end up with a comparison of pre-relocation; // values feeding a branch after relocation. This is semantically correct,; // but results in extra register pressure since both the pre-relocation and; // post-relocation copies must be available in registers. For code without; // relocations this is handled elsewhere, but teaching the scheduler to; // reverse the transform we're about to do would be slightly complex.; // Note: This may extend the live range of the inputs to the icmp and thus; // increase the liveset of any statepoint we move over. This is profitable; // as long as all statepoints are in rare blocks. If we had in-register; // lowering for live values this would be a much safer transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:9,Modifiability,Extend,Extend,9,// TODO: Extend this to handle switches,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:122,Security,access,access,122,// TODO: Handle more than just ICmps here. We should be able to move; // most instructions without side effects or memory access.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:189,Deployability,integrat,integrate,189,"// Nasty workaround - The base computation code in the main algorithm doesn't; // consider the fact that a GEP can be used to convert a scalar to a vector.; // The right fix for this is to integrate GEPs into the base rewriting; // algorithm properly, this is just a short term workaround to prevent; // crashes by canonicalizing such GEPs into fully vector GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:189,Integrability,integrat,integrate,189,"// Nasty workaround - The base computation code in the main algorithm doesn't; // consider the fact that a GEP can be used to convert a scalar to a vector.; // The right fix for this is to integrate GEPs into the base rewriting; // algorithm properly, this is just a short term workaround to prevent; // crashes by canonicalizing such GEPs into fully vector GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Performance,Cache,Cache,3,// Cache the 'defining value' relation used in the computation and; // insertion of base phis and selects. This ensures that we don't insert; // large numbers of duplicate base_phis. Use one cache for both; // inlineGetBaseAndOffset() and insertParsePoints().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:191,Performance,cache,cache,191,// Cache the 'defining value' relation used in the computation and; // insertion of base phis and selects. This ensures that we don't insert; // large numbers of duplicate base_phis. Use one cache for both; // inlineGetBaseAndOffset() and insertParsePoints().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:250,Modifiability,variab,variable,250,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:408,Performance,Optimiz,Optimization,408,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:635,Testability,test,tests,635,"// The choice to exclude all things constant here is slightly subtle.; // There are two independent reasons:; // - We assume that things which are constant (from LLVM's definition); // do not move at runtime. For example, the address of a global; // variable is fixed, even though it's contents may not be.; // - Second, we can't disallow arbitrary inttoptr constants even; // if the language frontend does. Optimization passes are free to; // locally exploit facts without respect to global reachability. This; // can create sections of code which are dynamically unreachable and; // contain just about anything. (see constants.ll in tests)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:79,Security,validat,validation,79,/// Check that the items in 'Live' dominate 'TI'. This is used as a basic; /// validation check for the liveness computation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,assert,assert,3,// assert OutLiveOut is a subset of LiveOut,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:3,Testability,assert,assert,3,// assert: OldLiveIn is a subset of LiveTmp,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp:84,Deployability,update,update,84,// We may have base pointers which are now live that weren't before. We need; // to update the PointerToBase structure to reflect this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/RewriteStatepointsForGC.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:60,Availability,mask,masked,60,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:417,Availability,mask,masked,417,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:573,Availability,mask,mask,573,"//===- ScalarizeMaskedMemIntrin.cpp - Scalarize unsupported masked mem ----===//; // intrinsics; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass replaces masked memory intrinsics - when unsupported by the target; // - with a chain of basic blocks, that deal with the elements one-by-one if the; // appropriate mask bit is set.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:64,Availability,mask,masked,64,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:122,Availability,mask,mask,122,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:237,Availability,mask,mask,237,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:327,Availability,mask,mask,327,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:697,Availability,mask,mask,697,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:1096,Availability,mask,mask,1096,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:22,Performance,load,load,22,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:71,Performance,load,load,71,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:187,Performance,load,loading,187,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:365,Performance,load,load,365,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:396,Performance,load,load,396,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:462,Performance,load,load,462,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:587,Performance,load,load,587,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:639,Performance,load,load,639,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:838,Performance,load,load,838,"// Translate a masked load intrinsic like; // <16 x i32 > @llvm.masked.load( <16 x i32>* %addr, i32 align,; // <16 x i1> %mask, <16 x i32> %passthru); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.load, label %else; //; // cond.load: ; preds = %0; // %3 = getelementptr i32* %1, i32 0; // %4 = load i32* %3; // %5 = insertelement <16 x i32> %passthru, i32 %4, i32 0; // br label %else; //; // else: ; preds = %0, %cond.load; // %res.phi.else = phi <16 x i32> [ %5, %cond.load ], [ poison, %0 ]; // %6 = extractelement <16 x i1> %mask, i32 1; // br i1 %6, label %cond.load1, label %else2; //; // cond.load1: ; preds = %else; // %7 = getelementptr i32* %1, i32 1; // %8 = load i32* %7; // %9 = insertelement <16 x i32> %res.phi.else, i32 %8, i32 1; // br label %else2; //; // else2: ; preds = %else, %cond.load1; // %res.phi.else3 = phi <16 x i32> [ %9, %cond.load1 ], [ %res.phi.else, %else ]; // %10 = extractelement <16 x i1> %mask, i32 2; // br i1 %10, label %cond.load4, label %else5; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:20,Availability,mask,mask,20,// Short-cut if the mask is all-true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:262,Performance,load,load,262,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = and i16 %scalar_mask, i32 1 << Idx; // %cond = icmp ne i16 %mask_1, 0; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:59,Availability,mask,masked,59,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:134,Availability,mask,mask,134,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:226,Availability,mask,mask,226,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:316,Availability,mask,mask,316,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:611,Availability,mask,mask,611,"// Translate a masked store intrinsic, like; // void @llvm.masked.store(<16 x i32> %src, <16 x i32>* %addr, i32 align,; // <16 x i1> %mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set; //; // %1 = bitcast i8* %addr to i32*; // %2 = extractelement <16 x i1> %mask, i32 0; // br i1 %2, label %cond.store, label %else; //; // cond.store: ; preds = %0; // %3 = extractelement <16 x i32> %val, i32 0; // %4 = getelementptr i32* %1, i32 0; // store i32 %3, i32* %4; // br label %else; //; // else: ; preds = %0, %cond.store; // %5 = extractelement <16 x i1> %mask, i32 1; // br i1 %5, label %cond.store1, label %else2; //; // cond.store1: ; preds = %else; // %6 = extractelement <16 x i32> %val, i32 1; // %7 = getelementptr i32* %1, i32 1; // store i32 %6, i32* %7; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:20,Availability,mask,mask,20,// Short-cut if the mask is all-true.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:66,Availability,mask,masked,66,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:129,Availability,Mask,Mask,129,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:239,Availability,mask,mask,239,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:357,Availability,Mask,Mask,357,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:734,Availability,Mask,Mask,734,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:1043,Availability,Mask,Mask,1043,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:189,Performance,load,loading,189,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:399,Performance,load,load,399,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:430,Performance,load,load,430,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:501,Performance,load,load,501,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:675,Performance,load,load,675,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:881,Performance,load,load,881,"// Translate a masked gather intrinsic like; // <16 x i32 > @llvm.masked.gather.v16i32( <16 x i32*> %Ptrs, i32 4,; // <16 x i1> %Mask, <16 x i32> %Src); // to a chain of basic blocks, with loading element one-by-one if; // the appropriate mask bit is set; //; // %Ptrs = getelementptr i32, i32* %base, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.load, label %else; //; // cond.load:; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // %Load0 = load i32, i32* %Ptr0, align 4; // %Res0 = insertelement <16 x i32> poison, i32 %Load0, i32 0; // br label %else; //; // else:; // %res.phi.else = phi <16 x i32>[%Res0, %cond.load], [poison, %0]; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.load1, label %else2; //; // cond.load1:; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // %Load1 = load i32, i32* %Ptr1, align 4; // %Res1 = insertelement <16 x i32> %res.phi.else, i32 %Load1, i32 1; // br label %else2; // . . .; // %Result = select <16 x i1> %Mask, <16 x i32> %res.phi.select, <16 x i32> %Src; // ret <16 x i32> %Result",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:177,Performance,load,load,177,"// Fill the ""else"" block, created in the previous iteration; //; // %Mask1 = and i16 %scalar_mask, i32 1 << Idx; // %cond = icmp ne i16 %mask_1, 0; // br i1 %Mask1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:15,Availability,mask,masked,15,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:61,Availability,mask,masked,61,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:142,Availability,Mask,Mask,142,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:234,Availability,mask,mask,234,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:352,Availability,Mask,Mask,352,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:648,Availability,Mask,Mask,648,"// Translate a masked scatter intrinsic, like; // void @llvm.masked.scatter.v16i32(<16 x i32> %Src, <16 x i32*>* %Ptrs, i32 4,; // <16 x i1> %Mask); // to a chain of basic blocks, that stores element one-by-one if; // the appropriate mask bit is set.; //; // %Ptrs = getelementptr i32, i32* %ptr, <16 x i64> %ind; // %Mask0 = extractelement <16 x i1> %Mask, i32 0; // br i1 %Mask0, label %cond.store, label %else; //; // cond.store:; // %Elt0 = extractelement <16 x i32> %Src, i32 0; // %Ptr0 = extractelement <16 x i32*> %Ptrs, i32 0; // store i32 %Elt0, i32* %Ptr0, align 4; // br label %else; //; // else:; // %Mask1 = extractelement <16 x i1> %Mask, i32 1; // br i1 %Mask1, label %cond.store1, label %else2; //; // cond.store1:; // %Elt1 = extractelement <16 x i32> %Src, i32 1; // %Ptr1 = extractelement <16 x i32*> %Ptrs, i32 1; // store i32 %Elt1, i32* %Ptr1, align 4; // br label %else2; // . . .",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,"// Shorten the way if the mask is a vector of constants.; // Create a build_vector pattern, with loads/poisons as necessary and then; // shuffle blend with the pass through value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:97,Performance,load,loads,97,"// Shorten the way if the mask is a vector of constants.; // Create a build_vector pattern, with loads/poisons as necessary and then; // shuffle blend with the pass through value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:187,Availability,mask,mask,187,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:232,Performance,load,load,232,"// Fill the ""else"" block, created in the previous iteration; //; // %res.phi.else3 = phi <16 x i32> [ %11, %cond.load1 ], [ %res.phi.else, %else ]; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.load, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:82,Performance,load,load,82,"// Create ""cond"" block; //; // %EltAddr = getelementptr i32* %1, i32 0; // %Elt = load i32* %EltAddr; // VResult = insertelement <16 x i32> VResult, i32 %Elt, i32 Idx; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:26,Availability,mask,mask,26,// Shorten the way if the mask is a vector of constants.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:10,Availability,mask,mask,10,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:43,Testability,test,test,43,"// If the mask is not v1i1, use scalar bit test operations. This generates; // better results on X86 at least.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:104,Availability,mask,mask,104,"// Fill the ""else"" block, created in the previous iteration; //; // %mask_1 = extractelement <16 x i1> %mask, i32 Idx; // br i1 %mask_1, label %cond.store, label %else; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:50,Performance,scalab,scalable,50,// The scalarization code below does not work for scalable vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:32,Availability,mask,masked,32,// Scalarize unsupported vector masked load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp:39,Performance,load,load,39,// Scalarize unsupported vector masked load,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/ScalarizeMaskedMemIntrin.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:521,Performance,optimiz,optimization,521,"//===- Scalarizer.cpp - Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass converts vector operations into scalar operations (or, optionally,; // operations on smaller vector widths), in order to expose optimization; // opportunities on the individual scalar operations.; // It is mainly intended for targets that do not have vector units, but it; // may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:514,Security,expose,expose,514,"//===- Scalarizer.cpp - Scalarize vector operations -----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass converts vector operations into scalar operations (or, optionally,; // operations on smaller vector widths), in order to expose optimization; // opportunities on the individual scalar operations.; // It is mainly intended for targets that do not have vector units, but it; // may also be useful for revectorizing code to different vector widths.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:55,Performance,load,loads,55,// This is disabled by default because having separate loads and stores; // makes it more likely that the -combiner-alias-analysis limits will be; // reached.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:191,Performance,load,load,191,"// Used to map a vector Value and associated type to its scattered form.; // The associated type is only non-null for pointer values that are ""scattered""; // when used as pointer operands to load or store.; //; // We use std::map because we want iterators to persist across insertion and; // because the values are relatively large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:39,Integrability,interface,interface,39,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:60,Security,access,accessing,60,// Provides a very limited vector-like interface for lazily accessing one; // component of a scattered vector or vector pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:104,Performance,Cache,Cache,104,"// Scatter V into Size components. If new instructions are needed,; // insert them before BBI in BB. If Cache is nonnull, use it to cache; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:132,Performance,cache,cache,132,"// Scatter V into Size components. If new instructions are needed,; // insert them before BBI in BB. If Cache is nonnull, use it to cache; // the results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:23,Performance,load,load,23,// Information about a load or store that we're scalarizing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:29,Availability,mask,masks,29,// Prepare the shufflevector masks once and re-use them for all; // fragments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:107,Performance,cache,cache,107,// Search through a chain of InsertElementInsts looking for element Frag.; // Record other elements in the cache. The new V is still suitable; // for all uncached indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:8,Performance,cache,cache,8,// Only cache the first entry we find for each index we're not actively; // searching for. This prevents us from going too far up the chain and; // caching incorrect entries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:44,Security,access,accessed,44,// Return a scattered form of V that can be accessed by Point. V must be a; // vector or a pointer to a vector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:54,Modifiability,rewrite,rewrite,54,"// When scalarizing PHI nodes we might try to examine/rewrite InsertElement; // nodes in predecessors. If those predecessors are unreachable from entry,; // then the IR in those blocks could have unexpected properties resulting in; // infinite loops in Scatterer::operator[]. By simply treating values; // originating from instructions in unreachable blocks as undef we do not; // need to analyse them further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:279,Usability,simpl,simply,279,"// When scalarizing PHI nodes we might try to examine/rewrite InsertElement; // nodes in predecessors. If those predecessors are unreachable from entry,; // then the IR in those blocks could have unexpected properties resulting in; // infinite loops in Scatterer::operator[]. By simply treating values; // originating from instructions in unreachable blocks as undef we do not; // need to analyse them further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:168,Safety,avoid,avoid,168,"// Replace Op with the gathered form of the components in CV. Defer the; // deletion of Op and creation of the gathered form to the end of the pass,; // so that we can avoid creating the gathered form if all uses of Op are; // replaced with uses of CV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:24,Safety,safe,safe,24,// Return true if it is safe to transfer the given metadata tag from; // vector to scalar instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:80,Safety,safe,safe,80,// Transfer metadata from Op to the instructions in CV if it is known; // to be safe to do so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:3,Performance,Perform,Perform,3,"// Perform actual scalarization, taking care to preserve any scalar operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:17,Modifiability,variab,variable,17,// Never split a variable insertelement that isn't fully scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp:17,Modifiability,variab,variable,17,// Never split a variable extractelement that isn't fully scalarized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Scalarizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1570,Energy Efficiency,reduce,reduce,1570,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3262,Integrability,depend,depending,3262,"example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportuni",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:507,Modifiability,variab,variable,507,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:708,Performance,load,load,708,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:740,Performance,load,load,740,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:772,Performance,load,load,772,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:808,Performance,load,load,808,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1299,Performance,load,load,1299,"//===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load ba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1330,Performance,load,loads,1330,"//===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load ba",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1604,Performance,optimiz,optimization,1604,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2169,Performance,load,loads,2169," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2240,Performance,load,load,2240," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2288,Performance,load,load,2288," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2323,Performance,load,load,2323," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:2499,Performance,load,loads,2499," similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias ana",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3498,Performance,optimiz,optimization,3498,". For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3692,Performance,load,load,3692,"ant PTX uses much fewer registers.; //; // mov.u32 %r1, %tid.x;; // mov.u32 %r2, %tid.y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3790,Performance,load,load,3790,"8;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6]; // so far the same as unoptimized PTX; // ld.global.f32 %f2, [%rl6+4]; // much better; // ld.global.f32 %f3, [%rl6+128]; // much better; // ld.global.f32 %f4, [%rl6+132]; // much better; //; // Another improvement enabled by the LowerGEP flag is to lower a GEP with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4388,Performance,load,load,4388,"P with; // multiple indices to either multiple GEPs with a single index or arithmetic; // operations (depending on whether the target uses alias analysis in codegen).; // Such transformation can have following benefits:; // (1) It can always extract constants in the indices of structure type.; // (2) After such Lowering, there are more optimization opportunities such as; // CSE, LICM and CGP.; //; // E.g. The following GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i6",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4738,Performance,load,load,4738,"owing GEPs have multiple indices:; // BB1:; // %p = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 3; // load %p; // ...; // BB2:; // %p2 = getelementptr [10 x %struct]* %ptr, i64 %i, i64 %j1, i32 2; // load %p2; // ...; //; // We can not do CSE to the common part related to index ""i64 %i"". Lowering; // GEPs can achieve such goals.; // If the target does not use alias analysis in codegen, this pass will; // lower a GEP with multiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5266,Performance,load,load,5266,"ultiple indices into arithmetic operations:; // BB1:; // %1 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = add i64 %1, %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = add i64 %3, %4; // %6 = add i64 %3, struct_field_3 ; Constant offset; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink addres",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:5653,Performance,load,load,5653,"set; // %p = inttoptr i64 %6 to i32*; // load %p; // ...; // BB2:; // %7 = ptrtoint [10 x %struct]* %ptr to i64 ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = add i64 %7, %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = add i64 %9, %10; // %12 = add i64 %11, struct_field_2 ; Constant offset; // %p = inttoptr i64 %12 to i32*; // load %p2; // ...; //; // If the target uses alias analysis in codegen, this pass will lower a GEP; // with multiple indices into multiple GEPs with a single index:; // BB1:; // %1 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %2 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %3 = getelementptr i8* %1, i64 %2 ; CSE opportunity; // %4 = mul i64 %j1, length_of_struct; // %5 = getelementptr i8* %3, i64 %4; // %6 = getelementptr i8* %5, struct_field_3 ; Constant offset; // %p = bitcast i8* %6 to i32*; // load %p; // ...; // BB2:; // %7 = bitcast [10 x %struct]* %ptr to i8* ; CSE opportunity; // %8 = mul i64 %i, length_of_10xstruct ; CSE opportunity; // %9 = getelementptr i8* %7, i64 %8 ; CSE opportunity; // %10 = mul i64 %j2, length_of_struct; // %11 = getelementptr i8* %9, i64 %10; // %12 = getelementptr i8* %11, struct_field_2 ; Constant offset; // %p2 = bitcast i8* %12 to i32*; // load %p2; // ...; //; // Lowering GEPs can also benefit other passes such as LICM and CGP.; // LICM (Loop Invariant Code Motion) can not hoist/sink a GEP of multiple; // indices if one of the index is variant. If we lower such GEP into invariant; // parts and variant parts, LICM can hoist/sink those invariant parts.; // CGP (CodeGen Prepare) tries to sink address calculations that match the; // target's addressing modes. A GEP with multiple indices may not match and will; // not be sunk. If we lower such GEP into smaller parts, CGP may sink some of; // them. So we end up with a better addressing mode.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:853,Safety,redund,redundancy,853,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:437,Security,access,accesses,437,"//===- SeparateConstOffsetFromGEP.cpp -------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Loop unrolling may create many similar GEPs for array accesses.; // e.g., a 2-level loop; //; // float a[32][32]; // global variable; //; // for (int i = 0; i < 2; ++i) {; // for (int j = 0; j < 2; ++j) {; // ...; // ... = a[x + i][y + j];; // ...; // }; // }; //; // will probably be unrolled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely fo",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:1744,Usability,simpl,simple,1744,"olled to:; //; // gep %a, 0, %x, %y; load; // gep %a, 0, %x, %y + 1; load; // gep %a, 0, %x + 1, %y; load; // gep %a, 0, %x + 1, %y + 1; load; //; // LLVM's GVN does not use partial redundancy elimination yet, and is thus; // unable to reuse (gep %a, 0, %x, %y). As a result, this misoptimization incurs; // significant slowdown in targets with limited addressing modes. For instance,; // because the PTX target does not support the reg+reg addressing mode, the; // NVPTX backend emits PTX code that literally computes the pointer address of; // each GEP, wasting tons of registers. It emits the following PTX for the; // first load and similar PTX for other loads.; //; // mov.u32 %r1, %x;; // mov.u32 %r2, %y;; // mul.wide.u32 %rl2, %r1, 128;; // mov.u64 %rl3, a;; // add.s64 %rl4, %rl3, %rl2;; // mul.wide.u32 %rl5, %r2, 4;; // add.s64 %rl6, %rl4, %rl5;; // ld.global.f32 %f1, [%rl6];; //; // To reduce the register pressure, the optimization implemented in this file; // merges the common part of a group of GEPs, so we can compute each pointer; // address by adding a simple offset to the common part, saving many registers.; //; // It works by splitting each GEP into a variadic base and a constant offset.; // The variadic base can be computed once and reused by multiple GEPs, and the; // constant offsets can be nicely folded into the reg+immediate addressing mode; // (supported by most targets) without using any extra register.; //; // For instance, we transform the four GEPs and four loads in the above example; // into:; //; // base = gep a, 0, x, y; // load base; // laod base + 1 * sizeof(float); // load base + 32 * sizeof(float); // load base + 33 * sizeof(float); //; // Given the transformed IR, a backend that supports the reg+immediate; // addressing mode can easily fold the pointer arithmetics into the loads. For; // example, the NVPTX backend can easily fold the pointer arithmetics into the; // ld.global.f32 instructions, and the resultant PTX uses much fewer registers.;",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:142,Testability,test,tests,142,"// Setting this flag may emit false positives when the input module already; // contains dead instructions. Therefore, we set it only in unit tests that are; // free of dead code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:829,Performance,optimiz,optimized,829,"/// A helper class for separating a constant offset from a GEP index.; ///; /// In real programs, a GEP index may be more complicated than a simple addition; /// of something and a constant integer which can be trivially splitted. For; /// example, to split ((a << 3) | 5) + b, we need to search deeper for the; /// constant offset, so that we can separate the index to (a << 3) + b and 5.; ///; /// Therefore, this class looks into the expression that computes a given GEP; /// index, and tries to find a constant integer that can be hoisted to the; /// outermost level of the expression as an addition. Not every constant in an; /// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +; /// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,; /// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:141,Usability,simpl,simple,141,"/// A helper class for separating a constant offset from a GEP index.; ///; /// In real programs, a GEP index may be more complicated than a simple addition; /// of something and a constant integer which can be trivially splitted. For; /// example, to split ((a << 3) | 5) + b, we need to search deeper for the; /// constant offset, so that we can separate the index to (a << 3) + b and 5.; ///; /// Therefore, this class looks into the expression that computes a given GEP; /// index, and tries to find a constant integer that can be hoisted to the; /// outermost level of the expression as an addition. Not every constant in an; /// expression can jump out. e.g., we cannot transform (b * (a + 5)) to (b * a +; /// 5); nor can we transform (3 * (a + 5)) to (3 * a + 5), however in this case,; /// -instcombine probably already optimized (3 * (a + 5)) to (3 * a + 15).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:175,Deployability,update,update,175,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:340,Modifiability,extend,extended,340,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:434,Modifiability,extend,extended,434,"/// Searches the expression that computes V for a non-zero constant C s.t.; /// V can be reassociated into the form V' + C. If the searching is; /// successful, returns C and update UserChain as a def-use chain from C to V;; /// otherwise, UserChain is empty.; ///; /// \p V The given expression; /// \p SignExtended Whether V will be sign-extended in the computation of the; /// GEP index; /// \p ZeroExtended Whether V will be zero-extended in the computation of the; /// GEP index; /// \p NonNegative Whether V is guaranteed to be non-negative. For example,; /// an index of an inbounds GEP is guaranteed to be; /// non-negative. Levaraging this, we can better split; /// inbounds GEPs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:294,Deployability,update,updates,294,"/// After the first step of rebuilding the GEP index without the constant; /// offset, distribute s/zext to the operands of all operators in UserChain.; /// e.g., zext(sext(a + (b + 5)) (assuming no overflow) =>; /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5))).; ///; /// The function also updates UserChain to point to new subexpressions after; /// distributing s/zext. e.g., the old UserChain of the above example is; /// 5 -> b + 5 -> a + (b + 5) -> sext(...) -> zext(sext(...)),; /// and the new UserChain is; /// zext(sext(5)) -> zext(sext(b)) + zext(sext(5)) ->; /// zext(sext(a)) + (zext(sext(b)) + zext(sext(5)); ///; /// \p ChainIndex The index to UserChain. ChainIndex is initially; /// UserChain.size() - 1, and is decremented during; /// the recursion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:353,Modifiability,extend,extends,353,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:89,Testability,log,logic,89,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:76,Usability,simpl,simplify,76,"/// Canonicalize array indices to pointer-size integers. This helps to; /// simplify the logic of splitting a GEP. For example, if a + b is a; /// pointer-size integer, we have; /// gep base, a + b = gep (gep base, a), b; /// However, this equality may not hold if the size of a + b is smaller than; /// the pointer size, because LLVM conceptually sign-extends GEP indices to; /// pointer size before computing the address; /// (http://llvm.org/docs/LangRef.html#id181).; ///; /// This canonicalization is very likely already done in clang and; /// instcombine. Therefore, the program will probably remain the same.; ///; /// Returns true if the module changes.; ///; /// Verified in @i32_add in split-gep.ll",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:4,Performance,Optimiz,Optimize,4,"/// Optimize sext(a)+sext(b) to sext(a+b) when a+b can't sign overflow.; /// SeparateConstOffsetFromGEP distributes a sext to leaves before extracting; /// the constant offset. After extraction, it becomes desirable to reunion the; /// distributed sexts. For example,; ///; /// &a[sext(i +nsw (j +nsw 5)]; /// => distribute &a[sext(i) +nsw (sext(j) +nsw 5)]; /// => constant extraction &a[sext(i) + sext(j)] + 5; /// => reunion &a[sext(i +nsw j)] + 5",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:18,Safety,safe,safe,18,// Check if it is safe to swap operand of two GEP.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:198,Testability,test,tests,198,"// Do not trace into ""or"" unless it is equivalent to ""add"". If LHS and RHS; // don't have common bits, (LHS | RHS) is equivalent to (LHS + RHS).; // FIXME: this does not appear to be covered by any tests; // (with x86/aarch64 backends at least)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:90,Modifiability,extend,extended,90,"// FIXME: We don't currently support constants from the RHS of subs,; // when we are zero-extended, because we need a way to zero-extended; // them before they are negated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:130,Modifiability,extend,extended,130,"// FIXME: We don't currently support constants from the RHS of subs,; // when we are zero-extended, because we need a way to zero-extended; // them before they are negated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:91,Usability,Clear,Clear,91,// BO being non-negative does not shed light on whether its operands are; // non-negative. Clear the NonNegative flag here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:341,Performance,optimiz,optimizations,341,"// If we found a constant offset in the left operand, stop and return that.; // This shortcut might cause us to miss opportunities of combining the; // constant offsets in both operands, e.g., (a + 4) + (b + 5) => (a + b) + 9.; // However, such cases are probably already handled by -instcombine,; // given this pass runs after the standard optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:204,Testability,benchmark,benchmarks,204,"// TODO(jingyue): We could trace into integer/pointer casts, such as; // inttoptr, ptrtoint, bitcast, and addrspacecast. We choose to handle only; // integers because it gives good enough results for our benchmarks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:9,Performance,optimiz,optimization,9,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:30,Usability,clear,clear,30,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:143,Usability,Clear,Clear,143,"// As an optimization, we can clear the SignExtended flag because; // sext(zext(a)) = zext(a). Verified in @sext_zext in split-gep.ll.; //; // Clear the NonNegative flag, because zext(a) >= 0 does not imply a >= 0.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:156,Performance,optimiz,optimization,156,"// If we found a non-zero constant offset, add it to the path for; // rebuildWithoutConstOffset. Zero is a valid constant offset, but doesn't; // help this optimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:56,Usability,simpl,simplify,56,"// If NextInChain is 0 and not the LHS of a sub, we can simplify the; // sub-expression to be just TheOther.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:23,Performance,scalab,scalable,23,// Constant offsets of scalable types are not really constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:363,Modifiability,variab,variable,363,"// If LowerGEP is disabled, before really splitting the GEP, check whether the; // backend supports the addressing mode we are about to produce. If no, this; // splitting probably won't be beneficial.; // If LowerGEP is enabled, even the extracted constant offset can not match; // the addressing mode, we can still do optimizations to other lowered parts; // of variable indices. Therefore, we don't check for addressing modes in that; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:319,Performance,optimiz,optimizations,319,"// If LowerGEP is disabled, before really splitting the GEP, check whether the; // backend supports the addressing mode we are about to produce. If no, this; // splitting probably won't be beneficial.; // If LowerGEP is enabled, even the extracted constant offset can not match; // the addressing mode, we can still do optimizations to other lowered parts; // of variable indices. Therefore, we don't check for addressing modes in that; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:23,Performance,scalab,scalable,23,// Constant offsets of scalable types are not really constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:537,Integrability,wrap,wrapping,537,"// Clear the inbounds attribute because the new index may be off-bound.; // e.g.,; //; // b = add i64 a, 5; // addr = gep inbounds float, float* p, i64 b; //; // is transformed to:; //; // addr2 = gep float, float* p, i64 a ; inbounds removed; // addr = gep inbounds float, float* addr2, i64 5; //; // If a is -4, although the old index b is in bounds, the new index a is; // off-bound. http://llvm.org/docs/LangRef.html#id181 says ""if the; // inbounds keyword is not present, the offsets are added to the base; // address with silently-wrapping two's complement arithmetic"".; // Therefore, the final code will be a semantically equivalent.; //; // TODO(jingyue): do some range analysis to keep as many inbounds as; // possible. GEPs with inbounds are more friendly to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:3,Usability,Clear,Clear,3,"// Clear the inbounds attribute because the new index may be off-bound.; // e.g.,; //; // b = add i64 a, 5; // addr = gep inbounds float, float* p, i64 b; //; // is transformed to:; //; // addr2 = gep float, float* p, i64 a ; inbounds removed; // addr = gep inbounds float, float* addr2, i64 5; //; // If a is -4, although the old index b is in bounds, the new index a is; // off-bound. http://llvm.org/docs/LangRef.html#id181 says ""if the; // inbounds keyword is not present, the offsets are added to the base; // address with silently-wrapping two's complement arithmetic"".; // Therefore, the final code will be a semantically equivalent.; //; // TODO(jingyue): do some range analysis to keep as many inbounds as; // possible. GEPs with inbounds are more friendly to alias analysis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:213,Safety,safe,safely,213,"// As currently BasicAA does not analyze ptrtoint/inttoptr, do not lower to; // arithmetic operations if the target uses alias analysis in codegen.; // Additionally, pointers that aren't integral (and so can't be safely; // converted to integers) or those whose offset size is different from their; // pointer size (which means that doing integer arithmetic on them could; // affect that data) can't be lowered in this way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:235,Performance,optimiz,optimization,235,"// Because we process the basic blocks in pre-order of the dominator tree, a; // candidate that doesn't dominate the current instruction won't dominate any; // future instruction either. Therefore, we pop it out of the stack. This; // optimization makes the algorithm O(n).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp:95,Performance,optimiz,optimize,95,"// Dom: LHS+RHS; // I: sext(LHS)+sext(RHS); // If Dom can't sign overflow and Dom dominates I, optimize I to sext(Dom).; // TODO: handle zext",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SeparateConstOffsetFromGEP.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:8,Usability,Simpl,SimpleLoopUnswitch,8,"///===- SimpleLoopUnswitch.cpp - Hoist loop-invariant control flow ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:93,Testability,log,logical,93,"// end anonymous namespace.; // Helper to skip (select x, true, false), which matches both a logical AND and; // OR and can confuse code that tries to determine if \p Cond is either a; // logical AND or OR but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:188,Testability,log,logical,188,"// end anonymous namespace.; // Helper to skip (select x, true, false), which matches both a logical AND and; // OR and can confuse code that tries to determine if \p Cond is either a; // logical AND or OR but not both.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:233,Performance,perform,perform,233,/// Collect all of the loop invariant input values transitively used by the; /// homogeneous instruction graph from a given root.; ///; /// This essentially walks from a root recursively through loop variant operands; /// which have perform the same logical operation (AND or OR) and finds all; /// inputs which are loop invariant. For some operations these can be; /// re-associated and unswitched out of the loop entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:250,Testability,log,logical,250,/// Collect all of the loop invariant input values transitively used by the; /// homogeneous instruction graph from a given root.; ///; /// This essentially walks from a root recursively through loop variant operands; /// which have perform the same logical operation (AND or OR) and finds all; /// inputs which are loop invariant. For some operations these can be; /// re-associated and unswitched out of the loop entirely.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:26,Security,access,access,26,// Get the first defining access before the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Security,access,access,19,"// If the defining access is a MemoryPhi, get the incoming; // value for the pre-header as defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:100,Security,access,access,100,"// If the defining access is a MemoryPhi, get the incoming; // value for the pre-header as defining access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the PHI nodes in an unswitched loop exit basic block.; ///; /// Requires that the loop exit and unswitched basic block are the same, and; /// that the exiting block was a unique predecessor of that block. Rewrites the; /// PHI nodes in that block such that what were LCSSA PHI nodes become trivial; /// PHI nodes from the old preheader that now contains the unswitched; /// terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:217,Modifiability,Rewrite,Rewrites,217,"/// Rewrite the PHI nodes in an unswitched loop exit basic block.; ///; /// Requires that the loop exit and unswitched basic block are the same, and; /// that the exiting block was a unique predecessor of that block. Rewrites the; /// PHI nodes in that block such that what were LCSSA PHI nodes become trivial; /// PHI nodes from the old preheader that now contains the unswitched; /// terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Deployability,update,update,61,"// When the loop exit is directly unswitched we just need to update the; // incoming basic block. We loop to handle weird cases with repeated; // incoming blocks, but expect to typically only have one operand here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite the PHI nodes in the loop exit basic block and the split off; /// unswitched block.; ///; /// Because the exit block remains an exit from the loop, this rewrites the; /// LCSSA PHI nodes in it to remove the unswitched edge and introduces PHI; /// nodes into the unswitched basic block to select between the value in the; /// old preheader and the loop exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:165,Modifiability,rewrite,rewrites,165,"/// Rewrite the PHI nodes in the loop exit basic block and the split off; /// unswitched block.; ///; /// Because the exit block remains an exit from the loop, this rewrites the; /// LCSSA PHI nodes in it to remove the unswitched edge and introduces PHI; /// nodes into the unswitched basic block to select between the value in the; /// old preheader and the loop exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:122,Deployability,update,update,122,"// The preheader will need to move with the body of this loop. However,; // because it isn't in this loop we also need to update the primary loop map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:121,Deployability,update,update,121,// Remove this loops blocks from the old parent and every other loop up the; // nest until reaching the new parent. Also update all of these; // no-longer-containing loops to reflect the nesting change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:316,Performance,optimiz,optimize,316,"// We shouldn't need to form dedicated exits because the exit introduced; // here is the (just split by unswitching) preheader. However, after trivial; // unswitching it is possible to get new non-dedicated exits out of parent; // loop so let's conservatively form dedicated exit blocks and figure out; // if we can optimize later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:865,Deployability,update,updated,865,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:81,Integrability,rout,routine,81,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:207,Integrability,rout,routine,207,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:398,Integrability,rout,routine,398,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:501,Integrability,rout,routine,501,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:162,Security,validat,validated,162,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:590,Usability,simpl,simplified,590,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:655,Usability,simpl,simplifies,655,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:800,Usability,simpl,simplifycfg,800,"/// Unswitch a trivial branch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the branch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and one of the successors is a loop exit. This; /// allows us to unswitch without duplicating the loop, making it trivial.; ///; /// If this routine fails to unswitch the branch it returns false.; ///; /// If the branch can be unswitched, this routine splits the preheader and; /// hoists the branch above that split. Preserves loop simplified form; /// (splitting the exit block as necessary). It simplifies the branch within; /// the loop to an unconditional branch but doesn't remove it entirely. Further; /// cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:250,Usability,simpl,simplified,250,"// Now that we have a place to insert the conditional branch, create a place; // to branch to: this is the exit block out of the loop that we are; // unswitching. We need to split this if there are other loop predecessors.; // Because the loop is in simplified form, *any* other predecessor is enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Deployability,update,update,50,"// Temporarily clone the terminator, to make MSSA update cheaper by; // separating ""insert edge"" updates from ""remove edge"" ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:97,Deployability,update,updates,97,"// Temporarily clone the terminator, to make MSSA update cheaper by; // separating ""insert edge"" updates from ""remove edge"" ones.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update the dominator tree with the added edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Availability,avail,available,85,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:32,Deployability,update,updated,32,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Deployability,update,update,61,"// After the dominator tree was updated with the added edge, update MemorySSA; // if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the relevant PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1533,Deployability,update,updated,1533,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:81,Integrability,rout,routine,81,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:207,Integrability,rout,routine,207,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:417,Integrability,rout,routine,417,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:520,Integrability,rout,routine,520,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:162,Security,validat,validated,162,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:851,Usability,simpl,simplified,851,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:917,Usability,simpl,simplifies,917,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1383,Usability,simpl,simplified,1383,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1468,Usability,simpl,simplifycfg,1468,"/// Unswitch a trivial switch if the condition is loop invariant.; ///; /// This routine should only be called when loop code leading to the switch has; /// been validated as trivial (no side effects). This routine checks if the; /// condition is invariant and that at least one of the successors is a loop; /// exit. This allows us to unswitch without duplicating the loop, making it; /// trivial.; ///; /// If this routine fails to unswitch the switch it returns false.; ///; /// If the switch can be unswitched, this routine splits the preheader and; /// copies the switch above that split. If the default case is one of the; /// exiting cases, it copies the non-exiting cases and points them at the new; /// preheader. If the default case is not exiting, it copies the exiting cases; /// and points the default at the preheader. It preserves loop simplified form; /// (splitting the exit blocks as necessary). It simplifies the switch within; /// the loop by removing now-dead cases. If the default case is one of those; /// unswitched, it replaces its destination with a new basic block containing; /// only unreachable. Such basic blocks, while technically loop exits, are not; /// considered for unswitching so this is a stable transform and the same; /// switch will not be revisited. If after unswitching there is only a single; /// in-loop successor, the switch is further simplified to an unconditional; /// branch. Still more cleanup can be done with some simplifycfg like pass.; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Usability,Clear,Clear,3,// Clear out the default destination temporarily to allow accurate; // predecessor lists to be examined below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:161,Deployability,update,update,161,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:196,Integrability,depend,depending,196,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the IR for the unswitched basic blocks. This requires two steps.; // First, we split any exit blocks with remaining in-loop predecessors. Then; // we update the PHIs in one of two ways depending on if there was a split.; // We walk in reverse so that we split in the same order as the cases; // appeared. This is purely for convenience of reading the resulting IR, but; // it doesn't cost anything really.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:144,Energy Efficiency,power,powerful,144,// Handle the default exit if necessary.; // FIXME: It'd be great if we could merge this with the loop below but LLVM's; // ranges aren't quite powerful enough yet.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:64,Deployability,update,update,64,// Note that we must use a reference in the for loop so that we update the; // container.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:65,Deployability,update,update,65,// Grab a reference to the exit block in the pair so that we can update it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:61,Usability,simpl,simply,61,"// If this case is the last edge into the exit block, we can simply reuse it; // as it will no longer be a loop exit. No mapping necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:8,Modifiability,rewrite,rewrite,8,// Only rewrite once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update the case pair to point to the split block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:99,Modifiability,rewrite,rewrite,99,"// If we ended up with a common successor for every path through the switch; // after unswitching, rewrite it to an unconditional branch to make it easy; // to recognize. Otherwise we potentially have to recognize the default case; // pointing at unreachable and other complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:262,Deployability,update,update,262,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,Safety,avoid,avoiding,245,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,Usability,simpl,simple,157,"// Move the last case to the default successor. This is valid as if the; // default got unswitched it cannot be reached. This has the advantage of; // being simple and keeping the number of edges from this switch to; // successors the same, and avoiding any PHI update complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:71,Deployability,update,update,71,"// Walk the unswitched exit blocks and the unswitched split blocks and update; // the dominator tree based on the CFG edits. While we are walking unordered; // containers here, the API for applyUpdates takes an unordered list of; // updates and requires them to not contain duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:233,Deployability,update,updates,233,"// Walk the unswitched exit blocks and the unswitched split blocks and update; // the dominator tree based on the CFG edits. While we are walking unordered; // containers here, the API for applyUpdates takes an unordered list of; // updates and requires them to not contain duplicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:542,Deployability,update,updated,542,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:9,Integrability,rout,routine,9,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:379,Integrability,rout,routine,379,"/// This routine scans the loop to find a branch or switch which occurs before; /// any side effects occur. These can potentially be unswitched without; /// duplicating the loop. If a branch or switch is successfully unswitched the; /// scanning continues to see if subsequent branches or switches have become; /// trivial. Once all trivial candidates have been unswitched, this routine; /// returns.; ///; /// The return value indicates whether anything was unswitched (and therefore; /// changed).; ///; /// If `SE` is not null, it will be updated based on the potential loop SCEVs; /// invalidated by this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:88,Performance,load,loads,88,"// Check if there are any side-effecting instructions (e.g. stores, calls,; // volatile loads) in the part of the loop that the code *would* execute; // without unswitching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:137,Usability,simpl,simplifycfg,137,// Don't bother trying to unswitch past a switch with a constant; // condition. This should be removed prior to running this pass by; // simplifycfg.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:111,Testability,log,logic,111,// If unswitching turned the terminator into an unconditional branch then; // we can continue. The unswitching logic specifically works to fold any; // cases it can into an unconditional branch to make it easier to; // recognize here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:130,Usability,simpl,simplifycfg,130,// Don't bother trying to unswitch past an unconditional branch or a branch; // with a constant value. These should be removed by simplifycfg prior to; // running this pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:902,Deployability,update,updates,902,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1092,Deployability,update,updates,1092,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1125,Deployability,update,update,1125,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:1328,Deployability,update,update,1328,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:277,Integrability,rout,routine,277,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:683,Usability,simpl,simple,683,"/// Build the cloned blocks for an unswitched copy of the given loop.; ///; /// The cloned blocks are inserted before the loop preheader (`LoopPH`) and; /// after the split block (`SplitBB`) that will be used to select between the; /// cloned and original loop.; ///; /// This routine handles cloning all of the necessary loop blocks and exit; /// blocks including rewriting their instructions and the relevant PHI nodes.; /// Any loop blocks or exit blocks which are dominated by a different successor; /// than the one for this clone of the loop blocks can be trivially skipped. We; /// use the `DominatingSucc` map to determine whether a block satisfies that; /// property with a simple map lookup.; ///; /// It also correctly creates the unconditional branch in the cloned; /// unswitched parent block to only point at the unswitched successor.; ///; /// This does not handle most of the necessary updates to `LoopInfo`. Only exit; /// block splitting is correctly reflected in `LoopInfo`, essentially all of; /// the cloned blocks (and their loops) are left without full `LoopInfo`; /// updates. This also doesn't fully update `DominatorTree`. It adds the cloned; /// blocks to them but doesn't create the cloned `DominatorTree` structure and; /// instead the caller must recompute an accurate DT. It *does* correctly; /// update the `AssumptionCache` provided in `AC`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:44,Integrability,wrap,wrap,44,"// We will need to clone a bunch of blocks, wrap up the clone operation in; // a helper.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:211,Safety,safe,safe,211,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:303,Usability,simpl,simplified,303,"// When we are going to clone an exit, we don't need to clone all the; // instructions in the exit block and we want to ensure we have an easy; // place to merge the CFG, so split the exit first. This is always safe to; // do because there cannot be any non-loop predecessors of a loop exit in; // loop simplified form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Testability,test,test,50,// Rearrange the names to make it easier to write test cases by having the; // exit block carry the suffix rather than the merge block carrying the; // suffix.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:171,Availability,avail,available,171,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:269,Deployability,update,update,269,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:291,Performance,cache,cache,291,"// Rewrite the instructions in the cloned blocks to refer to the instructions; // in the cloned blocks. We have to do this as a second pass so that we have; // everything available. Also, we have inserted new instructions which may; // include assume intrinsics, so we update the assumption cache while; // processing this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the cloned successors of the skipped blocks to not; // have spurious incoming values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:11,Usability,Simpl,Simplification,11,// Trivial Simplification. If Terminator is a conditional branch and; // condition becomes dead - erase it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:22,Deployability,update,updates,22,// Record the domtree updates for the new blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:173,Safety,avoid,avoid,173,"// If we have a nest, we can quickly clone the entire loop nest using an; // iterative approach because it is a tree. We keep the cloned parent in the; // data structure to avoid repeatedly querying through a map to find it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:95,Usability,simpl,simplifies,95,"/// Build the cloned loops of an original loop from unswitching.; ///; /// Because unswitching simplifies the CFG of the loop, this isn't a trivial; /// operation. We need to re-verify that there even is a loop (as the backedge; /// may not have been cloned), and even if there are remaining backedges the; /// backedge set may be different. However, we know that each child loop is; /// undisturbed, we only need to find where to place each child loop within; /// either any parent loop or within a cloned version of the original loop.; ///; /// Because child loops may end up cloned outside of any cloned version of the; /// original loop, multiple cloned sibling loops may be created. All of them; /// are returned so that the newly introduced loop nest roots can be; /// identified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:108,Usability,simpl,simplified,108,// The only possible non-loop header predecessor is the preheader because; // we know we cloned the loop in simplified form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:27,Usability,simpl,simplified,27,"// Because the loop was in simplified form, the only non-loop predecessor; // should be the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:225,Testability,log,logic,225,"// We don't want to just add the cloned loop blocks based on how we; // discovered them. The original order of blocks was carefully built in; // a way that doesn't rely on predecessor ordering. Rather than re-invent; // that logic, we just re-walk the original blocks (and those of the child; // loops) and filter them as we add them into the cloned loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:90,Deployability,update,update,90,"// If this pred has already been moved to our set or is part of some; // (inner) loop, no update needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:57,Usability,clear,clear,57,// Now delete the dead child loops. This raw delete will clear them; // recursively.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:50,Deployability,update,updated,50,// Check that the dominator tree has already been updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:27,Usability,simpl,simplified,27,"// Because the loop was in simplified form, the only non-loop predecessor; // is the preheader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:178,Usability,simpl,simplified,178,"// Because we know the inner loop structure remains valid we can use the; // loop structure to jump immediately across the entire nested loop.; // Further, because it is in loop simplified form, we can directly jump; // to its preheader afterward.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:388,Deployability,update,update,388,"/// Rebuild a loop after unswitching removes some subset of blocks and edges.; ///; /// The removal may have removed some child loops entirely but cannot have; /// disturbed any remaining child loops. However, they may need to be hoisted; /// to the parent loop (or to be top-level loops). The original loop may be; /// completely removed.; ///; /// The sibling loops resulting from this update are returned. If the original; /// loop remains a valid loop, it will be the first entry in this list with all; /// of the newly sibling loops following it.; ///; /// Returns true if the loop remains a loop after unswitching, and false if it; /// is no longer a loop after unswitching (and should not continue to be; /// referenced).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:10,Deployability,update,update,10,// Now we update all the blocks which are no longer within the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:90,Deployability,update,update,90,"// If this pred has already been moved to our set or is part of some; // (inner) loop, no update needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:104,Deployability,update,update,104,// If blocks in this exit loop were directly part of the original loop (as; // opposed to a child loop) update the map to point to this exit loop. This; // just updates a map and so the fact that the order is unstable is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:161,Deployability,update,updates,161,// If blocks in this exit loop were directly part of the original loop (as; // opposed to a child loop) update the map to point to this exit loop. This; // just updates a map and so the fact that the order is unstable is fine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:158,Deployability,update,update,158,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:203,Deployability,update,update,203,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:210,Energy Efficiency,efficient,efficient,210,// Sink all the child loops whose headers are no longer in the loop set to; // the parent (or to be top level loops). We reach into the loop and directly; // update its subloop vector to make this batch update efficient.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:474,Usability,simpl,simplified,474,// To compute the new parent of this hoisted loop we look at where we; // placed the preheader above. We can't lookup the header itself because we; // retained the mapping from the header to the hoisted loop. But the; // preheader and header should have the exact same new parent computed; // based on the set of exit blocks from the original loop as the preheader; // is a predecessor of the header and so reached in the reverse walk. And; // because the loops were all in simplified form the preheader of the; // hoisted loop can't be part of some *other* loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:49,Safety,avoid,avoid,49,"// Mark the new loop as partially unswitched, to avoid unswitching on; // the same condition again.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Integrability,inject,injection,19,// Do the same for injection of invariant conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Security,inject,injection,19,// Do the same for injection of invariant conditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:35,Modifiability,variab,variable,35,// Save the current loop name in a variable so that we can report it even; // after it has been deleted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:155,Integrability,rout,routine,155,// The branch should be in this exact loop. Any inner loop's invariant branch; // should be handled by unswitching that inner loop. The caller of this; // routine should filter out any candidates that remain (but were skipped for; // whatever reason).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:36,Deployability,update,update,36,"// Get blocks in RPO order for MSSA update, before changing the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:160,Deployability,update,update,160,"// Compute the outer-most loop containing one of our exit blocks. This is the; // furthest up our loopnest which can be mutated, which we will use below to; // update things.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Performance,cache,cached,85,"// At this point, we're definitely going to unswitch something so invalidate; // any cached information in ScalarEvolution for the outer most loop; // containing an exit block and all nested loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:320,Energy Efficiency,reduce,reduce,320,"// If the edge from this terminator to a successor dominates that successor,; // store a map from each block in its dominator subtree to it. This lets us; // tell when cloning for a particular successor if a block is dominated by; // some *other* successor with a single data structure. We use this to; // significantly reduce cloning.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:56,Safety,safe,safe,56,"// Split the preheader, so that we know that there is a safe place to insert; // the conditional branch. We will change the preheader to have a conditional; // branch on LoopCond. The original preheader will become the split point; // between the unswitched versions, and we will have a new preheader for the; // original loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:36,Deployability,update,updates,36,// Keep track of the dominator tree updates needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Integrability,depend,depends,52,// The stitching of the branched code back together depends on whether we're; // doing full unswitching or not with the exception that we always want to; // nuke the initial terminator placed in the split block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Modifiability,rewrite,rewrite,52,// Splice the terminator from the original loop and rewrite its; // successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:43,Deployability,update,updates,43,// Keep a clone of the terminator for MSSA updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:31,Deployability,update,update,31,// Walk the cases and directly update their successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:46,Deployability,update,updates,46,// We need to use the set to populate domtree updates as even when there; // are multiple cases pointing at the same successor we only want to; // remove and insert one edge in the domtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:91,Safety,avoid,avoid,91,"// Remove all but one edge to the retained block and all unswitched; // blocks. This is to avoid having duplicate entries in the cloned Phis,; // when we know we only keep a single edge for each case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:117,Usability,simpl,simpler,117,// Now unhook the successor relationship as we'll be replacing; // the terminator with a direct branch. This is much simpler for branches; // than switches so we handle those first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:46,Deployability,update,updates,46,// We need to use the set to populate domtree updates as even when there; // are multiple cases pointing at the same successor we only want to; // remove and insert one edge in the domtree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:15,Deployability,update,update,15,"// After MSSAU update, remove the cloned terminator instruction NewTI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:24,Deployability,update,updates,24,// Perform MSSA cloning updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Performance,Perform,Perform,3,// Perform MSSA cloning updates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:13,Deployability,update,updates,13,// Apply the updates accumulated above to get an up-to-date dominator tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:122,Usability,simpl,simplified,122,// Build the cloned loop structure itself. This may be substantially; // different from the original structure due to the simplified CFG. This also; // handles inserting all the cloned blocks into the correct loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:53,Deployability,update,update,53,"// Now that our cloned loops have been built, we can update the original loop.; // First we delete the dead blocks from it and then we rebuild the loop; // structure taking these deletions into account.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:157,Availability,error,errors,157,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:34,Safety,risk,risk,34,"// This transformation has a high risk of corrupting the dominator tree, and; // the below steps to rebuild loop structures will result in hard to debug; // errors in that case so verify that the dominator tree is sane first.; // FIXME: Remove this when the bugs stop showing up and rely on existing; // verification steps.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:228,Deployability,update,updated,228,// If we unswitched a branch which collapses the condition to a known; // constant we want to replace all the uses of the invariants within both; // the original and cloned blocks. We do this here so that we can use the; // now updated dominator tree to identify which side the users are on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:541,Deployability,update,update,541,"// We can change which blocks are exit blocks of all the cloned sibling; // loops, the current loop, and any parent loops which shared exit blocks; // with the current loop. As a consequence, we need to re-form LCSSA for; // them. But we shouldn't need to re-form LCSSA for any child loops.; // FIXME: This could be made more efficient by tracking which exit blocks are; // new, and focusing on them, but that isn't likely to be necessary.; //; // In order to reasonably rebuild LCSSA we need to walk inside-out across the; // loop nest and update every loop that could have had its exits changed. We; // also need to cover any intervening loops. We add all of these loops to; // a list and sort them by loop depth to achieve this without updating; // unnecessary loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:326,Energy Efficiency,efficient,efficient,326,"// We can change which blocks are exit blocks of all the cloned sibling; // loops, the current loop, and any parent loops which shared exit blocks; // with the current loop. As a consequence, we need to re-form LCSSA for; // them. But we shouldn't need to re-form LCSSA for any child loops.; // FIXME: This could be made more efficient by tracking which exit blocks are; // new, and focusing on them, but that isn't likely to be necessary.; //; // In order to reasonably rebuild LCSSA we need to walk inside-out across the; // loop nest and update every loop that could have had its exits changed. We; // also need to cover any intervening loops. We add all of these loops to; // a list and sort them by loop depth to achieve this without updating; // unnecessary loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:65,Deployability,update,update,65,"// For non-child cloned loops and hoisted loops, we just need to update LCSSA; // and we can do it in any order as they don't nest relative to each other.; //; // Also check if any of the loops we have updated have become top-level loops; // as that will necessitate widening the outer loop scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:202,Deployability,update,updated,202,"// For non-child cloned loops and hoisted loops, we just need to update LCSSA; // and we can do it in any order as they don't nest relative to each other.; //; // Also check if any of the loops we have updated have become top-level loops; // as that will necessitate widening the outer loop scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:105,Deployability,update,update,105,"// If the original loop had exit blocks, walk up through the outer most loop; // of those exit blocks to update LCSSA and form updated dedicated exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:127,Deployability,update,updated,127,"// If the original loop had exit blocks, walk up through the outer most loop; // of those exit blocks to update LCSSA and form updated dedicated exits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:59,Deployability,update,updates,59,// Verify the entire loop structure to catch any incorrect updates before we; // progress in the pass pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:102,Deployability,pipeline,pipeline,102,// Verify the entire loop structure to catch any incorrect updates before we; // progress in the pass pipeline.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:121,Deployability,update,updated,121,"// Now that we've unswitched something, make callbacks to report the changes.; // For that we need to merge together the updated loops and the cloned loops; // and check whether the original loop survived.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:64,Deployability,update,update,64,"// If not, we have to compute it. We can't use insert above and update; // because computing the cost may insert more things into the map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:477,Deployability,update,updates,477,"/// Turns a select instruction into implicit control flow branch,; /// making the following replacement:; ///; /// head:; /// --code before select--; /// select %cond, %trueval, %falseval; /// --code after select--; ///; /// into; ///; /// head:; /// --code before select--; /// br i1 %cond, label %then, label %tail; ///; /// then:; /// br %tail; ///; /// tail:; /// phi [ %trueval, %then ], [ %falseval, %head]; /// unreachable; ///; /// It also makes all relevant DT and LI updates, so that all structures are in; /// valid state after this transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:546,Deployability,update,updates,546,"/// Turns a llvm.experimental.guard intrinsic into implicit control flow branch,; /// making the following replacement:; ///; /// --code before guard--; /// call void (i1, ...) @llvm.experimental.guard(i1 %cond) [ ""deopt""() ]; /// --code after guard--; ///; /// into; ///; /// --code before guard--; /// br i1 %cond, label %guarded, label %deopt; ///; /// guarded:; /// --code after guard--; ///; /// deopt:; /// call void (i1, ...) @llvm.experimental.guard(i1 false) [ ""deopt""() ]; /// unreachable; ///; /// It also makes all relevant DT and LI updates, so that all structures are in; /// valid state after this transform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:166,Availability,avail,available,166,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:543,Safety,predict,prediction,543,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:677,Safety,predict,predictions,677,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:376,Usability,simpl,simple,376,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:458,Usability,simpl,simple,458,"/// Cost multiplier is a way to limit potentially exponential behavior; /// of loop-unswitch. Cost is multipied in proportion of 2^number of unswitch; /// candidates available. Also accounting for the number of ""sibling"" loops with; /// the idea to account for previous unswitches that already happened on this; /// cluster of loops. There was an attempt to keep this formula simple,; /// just enough to limit the worst case behavior. Even if it is not that simple; /// now it is still not an attempt to provide a detailed heuristic size; /// prediction.; ///; /// TODO: Make a proper accounting of ""explosion"" effect for all kinds of; /// unswitch candidates, making adequate predictions instead of wild guesses.; /// That requires knowing not just the number of ""remaining"" candidates but; /// also costs of unswitching for each of these candidates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:97,Energy Efficiency,power,power-of-two,97,"// Ignore up to the ""unscaled candidates"" number of unswitch candidates; // when calculating the power-of-two scaling of the cost. The main idea; // with this control is to allow a small number of unswitches to happen; // and rely more on siblings multiplier (see below) when the number; // of candidates is small.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:38,Testability,log,logical,38,// Do not unswitch vector selects and logical and/or selects,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:183,Integrability,inject,injected,183,"/// Tries to canonicalize condition described by:; ///; /// br (LHS pred RHS), label IfTrue, label IfFalse; ///; /// into its equivalent where `Pred` is something that we support for injected; /// invariants (so far it is limited to ult), LHS in canonicalized form is; /// non-invariant and RHS is an invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:183,Security,inject,injected,183,"/// Tries to canonicalize condition described by:; ///; /// br (LHS pred RHS), label IfTrue, label IfFalse; ///; /// into its equivalent where `Pred` is something that we support for injected; /// invariants (so far it is limited to ult), LHS in canonicalized form is; /// non-invariant and RHS is an invariant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:150,Integrability,inject,injecting,150,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:132,Performance,optimiz,optimized,132,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:150,Security,inject,injecting,150,"/// Returns true, if predicate described by ( \p Pred, \p LHS, \p RHS ); /// succeeding into blocks ( \p IfTrue, \p IfFalse) can be optimized by; /// injecting a loop-invariant condition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:57,Deployability,update,updates,57,"// FIXME: For some reason this causes problems with MSSA updates, need to; // investigate why. So far, just don't unswitch latch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:98,Integrability,inject,injection,98,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:52,Performance,optimiz,optimize,52,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:98,Security,inject,injection,98,"/// Returns true, if metadata on \p BI allows us to optimize branching into \p; /// TakenSucc via injection of invariant conditions. The branch should be not; /// enough and not previously unswitched, the information about this comes from; /// the metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Integrability,inject,injected,85,"/// Materialize pending invariant condition of the given candidate into IR. The; /// injected loop-invariant condition implies the original loop-variant branch; /// condition, so the materialization turns; ///; /// loop_block:; /// ...; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; ///; /// into; ///; /// preheader:; /// %invariant_cond = LHS pred RHS; /// ...; /// loop_block:; /// br i1 %invariant_cond, label InLoopSucc, label OriginalCheck; /// OriginalCheck:; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; /// ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Security,inject,injected,85,"/// Materialize pending invariant condition of the given candidate into IR. The; /// injected loop-invariant condition implies the original loop-variant branch; /// condition, so the materialization turns; ///; /// loop_block:; /// ...; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; ///; /// into; ///; /// preheader:; /// %invariant_cond = LHS pred RHS; /// ...; /// loop_block:; /// br i1 %invariant_cond, label InLoopSucc, label OriginalCheck; /// OriginalCheck:; /// br i1 %variant_cond, label InLoopSucc, label OutOfLoopSucc; /// ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:112,Performance,optimiz,optimize,112,// Do not use builder here: CreateICmp may simplify this into a constant and; // unswitching will break. Better optimize it away later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:43,Usability,simpl,simplify,43,// Do not use builder here: CreateICmp may simplify this into a constant and; // unswitching will break. Better optimize it away later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,Integrability,inject,injected,176,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:176,Security,inject,injected,176,"// TODO: In fact, cost of unswitching a new invariant candidate is *slightly*; // higher because we have just inserted a new block. Need to think how to; // adjust the cost of injected candidates when it was first computed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:389,Integrability,inject,inject,389,"/// Given chain of loop branch conditions looking like:; /// br (Variant < Invariant1); /// br (Variant < Invariant2); /// br (Variant < Invariant3); /// ...; /// collect set of invariant conditions on which we want to unswitch, which; /// look like:; /// Invariant1 <= Invariant2; /// Invariant2 <= Invariant3; /// ...; /// Though they might not immediately exist in the IR, we can still inject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:389,Security,inject,inject,389,"/// Given chain of loop branch conditions looking like:; /// br (Variant < Invariant1); /// br (Variant < Invariant2); /// br (Variant < Invariant3); /// ...; /// collect set of invariant conditions on which we want to unswitch, which; /// look like:; /// Invariant1 <= Invariant2; /// Invariant2 <= Invariant3; /// ...; /// Though they might not immediately exist in the IR, we can still inject them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,Integrability,inject,injected,128,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:266,Performance,load,load,266,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:128,Security,inject,injected,128,"/// Collect unswitch candidates by invariant conditions that are not immediately; /// present in the loop. However, they can be injected into the code if we; /// decide it's profitable.; /// An example of such conditions is following:; ///; /// for (...) {; /// x = load ...; /// if (! x <u C1) break;; /// if (! x <u C2) break;; /// <do something>; /// }; ///; /// We can unswitch by condition ""C1 <=u C2"". If that is true, then ""x <u C1 <=; /// C2"" automatically implies ""x <u C2"", so we can get rid of one of; /// loop-variant checks in unswitched loop version.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:220,Performance,cache,cache,220,"// Given that unswitching these terminators will require duplicating parts of; // the loop, so we need to be able to model that cost. Compute the ephemeral; // values and set up a data structure to hold per-BB costs. We cache each; // block's cost so that we don't recompute this when considering different; // subsets of the loop for duplication during unswitching.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:245,Safety,safe,safely,245,"// Compute the cost of each block, as well as the total loop cost. Also, bail; // out if we see instructions which are incompatible with loop unswitching; // (convergent, noduplicate, or cross-basic-block tokens).; // FIXME: We might be able to safely handle some of these in non-duplicated; // regions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:238,Availability,redundant,redundant,238,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:533,Availability,redundant,redundant,533,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:219,Safety,avoid,avoid,219,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:238,Safety,redund,redundant,238,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:527,Safety,avoid,avoid,527,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:533,Safety,redund,redundant,533,// Now we find the best candidate by searching for the one with the following; // properties in order:; //; // 1) An unswitching cost below the threshold; // 2) The smallest number of duplicated unswitch candidates (to avoid; // creating redundant subsequent unswitching); // 3) The smallest cost after unswitching.; //; // We prioritize reducing fanout of unswitch candidates provided the cost; // remains below the threshold because this has a multiplicative effect.; //; // This requires memoizing each dominator subtree to avoid redundant work.; //; // FIXME: Need to actually do the number of candidates part above.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:464,Deployability,update,updated,464,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:523,Deployability,update,updated,523,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:987,Deployability,update,update,987,"/// Unswitch control flow predicated on loop invariant conditions.; ///; /// This first hoists all branches or switches which are trivial (IE, do not; /// require duplicating any part of the loop) out of the loop body. It then; /// looks at other loop invariant control flows and tries to unswitch those as; /// well by cloning the loop if the result is small enough.; ///; /// The `DT`, `LI`, `AC`, `AA`, `TTI` parameters are required analyses that are; /// also updated based on the unswitch. The `MSSA` analysis is also updated if; /// valid (i.e. its use is enabled).; ///; /// If either `NonTrivial` is true or the flag `EnableNonTrivialUnswitch` is; /// true, we will attempt to do non-trivial unswitching as well as trivial; /// unswitching.; ///; /// The `postUnswitch` function will be run after unswitching is complete; /// with information on whether or not the provided loop remains a loop and; /// a list of new sibling loops created.; ///; /// If `SE` is non-null, we will update that analysis based on the unswitching; /// done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:19,Usability,simpl,simplified,19,// Must be in loop simplified form: we need a preheader and dedicated exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Integrability,Inject,InjectedCondition,2,/*InjectedCondition*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:2,Security,Inject,InjectedCondition,2,/*InjectedCondition*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:404,Availability,avail,available,404,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:102,Modifiability,variab,variable,102,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:155,Testability,test,testing,155,"// Check whether we should continue with non-trivial conditions.; // EnableNonTrivialUnswitch: Global variable that forces non-trivial; // unswitching for testing and debugging.; // NonTrivial: Parameter that enables non-trivial unswitching for this; // invocation of the transform. But this should be allowed only; // for targets without branch divergence.; //; // FIXME: If divergence analysis becomes available to a loop; // transform, we should allow unswitching for non-trivial uniform; // branches even on targets that have divergence.; // https://bugs.llvm.org/show_bug.cgi?id=48819",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:3,Performance,Perform,Perform,3,// Perform legality checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:278,Usability,simpl,simplified,278,"// For non-trivial unswitching, because it often creates new loops, we rely on; // the pass manager to iterate on the loops rather than trying to immediately; // reach a fixed point. There is no substantial advantage to iterating; // internally, and if any of the new loops are simplified enough to contain; // trivial unswitching we want to prefer those.; // Try to unswitch the best invariant condition. We prefer this full unswitch to; // a partial unswitch when possible below the threshold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp:85,Testability,assert,asserts,85,// Historically this pass has had issues with the dominator tree so verify it; // in asserts builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimpleLoopUnswitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:510,Performance,optimiz,optimizations,510,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:7,Usability,Simpl,SimplifyCFGPass,7,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:33,Usability,Simpl,Simplification,33,"//===- SimplifyCFGPass.cpp - CFG Simplification Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements dead code elimination and basic block merging, along; // with a collection of other peephole control flow optimizations. For example:; //; // * Removes basic blocks with no predecessors.; // * Merges a basic block into its predecessor if there is only one and the; // predecessor only has one successor.; // * Eliminates PHI nodes for basic blocks with a single predecessor.; // * Eliminates a basic block that only contains an unconditional branch.; // * Changes invoke instructions to nounwind functions to be calls.; // * Change things like ""if (x) if (y)"" into ""if (x&y)"".; // * etc..; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:45,Modifiability,rewrite,rewrite,45,"// If the canonical terminator has operands, rewrite it to take PHI's.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:89,Modifiability,rewrite,rewrite,89,"// Now, go through each block (with the current terminator type); // we've recorded, and rewrite it to branch to the new common block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:31,Usability,resume,resume,31,// Fow now only support `ret`/`resume` function terminators.; // FIXME: lift this restriction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:9,Usability,Simpl,SimplifyCFG,9,"/// Call SimplifyCFG on all the blocks in the function,; /// iterating until no more changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:180,Performance,optimiz,optimizations,180,"// iterativelySimplifyCFG can (rarely) make some loops dead. If this happens,; // removeUnreachableBlocks is needed to nuke them, which means we should; // iterate between the two optimizations. We structure the code like this to; // avoid rerunning iterativelySimplifyCFG if the second pass of; // removeUnreachableBlocks doesn't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:234,Safety,avoid,avoid,234,"// iterativelySimplifyCFG can (rarely) make some loops dead. If this happens,; // removeUnreachableBlocks is needed to nuke them, which means we should; // iterate between the two optimizations. We structure the code like this to; // avoid rerunning iterativelySimplifyCFG if the second pass of; // removeUnreachableBlocks doesn't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp:10,Integrability,interface,interface,10,// Public interface to the CFGSimplification pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SimplifyCFGPass.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:48,Integrability,depend,dependent,48,// Convergent operations cannot be made control-dependent on additional; // values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:20,Performance,load,load,20,// We cannot sink a load across a critical edge - there may be stores in; // other code paths.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:46,Safety,safe,safe,46,/// SinkInstruction - Determine whether it is safe to sink the specified machine; /// instruction out of its current block into a successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:17,Safety,safe,safe,17,// Check if it's safe to move the instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:245,Availability,down,down,245,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.; // SuccToSinkTo - This is the successor to sink this instruction to, once we; // decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp:393,Availability,down,down,393,"// FIXME: This should include support for sinking instructions within the; // block they are currently in to shorten the live ranges. We often get; // instructions sunk into the top of a large block, but it would be better to; // also sink them down before their first use in the block. This xform has to; // be careful not to *increase* register pressure though, e.g. sinking; // ""x = y + z"" down if it kills y and z would increase the live ranges of y; // and z and only shrink the live range of x.; // SuccToSinkTo - This is the successor to sink this instruction to, once we; // decide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/Sink.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:2123,Deployability,pipeline,pipeline,2123,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:972,Performance,optimiz,optimized,972,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1153,Performance,optimiz,optimization,1153,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:539,Usability,simpl,simple,539,"//===- SpeculativeExecution.cpp ---------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDiverg",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1251,Usability,Simpl,SimplifyCFG,1251,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===---------------------------",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1264,Usability,Simpl,SimplifyCFG,1264,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:1546,Usability,Simpl,SimplifyCFG,1546,"e-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass hoists instructions to enable speculative execution on; // targets where branches are expensive. This is aimed at GPUs. It; // currently works on simple if-then and if-then-else; // patterns.; //; // Removing branches is not the only motivation for this; // pass. E.g. consider this code and assume that there is no; // addressing mode for multiplying by sizeof(*a):; //; // if (b > 0); // c = a[i + 1]; // if (d > 0); // e = a[i + 2]; //; // turns into; //; // p = &a[i + 1];; // if (b > 0); // c = *p;; // q = &a[i + 2];; // if (d > 0); // e = *q;; //; // which could later be optimized to; //; // r = &a[i];; // if (b > 0); // c = r[1];; // if (d > 0); // e = r[2];; //; // Later passes sink back much of the speculated code that did not enable; // further optimization.; //; // This pass is more aggressive than the function SpeculativeyExecuteBB in; // SimplifyCFG. SimplifyCFG will not speculate if no selects are introduced and; // it will speculate at most one instruction. It also will not speculate if; // there is a value defined in the if-block that is only used in the then-block.; // These restrictions make sense since the speculation in SimplifyCFG seems; // aimed at introducing cheap selects, while this pass is intended to do more; // aggressive speculation while counting on later passes to either capitalize on; // that or clean it up.; //; // If the pass was created by calling; // createSpeculativeExecutionIfHasBranchDivergencePass or the; // -spec-exec-only-if-divergent-target option is present, this pass only has an; // effect on targets where TargetTransformInfo::hasBranchDivergence() is true;; // on other targets, it is a nop.; //; // This lets you include this pass unconditionally in the IR pass pipeline, but; // only enable it for relevant targets.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:7,Safety,risk,risk,7,"// The risk that speculation will not pay off increases with the; // number of instructions speculated, so we put a limit on that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:218,Performance,optimiz,optimization,218,// Speculating just a few instructions from a larger block tends not; // to be profitable and this limit prevents that. A reason for that is; // that small basic blocks are more likely to be candidates for; // further optimization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:3,Modifiability,Variab,Variable,3,// Variable preserved purely for correct name printing.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:9,Modifiability,variab,variable,9,// Debug variable has special operand to check it's not hoisted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp:161,Safety,detect,detect,161,// Usially debug label intrinsic corresponds to label in LLVM IR. In these; // cases we should not move it here.; // TODO: Possible special processing needed to detect it is related to a; // hoisted instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SpeculativeExecution.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:980,Performance,perform,performs,980,"//===- SROA.cpp - Scalar Replacement Of Aggregates ------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; /// This transformation implements the well known scalar replacement of; /// aggregates transformation. It tries to identify promotable elements of an; /// aggregate alloca, and promote them to registers. It will also try to; /// convert uses of an element (or set of elements) of an alloca into a vector; /// or bitfield-style integer scalar if appropriate.; ///; /// It works to do this with minimal slicing of the alloca so that regions; /// which are merely transferred in and out of external memory remain unchanged; /// and are not decomposed to scalar code.; ///; /// Because this also performs alloca promotion, it can be thought of as also; /// serving the purpose of SSA formation. The algorithm iterates on the; /// function until all opportunities for promotion have been realized.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Testability,test,test,52,/// Disable running mem2reg during SROA in order to test or debug SROA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,optimiz,optimization,7,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:871,Safety,detect,detect,871,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:488,Security,access,accesses,488,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:552,Security,access,accesses,552,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:588,Security,access,accesses,588,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:891,Security,access,accesses,891,"/// An optimization pass providing Scalar Replacement of Aggregates.; ///; /// This pass takes allocations which can be completely analyzed (that is, they; /// don't escape) and tries to turn them into scalar SSA values. There are; /// a few steps to this process.; ///; /// 1) It takes allocations of aggregates and analyzes the ways in which they; /// are used to try to split them into smaller allocations, ideally of; /// a single scalar data type. It will split up memcpy and memset accesses; /// as necessary and try to isolate individual scalar accesses.; /// 2) It will transform accesses into forms which are suitable for SSA value; /// promotion. This can be replacing a memset with a scalar store of an; /// integer value, or it can involve speculating operations on a PHI or; /// select to be a PHI or select of the results.; /// 3) Finally, this will try to detect a pattern of accesses which map cleanly; /// onto insert and extract operations on a vector value, and convert them to; /// this form. By doing so, it will enable promotion of vector aggregates to; /// SSA vector values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:254,Modifiability,rewrite,rewrite,254,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:39,Usability,simpl,simplify,39,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:173,Usability,simpl,simplify,173,"/// Worklist of alloca instructions to simplify.; ///; /// Each alloca in the function is added to this. Each new alloca formed gets; /// added to it as well to recursively simplify unless that alloca can be; /// directly promoted. Finally, each time we rewrite a use of an alloca other; /// the one being actively rewritten, we add it back onto the list if not; /// already present to ensure it is re-visited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:124,Energy Efficiency,efficient,efficient,124,/// A collection of instructions to delete.; /// We try to batch deletions to simplify code and make things a bit more; /// efficient. We also make sure there is no dangling pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:78,Usability,simpl,simplify,78,/// A collection of instructions to delete.; /// We try to batch deletions to simplify code and make things a bit more; /// efficient. We also make sure there is no dangling pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Usability,clear,clear,291,"/// Post-promotion worklist.; ///; /// Sometimes we discover an alloca which has a high probability of becoming; /// viable for SROA after a round of promotion takes place. In those cases,; /// the alloca is enqueued here for re-processing.; ///; /// Note that we have to be very careful to clear allocas out of this list in; /// the event they are deleted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:231,Performance,queue,queue,231,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:118,Safety,safe,safety,118,/// A worklist of PHIs to speculate prior to promoting allocas.; ///; /// All of these PHIs have been checked for the safety of speculation and by; /// being speculated will allow promoting allocas currently in the promotable; /// queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Modifiability,rewrite,rewrite,41,/// A worklist of select instructions to rewrite prior to promoting; /// allocas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:64,Performance,load,loaded,64,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:96,Performance,load,load,96,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:175,Performance,load,load,175,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:288,Performance,load,load,288,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:329,Performance,load,load,329,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:386,Performance,load,load,386,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:518,Performance,load,loads,518,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:576,Performance,load,loaded,576,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:629,Performance,perform,perform,629,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:718,Performance,load,load,718,"/// Select instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers and then select between the result,; /// allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = select i1 %cond, ptr %Alloca, ptr %Other; /// %V = load <type>, ptr %P2; /// to:; /// %V1 = load <type>, ptr %Alloca -> will be mem2reg'd; /// %V2 = load <type>, ptr %Other; /// %V = select i1 %cond, <type> %V1, <type> %V2; ///; /// We can do this to a select if its only uses are loads; /// and if either the operand to the select can be loaded unconditionally,; /// or if we are allowed to perform CFG modifications.; /// If found an intervening bitcast with a single use of the load,; /// allow the promotion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,variab,variable,60,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:301,Modifiability,variab,variable,301,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Modifiability,variab,variable,365,"// end anonymous namespace; /// Calculate the fragment of a variable to use when slicing a store; /// based on the slice dimensions, existing fragment, and base storage; /// fragment.; /// Results:; /// UseFrag - Use Target as the new fragment.; /// UseNoFrag - The new slice already covers the whole variable.; /// Skip - The new alloca slice doesn't include this variable.; /// FIXME: Can we use calculateFragmentIntersect instead?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:45,Modifiability,variab,variable,45,// If the base storage describes part of the variable apply the offset and; // the size constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:57,Modifiability,variab,variable,57,"// If this slice extracts the entirety of an independent variable from a; // larger alloca, do not produce a fragment expression, as the variable is; // not fragmented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:137,Modifiability,variab,variable,137,"// If this slice extracts the entirety of an independent variable from a; // larger alloca, do not produce a fragment expression, as the variable is; // not fragmented.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Modifiability,variab,variable,52,// Treat the current fragment as covering the whole variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:247,Modifiability,variab,variable,247,/// Find linked dbg.assign and generate a new one with the correct; /// FragmentInfo. Link Inst to the new dbg.assign. If Value is nullptr the; /// value component is copied from the old dbg.assign to the new.; /// \param OldAlloca Alloca for the variable before splitting.; /// \param IsSplit True if the store (not necessarily alloca); /// is being split.; /// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.; /// \param SliceSizeInBits New number of bits being written to.; /// \param OldInst Instruction that is being split.; /// \param Inst New instruction performing this part of the; /// split store.; /// \param Dest Store destination.; /// \param Value Stored value.; /// \param DL Datalayout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:585,Performance,perform,performing,585,/// Find linked dbg.assign and generate a new one with the correct; /// FragmentInfo. Link Inst to the new dbg.assign. If Value is nullptr the; /// value component is copied from the old dbg.assign to the new.; /// \param OldAlloca Alloca for the variable before splitting.; /// \param IsSplit True if the store (not necessarily alloca); /// is being split.; /// \param OldAllocaOffsetInBits Offset of the slice taken from OldAlloca.; /// \param SliceSizeInBits New number of bits being written to.; /// \param OldInst Instruction that is being split.; /// \param Inst New instruction performing this part of the; /// split store.; /// \param Dest Store destination.; /// \param Value Stored value.; /// \param DL Datalayout.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Modifiability,variab,variables,21,/// Map of aggregate variables to their fragment associated with OldAlloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:112,Testability,assert,assert,112,// The new inst needs a DIAssignID unique metadata tag (if OldInst has; // one). It shouldn't already have one: assert this assumption.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite NewFragment to be relative to the existing one (this is; // what createFragmentExpression wants). CalculateFragment has; // already resolved the size for us. FIXME: Should it return the; // relative fragment too?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Deployability,update,updated,12,"// If we've updated the value but the original dbg.assign has an arglist; // then kill it now - we can't use the requested new value.; // We can't replace the DIArgList with the new value as it'd leave; // the DIExpression in an invalid state (DW_OP_LLVM_arg operands without; // an arglist). And we can't keep the DIArgList in case the linked store; // is being split - in which case the DIArgList + expression may no longer; // be computing the correct value.; // This should be a very rare situation as it requires the value being; // stored to differ from the dbg.assign (i.e., the value has been; // represented differently in the debug intrinsic for some reason).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:75,Testability,Assert,Assert,75,"/// A custom IRBuilder inserter which prefixes all names, but only in; /// Assert builds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Deployability,release,release,53,/// Provide a type for IRBuilder that drops names in release builds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether a pointer to the allocation escapes our analysis.; ///; /// If this is true, the slices are never fully built and should be; /// ignored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Security,access,accessor,42,// Forward declare the iterator and range accessor for walking the; // partitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access the dead users for this alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access Uses that should be dropped if the alloca is promotable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Security,Access,Access,4,/// Access the dead operands referring to this alloca.; ///; /// These are operands which have cannot actually be used to refer to the; /// alloca as they are outside its range and the user doesn't correct for; /// that. These mostly consist of PHI node inputs and the like which we just; /// need to replace with undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:52,Integrability,interface,interfaces,52,/// Handle to alloca instruction to simplify method interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:36,Usability,simpl,simplify,36,/// Handle to alloca instruction to simplify method interfaces.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:207,Safety,abort,abort,207,"/// The instruction responsible for this alloca not having a known set; /// of slices.; ///; /// When an instruction (potentially) escapes the pointer to the alloca, we; /// store a pointer to that here and abort trying to form slices of the; /// alloca. This will be null if the alloca slices are analyzed successfully.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:340,Energy Efficiency,allocate,allocated,340,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Modifiability,rewrite,rewrite,46,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:259,Usability,simpl,simply,259,"/// Instructions which will become dead if we rewrite the alloca.; ///; /// Note that these are not separated by slice. This is because we expect an; /// alloca to be completely rewritten or not rewritten at all. If rewritten,; /// all these instructions can simply be removed and replaced with poison as; /// they come from outside of the allocated space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Modifiability,rewrite,rewrite,42,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:161,Modifiability,rewrite,rewrite,161,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:426,Usability,simpl,simplify,426,"/// Operands which will become dead if we rewrite the alloca.; ///; /// These are operands that in their particular use can be replaced with; /// poison when we rewrite the alloca. These show up in out-of-bounds inputs; /// to PHI nodes and the like. They aren't entirely dead (there might be; /// a GEP back into the bounds using it elsewhere) and nor is the PHI, but we; /// want to swap this particular input for poison to simplify the use lists of; /// the alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:239,Security,access,access,239,"/// A partition of the slices.; ///; /// An ephemeral representation for a range of slices which can be viewed as; /// a partition of the alloca. This range represents a span of the alloca's; /// memory which cannot be split, and provides access to all of the slices; /// overlapping some part of the partition.; ///; /// Objects of this type are produced by traversing the alloca's slices, but; /// are only ephemeral and not persistent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether this partition contains no slices, and merely spans; /// a region occupied by split slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:396,Integrability,interface,interface,396,"/// \name Iterate slices that start within the partition.; /// These may be splittable or unsplittable. They have a begin offset >= the; /// partition begin offset.; /// @{; // FIXME: We should probably define a ""concat_iterator"" helper and use that; // to stitch together pointee_iterators over the split tails and the; // contiguous iterators of the partition. That would give a much nicer; // interface here. We could then additionally expose filtered iterators for; // split, unsplit, and unsplittable splices based on the usage patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:439,Security,expose,expose,439,"/// \name Iterate slices that start within the partition.; /// These may be splittable or unsplittable. They have a begin offset >= the; /// partition begin offset.; /// @{; // FIXME: We should probably define a ""concat_iterator"" helper and use that; // to stitch together pointee_iterators over the split tails and the; // contiguous iterators of the partition. That would give a much nicer; // interface here. We could then additionally expose filtered iterators for; // split, unsplit, and unsplittable splices based on the usage patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Integrability,interface,interface,85,/// Most of the state for walking the partitions is held in a class; /// with a nice interface for examining them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Usability,Clear,Clear,3,// Clear out any split uses which have ended.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:45,Usability,clear,cleared,45,"// If P.SI is already at the end, then we've cleared the split tail and; // now have an end iterator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Modifiability,extend,extend,99,"// When we're forming an unsplittable region, it must always start at; // the first slice and will extend through its end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:79,Security,access,accesses,79,"/// A forward range over the partitions of the alloca's slices.; ///; /// This accesses an iterator range over the partitions of the alloca's; /// slices. It computes these partitions on the fly based on the overlapping; /// offsets of the slices and the ability to split them. It will visit ""empty""; /// partitions to cover regions of the alloca only accessed via split; /// slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:352,Security,access,accessed,352,"/// A forward range over the partitions of the alloca's slices.; ///; /// This accesses an iterator range over the partitions of the alloca's; /// slices. It computes these partitions on the fly based on the overlapping; /// offsets of the slices and the ability to split them. It will visit ""empty""; /// partitions to cover regions of the alloca only accessed via split; /// slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:165,Performance,load,load,165,/// Builder for the alloca slices.; ///; /// This class builds a set of alloca slices by recursively visiting the uses; /// of an alloca and making a slice for each load and store at each offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:270,Performance,load,loads,270,"// Clamp the end offset to the end of the allocation. Note that this is; // formulated to handle even the case where ""BeginOffset + Size"" overflows.; // This may appear superficially to be something we could ignore entirely,; // but that is not so! There may be widened loads or PHI-node uses where; // some instructions are dead but not others. We can't completely ignore; // them, and so have to record at least the information here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:435,Availability,avail,available,435,"// FIXME: This is a manually un-factored variant of the basic code inside; // of GEPs with checking of the inbounds invariant specified in the; // langref in a very strict sense. If we ever want to enable; // SROAStrictInbounds, this code should be factored cleanly into; // PtrUseVisitor, but it is easier to experiment with SROAStrictInbounds; // by writing out the code here where we have the underlying allocation; // size readily available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:38,Performance,load,loads,38,"// We allow splitting of non-volatile loads and stores where the type is an; // integer type. These may be used to implement 'memcpy' or other ""transfer; // of bits"" patterns.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:54,Modifiability,extend,extend,54,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:441,Performance,race condition,race conditions,441,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Safety,risk,risk,291,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:18,Security,access,access,18,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:134,Usability,simpl,simply,134,"// If this memory access can be shown to *statically* extend outside the; // bounds of the allocation, it's behavior is undefined, so simply; // ignore it. Note that this is more strict than the generic clamping; // behavior of insertUse. We also try to handle cases which might run the; // risk of overflow.; // FIXME: We should instead consider the pointer to have escaped if this; // function is being instrumented for addressing bugs or race conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:58,Performance,load,load,58,// We consider any PHI or select that results in a direct load or store of; // the same offset to be a viable use for slicing purposes. These uses; // are considered unsplittable and the size is the maximum loaded or stored; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:207,Performance,load,loaded,207,// We consider any PHI or select that results in a direct load or store of; // the same offset to be a viable use for slicing purposes. These uses; // are considered unsplittable and the size is the maximum loaded or stored; // size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:19,Performance,load,loads,19,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Security,access,access,40,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:88,Security,access,access,88,"// If there are no loads or stores, the access is dead. We mark that as; // a size zero access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:201,Performance,load,loading,201,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:245,Performance,load,load,245,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:404,Performance,load,load,404,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:22,Usability,simpl,simplifyInstruction,22,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:319,Usability,simpl,simply,319,"// TODO: We could use simplifyInstruction here to fold PHINodes and; // SelectInsts. However, doing so requires to change the current; // dead-operand-tracking mechanism. For instance, suppose neither loading; // from %U nor %other traps. Then ""load (select undef, %U, %other)"" does not; // trap either. However, if we simply replace %U with undef using the; // current dead-operand-tracking mechanism, ""load (select undef, undef,; // %other)"" may trap because the select may return the first operand; // ""undef"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Safety,unsafe,unsafe,42,"// This is a new PHI/Select, check for an unsafe use of it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Security,sanitiz,sanitization,365,"// For PHI and select operands outside the alloca, we can't nuke the entire; // phi or select -- the other side might still be relevant, so we special; // case them here and use a separate structure to track the operands; // themselves which should be replaced with poison.; // FIXME: This should instead be escaped in the event we're instrumenting; // for address sanitization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Safety,abort,abort,40,"// FIXME: We should sink the escape vs. abort info into the caller nicely,; // possibly by just storing the PtrInfo in the AllocaSlices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Integrability,depend,depending,12,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:77,Integrability,depend,depend,77,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:6,Safety,avoid,avoid,6,"// To avoid depending on the order of slices, Ty and TyIsCommon must not; // depend on types skipped above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:61,Performance,load,loaded,61,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:93,Performance,load,load,93,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:181,Performance,load,load,181,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:285,Performance,load,load,285,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:319,Performance,load,load,319,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:378,Performance,load,load,378,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:495,Performance,load,loads,495,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:547,Performance,load,loaded,547,"/// PHI instructions that use an alloca and are subsequently loaded can be; /// rewritten to load both input pointers in the pred blocks and then PHI the; /// results, allowing the load of the alloca to be promoted.; /// From this:; /// %P2 = phi [i32* %Alloca, i32* %Other]; /// %V = load i32* %P2; /// to:; /// %V1 = load i32* %Alloca -> will be mem2reg'd; /// ...; /// %V2 = load i32* %Other; /// ...; /// %V = phi [i32 %V1, i32 %V2]; ///; /// We can do this to a select if its only uses are loads and if the operands; /// to the select can be loaded unconditionally.; ///; /// FIXME: This should be hoisted into a generic utility, likely in; /// Transforms/Util/Local.h",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:49,Performance,load,load,49,"// For now, we can only do this promotion if the load is in the same block; // as the PHI, and if there are no stores between the phi and load.; // TODO: Allow recursive phi users.; // TODO: Allow stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:138,Performance,load,load,138,"// For now, we can only do this promotion if the load is in the same block; // as the PHI, and if there are no stores between the phi and load.; // TODO: Allow recursive phi users.; // TODO: Allow stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,loads,25,// For now we only allow loads in the same block as the PHI. This is; // a common case that happens when instcombine merges two loads through; // a PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:128,Performance,load,loads,128,// For now we only allow loads in the same block as the PHI. This is; // a common case that happens when instcombine merges two loads through; // a PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:65,Performance,load,load,65,// Ensure that there are no instructions between the PHI and the load that; // could store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Performance,load,loads,56,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:172,Performance,load,load,172,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:39,Safety,safe,safe,39,// We can only transform this if it is safe to push the loads into the; // predecessor blocks. The only thing to watch out for is that we can't put; // a possibly trapping load in the predecessor if it is a critical edge.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:138,Performance,load,load,138,"// If the value is produced by the terminator of the predecessor (an; // invoke) or it has side-effects, there is no valid place to put a load; // in the predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Performance,load,load,37,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:90,Performance,load,load,90,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:130,Performance,load,load,130,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:29,Safety,safe,safe,29,"// If this pointer is always safe to load, or if we can prove that there; // is already a load in the block, then we can move the load to the pred; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Performance,load,loads,56,// Get the AA tags and alignment to use from one of the loads. It does not; // matter which one we get and if any differ.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all loads of the PN to use the new PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,loads,15,// Rewrite all loads of the PN to use the new PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Integrability,Inject,Inject,3,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:10,Performance,load,loads,10,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Security,Inject,Inject,3,// Inject loads into all of the pred blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Integrability,inject,injected,144,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:159,Performance,load,load,159,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:214,Performance,load,load,214,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Security,inject,injected,144,"// A PHI node is allowed to have multiple (duplicated) entries for the same; // basic block, as long as the value is the same. So if we already injected; // a load in the predecessor, then we should reuse the same load for all; // duplicated entries.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:20,Performance,load,loads,20,// Note that atomic loads can be transformed;; // atomic semantics do not have any meaning for a local alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:11,Performance,load,load,11,"// If the `load` is not simple, we can't speculatively execute it,; // but we could handle this via a CFG modification. But can we?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:24,Usability,simpl,simple,24,"// If the `load` is not simple, we can't speculatively execute it,; // but we could handle this via a CFG modification. But can we?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,load,21,// Replace the given load of the select with a select of two loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:61,Performance,load,loads,61,// Replace the given load of the select with a select of two loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,load,41,/// Compute the adjusted alignment for a load or store from an offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:283,Integrability,wrap,wrappings,283,"/// Test whether we can convert a value from the old to the new type.; ///; /// This predicate should be used to guard calls to convertValue in order to; /// ensure that we only try to convert viable values. The strategy is that we; /// will peel off single element struct and array wrappings to get to an; /// underlying value, and convert that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether we can convert a value from the old to the new type.; ///; /// This predicate should be used to guard calls to convertValue in order to; /// ensure that we only try to convert viable values. The strategy is that we; /// will peel off single element struct and array wrappings to get to an; /// underlying value, and convert that value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:186,Performance,load,loads,186,"// For integer types, we can't handle any bit-width differences. This would; // break both vector conversions with extension and introduce endianness; // issues when in conjunction with loads and stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Integrability,rout,routine,12,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:280,Integrability,rout,routine,280,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:236,Testability,test,test,236,"/// Generic routine to convert an SSA value to a value of a different; /// type.; ///; /// This will try various different casting techniques, such as bitcasts,; /// inttoptr, and ptrtoint casts. Use the \c canConvertValue predicate to test; /// two types for viability with this routine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether the given slice use can be promoted to a vector.; ///; /// This function is called to test each entry in a partition which is slated; /// for a single slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:103,Testability,test,test,103,/// Test whether the given slice use can be promoted to a vector.; ///; /// This function is called to test each entry in a partition which is slated; /// for a single slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Security,validat,validate,9,// First validate the slice offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Disable vector promotion when there are loads or stores of an FCA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Disable vector promotion when there are loads or stores of an FCA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether a vector type is viable for promotion.; ///; /// This implements the necessary checking for \c checkVectorTypesForPromotion; /// (and thus isVectorPromotionViable) over all slices of the alloca for the; /// given VectorType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether any vector type in \p CandidateTys is viable for promotion.; ///; /// This implements the necessary checking for \c isVectorPromotionViable over; /// all slices of the alloca for the given VectorType.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:150,Performance,perform,perform,150,"// Pointer-ness is sticky, if we had a vector-of-pointers candidate type,; // then we should choose it, not some other alternative.; // But, we can't perform a no-op pointer address space change via bitcast,; // so if we didn't have a common pointer element type, bail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Performance,load,load,85,// Consider additional vector types where the element type size is a; // multiple of load/store element size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:156,Modifiability,rewrite,rewrite,156,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:444,Modifiability,rewrite,rewrites,444,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:278,Performance,load,loads,278,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:127,Testability,test,test,127,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:538,Testability,test,test,538,"/// Test whether the given alloca partitioning and range of slices can be; /// promoted to a vector.; ///; /// This is a quick test to check whether we can rewrite a particular alloca; /// partition (and its newly formed alloca) into a vector alloca with only; /// whole-vector loads and stores such that it could be promoted to a vector; /// SSA value. We only can ensure this for a limited set of operations, and we; /// don't want to do the rewrites unless we are confident that the result will; /// be promotable, so we have an early test here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,load,load,7,// Put load and store types into a set for de-duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,loads,16,// Consider any loads or stores that are the exact size of the slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether a slice of an alloca is valid for integer widening.; ///; /// This implements the necessary checking for the \c isIntegerWideningViable; /// test below on a single slice of the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:158,Testability,test,test,158,/// Test whether a slice of an alloca is valid for integer widening.; ///; /// This implements the necessary checking for the \c isIntegerWideningViable; /// test below on a single slice of the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Performance,load,load,99,// Lifetime intrinsics operate over the whole alloca whose sizes are usually; // larger than other load/store slices (RelEnd > Size). But lifetime are; // always promotable and should not impact other slices' promotability of the; // partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,extend,extends,60,// We can't reasonably handle cases where the load or store extends past; // the end of the alloca's type and into its padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Performance,load,load,46,// We can't reasonably handle cases where the load or store extends past; // the end of the alloca's type and into its padding.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:46,Energy Efficiency,allocate,allocated,46,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Modifiability,extend,extend,30,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:19,Performance,load,loads,19,// We can't handle loads that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Modifiability,rewrite,rewriteIntegerLoad,82,"// So far, AllocaSliceRewriter does not support widening split slice tails; // in rewriteIntegerLoad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:35,Performance,load,loads,35,// Note that we don't count vector loads or stores as whole-alloca; // operations which enable integer widening because we would prefer to use; // vector widening instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,loads,15,// Non-integer loads need to be convertible from the alloca type so that; // they are promotable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Energy Efficiency,allocate,allocated,47,// We can't handle stores that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:31,Modifiability,extend,extend,31,// We can't handle stores that extend past the allocated memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Modifiability,rewrite,rewriteIntegerStore,82,"// So far, AllocaSliceRewriter does not support widening split slice tails; // in rewriteIntegerStore.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:35,Performance,load,loads,35,// Note that we don't count vector loads or stores as whole-alloca; // operations which enable integer widening because we would prefer to use; // vector widening instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:160,Modifiability,rewrite,rewrite,160,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:180,Performance,load,loads,180,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:236,Performance,load,loads,236,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Testability,Test,Test,4,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:131,Testability,test,test,131,/// Test whether the given alloca partition's integer operations can be; /// widened to promotable ones.; ///; /// This is a quick test to check whether we can rewrite the integer loads and; /// stores to a particular alloca into wider loads and stores and be able to; /// promote the resulting alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:66,Performance,load,load,66,"// While examining uses, we ensure that the alloca has a covering load or; // store. We don't want to widen the integer operations only to fail to; // promote due to some other unsplittable entry (which we may make splittable; // later). However, if there are only splittable uses, go ahead and assume; // that we cover the alloca.; // FIXME: We shouldn't consider split slices that happen to start in the; // partition here...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:187,Performance,load,loaded,187,"// When inserting a smaller vector into the larger to store, we first; // use a shuffle vector to widen it with undef elements, and then; // a second shuffle vector to select between the loaded vector and the; // incoming vector.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Modifiability,rewrite,rewrite,15,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:156,Security,access,accesses,156,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:257,Testability,log,logic,257,/// Visitor to rewrite instructions using p particular slice of an alloca; /// to use a new alloca.; ///; /// Also implements the rewriting to vector-based accesses when the partition; /// passes the isVectorPromotionViable predicate. Most of the rewriting logic; /// lives here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Modifiability,variab,variable,34,"// This is a convenience and flag variable that will be null unless the new; // alloca's integer operations should be widened to this integer type due to; // passing isIntegerWideningViable above. If it is non-null, the desired; // integer type will be stored here for easy access during rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:274,Security,access,access,274,"// This is a convenience and flag variable that will be null unless the new; // alloca's integer operations should be widened to this integer type due to; // passing isIntegerWideningViable above. If it is non-null, the desired; // integer type will be stored here for easy access during rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:291,Security,access,accesses,291,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:381,Security,access,accessing,381,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:500,Security,access,access,500,"// If we are rewriting an alloca partition which can be written as pure; // vector operations, we stash extra information here. When VecTy is; // non-null, we have some strict guarantees about the rewritten alloca:; // - The new alloca is exactly the size of the vector type here.; // - The accesses all either map to the entire vector or to a single; // element.; // - The set of accessing instructions is only one of those handled above; // in isVectorPromotionViable. Generally these are the same access kinds; // which are promotable via mem2reg.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Modifiability,rewrite,rewrite,14,// Track post-rewrite users which are PHI nodes and Selects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:57,Safety,avoid,avoid,57,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,Security,access,access,104,"// Return the new alloca, addrspacecasted if required to avoid changing the; // addrspace of a volatile access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:60,Modifiability,rewrite,rewrite,60,// Every instruction which can end up as a user must have a rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:127,Integrability,rout,routine,127,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Security,access,access,34,"/// Compute suitable alignment to access this slice of the *new*; /// alloca.; ///; /// You can optionally pass a type to this routine and if that type's ABI; /// alignment is itself suitable, this will return zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:257,Modifiability,extend,extend,257,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Performance,load,load,53,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:95,Performance,load,load,95,"// It is possible that the extracted type is not the load type. This; // happens if there is a load past the end of the alloca, and as; // a consequence the slice is narrower but still a candidate for integer; // lowering. To handle this case, we just zero extend the extracted; // integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Performance,load,load,47,"// Copy any metadata that is valid for the new load. This may require; // conversion to a different kind of metadata, e.g. !nonnull might change; // to !range or vice versa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,load,25,// If this is an integer load past the end of the slice (which means the; // bytes outside the slice are undef or this load is dead) just forcibly; // fix the integer size with correct handling of endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:119,Performance,load,load,119,// If this is an integer load past the end of the slice (which means the; // bytes outside the slice are undef or this load is dead) just forcibly; // fix the integer size with correct handling of endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Performance,load,load,42,// Move the insertion point just past the load so that we can refer to it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:114,Integrability,rout,routine,114,"/// Compute an integer value from splatting an i8 across the given; /// number of bytes.; ///; /// Note that this routine assumes an i8 is a byte. If that isn't true, don't; /// call this routine.; /// FIXME: Heed the advice above.; ///; /// \param V The i8 value to splat.; /// \param Size The number of bytes in the output (assuming i8 is one byte)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:188,Integrability,rout,routine,188,"/// Compute an integer value from splatting an i8 across the given; /// number of bytes.; ///; /// Note that this routine assumes an i8 is a byte. If that isn't true, don't; /// call this routine.; /// FIXME: Heed the advice above.; ///; /// \param V The i8 value to splat.; /// \param Size The number of bytes in the output (assuming i8 is one byte)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:23,Modifiability,variab,variable,23,"// If the memset has a variable size, it cannot be split, just adjust the; // pointer to the new alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:173,Modifiability,variab,variable,173,"// In theory we should call migrateDebugInfo here. However, we do not; // emit dbg.assign intrinsics for mem intrinsics storing through non-; // constant geps, or storing a variable number of bytes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,Usability,simpl,simple,33,"// If we can represent this as a simple value, we have to build the actual; // value to store, which requires expanding the byte present in memset to; // a sensible representation for the alloca type. This is essentially; // splatting the byte to a sufficiently wide integer, splatting it across; // any desired vector width, and bitcasting to the final type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:440,Deployability,update,update,440,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:297,Modifiability,variab,variable,297,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Performance,optimiz,optimization,113,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Usability,simpl,simply,30,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:380,Usability,simpl,simply,380,"// For unsplit intrinsics, we simply modify the source and destination; // pointers in place. This isn't just an optimization, it is a matter of; // correctness. With unsplit intrinsics we may be dealing with transfers; // within a single alloca before SROA ran, or with transfers that have; // a variable length. We may also be dealing with memmove instead of; // memcpy, and so simply updating the pointers is the necessary for us to; // update both source and dest of a single call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Deployability,Update,Update,3,// Update the address component of linked dbg.assigns.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:295,Availability,down,downsides,295,"// For split transfer intrinsics we have an incredibly useful assurance:; // the source and destination do not reside within the same alloca, and at; // least one of them does not escape. This means that we can replace; // memmove with memcpy, and we don't need to worry about all manner of; // downsides to splitting and transforming the operations.; // If this doesn't map cleanly onto the alloca type, and that type isn't; // a single value type, just emit a memcpy.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the size as needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:83,Usability,simpl,simple,83,"// Compute the other pointer, folding as much as possible to produce; // a single, simple GEP in most cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:115,Performance,load,load,115,"// This algorithm implements the same visitor loop as; // hasUnsafePHIOrSelectUse, and fixes the alignment of each load; // or store found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:28,Performance,load,loads,28,// Fix the alignment of any loads or stores using this PHI node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Modifiability,rewrite,rewriter,113,"// PHIs can't be promoted on their own, but often can be speculated. We; // check the speculation outside of the rewriter so that we see the; // fully-rewritten alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:28,Performance,load,loads,28,// Fix the alignment of any loads or stores using this select.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:116,Modifiability,rewrite,rewriter,116,"// Selects can't be promoted on their own, but often can be speculated. We; // check the speculation outside of the rewriter so that we see the; // fully-rewritten alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Modifiability,rewrite,rewrite,15,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:94,Modifiability,rewrite,rewrites,94,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:33,Performance,load,loads,33,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:117,Performance,load,loads,117,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:235,Performance,load,loads,235,/// Visitor to rewrite aggregate loads and stores as scalar.; ///; /// This pass aggressively rewrites all aggregate loads and stores on; /// a particular pointer (or any pointer derived from it which we can identify); /// with scalar loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Modifiability,rewrite,rewrite,53,/// Queue of pointer uses to analyze and potentially rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Performance,Queue,Queue,4,/// Queue of pointer uses to analyze and potentially rewrite.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Modifiability,Rewrite,Rewrite,4,/// Rewrite loads and stores through a pointer and all pointers derived from; /// it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:12,Performance,load,loads,12,/// Rewrite loads and stores through a pointer and all pointers derived from; /// it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Modifiability,rewrite,rewrite,34,// Conservative default is to not rewrite anything.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Integrability,rout,routine,37,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:300,Integrability,rout,routine,300,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:607,Integrability,depend,depending,607,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:104,Performance,load,load,104,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:653,Performance,load,load,653,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:286,Testability,log,logic,286,"/// Generic recursive split emission routine.; ///; /// This method recursively splits an aggregate op (load or store) into; /// scalar or vector ops. It splits recursively until it hits a single value; /// and emits that single value operation via the template argument.; ///; /// The logic of this routine relies on GEPs and insertvalue and; /// extractvalue all operating with the same fundamental index list, merely; /// formatted differently (GEPs need actual values).; ///; /// \param Ty The type being split recursively into smaller ops.; /// \param Agg The aggregate value being built up or stored, depending on; /// whether this is splitting a load or a store respectively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,load,16,/// Emit a leaf load of a single value. This is called at the leaves of the; /// recursive emission to actually load values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:112,Performance,load,load,112,/// Emit a leaf load of a single value. This is called at the leaves of the; /// recursive emission to actually load values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Performance,Load,Load,3,// Load the single value and insert it using the indices.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Performance,load,loaded,30,"// We have an aggregate being loaded, split it apart.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:240,Energy Efficiency,allocate,allocated,240,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Integrability,wrap,wrapping,53,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:108,Integrability,wrap,wrapping,108,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:164,Modifiability,layers,layers,164,// end anonymous namespace; /// Strip aggregate type wrapping.; ///; /// This removes no-op aggregate types wrapping an underlying type. It will; /// strip as many layers of types as it can without changing either the type; /// size or the allocated size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:389,Integrability,rout,routine,389,"/// Try to find a partition of the aggregate type passed in for a given; /// offset and size.; ///; /// This recurses through the aggregate type and tries to compute a subtype; /// based on the offset and size. When the offset and size span a sub-section; /// of an array, it will even compute a new array type for that sub-section,; /// and the same for structs.; ///; /// Note that this routine is very strict and tries to find a partition of the; /// type which produces the *exact* right offset and size. It is not forgiving; /// when the size or offset cause either end of type-based partition to be off.; /// Also, this is a best-effort routine. It is reasonable to give up and not; /// return a type if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:643,Integrability,rout,routine,643,"/// Try to find a partition of the aggregate type passed in for a given; /// offset and size.; ///; /// This recurses through the aggregate type and tries to compute a subtype; /// based on the offset and size. When the offset and size span a sub-section; /// of an array, it will even compute a new array type for that sub-section,; /// and the same for structs.; ///; /// Note that this routine is very strict and tries to find a partition of the; /// type which produces the *exact* right offset and size. It is not forgiving; /// when the size or offset cause either end of type-based partition to be off.; /// Also, this is a best-effort routine. It is reasonable to give up and not; /// return a type if necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:70,Energy Efficiency,power,power-of-two,70,// FIXME: This isn't right for vectors with non-byte-sized or; // non-power-of-two sized elements.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:180,Availability,down,down,180,"// Within a single element and its padding.; // Don't try to form ""natural"" types if the elements don't line up with the; // expected size.; // FIXME: We could potentially recurse down through the last element in the; // sub-struct to find a natural end point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,Availability,recover,recover,920,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Performance,load,loads,14,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:99,Performance,load,load,99,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:335,Performance,load,loads,335,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:692,Performance,load,load,692,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:752,Performance,load,load,752,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:785,Performance,load,load,785,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:920,Safety,recover,recover,920,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:227,Security,access,accesses,227,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Usability,simpl,simplify,34,"/// Pre-split loads and stores to simplify rewriting.; ///; /// We want to break up the splittable load+store pairs as much as; /// possible. This is important to do as a preprocessing step, as once we; /// start rewriting the accesses to partitions of the alloca we lose the; /// necessary information to correctly split apart paired loads and stores; /// which both point into this alloca. The case to consider is something like; /// the following:; ///; /// %a = alloca [12 x i8]; /// %gep1 = getelementptr i8, ptr %a, i32 0; /// %gep2 = getelementptr i8, ptr %a, i32 4; /// %gep3 = getelementptr i8, ptr %a, i32 8; /// store float 0.0, ptr %gep1; /// store float 1.0, ptr %gep2; /// %v = load i64, ptr %gep1; /// store i64 %v, ptr %gep2; /// %f1 = load float, ptr %gep2; /// %f2 = load float, ptr %gep3; ///; /// Here we want to form 3 partitions of the alloca, each 4 bytes large, and; /// promote everything so we recover the 2 SSA values that should have been; /// there all along.; ///; /// \returns true if any changes are made.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:13,Performance,load,loads,13,"// Track the loads and stores which are candidates for pre-splitting here, in; // the order they first appear during the partition scan. These give stable; // iteration order and a basis for tracking which loads and stores we; // actually split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:206,Performance,load,loads,206,"// Track the loads and stores which are candidates for pre-splitting here, in; // the order they first appear during the partition scan. These give stable; // iteration order and a basis for tracking which loads and stores we; // actually split.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:53,Performance,load,load,53,// We need to accumulate the splits required of each load or store where we; // can find them via a direct lookup. This is important to cross-check loads; // and stores against each other. We also track the slice so that we can kill; // all the slices that end up split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:148,Performance,load,loads,148,// We need to accumulate the splits required of each load or store where we; // can find them via a direct lookup. This is important to cross-check loads; // and stores against each other. We also track the slice so that we can kill; // all the slices that end up split.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Performance,load,loads,9,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:144,Performance,load,loads,144,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:258,Performance,load,load,258,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:676,Performance,load,load,676,"// Track loads out of this alloca which cannot, for any reason, be pre-split.; // This is important as we also cannot pre-split stores of those loads!; // FIXME: This is all pretty gross. It means that we can be more aggressive; // in pre-splitting when the load feeding the store happens to come from; // a separate alloca. Put another way, the effectiveness of SROA would be; // decreased by a frontend which just concatenated all of its local allocas; // into one big flat alloca. But defeating such patterns is exactly the job; // SROA is tasked with! Sadly, to not have this discrepancy we would have; // change store pre-splitting to actually force pre-splitting of the load; // that feeds it *and all stores*. That makes pre-splitting much harder, but; // maybe it would make it more principled?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:16,Performance,load,load,16,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:114,Performance,load,load,114,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:150,Performance,load,load,150,// If this is a load we have to track that it can't participate in any; // pre-splitting. If this is a store of a load we have to track that; // that load also can't participate in any pre-splitting.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:7,Performance,load,load,7,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:155,Safety,avoid,avoid,155,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:145,Usability,simpl,simple,145,// The load must be used exclusively to store into other pointers for; // us to be able to arbitrarily pre-split it. The stores must also be; // simple to avoid changing semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,loads,21,"// We may have split loads where some of their stores are split stores. For; // such loads and stores, we can only pre-split them if their splits exactly; // match relative to their starting offset. We have to verify this prior to; // any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:85,Performance,load,loads,85,"// We may have split loads where some of their stores are split stores. For; // such loads and stores, we can only pre-split them if their splits exactly; // match relative to their starting offset. We have to verify this prior to; // any rewriting.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Performance,load,load,14,// Lookup the load we are storing in our map of split; // offsets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:13,Performance,load,loads,13,// Unrelated loads are definitely safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Safety,safe,safe,34,// Unrelated loads are definitely safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:48,Performance,load,load,48,"// If the relative offsets of each split in the load and; // store match exactly, then we can split them and we; // don't need to remove them here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:27,Performance,load,load,27,// We've found a store and load that we need to split; // with mismatched relative splits. Just give up on them; // and remove both instructions from our list of; // candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:113,Performance,load,load,113,"// Now we have to go *back* through all the stores, because a later store may; // have caused an earlier store's load to become unsplittable and if it is; // unsplittable for the later store, then we can't rely on it being split in; // the earlier store either.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:34,Performance,load,loads,34,"// Once we've established all the loads that can't be split for some reason,; // filter any that made it into our list out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:9,Performance,load,loads,9,"// If no loads or stores are left, there is no pre-splitting to be done for; // this alloca.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Security,access,accesses,56,"// From here on, we can't fail and will be building new accesses, so rig up; // an IR builder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,loads,41,// Track any allocas we end up splitting loads and stores for so we iterate; // on them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:286,Modifiability,rewrite,rewrite,286,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:47,Performance,load,loads,47,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:215,Performance,load,loads,215,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:311,Performance,load,loads,311,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:353,Performance,load,load,353,"// At this point, we have collected all of the loads and stores we can; // pre-split, and the specific splits needed for them. We actually do the; // splitting in a specific order in order to handle when one of the loads in; // the value operand to one of the stores.; //; // First, we rewrite all of the split loads, and just accumulate each split; // load in a parallel structure. We also build the slices for them and append; // them to the alloca slices.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:80,Modifiability,rewrite,rewrite,80,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:15,Performance,load,load,15,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Performance,load,loads,43,// Append this load onto the list of split loads so we can find it later; // to rewrite the stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:88,Modifiability,rewrite,rewrite,88,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:30,Performance,load,loads,30,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:79,Performance,load,load,79,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:136,Performance,load,loads,136,"// Now that we have the split loads, do the slow walk over all uses of the; // load and rewrite them as split stores, or save the split loads to use; // below if the store is going to be split there anyways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:18,Performance,load,loads,18,// Save the split loads if there are deferred stores among the users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:21,Performance,load,load,21,// Mark the original load as dead and kill the original slice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:14,Modifiability,rewrite,rewrite,14,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:83,Performance,load,loads,83,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:154,Performance,load,loads,154,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:206,Performance,load,loads,206,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:237,Performance,load,loads,237,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:259,Performance,load,loads,259,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:168,Usability,simpl,simply,168,"// Second, we rewrite all of the split stores. At this point, we know that; // all loads from this alloca have been split already. For stores of such; // loads, we can simply look up the pre-existing split loads. For stores of; // other loads, we split those loads first and then write split stores of; // them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:42,Performance,load,load,42,// Check whether we have an already split load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:25,Performance,load,load,25,// Either lookup a split load or create one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:80,Performance,load,load,80,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:123,Performance,load,load,123,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:184,Performance,load,loads,184,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:263,Performance,load,loads,263,"// We want to immediately iterate on any allocas impacted by splitting; // this load, which is only relevant if it isn't a load of this alloca and; // thus we didn't already split the loads above. We also have to keep track; // of any promotable allocas we split loads on as they can no longer be; // promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,Availability,redundant,redundant,302,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:118,Performance,load,load,118,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:218,Performance,load,load,218,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:273,Performance,load,load,273,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:312,Performance,load,loads,312,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:365,Performance,optimiz,optimizer,365,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:490,Performance,load,loads,490,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:302,Safety,redund,redundant,302,"// Mark the original store as dead now that we've split it up and kill its; // slice. Note that we leave the original load in place unless this store; // was its only use. It may in turn be split up if it is an alloca load; // for some other alloca, but it may be a normal load. This may introduce; // redundant loads, but where those can be merged the rest of the optimizer; // should handle the merging, and this uncovers SSA splits which is more; // important. In practice, the original loads will almost always be fully; // split and removed eventually, and the splits will be merged by any; // trivial CSE, including instcombine.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:56,Integrability,rout,routine,56,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:134,Modifiability,rewrite,rewrite,134,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:363,Modifiability,rewrite,rewrite,363,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:502,Modifiability,rewrite,rewrite,502,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:566,Performance,queue,queues,566,"/// Rewrite an alloca partition's users.; ///; /// This routine drives both of the rewriting goals of the SROA pass. It tries; /// to rewrite uses of an alloca partition to be conducive for SSA value; /// promotion. If the partition needs a new, more refined alloca, this will; /// build that new alloca, preserving as much type information as possible, and; /// rewrite the uses of the old alloca to point at the new one and have the; /// appropriate new offsets. It also evaluates how successful the rewrite was; /// at enabling promotion and if it was successful queues the alloca to be; /// promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:62,Energy Efficiency,allocate,allocated,62,"// If not, can we find an appropriate subtype in the original allocated type?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:43,Modifiability,rewrite,rewrite,43,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:217,Modifiability,rewrite,rewriter,217,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:233,Performance,perform,perform,233,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:129,Security,access,access,129,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:362,Security,access,access,362,"// Check for the case where we're going to rewrite to a new alloca of the; // exact same type as the original, and with the same access offsets. In that; // case, re-use the existing alloca, but still run through the rewriter to; // perform phi and select speculation.; // P.beginOffset() can be non-zero even with the same type in a case with; // out-of-bounds access (e.g. @PR35657 function in SROA/basictest.ll).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:157,Energy Efficiency,schedul,scheduled,157,// Track the high watermark on the worklist as it is only relevant for; // promoted allocas. We will reset it to this point if the alloca is not in; // fact scheduled for promotion.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:90,Performance,queue,queue,90,"// If we have either PHIs or Selects to speculate, add them to those; // worklists and re-queue the new alloca so that we promote in on the; // next iteration.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:82,Security,expose,exposed,82,"// If we can't promote the alloca, iterate on it to check for new; // refinements exposed by splitting the current alloca. Don't iterate on an; // alloca which didn't actually change and didn't get promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:26,Performance,load,loads,26,// First try to pre-split loads and stores.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:73,Performance,load,loads,73,"// Now that we have identified any pre-splitting opportunities,; // mark loads and stores unsplittable except for the following case.; // We leave a slice splittable if all other slices are disjoint or fully; // included in the slice, such as whole-alloca loads and stores.; // If we fail to split these during pre-splitting, we want to force them; // to be rewritten into a partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:256,Performance,load,loads,256,"// Now that we have identified any pre-splitting opportunities,; // mark loads and stores unsplittable except for the following case.; // We leave a slice splittable if all other slices are disjoint or fully; // included in the slice, such as whole-alloca loads and stores.; // If we fail to split these during pre-splitting, we want to force them; // to be rewritten into a partition.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,load,41,"// If a byte boundary is included in any load or store, a slice starting or; // ending at the boundary is not splittable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:41,Performance,load,loads,41,// We only allow whole-alloca splittable loads and stores; // for a large alloca to avoid creating too large BitVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:84,Safety,avoid,avoid,84,// We only allow whole-alloca splittable loads and stores; // for a large alloca to avoid creating too large BitVector.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Modifiability,rewrite,rewritePartition,40,/// Describes the allocas introduced by rewritePartition in order to migrate; /// the debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite each partition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:37,Modifiability,variab,variable,37,// The alloca may be larger than the variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:63,Modifiability,variab,variable,63,// Avoid creating a fragment expression that covers the entire variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:3,Safety,Avoid,Avoid,3,// Avoid creating a fragment expression that covers the entire variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:71,Modifiability,variab,variable,71,// Remove any existing intrinsics on the new alloca describing; // the variable fragment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:24,Performance,load,loads,24,"// First, split any FCA loads and stores touching this alloca to promote; // better splitting and promotion opportunities.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:40,Availability,avail,available,40,"/// Promote the allocas, using the best available technique.; ///; /// This attempts to promote whatever allocas have been identified as viable in; /// the PromotableAllocas list. If that list is empty, there is nothing to do.; /// This function returns whether any promotion occurred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp:51,Integrability,wrap,wraps,51,/// A legacy pass for the legacy pass manager that wraps the \c SROA pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/SROA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:511,Energy Efficiency,reduce,reduce,511,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1066,Modifiability,variab,variable,1066,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1191,Modifiability,rewrite,rewrite,1191,"e https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the archite",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1933,Modifiability,rewrite,rewrite,1933,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:775,Performance,optimiz,optimizations,775,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:796,Performance,perform,perform,796,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1745,Performance,optimiz,optimized,1745,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:2382,Performance,perform,perform,2382,"ents straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the architecture level. Targets that are very; // sensitive to ILP may want to disable it. Having SLSR to consider ILP is; // left as future work.; //; // - When (i' - i) is constant but i and i' are not, we could still perform; // SLSR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:533,Safety,redund,redundancy,533,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:715,Testability,log,logic,715,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:621,Usability,simpl,simplifying,621,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:702,Usability,simpl,simplify,702,"//===- StraightLineStrengthReduce.cpp - -----------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:1211,Usability,simpl,simpler,1211,"e https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements straight-line strength reduction (SLSR). Unlike loop; // strength reduction, this algorithm is designed to reduce arithmetic; // redundancy in straight-line code instead of loops. It has proven to be; // effective in simplifying arithmetic statements derived from an unrolled loop.; // It can also simplify the logic of SeparateConstOffsetFromGEP.; //; // There are many optimizations we can perform in the domain of SLSR. This file; // for now contains only an initial step. Specifically, we look for strength; // reduction candidates in the following forms:; //; // Form 1: B + i * S; // Form 2: (B + i) * S; // Form 3: &B[i * S]; //; // where S is an integer variable, and i is a constant integer. If we found two; // candidates S1 and S2 in the same form and S1 dominates S2, we may rewrite S2; // in a simpler way with respect to S1. For example,; //; // S1: X = B + i * S; // S2: Y = B + i' * S => X + (i' - i) * S; //; // S1: X = (B + i) * S; // S2: Y = (B + i') * S => X + (i' - i) * S; //; // S1: X = &B[i * S]; // S2: Y = &B[i' * S] => &X[(i' - i) * S]; //; // Note: (i' - i) * S is folded to the extent possible.; //; // This rewriting is in general a good idea. The code patterns we focus on; // usually come from loop unrolling, so (i' - i) * S is likely the same; // across iterations and can be reused. When that happens, the optimized form; // takes only one add starting from the second iteration.; //; // When such rewriting is possible, we call S1 a ""basis"" of S2. When S2 has; // multiple bases, we choose to rewrite S2 with respect to its ""immediate""; // basis, the basis that is the closest ancestor in the dominator tree.; //; // TODO:; //; // - Floating point arithmetics when fast math is enabled.; //; // - SLSR may decrease ILP at the archite",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:156,Modifiability,extend,extended,156,"// Note that Index and Stride of a GEP candidate do not necessarily have the; // same integer type. In that case, during rewriting, Stride will be; // sign-extended or truncated to Index's type.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:194,Integrability,depend,depending,194,"// The instruction this candidate corresponds to. It helps us to rewrite a; // candidate with respect to its immediate basis. Note that one instruction; // can correspond to multiple candidates depending on how you associate the; // expression. For instance,; //; // (a + 1) * (b + 2); //; // can be treated as; //; // <Base: a, Index: 1, Stride: b + 2>; //; // or; //; // <Base: b, Index: 2, Stride: a + 1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:65,Modifiability,rewrite,rewrite,65,"// The instruction this candidate corresponds to. It helps us to rewrite a; // candidate with respect to its immediate basis. Note that one instruction; // can correspond to multiple candidates depending on how you associate the; // expression. For instance,; //; // (a + 1) * (b + 2); //; // can be treated as; //; // <Base: a, Index: 1, Stride: b + 2>; //; // or; //; // <Base: b, Index: 2, Stride: a + 1>",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:37,Usability,simpl,simplest,37,// Returns true if C is already in a simplest form and not worth being; // rewritten.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for Add instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for Mul instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:60,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,60,"// Splits LHS into Base + Index and, if succeeds, calls; // allocateCandidatesAndFindBasis.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate candidates and find bases for GetElementPtr instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:74,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,74,// A helper function that scales Idx with ElementSize before invoking; // allocateCandidatesAndFindBasis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Modifiability,Rewrite,Rewrites,3,// Rewrites candidate C with respect to Basis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:106,Energy Efficiency,allocate,allocateCandidatesAndFindBasis,106,"// A helper function that factors ArrayIdx to a product of a stride and a; // constant index, and invokes allocateCandidatesAndFindBasis with the; // factorings.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:81,Modifiability,rewrite,rewriteCandidateWithBasis,81,// Temporarily holds all instructions that are unlinked (but not deleted) by; // rewriteCandidateWithBasis. These instructions will be actually removed; // after all rewriting finishes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:37,Modifiability,rewrite,rewrite,37,// Basis must dominate C in order to rewrite C with respect to Basis.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:475,Availability,down,down,475,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:346,Security,hash,hash,346,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:491,Security,hash,hash-table,491,"// TODO: We currently implement an algorithm whose time complexity is linear in; // the number of existing candidates. However, we could do better by using; // ScopedHashTable. Specifically, while traversing the dominator tree, we could; // maintain all the candidates that dominate the basic block being traversed in; // a ScopedHashTable. This hash table is indexed by the base and the stride of; // a candidate. Therefore, finding the immediate basis of a candidate boils down; // to one hash-table look up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:196,Usability,simpl,simplest,196,"// SLSR can complicate an instruction in two cases:; //; // 1. If we can fold I into an addressing mode, computing I is likely free or; // takes only one instruction.; //; // 2. I is already in a simplest form. For example, when; // X = B + 8 * S; // Y = B + S,; // rewriting Y to X - 7 * S is probably a bad idea.; //; // In the above cases, we still add I to the candidate list so that I can be; // the basis of other candidates, but we leave I's basis blank so that I; // won't be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:28,Safety,avoid,avoid,28,// Limit the scan radius to avoid running in quadratice time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:48,Modifiability,extend,extend,48,// Try matching (B + i) * S.; // TODO: we could extend SLSR to float and vector types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:164,Safety,safe,safe,164,// I = B + sext(Idx *nsw S) * ElementSize; // = B + (sext(Idx) * sext(S)) * ElementSize; // = B + (sext(Idx) * ElementSize) * sext(S); // Casting to IntegerType is safe because we skipped vector GEPs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:21,Safety,unsafe,unsafe,21,// SLSR is currently unsafe if i * S may overflow.; // GEP = Base + sext(LHS *nsw RHS) * ElementSize,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:159,Modifiability,extend,extended,159,"// When ArrayIdx is the sext of a value, we try to factor that value as; // well. Handling this case is important because array indices are; // typically sign-extended to the pointer index size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,Energy Efficiency,power,power,20,"// If (i' - i) is a power of 2, Bump = sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:56,Testability,log,log,56,"// If (i' - i) is a power of 2, Bump = sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:20,Energy Efficiency,power,power,20,"// If (i - i') is a power of 2, Bump = -sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:57,Testability,log,log,57,"// If (i - i') is a power of 2, Bump = -sext/trunc(S) << log(i' - i).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:10,Modifiability,rewrite,rewriteCandidateWithBasis,10,"// We run rewriteCandidateWithBasis on all candidates in a post-order, so the; // basis of a candidate cannot be unlinked before the candidate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:122,Modifiability,rewrite,rewrite,122,"// An instruction can correspond to multiple candidates. Therefore, instead of; // simply deleting an instruction when we rewrite it, we mark its parent as; // nullptr (i.e. unlink it) so that we can skip the candidates whose; // instruction is already rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:83,Usability,simpl,simply,83,"// An instruction can correspond to multiple candidates. Therefore, instead of; // simply deleting an instruction when we rewrite it, we mark its parent as; // nullptr (i.e. unlink it) so that we can skip the candidates whose; // instruction is already rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:48,Energy Efficiency,Reduce,Reduced,48,"// It's tempting to preserve nsw on Bump and/or Reduced. However, it's; // usually unsound, e.g.,; //; // X = (-2 +nsw 1) *nsw INT_MAX; // Y = (-2 +nsw 3) *nsw INT_MAX; // =>; // Y = X + 2 * INT_MAX; //; // Neither + and * in the resultant expression are nsw.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite candidates in the reverse depth-first order. This order makes sure; // a candidate being rewritten is not a basis for any other candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StraightLineStrengthReduce.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:8,Integrability,wrap,wraps,8,"// This wraps a set of Nodes into the iterator, so we know which edges to; // filter out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:44,Performance,perform,performing,44,"/// Build up the general order of nodes, by performing a topological sort of the; /// parent region's nodes, while ensuring that there is no outer cycle node; /// between any two inner cycle nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:38,Energy Efficiency,reduce,reduced,38,"// An SCC up to the size of 2, can be reduced to an entry (the last node),; // and a possible additional node. Therefore, it is already in order, and; // there is no need to add it to the work-list.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Deployability,Update,Update,3,// Update the entry node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Testability,Test,Test,3,// Test for exit as back edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Testability,Test,Test,3,// Test for successors as back edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:4,Usability,Simpl,Simplify,4,/// Simplify any inverted conditions that were built by buildConditions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:143,Availability,avail,available,143,"/// When we are reconstructing a PHI inside \p PHIBlock with incoming values; /// from predecessors \p Incomings, we have a chance to mark the available value; /// from some blocks as undefined. The function will find out all such blocks; /// and return in \p UndefBlks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:704,Safety,safe,safely,704,"// We may get a post-structured CFG like below:; //; // | P1; // |/; // F1; // |\; // | N; // |/; // F2; // |\; // | P2; // |/; // F3; // |\; // B; //; // B is the block that has a PHI being reconstructed. P1/P2 are predecessors; // of B before structurization. F1/F2/F3 are flow blocks inserted during; // structurization process. Block N is not a predecessor of B before; // structurization, but are placed between the predecessors(P1/P2) of B after; // structurization. This usually means that threads went to N never take the; // path N->F2->F3->B. For example, the threads take the branch F1->N may; // always take the branch F2->P2. So, when we are reconstructing a PHI; // originally in B, we can safely say the incoming value from N is undefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:153,Availability,avail,available,153,"// If this undef block is dominated by any predecessor(before; // structurization) of reconstructed PHI with constant incoming value,; // don't mark the available value as undefined. Setting undef to such; // block will stop us from getting optimal phi insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:37,Modifiability,extend,extend,37,"// Setting CanUseUndef to true might extend value liveness, set it to false; // to achieve better register pressure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:3,Deployability,Update,Update,3,// Update the region info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:31,Deployability,update,update,31,/// Create a new flow node and update dominator tree and region info,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:19,Modifiability,variab,variable,19,// use a temporary variable to avoid a use-after-free if the map's storage is; // reallocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:31,Safety,avoid,avoid,31,// use a temporary variable to avoid a use-after-free if the map's storage is; // reallocated,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp:11,Safety,predict,predict,11,/// Can we predict that this node will always be called?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/StructurizeCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1098,Energy Efficiency,efficient,efficient,1098,"//===- TailRecursionElimination.cpp - Eliminate Tail Calls ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1012,Modifiability,variab,variable,1012,"//===- TailRecursionElimination.cpp - Eliminate Tail Calls ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry bloc",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1128,Performance,perform,performed,1128,"e information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file transforms calls of the current function (self recursion) followed; // by a return instruction with a branch to the entry of the function, creating; // a loop. This pass also implements the following extensions to the basic; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's pos",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2136,Performance,perform,performed,2136,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2664,Performance,perform,performed,2664,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1957,Safety,Safe,Safely,1957,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2578,Safety,safe,safe,2578,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2767,Safety,detect,detect,2767,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:1574,Security,access,access,1574,"c; // algorithm:; //; // 1. Trivial instructions between the call and return do not prevent the; // transformation from taking place, though currently the analysis cannot; // support moving any really useful instructions (only dead ones).; // 2. This pass transforms functions that are prevented from being tail; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, b",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2785,Security,access,access,2785,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:2725,Testability,benchmark,benchmark,2725,"; // recursive by an associative and commutative expression to use an; // accumulator variable, thus compiling the typical naive factorial or; // 'fib' implementation into efficient code.; // 3. TRE is performed if the function returns void, if the return; // returns the result returned by the call, or if the function returns a; // run-time constant on all exits from the function. It is possible, though; // unlikely, that the return returns something else (like constant 0), and; // can still be TRE'd. It can be TRE'd if ALL OTHER return instructions in; // the function return the exact same value.; // 4. If it can prove that callees do not access their caller stack frame,; // they are marked as eligible for tail call elimination (by the code; // generator).; //; // There are several improvements that could be made:; //; // 1. If the function has any alloca instructions, these instructions will be; // moved out of the entry block of the function, causing them to be; // evaluated each time through the tail recursion. Safely keeping allocas; // in the entry block requires analysis to proves that the tail-called; // function does not read or write the stack object.; // 2. Tail recursion is only performed if the call immediately precedes the; // return instruction. It's possible that there could be a jump between; // the call and the return.; // 3. There can be intervening operations between the call and the return that; // prevent the TRE from occurring. For example, there could be GEP's and; // stores to memory that will not be read or written by the call. This; // requires some substantial analysis (such as with DSA) to prove safe to; // move ahead of the call, but doing so could allow many more TREs to be; // performed, for example in TreeAdd/TreeAlloc from the treeadd benchmark.; // 4. The algorithm we use to detect if callees access their caller stack; // frames is very primitive.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:74,Energy Efficiency,allocate,allocate,74,// TODO: We don't do TRE if dynamic allocas are used.; // Dynamic allocas allocate stack space which should be; // deallocated before new iteration started. That is; // currently not implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:19,Performance,load,load,19,"// The result of a load is not alloca-derived (unless an alloca has; // otherwise escaped, but this is a local analysis).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:84,Security,access,accessing,84,// A PseudoProbeInst has the IntrInaccessibleMemOnly tag hence it is; // considered accessing memory and will be marked as a tail call if we; // don't bail out here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:202,Performance,load,load,202,"// A call to a readnone function whose arguments are all things computed; // outside this function can be marked tail. Even if you stored the; // alloca address into a global, a readnone function can't load the; // global anyhow.; //; // Note that this runs whether we know an alloca has escaped or not. If; // it has, then we can't trust Tracker.AllocaUsers to be accurate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Safety,safe,safe,25,"/// Return true if it is safe to move the specified; /// instruction from after the call to before the call, assuming that all; /// instructions between the call and this instruction are movable.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:22,Performance,load,load,22,// FIXME: We can move load/store/call/free instructions above the call if the; // call does not mod/ref the memory location being processed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:30,Performance,load,loads,30,// This also handles volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Performance,Load,Loads,3,// Loads may always be moved above calls without side effects.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:16,Performance,load,loads,16,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Performance,load,load,109,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:208,Performance,load,loaded,208,// Non-volatile loads may be moved above a call with side effects if it; // does not write to memory and the load provably won't trap.; // Writes to memory only matter if they may alias the pointer; // being loaded from.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:46,Availability,avail,available,46,// The below are shared state we want to have available when eliminating any; // calls in the function. There values should be populated by; // createTailRecurseLoopHeader the first time we find a call we can eliminate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:42,Performance,perform,performing,42,// The below are shared state needed when performing accumulator recursion.; // There values should be populated by insertAccumulator the first time we; // find an elimination that requires an accumulator.; // PHI node to store our current accumulated value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:22,Safety,detect,detect,22,"// As a special case, detect code like this:; // double fabs(double f) { return __builtin_fabs(f); } // a 'fabs' call; // and disable this xform in this case, because the code generator will; // lower the call to fabs into inline code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:122,Modifiability,variab,variable,122,// Creates a copy of contents of ByValue operand of the specified; // call instruction into the newly created temporarily variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:55,Modifiability,variab,variable,55,// Copy data from byvalue operand into the temporarily variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:35,Modifiability,variab,variable,35,// Creates a copy from temporarily variable(keeping value of ByVal argument); // into the corresponding function argument location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:34,Modifiability,variab,variable,34,// Copy data from the temporarily variable into corresponding; // function argument location.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:56,Modifiability,variab,variables,56,// Copy values of ByVal operands into local temporarily variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:168,Safety,safe,safe,168,"// When eliminating a tail call, we modify the values of the arguments.; // Therefore, if the byval parameter has a readonly attribute, we have to; // remove it. It is safe because, from the perspective of a caller, the; // byval parameter is always treated as ""readonly,"" even if the readonly; // attribute is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite the accumulator recursion instruction so that it does not use; // the result of the call anymore, instead, use the PHI node we just; // inserted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:3,Deployability,Update,Update,3,// Update our return value tracking,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:322,Safety,safe,safe,322,"// If all predecessors of Succ have been eliminated by; // FoldReturnIntoUncondBranch, delete it. It is important to empty it,; // because the ret instruction in there is still using a value which; // eliminateCall will attempt to remove. This block can only contain; // instructions that can't have uses, therefore it is safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:80,Deployability,Update,UpdateStrategy,80,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:156,Deployability,Update,UpdateStrategy,156,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Performance,perform,performance,25,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Testability,test,test,109,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:10,Integrability,interface,interface,10,// Public interface to the TailCallElimination pass,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:80,Deployability,Update,UpdateStrategy,80,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:156,Deployability,Update,UpdateStrategy,156,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:25,Performance,perform,performance,25,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp:109,Testability,test,test,109,// There is no noticable performance difference here between Lazy and Eager; // UpdateStrategy based on some test results. It is feasible to switch the; // UpdateStrategy to Lazy if we find it profitable later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TailRecursionElimination.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:44,Availability,Redundant,Redundant,44,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:412,Availability,Redundant,Redundant,412,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:58,Performance,Load,Loads,58,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:426,Performance,Load,Loads,426,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:44,Safety,Redund,Redundant,44,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:412,Safety,Redund,Redundant,412,"//===- TLSVariableHoist.cpp -------- Remove Redundant TLS Loads ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass identifies/eliminate Redundant TLS Loads if related option is set.; // The example: Please refer to the comment at the head of TLSVariableHoist.h.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:12,Modifiability,Variab,Variable,12,/// The TLS Variable hoist pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:20,Modifiability,Variab,Variable,20,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Performance,Perform,Perform,4,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:35,Performance,optimiz,optimization,35,/// Perform the TLS Variable Hoist optimization for the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:40,Modifiability,Variab,Variable,40,"// First, quickly check if there is TLS Variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:21,Modifiability,Variab,Variable,21,"// Then, collect TLS Variable info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:27,Modifiability,variab,variables,27,/// Optimize expensive TLS variables in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:4,Performance,Optimiz,Optimize,4,/// Optimize expensive TLS variables in the given function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp:19,Modifiability,variab,variable,19,// Collect all TLS variable candidates.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/TLSVariableHoist.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:441,Performance,perform,performed,441,"//===- LoopTransformWarning.cpp - ----------------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Emit warnings if forced code transformations have not been performed.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:101,Performance,perform,performed,101,/// Emit warnings for forced (i.e. user-defined) loop transformations which have; /// still not been performed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp:52,Performance,optimiz,optimizations,52,// Do not warn about not applied transformations if optimizations are; // disabled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Scalar/WarnMissedTransforms.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:1115,Performance,load,load,1115,"ache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd.org/index.php?title=Path_Discriminators; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:908,Safety,abort,abort,908,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:1299,Safety,abort,abort,1299,"ache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd.org/index.php?title=Path_Discriminators; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:876,Testability,ASSERT,ASSERT,876,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:955,Testability,ASSERT,ASSERT,955,"//===- AddDiscriminators.cpp - Insert DWARF path discriminators -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file adds DWARF discriminators to the IR. Path discriminators are; // used to decide what CFG path was taken inside sub-graphs whose instructions; // share the same line and column number information.; //; // The main user of this is the sample profiler. Instruction samples are; // mapped to line number information. Since a single line may be spread; // out over several basic blocks, discriminators add more precise location; // for the samples.; //; // For example,; //; // 1 #define ASSERT(P); // 2 if (!(P)); // 3 abort(); // ...; // 100 while (true) {; // 101 ASSERT (sum < 0);; // 102 ...; // 130 }; //; // when converted to IR, this snippet looks something like:; //; // while.body: ; preds = %entry, %if.end; // %0 = load i32* %sum, align 4, !dbg !15; // %cmp = icmp slt i32 %0, 0, !dbg !15; // br i1 %cmp, label %if.end, label %if.then, !dbg !15; //; // if.then: ; preds = %while.body; // call void @abort(), !dbg !15; // br label %if.end, !dbg !15; //; // Notice that all the instructions in blocks 'while.body' and 'if.then'; // have exactly the same debug information. When this program is sampled; // at runtime, the profiler will assume that all these instructions are; // equally frequent. This, in turn, will consider the edge while.body->if.then; // to be frequently taken (which is incorrect).; //; // By adding a discriminator value to the instructions in block 'if.then',; // we can distinguish instructions at line 101 with discriminator 0 from; // the instructions at line 101 with discriminator 1.; //; // For more details about DWARF discriminators, please visit; // http://wiki.dwarfstd",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:508,Performance,load,load,508,"/// Assign DWARF discriminators.; ///; /// To assign discriminators, we examine the boundaries of every; /// basic block and its successors. Suppose there is a basic block B1; /// with successor B2. The last instruction I1 in B1 and the first; /// instruction I2 in B2 are located at the same file and line number.; /// This situation is illustrated in the following code snippet:; ///; /// if (i < 10) x = i;; ///; /// entry:; /// br i1 %cmp, label %if.then, label %if.end, !dbg !10; /// if.then:; /// %1 = load i32* %i.addr, align 4, !dbg !10; /// store i32 %1, i32* %x, align 4, !dbg !10; /// br label %if.end, !dbg !10; /// if.end:; /// ret void, !dbg !12; ///; /// Notice how the branch instruction in block 'entry' and all the; /// instructions in block 'if.then' have the exact same debug location; /// information (!dbg !10).; ///; /// To distinguish instructions in block 'entry' from instructions in; /// block 'if.then', we generate a new lexical block for all the; /// instruction in block 'if.then' that share the same file and line; /// location with the last instruction of block 'entry'.; ///; /// This new lexical block will have the same location information as; /// the previous one, but with a new DWARF discriminator value.; ///; /// One of the main uses of this discriminator value is in runtime; /// sample profilers. It allows the profiler to distinguish instructions; /// at location !dbg !10 that execute on different basic blocks. This is; /// important because while the predicate 'if (x < 10)' may have been; /// executed millions of times, the assignment 'x = i' may have only; /// executed a handful of times (meaning that the entry->if.then edge is; /// seldom taken).; ///; /// If we did not have discriminator information, the profiler would; /// assign the same weight to both blocks 'entry' and 'if.then', which; /// in turn will make it conclude that the entry->if.then edge is very; /// hot.; ///; /// To decide where to create new discriminator values, this func",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:279,Performance,load,loads,279,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:314,Performance,load,load,314,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:71,Safety,avoid,avoid,71,"// Not all intrinsic calls should have a discriminator.; // We want to avoid a non-deterministic assignment of discriminators at; // different debug levels. We still allow discriminators on memory; // intrinsic calls because those can be early expanded by SROA into; // pairs of loads and stores, and the expanded load/store instructions; // should have a valid discriminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp:78,Safety,avoid,avoid,78,// We bypass intrinsic calls for the following two reasons:; // 1) We want to avoid a non-deterministic assignment of; // discriminators.; // 2) We want to minimize the number of base discriminators used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AddDiscriminators.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:67,Energy Efficiency,allocate,allocates,67,"// Calculates frame size required for current printf expansion and allocates; // space on printf buffer. Printf frame includes following contents; // [ ControlDWord , format string/Hash , Arguments (each aligned to 8 byte) ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:181,Security,Hash,Hash,181,"// Calculates frame size required for current printf expansion and allocates; // space on printf buffer. Printf frame includes following contents; // [ ControlDWord , format string/Hash , Arguments (each aligned to 8 byte) ]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:24,Security,hash,hash,24,// First 8 bytes of MD5 hash,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:225,Safety,safe,safe,225,"// This copies the contents of the string, however the next offset; // is at aligned length, the extra space that might be created due; // to alignment padding is not populated with any specific value; // here. This would be safe as long as runtime is sync with; // the offsets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:115,Availability,failure,failure,115,"// The buffered version still follows OpenCL printf standards for; // printf return value, i.e 0 on success, -1 on failure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:14,Security,hash,hash,14,"// Create MD5 hash for costant format string, push low 64 bits of the; // same onto buffer and metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp:28,Availability,failure,failure,28,"// End block, returns -1 on failure",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AMDGPUEmitPrintf.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:21,Modifiability,variab,variables,21,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:149,Modifiability,variab,variables,149,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:182,Modifiability,variab,variables,182,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:318,Modifiability,variab,variables,318,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:430,Modifiability,variab,variables,430,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:443,Safety,avoid,avoid,443,"// We sort the stack variables by alignment (largest first) to minimize; // unnecessary large gaps due to alignment.; // It is tempting to also sort variables by size so that larger variables; // have larger redzones at both ends. But reordering will make report analysis; // harder, especially when temporary unnamed variables are present.; // So, until we can provide more information (type, line number, etc); // for the stack variables we avoid reordering them too much.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:45,Modifiability,variab,variable,45,// We want to add a full redzone after every variable.; // The larger the variable Size the larger is the redzone.; // The resulting frame size is a multiple of Alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:74,Modifiability,variab,variable,74,// We want to add a full redzone after every variable.; // The larger the variable Size the larger is the redzone.; // The resulting frame size is a multiple of Alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp:16,Testability,assert,asserts,16,// Used only in asserts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ASanStackFrameLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp:123,Deployability,update,update,123,/// Remove knowledge stored in assume when it is already know by an attribute; /// or an other assume. This can when valid update an existing knowledge in an; /// attribute or an other assume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/AssumeBundleBuilder.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:408,Performance,perform,perform,408,"//===- BasicBlockUtils.cpp - BasicBlock Utilities --------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on basic blocks, and; // instructions contained within basic blocks.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:10,Deployability,update,updates,10,// Memdep updates AA itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:75,Deployability,Update,Update,75,"// Currently only allow PredBB to have two predecessors, one being BB.; // Update BI to branch to BB's only successor instead of BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:7,Deployability,update,update,7,// DTU update: Collect all the edges that exit BB.; // These dominator edges will be redirected from Pred.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:206,Deployability,update,updates,206,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:353,Deployability,update,updates,353,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:431,Energy Efficiency,reduce,reduce,431,"// Add insert edges first. Experimentally, for the particular case of two; // blocks that can be merged, with a single successor and single predecessor; // respectively, it is beneficial to have all insert updates first. Deleting; // edges first may lead to unreachable blocks, followed by inserting edges; // making the blocks reachable again. Such DT updates lead to high compile; // times. We add inserts before deletes here to reduce compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update branch in the predecessor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,Security,access,accessing,30,// Terminator may be a memory accessing instruction too.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Modifiability,Inherit,Inherit,3,// Inherit predecessors name if it exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:36,Deployability,update,update,36,"// Finally, erase the old block and update dominator info.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:184,Modifiability,variab,variable,184,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:673,Modifiability,variab,variable,673,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant instructions within sequences of consecutive dbg.value; /// instructions. This is done using a backward scan to keep the last dbg.value; /// describing a specific variable/fragment.; ///; /// BackwardScan strategy:; /// ----------------------; /// Given a sequence of consecutive DbgValueInst like this; ///; /// dbg.value ..., ""x"", FragmentX1 (*); /// dbg.value ..., ""y"", FragmentY1; /// dbg.value ..., ""x"", FragmentX2; /// dbg.value ..., ""x"", FragmentX1 (**); ///; /// then the instruction marked with (*) can be removed (it is guaranteed to be; /// obsoleted by the instruction marked with (**) as the latter instruction is; /// describing the same variable using the same fragment info).; ///; /// Possible improvements:; /// - Check fully overlapping fragments and not only identical fragments.; /// - Support dbg.declare. dbg.label, and possibly other meta instructions being; /// part of the sequence of consecutive instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Modifiability,variab,variable,15,// If the same variable fragment is described more than once it is enough; // to keep the last one (i.e. the first found since we for reverse; // iteration).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Availability,redundant,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Safety,redund,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:53,Usability,Clear,Clear,53,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:10,Modifiability,variab,variable,10,// If the variable fragment hasn't been seen before then we don't want; // to remove this dbg intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Modifiability,variab,variable,15,// If the same variable fragment is described more than once it is enough; // to keep the last one (i.e. the first found since we for reverse; // iteration).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Availability,redundant,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:94,Safety,redund,redundant,94,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:53,Usability,Clear,Clear,53,// Sequence with consecutive dbg.value instrs ended. Clear the map to; // restart identifying redundant instructions if case we find another; // dbg.value sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:119,Availability,redundant,redundant,119,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:159,Modifiability,variab,variable,159,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:425,Modifiability,variab,variable,425,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:659,Modifiability,Variab,Variable,659,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:119,Safety,redund,redundant,119,"/// Remove redundant dbg.value instructions using a forward scan. This can; /// remove a dbg.value instruction that is redundant due to indicating that a; /// variable has the same value as already being indicated by an earlier; /// dbg.value.; ///; /// ForwardScan strategy:; /// ---------------------; /// Given two identical dbg.value instructions, separated by a block of; /// instructions that isn't describing the same variable, like this; ///; /// dbg.value X1, ""x"", FragmentX1 (**); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value X1, ""x"", FragmentX1 (*); ///; /// then the instruction marked with (*) can be removed. Variable ""x"" is already; /// described as being mapped to the SSA value X1.; ///; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:72,Modifiability,variab,variable,72,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:92,Modifiability,variab,variable,92,"// Update the map if we found a new value/expression describing the; // variable, or if the variable wasn't mapped already.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Availability,redundant,redundant,11,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:271,Modifiability,variab,variable,271,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:430,Modifiability,variab,variable,430,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:11,Safety,redund,redundant,11,"/// Remove redundant undef dbg.assign intrinsic from an entry block using a; /// forward scan.; /// Strategy:; /// ---------------------; /// Scanning forward, delete dbg.assign intrinsics iff they are undef, not; /// linked to an intrinsic, and don't share an aggregate variable with a debug; /// intrinsic that didn't meet the criteria. In other words, undef dbg.assigns; /// that come before non-undef debug intrinsics for the variable are; /// deleted. Given:; ///; /// dbg.assign undef, ""x"", FragmentX1 (*); /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.value %V, ""x"", FragmentX2; /// <block of instructions, none being ""dbg.value ..., ""x"", ..."">; /// dbg.assign undef, ""x"", FragmentX1; ///; /// then (only) the instruction marked with (*) can be removed.; /// Possible improvements:; /// - Keep track of non-overlapping fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:30,Safety,avoid,avoid,30,// Remember visited blocks to avoid infinite loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:95,Testability,log,logic,95,"// If it is a critical edge, and the succesor is an exception block, handle; // the split edge logic in this specific function",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:15,Deployability,update,update,15,"// We manually update the LandingPadReplacement PHINode and it is the last; // PHI Node. So, if we find it, we are done.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:66,Usability,simpl,simplify,66,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:199,Usability,simpl,simplify,199,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:51,Usability,simpl,simplify,51,"// Loop is not in LoopSimplify form, no need to re simplify after; // splitting edge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:8,Usability,simpl,simplify,8,"// Loop-simplify form can be preserved, if we can split all in-loop; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:75,Deployability,update,update,75,"// If BB is in a loop and Succ is outside of that loop, we may need to; // update LoopSimplify form and LCSSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update LCSSA form in the newly created exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the original PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:70,Deployability,Update,Update,70,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:77,Security,access,accesses,77,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:70,Deployability,Update,Update,70,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:77,Security,access,accesses,77,"// Move MemoryAccesses still tracked in Old, but part of New now.; // Update accesses in successor blocks accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:4,Deployability,Update,Update,4,"/// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:28,Availability,avail,available,28,// Update dominator tree if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update dominator tree if available.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:56,Integrability,interface,interface,56,// The entry block was removed and there is no external interface for; // the dominator tree to be notified of this change. In this corner-case; // we recalculate the entire tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:49,Availability,avail,available,49,// Update MemoryPhis after split if MemorySSA is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update MemoryPhis after split if MemorySSA is available,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:19,Testability,log,logic,19,// The rest of the logic is only relevant for updating the loop structures.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:65,Safety,avoid,avoid,65,// Seek a loop which actually contains the block being split (to avoid; // adjacent loops).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:117,Availability,avail,available,117,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:4,Deployability,Update,Update,4,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:91,Deployability,update,updates,91,"/// Update the PHI nodes in OrigBB to include the values coming from NewBB.; /// This also updates AliasAnalysis, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:185,Deployability,update,updated,185,// This is slightly more strict than necessary; the minimum requirement; // is that there be no more than one indirectbr branching to BB. And; // all BlockAddress uses would need to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in BB with the values coming from NewBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:185,Deployability,update,updated,185,// This is slightly more strict than necessary; the minimum requirement; // is that there be no more than one indirectbr branching to BB. And; // all BlockAddress uses would need to be updated.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in OrigBB with the values coming from NewBB1.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,"// Update DominatorTree, LoopInfo, and LCCSA analysis information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHI nodes in OrigBB with the values coming from NewBB2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the returning block to realize that we no; // longer branch to them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:19,Testability,log,logic,19,// Encapsulate the logic around creation/insertion/etc of a new block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:433,Performance,perform,performed,433,"// After creating a control flow hub, the operands of PHINodes in an outgoing; // block Out no longer match the predecessors of that block. Predecessors of Out; // that are incoming blocks to the hub are now replaced by just one edge from; // the hub. To match this new control flow, the corresponding values from each; // PHINode must now be moved a new PHINode in the first guard block of the hub.; //; // This operation cannot be performed with SSAUpdater, because it involves one; // new use: If the block Out is in the list of Incoming blocks, then the newly; // created PHI in the Hub will use itself along that edge from Out to Hub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:25,Usability,simpl,simple,25,"// To help keep the loop simple, temporarily append the last; // outgoing block to the list of guard blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:140,Usability,simpl,simple,140,"/// We are using one integer to represent the block we are branching to. Then at; /// each guard block, the predicate was calcuated using a simple `icmp eq`.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization: Consider an incoming block A with both successors; // Succ0 and Succ1 in the set of outgoing blocks. The predicates; // for Succ0 and Succ1 complement each other. If Succ0 is visited; // first in the loop below, control will branch to Succ0 using the; // corresponding predicate. But if that branch is not taken, then; // control must reach Succ1, which means that the incoming value of; // the predicate from `In` is true for Succ1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Performance,Optimiz,Optimization,3,"// Optimization: When only one successor is an outgoing block,; // the incoming predicate from `In` is always true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:3,Deployability,Update,Update,3,// Update the PHINodes in each outgoing block to match the new control flow.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp:95,Usability,simpl,simply,95,"// If this is a ""cmp"" instruction, only used for branching (and nowhere; // else), then we can simply invert the predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BasicBlockUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:679,Deployability,update,update,679,"//===- BreakCriticalEdges.cpp - Critical Edge Elimination Pass ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // BreakCriticalEdges pass - Break all of the critical edges in the CFG by; // inserting a dummy basic block. This pass may be ""required"" by passes that; // cannot deal with critical edges. For this usage, the structure type is; // forward declared. This pass obviously invalidates the CFG, but can update; // dominator trees.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:66,Usability,simpl,simplify,66,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:199,Usability,simpl,simplify,199,"// Check if extra modifications will be required to preserve loop-simplify; // form after splitting. If it would require splitting blocks with IndirectBr; // terminators, bail out if preserving loop-simplify form is requested.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:17,Usability,simpl,simplify,17,"// No need to re-simplify, it wasn't to start with.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:8,Usability,simpl,simplify,8,"// Loop-simplify form can be preserved, if we can split all in-loop; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:52,Deployability,update,update,52,"// If there are any PHI nodes in DestBB, we need to update them so that they; // merge incoming values from NewBB instead of from TIBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:53,Deployability,update,update,53,"// If there are any other edges from TIBB to DestBB, update those to go; // through the split block, making those edges non-critical as well (and; // reducing the number of phi entries in the DestBB if relevant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:25,Deployability,update,update,25,"// If we have nothing to update, just return.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,"// Update the DominatorTree.; // ---> NewBB -----\; // / V; // TIBB -------\\------> DestBB; //; // First, inform the DT about the new path from TIBB to DestBB via NewBB,; // then delete the old edge from TIBB to DestBB. By doing this in that order; // DestBB stays reachable in the DT the whole time and its subtree doesn't; // get disconnected.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if it is around.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:114,Deployability,update,updated,114,"// If one or the other blocks were not in a loop, the new block is not; // either, and thus LI doesn't need to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:79,Deployability,update,update,79,"// If TIBB is in a loop and DestBB is outside of that loop, we may need; // to update LoopSimplify form and LCSSA form.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:3,Deployability,Update,Update,3,// Update LCSSA form in the newly created exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:105,Deployability,update,updated,105,"// If the target is a loop to itself, then the terminator of the split; // block (BodyBlock) needs to be updated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp:32,Safety,avoid,avoid,32,"// Advance the pointer here, to avoid invalidation issues when the old; // PHI is erased.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BreakCriticalEdges.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:27,Integrability,depend,depend,27,"//; // Those functions may depend on the locale, which may be accessed through; // global memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:62,Security,access,accessed,62,"//; // Those functions may depend on the locale, which may be accessed through; // global memory.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:88,Availability,reliab,reliably,88,// We have to do this step after AllocKind has been inferred on functions so; // we can reliably identify free-like and realloc-like functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:282,Performance,optimiz,optimizer,282,// Make sure any mandatory argument attributes are added.; // Any outgoing i32 argument should be handled with setArgExtAttr() which; // will add an extension attribute if the target ABI requires it. Adding; // argument extensions is typically done by the front end but when an; // optimizer is building a library call on its own it has to take care of; // this. Each such generated function must be handled here with sign or; // zero extensions as needed. F is retreived with cast<> because we demand; // of the caller to have called isLibFuncEmittable() first.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp:175,Testability,assert,assert,175,// These are functions that are known to not need any argument extension; // on any target: A size_t argument (which may be an i32 on some targets); // should not trigger the assert below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BuildLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:405,Performance,optimiz,optimization,405,"//===- BypassSlowDivision.cpp - Bypass slow division ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an optimization for div and rem on architectures that; // execute short instructions significantly faster than longer instructions.; // For example, on Intel Atom 32-bit divides are slow enough that during; // runtime it is profitable to check the value of the operands, and if they are; // positive and less than 256 use an unsigned 8-bit divide.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:56,Testability,log,logically,56,"/// A quotient and remainder, plus a BB from which they logically ""originate"".; /// If you use Quotient or Remainder in a Phi node, you should use BB as its; /// corresponding predecessor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:39,Performance,optimiz,optimize,39,// Skip division on vector types. Only optimize integer instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:163,Performance,perform,perform,163,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:175,Performance,optimiz,optimization,175,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:192,Performance,cache,caches,192,"/// Reuses previously-computed dividend or remainder from the current BB if; /// operands and operation are identical. Otherwise calls insertFastDivAndRem to; /// perform the optimization and caches the resulting dividend and remainder.; /// If no replacement can be generated, nullptr is returned.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:29,Performance,Cache,Cache,29,"// Then, look for a value in Cache.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:54,Integrability,rout,routine,54,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:77,Safety,detect,detect,77,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:453,Safety,detect,detect,453,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:34,Security,hash,hash,34,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:122,Security,hash,hash,122,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:155,Security,hash,hash,155,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:359,Security,hash,hash,359,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:467,Security,hash,hash,467,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:617,Security,hash,hash-like,617,"/// Check if a value looks like a hash.; ///; /// The routine is expected to detect values computed using the most common hash; /// algorithms. Typically, hash computations end with one of the following; /// instructions:; ///; /// 1) MUL with a constant wider than BypassType; /// 2) XOR instruction; ///; /// And even if we are wrong and the value is not a hash, it is still quite; /// unlikely that such values will fit into BypassType.; ///; /// To detect string hash algorithms like FNV we have to look through PHI-nodes.; /// It is implemented as a depth-first search for values that look neither long; /// nor hash-like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:140,Security,hash,hash-like,140,// Do not visit nodes that have been visited already. We return true because; // it means that we couldn't find any value that doesn't look hash-like.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:216,Safety,detect,detect,216,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:44,Security,hash,hashtable,44,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:123,Security,hash,hash,123,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:281,Security,hash,hashes,281,// Long integer divisions are often used in hashtable implementations. It's; // not worth bypassing such divisions because hash values are extremely; // unlikely to have enough leading zeros. The call below tries to detect; // values that are unlikely to fit BypassType (including hashes).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:26,Performance,optimiz,optimization,26,// udiv/urem because this optimization only handles positive numbers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:31,Testability,test,test,31,/// Creates a runtime check to test whether both the divisor and dividend fit; /// into BypassType. The check is inserted at the end of MainBB. True return; /// value means that the operands fit. Either of the operands may be NULL if it; /// doesn't need a runtime check.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:119,Usability,clear,clear,119,"// If the divisor is not a constant, DAGCombiner will convert it to a; // multiplication by a magic constant. It isn't clear if it is worth; // introducing control flow to get a narrower multiply.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:508,Safety,avoid,avoid,508,"// If the division is unsigned and Dividend is known to be short, then; // either; // 1) Divisor is less or equal to Dividend, and the result can be computed; // with a short division.; // 2) Divisor is greater than Dividend. In this case, no division is needed; // at all: The quotient is 0 and the remainder is equal to Dividend.; //; // So instead of checking at runtime whether Divisor fits into BypassType,; // we emit a runtime check to differentiate between these two cases. This; // lets us entirely avoid a long div.; // Split the basic block before the div/rem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:9,Performance,optimiz,optimization,9,"/// This optimization identifies DIV/REM instructions in a BB that can be; /// profitably bypassed and carried out with a shorter, faster divide.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:37,Safety,avoid,avoid,37,// Ignore dead code to save time and avoid bugs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp:67,Energy Efficiency,efficient,efficiently,67,"// Above we eagerly create divs and rems, as pairs, so that we can efficiently; // create divrem machine instructions. Now erase any unused divs / rems so we; // don't leave extra instructions sitting around.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/BypassSlowDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:50,Deployability,update,update,50,"//===- CallGraphUpdater.cpp - A (lazy) call graph update helper -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:415,Integrability,interface,interfaces,415,"//===- CallGraphUpdater.cpp - A (lazy) call graph update helper -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; /// \file; ///; /// This file provides interfaces used to manipulate a call graph, regardless; /// if it is a ""old style"" CallGraph or an ""new style"" LazyCallGraph.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:3,Deployability,Update,Update,3,// Update the call graph for the newly promoted function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp:7,Deployability,update,update,7,// And update the SCC we're iterating as well.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallGraphUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:276,Integrability,depend,depends,276,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:749,Performance,perform,performed,749,"/// Cast a call or invoke instruction to the given type.; ///; /// When promoting a call site, the return type of the call site might not match; /// that of the callee. If this is the case, we have to cast the returned value; /// to the correct type. The location of the cast depends on if we have a call; /// or invoke instruction.; ///; /// For example, if the call instruction below requires a bitcast after; /// promotion:; ///; /// orig_bb:; /// %t0 = call i32 @func(); /// ...; ///; /// The bitcast is placed after the call instruction:; ///; /// orig_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t0 = call i32 @func(); /// %t1 = bitcast i32 %t0 to ...; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, a new block is created for the bitcast. For; /// example, if the invoke instruction below requires a bitcast after promotion:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %normal_dst unwind label %unwind_dst; ///; /// The edge between the original block and the invoke's normal destination is; /// split, and the bitcast is placed there:; ///; /// orig_bb:; /// %t0 = invoke i32 @func() to label %split_bb unwind label %unwind_dst; ///; /// split_bb:; /// ; Uses of the original return value are replaced by uses of the bitcast.; /// %t1 = bitcast i32 %t0 to ...; /// br label %normal_dst; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:98,Integrability,depend,depends,98,// Determine an appropriate location to create the bitcast for the return; // value. The location depends on if we have a call or invoke instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:1146,Performance,perform,performed,1146,"he ""if"" condition compares the call site's called value to the given; /// callee. The original call site is moved into the ""else"" block, and a clone; /// of the call site is placed in the ""then"" block. The cloned instruction is; /// returned.; ///; /// For example, the call instruction below:; ///; /// orig_bb:; /// %t0 = call i32 %ptr(); /// ...; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original call instruction is placed in the ""then""; /// ; block. It is not yet promoted.; /// %t1 = call i32 %ptr(); /// br merge_bb; ///; /// else_bb:; /// ; The original call instruction is moved to the ""else"" block.; /// %t0 = call i32 %ptr(); /// br merge_bb; ///; /// merge_bb:; /// ; Uses of the original call instruction are replaced by uses of the phi; /// ; node.; /// %t2 = phi i32 [ %t0, %else_bb ], [ %t1, %then_bb ]; /// ...; ///; /// A similar transformation is performed for invoke instructions. However,; /// since invokes are terminating, more work is required. For example, the; /// invoke instruction below:; ///; /// orig_bb:; /// %t0 = invoke %ptr() to label %normal_dst unwind label %unwind_dst; ///; /// Is replace by the following:; ///; /// orig_bb:; /// %cond = icmp eq i32 ()* %ptr, @func; /// br i1 %cond, %then_bb, %else_bb; ///; /// then_bb:; /// ; The clone of the original invoke instruction is placed in the ""then""; /// ; block, and its normal destination is set to the ""merge"" block. It is; /// ; not yet promoted.; /// %t1 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// else_bb:; /// ; The original invoke instruction is moved into the ""else"" block, and; /// ; its normal destination is set to the ""merge"" block.; /// %t0 = invoke i32 %ptr() to label %merge_bb unwind label %unwind_dst; ///; /// merge_bb:; /// ; Uses of the original invoke instruction are replaced by uses of the; /// ; phi node, and the merge ",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:57,Usability,clear,clear,57,"// Since the call site will no longer be direct, we must clear metadata that; // is only appropriate for indirect calls. This includes !prof and !callees; // metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:22,Performance,load,load,22,// Not a vtable entry load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:16,Performance,load,load,16,// Not a vtable load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp:40,Modifiability,variab,variable,40,// Not in the form of a global constant variable with an initializer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CallPromotionUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp:1027,Performance,optimiz,optimization,1027,"//===- CanonicalizeAliases.cpp - ThinLTO Support: Canonicalize Aliases ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Currently this file implements partial alias canonicalization, to; // flatten chains of aliases (also done by GlobalOpt, but not on for; // O0 compiles). E.g.; // @a = alias i8, i8 *@b; // @b = alias i8, i8 *@g; //; // will be converted to:; // @a = alias i8, i8 *@g <-- @a is now an alias to base object @g; // @b = alias i8, i8 *@g; //; // Eventually this file will implement full alias canonicalization, so that; // all aliasees are private anonymous values. E.g.; // @a = alias i8, i8 *@g; // @g = global i8 0; //; // will be converted to:; // @0 = private global; // @a = alias i8, i8* @0; // @g = alias i8, i8* @0; //; // This simplifies optimization and ThinLTO linking of the original symbols.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp:1016,Usability,simpl,simplifies,1016,"//===- CanonicalizeAliases.cpp - ThinLTO Support: Canonicalize Aliases ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Currently this file implements partial alias canonicalization, to; // flatten chains of aliases (also done by GlobalOpt, but not on for; // O0 compiles). E.g.; // @a = alias i8, i8 *@b; // @b = alias i8, i8 *@g; //; // will be converted to:; // @a = alias i8, i8 *@g <-- @a is now an alias to base object @g; // @b = alias i8, i8 *@g; //; // Eventually this file will implement full alias canonicalization, so that; // all aliasees are private anonymous values. E.g.; // @a = alias i8, i8 *@g; // @g = global i8 0; //; // will be converted to:; // @0 = private global; // @a = alias i8, i8* @0; // @g = alias i8, i8* @0; //; // This simplifies optimization and ThinLTO linking of the original symbols.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CanonicalizeAliases.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:426,Integrability,interface,interface,426,"//===- CloneFunction.cpp - Clone a function into another function ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CloneFunctionInto interface, which is used as the; // low-level function cloner. This is used by the CloneFunction and function; // inliner to do the dirty work of copying the body of a function around.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:65,Safety,avoid,avoid,65,"// When we remap instructions within the same module, we want to avoid; // duplicating inlined DISubprograms, so record all subprograms we find as we; // duplicate instructions and then freeze them in the MD map. We also record; // information about dbg.value and dbg.declare to avoid duplicating the; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:279,Safety,avoid,avoid,279,"// When we remap instructions within the same module, we want to avoid; // duplicating inlined DISubprograms, so record all subprograms we find as we; // duplicate instructions and then freeze them in the MD map. We also record; // information about dbg.value and dbg.declare to avoid duplicating the; // types.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:67,Performance,tune,tune,67,// Track the subprogram attachment that needs to be cloned to fine-tune the; // mapping within the same module.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,// Avoid clobbering an existing mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,"// Avoid cloning types, compile units, and (other) subprograms.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:8,Deployability,update,update,8,"// Only update !llvm.dbg.cu for DifferentModule (not CloneModule). In the; // same module, the compile unit will already be listed (or not). When; // cloning a module, CloneModule() will handle creating the named metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:267,Deployability,update,update,267,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:572,Deployability,update,update,572,"// Update !llvm.dbg.cu with compile units added to the new module if this; // function is being cloned in isolation.; //; // FIXME: This is making global / module-level changes, which doesn't seem; // like the right encapsulation Consider dropping the requirement to update; // !llvm.dbg.cu (either obsoleting the node, or restricting it to; // non-discardable compile units) instead of discovering compile units by; // visiting the metadata attached to global values, which would allow this; // code to be deleted. Alternatively, perhaps give responsibility for this; // update to CloneFunctionInto's callers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiple insertions of the same DICompileUnit to NMD.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:341,Deployability,update,updated,341,"/// Return a copy of the specified function and add it to that function's; /// module. Also, any references specified in the VMap are changed to refer to; /// their mapped value instead of the original one. If any of the arguments to; /// the function are in the VMap, the arguments are deleted from the resultant; /// function. The VMap is updated to include mappings from all of the; /// instructions and basicblocks in the function from their old to new values.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:481,Safety,safe,safe,481,"// It is only legal to clone a function if a block address within that; // function is never referenced outside of the function. Given that, we; // want to map block addresses from the old function to block addresses in; // the clone. (This is different from the generic ValueMapper; // implementation, which generates an invalid blockaddress when; // cloning a function.); //; // Note that we don't need to fix the mapping for unreachable blocks;; // the default mapping there is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:103,Performance,optimiz,optimizations,103,// All function calls in the inlined function must get 'strictfp'; // attribute to prevent undesirable optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:123,Deployability,update,update,123,"// Eagerly remap operands to the newly cloned instruction, except for PHI; // nodes for which we defer processing until we update the CFG. Also defer; // debug intrinsic processing because they may contain use-before-defs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:13,Usability,simpl,simplify,13,"// If we can simplify this instruction to some other value, simply add; // a mapping to that value rather than inserting a new instruction into; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:60,Usability,simpl,simply,60,"// If we can simplify this instruction to some other value, simply add; // a mapping to that value rather than inserting a new instruction into; // the basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:31,Usability,simpl,simplifies,31,"// On the off-chance that this simplifies to an instruction in the old; // function, map it back into the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:85,Deployability,update,updated,85,"// The loop above has removed PHI entries for those blocks that are dead; // and has updated others. However, if a block is live (i.e. copied over); // but its terminator has been changed to not go to this block, then our; // phi nodes will have invalid entries. Update the PHI nodes in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:263,Deployability,Update,Update,263,"// The loop above has removed PHI entries for those blocks that are dead; // and has updated others. However, if a block is live (i.e. copied over); // but its terminator has been changed to not go to this block, then our; // phi nodes will have invalid entries. Update the PHI nodes in this; // case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:213,Deployability,update,update,213,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:135,Performance,perform,performing,135,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:180,Security,expose,exposed,180,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:107,Usability,simpl,simplifying,107,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:164,Usability,simpl,simplifications,164,"// Make a second pass over the PHINodes now that all of them have been; // remapped into the new function, simplifying the PHINode and performing any; // recursive simplifications exposed. This will transparently update the; // WeakTrackingVH in the VMap. Notably, we rely on that so that if we coalesce; // two PHINodes, the iteration over the old PHIs remains valid, and the; // mapping will just map us to the new node (which may not even be a PHI; // node).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:21,Testability,test,test,21,"// Note that we must test the size on each iteration, the worklist can grow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:27,Usability,simpl,simplifies,27,// See if this instruction simplifies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:89,Usability,simpl,simplifications,89,// Stash away all the uses of the old instruction so we can check them for; // recursive simplifications after a RAUW. This is cheaper than checking all; // uses of To on the recursive step in most cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:196,Availability,avail,available,196,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Usability,Simpl,Simplify,3,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:126,Usability,simpl,simplification,126,"// Simplify conditional branches and switches with a constant operand. We try; // to prune these out when cloning, but if the simplification required; // looking through PHI nodes, those are only available after forming the full; // basic block. That may leave some here, and we still want to prune the dead; // code as early as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:77,Usability,simpl,simple,77,"/// This works exactly like CloneFunctionInto,; /// except that it does some simple constant prop and DCE on the fly. The; /// effect of this is to copy significantly less code in cases where (for; /// example) a function call with constant arguments is inlined, and those; /// constant arguments cause a significant amount of code in the callee to be; /// dead. Since this doesn't produce an exact copy of the input, it can't be; /// used for things like CloneFunction or CloneModule.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite the code to refer to itself.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:92,Deployability,Update,Updates,92,/// Clones a loop \p OrigLoop. Returns the loop and the blocks in \p; /// Blocks.; ///; /// Updates LoopInfo and DominatorTree assuming the loop is dominated by block; /// \p LoopDomBB. Insert the new blocks before block specified in \p Before.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update LoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update DominatorTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update LoopInfo.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:52,Deployability,update,update,52,"// Add DominatorTree node. After seeing all blocks, update to correct; // IDom.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update loop headers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:3,Deployability,Update,Update,3,// Update DominatorTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:85,Deployability,update,update,85,"// FIXME: SplitEdge does not yet take a DTU, so we include the split edge; // in the update set here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:21,Deployability,patch,patch,21,// Remap operands to patch up intra-block references.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Energy Efficiency,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Modifiability,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Energy Efficiency,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp:51,Modifiability,adapt,adaptation,51,// Identify instructions using metadata that needs adaptation,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:420,Integrability,interface,interface,420,"//===- CloneModule.cpp - Clone an entire module ---------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the CloneModule interface which makes a copy of an; // entire module.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:101,Modifiability,variab,variables,101,"/// This is not as easy as it might seem because we have to worry about making; /// copies of global variables and functions, and making their (initializers and; /// references, respectively) refer to the right globals.; ///; /// Cloning un-materialized modules is not currently supported, so any; /// modules initialized via lazy loading should be materialized before cloning",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:331,Performance,load,loading,331,"/// This is not as easy as it might seem because we have to worry about making; /// copies of global variables and functions, and making their (initializers and; /// references, respectively) refer to the right globals.; ///; /// Cloning un-materialized modules is not currently supported, so any; /// modules initialized via lazy loading should be materialized before cloning",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:31,Modifiability,variab,variables,31,"// Loop over all of the global variables, making corresponding globals in the; // new module. Here we add them to the VMap and to the new Module. We; // don't worry about attributes or initializers, they will come later.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:113,Integrability,depend,depending,113,"// An alias cannot act as an external reference, so we need to create; // either a function or a global variable depending on the value type.; // FIXME: Once pointee types are gone we can probably pick one or the; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:104,Modifiability,variab,variable,104,"// An alias cannot act as an external reference, so we need to create; // either a function or a global variable depending on the value type.; // FIXME: Once pointee types are gone we can probably pick one or the; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:42,Modifiability,variab,variable,42,"// Now that all of the things that global variable initializer can refer to; // have been created, loop through and copy the global variable referrers; // over... We also set the attributes on the global now.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp:132,Modifiability,variab,variable,132,"// Now that all of the things that global variable initializer can refer to; // have been created, loop through and copy the global variable referrers; // over... We also set the attributes on the global now.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CloneModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:408,Integrability,interface,interface,408,"//===- CodeExtractor.cpp - Pull code region into a new function -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the interface to tear out a code region, such as an; // individual loop or a parallel section, into a new function, replacing it with; // a call to the new function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:4,Testability,Test,Test,4,/// Test whether a block is valid for extraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:60,Safety,abort,aborting,60,"// Loop over the blocks, adding them to our set-vector, and aborting with an; // empty set if we encounter invalid blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Modifiability,variab,variable,10,// Global variable can not be aliased with locals.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:167,Safety,avoid,avoid,167,// Find bitcasts in the outlined region that have lifetime marker users; // outside that region. Replace the lifetime marker use with an; // outside region bitcast to avoid unnecessary alloca/reload instructions; // and extra lifetime markers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:95,Deployability,update,update,95,"// Okay, everything within the region is now branching to the right block, we; // just have to update the PHI nodes now, inserting PHI nodes into NewBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:205,Safety,safe,safe,205,"// Do not process PHI if there is one (or fewer) predecessor from region.; // If PHI has exactly one predecessor from region, only this one incoming; // will be replaced on codeRepl block, so it should be safe to skip PHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:29,Integrability,depend,dependent,29,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Inherit,Inherit,3,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:385,Modifiability,inherit,inherited,385,"// Inherit all of the target dependent attributes and white-listed; // target independent attributes.; // (e.g. If the extracted region contains a call to an x86.sse; // instruction we need to make sure that the extracted region has the; // ""target-features"" attribute allowing it to be lowered.; // FIXME: This should be changed to check to see if a specific; // attribute can not be inherited.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:41,Safety,safe,safely,41,// Those attributes cannot be propagated safely. Explicitly list them; // here so we get a warning if new attributes are added.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:30,Safety,safe,safe,30,// Those attributes should be safe to propagate to the extracted function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all users of the inputs in the extracted region to use the; // arguments (or appropriate addressing into struct) instead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite branches to basic blocks outside of the loop to new dummy blocks; // within the new function. This must be done before we lose track of which; // blocks were originally in the code region.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:119,Energy Efficiency,allocate,allocated,119,"// Emit a call to the new function, passing in: *pointer to struct (if; // aggregating parameters), or plan inputs and allocated memory for outputs",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Energy Efficiency,Allocate,Allocate,3,// Allocate a struct at the beginning of this function,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:36,Testability,stub,stub,36,"// If we don't already have an exit stub for this non-extracted; // destination, create one now!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the switch instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Modifiability,rewrite,rewrite,3,// rewrite the original branch instruction with this new target,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:116,Testability,stub,stubs,116,// Store the arguments right after the definition of output value.; // This should be proceeded after creating exit stubs to be ensure that invoke; // result restore will be placed in the outlined function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:33,Usability,simpl,simplify,33,"// Now that we've done the deed, simplify the switch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Availability,redundant,redundant,10,// Remove redundant case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Safety,redund,redundant,10,// Remove redundant case,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weights for the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:22,Deployability,update,update,22,// Get the weight and update the current BFI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:51,Deployability,update,updated,51,"// Debug intrinsics in the new function need to be updated in one of two; // ways:; // 1) They need to be deleted, because they describe a value in the old; // function.; // 2) They need to point to fresh metadata, e.g. because they currently; // point to a variable in the wrong scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:258,Modifiability,variab,variable,258,"// Debug intrinsics in the new function need to be updated in one of two; // ways:; // 1) They need to be deleted, because they describe a value in the old; // function.; // 2) They need to point to fresh metadata, e.g. because they currently; // point to a variable in the wrong scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:17,Deployability,update,updates,17,"// Apply the two updates that dbg.values get: invalid operands, and; // variable metadata fixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:72,Modifiability,variab,variable,72,"// Apply the two updates that dbg.values get: invalid operands, and; // variable metadata fixup.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:10,Modifiability,variab,variable,10,"// If the variable was in the scope of the old function, i.e. it was not; // inlined, point the intrinsic to a fresh variable within the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:117,Modifiability,variab,variable,117,"// If the variable was in the scope of the old function, i.e. it was not; // inlined, point the intrinsic to a fresh variable within the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:107,Performance,cache,cache,107,// Remove @llvm.assume calls that will be moved to the new function from the; // old function's assumption cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weight for this successor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the entry count of the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:3,Deployability,Update,Update,3,// Update the branch weights for the exit block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:156,Safety,avoid,avoid,156,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:69,Usability,resume,resume,69,// Mark the new function `noreturn` if applicable. Terminators which resume; // exception propagation are treated as returning instructions. This is to; // avoid inserting traps after calls to outlined functions which unwind.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp:66,Performance,cache,cache,66,"// There shouldn't be any stale affected values in the assumption cache; // that were previously in the old function, but that have now been moved; // to the new function.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeExtractor.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:818,Modifiability,Extend,Extended-TSP,818,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:404,Performance,cache,cache-aware,404,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:570,Performance,optimiz,optimizing,570,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:616,Performance,cache,cache,616,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:796,Performance,optimiz,optimization,796,"//===- CodeLayout.cpp - Implementation of code layout algorithms ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation su",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:1200,Performance,cache,cache,1200,"LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The file implements ""cache-aware"" layout algorithms of basic blocks and; // functions in a binary.; //; // The algorithm tries to find a layout of nodes (basic blocks) of a given CFG; // optimizing jump locality and thus processor I-cache utilization. This is; // achieved via increasing the number of fall-through jumps and co-locating; // frequently executed nodes together. The name follows the underlying; // optimization problem, Extended-TSP, which is a generalization of classical; // (maximum) Traveling Salesmen Problem.; //; // The algorithm is a greedy heuristic that works with chains (ordered lists); // of basic blocks. Initially all chains are isolated basic blocks. On every; // iteration, we pick a pair of chains whose merging yields the biggest increase; // in the ExtTSP score, which models how i-cache ""friendly"" a specific chain is.; // A pair of chains giving the maximum gain is merged into a new chain. The; // procedure stops when there is only one chain left, or when merging does not; // increase ExtTSP. In the latter case, the remaining chains are sorted by; // density in the decreasing order.; //; // An important aspect is the way two chains are merged. Unlike earlier; // algorithms (e.g., based on the approach of Pettis-Hansen), two; // chains, X and Y, are first split into three, X1, X2, and Y. Then we; // consider all possible ways of gluing the three chains (e.g., X1YX2, X1X2Y,; // X2X1Y, X2YX1, YX1X2, YX2X1) and choose the one producing the largest score.; // This improves the quality of the final result (the search space is larger); // while keeping the implementation sufficiently fast.; //; // Reference:; // * A. Newell and S. Pupyrev, Improved Basic Block Reordering,; // IEEE Transactions on Computers, 2020; // http",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:76,Performance,tune,tuned,76,// namespace llvm; // Algorithm-specific params for Ext-TSP. The values are tuned for the best; // performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:99,Performance,perform,performance,99,// namespace llvm; // Algorithm-specific params for Ext-TSP. The values are tuned for the best; // performance of large-scale front-end bound binaries.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:107,Energy Efficiency,efficient,efficiently,107,// The maximum size of a chain created by the algorithm. The size is bounded; // so that the algorithm can efficiently process extremely large instances.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the current gain if Other is preferred over this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the chain's data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update the node's data.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,// Cached ext-tsp score for the chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:125,Safety,avoid,avoid,125,"// The total execution count of the chain. Since the execution count of; // a basic block is uint64_t, using doubles here to avoid overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,// Cached gain value for merging the pair of chains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cached,3,"// Cached gain values for merging the pair of chains. Since the gain of; // merging (Src, Dst) and (Dst, Src) might be different, we store both values; // here and a flag indicating which of the options results in a higher gain.; // Cached gain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:233,Performance,Cache,Cached,233,"// Cached gain values for merging the pair of chains. Since the gain of; // merging (Src, Dst) and (Dst, Src) might be different, we store both values; // here and a flag indicating which of the options results in a higher gain.; // Cached gain values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:15,Performance,cache,cached,15,// Whether the cached value must be recomputed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update edges adjacent to chain Other.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:86,Safety,avoid,avoid,86,/// A wrapper around three concatenated vectors (chains) of nodes; it is used; /// to avoid extra instantiation of the vectors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:6,Integrability,wrap,wrapper,6,/// A wrapper around two concatenated vectors (chains) of jumps.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:36,Performance,optimiz,optimized,36,/// Run the algorithm and return an optimized ordering of nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:31,Energy Efficiency,reduce,reduce,31,// Pass 3: Merge cold nodes to reduce code size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:41,Integrability,depend,dependencies,41,"// There might be 'cycles' in the forced dependencies, since profile; // data isn't 100% accurate. Typically this is observed in loops, when the; // loop edges are the hottest successors for the basic blocks of the loop.; // Break the cycles by choosing the node with the smallest index as the; // head. This helps to keep the original order of the loops, which likely; // have already been rotated in the optimized manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:406,Performance,optimiz,optimized,406,"// There might be 'cycles' in the forced dependencies, since profile; // data isn't 100% accurate. Typically this is observed in loops, when the; // loop edges are the hottest successors for the basic blocks of the loop.; // Break the cycles by choosing the node with the smallest index as the; // head. This helps to keep the original order of the loops, which likely; // have already been rotated in the optimized manner.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:85,Deployability,update,update,85,"/// Given a merge offset and a list of merge types, try to merge two chains; /// and update Gain with a better alternative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:56,Deployability,update,update,56,"// Apply the merge, compute the corresponding gain, and update the best; // value, if the merge is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:119,Energy Efficiency,reduce,reduce,119,"// In practice, applying X2_Y_X1 merging almost never provides benefits;; // thus, we exclude it from consideration to reduce the search space.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:38,Deployability,update,update,38,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:122,Performance,cache,cached,122,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Deployability,Update,Update,3,// Update cached ext-tsp score for the new chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:10,Performance,cache,cached,10,// Update cached ext-tsp score for the new chain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:14,Performance,cache,caches,14,// Invalidate caches.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:35,Deployability,update,updated,35,/// Active chains. The vector gets updated at runtime when chains are merged.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:30,Performance,Cache,Cache-Directed,30,/// The implementation of the Cache-Directed Sort (CDSort) algorithm for; /// ordering functions represented by a call graph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:21,Performance,queue,queue,21,// Create a priority queue containing all edges ordered by the merge gain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:29,Performance,queue,queue,29,// Insert the edges into the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:34,Performance,queue,queue,34,// Remove outdated edges from the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:39,Performance,queue,queue,39,// Insert newly created edges into the queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:61,Deployability,update,update,61,"/// Given a list of merge types, try to merge two chains and update Gain; /// with a better alternative.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:56,Deployability,update,update,56,"// Apply the merge, compute the corresponding gain, and update the best; // value, if the merge is beneficial.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:16,Integrability,depend,depend,16,// This doesn't depend on the ordering of the nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cache,3,// Cache misses on the chains before merging.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:3,Performance,Cache,Cache,3,// Cache misses on the merged chain,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:38,Deployability,update,update,38,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:122,Performance,cache,cached,122,"/// Merge chain From into chain Into, update the list of active chains,; /// adjacency information, and the corresponding cached values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:20,Safety,avoid,avoid,20,// Using doubles to avoid overflow of ExecutionCounts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:4,Modifiability,Config,Config,4,/// Config for the algorithm.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp:16,Modifiability,config,config,16,// Populate the config from the command-line options.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeLayout.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:408,Performance,perform,perform,408,"//===- CodeMoverUtils.cpp - CodeMover Utilities ----------------------------==//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform movements on basic blocks, and instructions; // contained within a function.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:37,Testability,log,logic,37,"// FIXME: Use SCEV and reuse GVN/CSE logic to check for equivalence between; // Values.; // Currently, isEquivalent rely on other passes to ensure equivalent conditions; // have the same value, e.g. GVN.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:8,Testability,test,tests,8,// Skip tests when we don't have PDT or DI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:128,Availability,avail,available,128,"// If OpInst is an instruction that appears earlier in the same BB as; // I, then it is okay to move since OpInst will still be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp:39,Integrability,depend,dependences,39,// Check if I has any output/flow/anti dependences with instructions from \p; // StartInst to \p EndInst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CodeMoverUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:93,Performance,optimiz,optimize,93,// Verify that the initializer is simple enough for us to handle. We are; // only allowed to optimize the initializer if it is unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:34,Usability,simpl,simple,34,// Verify that the initializer is simple enough for us to handle. We are; // only allowed to optimize the initializer if it is unique.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp:27,Performance,optimiz,optimizing,27,"// Loop over global ctors, optimizing them when we can.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/CtorUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:55,Performance,optimiz,optimizations,55,"//===- Debugify.cpp - Check debug info preservation in optimizations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file In the `synthetic` mode, the `-debugify` attaches synthetic debug info; /// to everything. It can be used to create targeted tests for debug info; /// preservation. In addition, when using the `original` mode, it can check; /// original debug info preservation. The `synthetic` mode is default one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:516,Testability,test,tests,516,"//===- Debugify.cpp - Check debug info preservation in optimizations ------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file In the `synthetic` mode, the `-debugify` attaches synthetic debug info; /// to everything. It can be used to create targeted tests for debug info; /// preservation. In addition, when using the `original` mode, it can check; /// original debug info preservation. The `synthetic` mode is default one.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:63,Deployability,update,updates,63,// Maintain an insertion point which can't be invalidated when updates; // are made.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:174,Testability,test,tests,174,"// Make sure we emit at least one dbg.value, otherwise MachineDebugify may; // not have anything to work with as it goes about inserting DBG_VALUEs.; // (It's common for MIR tests to be written containing skeletal IR with; // empty functions -- we're still interested in debugifying the MIR within; // those tests, and this helps with that.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:308,Testability,test,tests,308,"// Make sure we emit at least one dbg.value, otherwise MachineDebugify may; // not have anything to work with as it goes about inserting DBG_VALUEs.; // (It's common for MIR tests to be written containing skeletal IR with; // empty functions -- we're still interested in debugifying the MIR within; // those tests, and this helps with that.)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:42,Modifiability,variab,variables,42,// Track the number of distinct lines and variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:22,Modifiability,variab,variables,22,// Original number of variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:83,Modifiability,variab,variables,83,"// Strip out all debug intrinsics and supporting metadata (subprograms, types,; // variables, etc).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:44,Modifiability,variab,variable,44,// Collect debug locations (!dbg) and debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Skip inlined variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:15,Safety,avoid,avoid,15,"// In order to avoid pointer reuse/recycling, skip the values that might; // have been deleted during a pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:50,Modifiability,variab,variable,50,// This checks the preservation of original debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:44,Modifiability,variab,variable,44,// Collect debug locations (!dbg) and debug variable intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Skip inlined variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:207,Availability,failure,failures,207,"// The size of a dbg.value's value operand should match the size of the; // variable it corresponds to.; //; // TODO: This, along with a check for non-null value operands, should be; // promoted to verifier failures.; // For now, don't try to interpret anything more complicated than an empty; // DIExpression. Eventually we should try to handle OP_deref and fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:76,Modifiability,variab,variable,76,"// The size of a dbg.value's value operand should match the size of the; // variable it corresponds to.; //; // TODO: This, along with a check for non-null value operands, should be; // promoted to verifier failures.; // For now, don't try to interpret anything more complicated than an empty; // DIExpression. Eventually we should try to handle OP_deref and fragments.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:16,Modifiability,variab,variables,16,// Find missing variables and mis-sized debug values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp:3,Deployability,Update,Update,3,// Update DI loss statistics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Debugify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:142,Energy Efficiency,allocate,allocated,142,"/// DemoteRegToStack - This function takes a virtual register computed by an; /// Instruction and replaces it with a slot in the stack frame, allocated via; /// alloca. This allows the CFG to be changed around without fear of; /// invalidating the SSA information for the value. It returns the pointer to; /// the alloca inserted to create a stack slot for I.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:44,Performance,load,load,44,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:101,Performance,load,load,101,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:287,Performance,load,loads,287,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:378,Performance,load,load,378,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:494,Performance,load,loads,494,"// If this is a PHI node, we can't insert a load of the value before the; // use. Instead insert the load in the predecessor block corresponding; // to the incoming value.; //; // Note that if there are multiple edges from a basic block to this PHI; // node that we cannot have multiple loads. The problem is that the; // resulting PHI node will have multiple values (from each load) coming in; // from the same block, which is illegal SSA form. For this reason, we; // keep track of and reuse loads we insert.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:14,Performance,load,load,14,// Insert the load into the predecessor block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:50,Performance,load,load,50,"// If this is a normal instruction, just insert a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:137,Energy Efficiency,allocate,allocated,137,/// DemotePHIToStack - This function takes a virtual register computed by a PHI; /// node and replaces it with a slot in the stack frame allocated via alloca.; /// The PHI node is deleted. It returns the pointer to the alloca inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:12,Performance,load,load,12,// Insert a load in place of the PHI and replace all uses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp:22,Performance,load,load,22,// We need a separate load before each actual use of the PHI,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DemoteRegToStack.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp:25,Deployability,Upgrade,Upgrade,25,"//===- DXILUpgrade.cpp - Upgrade DXIL metadata to LLVM constructs ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp:21,Security,validat,validation,21,"// We don't need the validation version internally, so we drop it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/DXILUpgrade.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp:197,Usability,Simpl,Simply,197,// The asm in a naked function may reasonably expect the argument registers; // and the return address register (if present) to be live. An inserted; // function call will clobber these registers. Simply skip naked functions for; // all targets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EntryExitInstrumenter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp:23,Usability,resume,resume,23,"// Find all 'return', 'resume', and 'unwind' instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp:52,Usability,resume,resume,52,"// Branches and invokes do not escape, only unwind, resume, and return; // do.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/EscapeEnumerator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:340,Safety,avoid,avoid,340,/// Return true if the specified constant can be handled by the code generator.; /// We don't want to generate something like:; /// void *X = &X/42;; /// because the code generator doesn't have a relocation that can handle that.; ///; /// This function should be called if C was not found (but just got inserted); /// in SimpleConstants to avoid having to rescan the same constants all the; /// time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:321,Usability,Simpl,SimpleConstants,321,/// Return true if the specified constant can be handled by the code generator.; /// We don't want to generate something like:; /// void *X = &X/42;; /// because the code generator doesn't have a relocation that can handle that.; ///; /// This function should be called if C was not found (but just got inserted); /// in SimpleConstants to avoid having to rescan the same constants all the; /// time.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Usability,Simpl,Simple,3,"// Simple global addresses are supported, do not allow dllimport or; // thread-local globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Usability,Simpl,Simple,3,"// Simple integer, undef, constant aggregate zero, etc are all supported.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:24,Safety,safe,safe,24,// Aggregate values are safe if all their elements are.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:128,Safety,safe,safe,128,"// We don't know exactly what relocations are allowed in constant expressions,; // so we allow &global+constantoffset, which is safe and uniformly supported; // across targets.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:24,Usability,simpl,simple,24,// GEP is fine if it is simple + constant offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:12,Usability,simpl,simple,12,// We allow simple+cst.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:49,Performance,load,load,49,"/// Return the value that would be computed by a load from P after the stores; /// reflected by 'memory' have been performed. If we can't decide, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:115,Performance,perform,performed,115,"/// Return the value that would be computed by a load from P after the stores; /// reflected by 'memory' have been performed. If we can't decide, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:15,Security,access,accesses,15,// no volatile accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:93,Modifiability,variab,variable,93,// If this might be too difficult for the backend to handle (e.g. the addr; // of one global variable divided by another) then we can't commit it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:15,Security,access,accesses,15,// no volatile accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:22,Performance,load,load,22,// Could not evaluate load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,Safety,safe,safely,18,// Debug info can safely be ignored here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:3,Safety,Avoid,Avoid,3,// Avoid the byte-per-byte scan if we're memseting a zeroinitializer; // to zero.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:19,Usability,resume,resume,19,"// invoke, unwind, resume, unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:196,Safety,detect,detect,196,"// ExecutedBlocks - We only handle non-looping, non-recursive code. As such,; // we can only evaluate any one basic block at most once. This set keeps; // track of what we have executed so we can detect recursive cases etc.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:18,Safety,avoid,avoid,18,// Initialized to avoid compiler warnings.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:151,Security,access,accesses,151,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp:104,Usability,simpl,simple,104,"// The Evaluator can look through pointer casts as long as alias; // analysis holds because it's just a simple interpreter and doesn't; // skip memory accesses due to invariant group metadata, but we can't; // let users of Evaluator use a value that's been gleaned looking; // through stripping pointer casts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Evaluator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:33,Integrability,wrap,wrappers,33,// namespace llvm; // Overloaded wrappers to go with the function template below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:9,Performance,optimiz,optimization,9,"// Minor optimization: The SCC blocks are usually discovered in an order; // that is the opposite of the order in which these blocks appear as branch; // targets. This results in a lot of condition inversions in the control; // flow out of the new ControlFlowHub, which can be mitigated if the orders; // match. So we discover the headers using the reverse of the block order.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,Energy Efficiency,reduce,reduced,12,"// Any SCCs reduced are now already in the list of top-level loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:71,Usability,simpl,simply,71,"// Any SCCs reduced are now already in the list of top-level loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:12,Energy Efficiency,reduce,reduced,12,"// Any SCCs reduced are now already in the list of child loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp:67,Usability,simpl,simply,67,"// Any SCCs reduced are now already in the list of child loops, so simply; // add them all to the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FixIrreducible.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:383,Energy Efficiency,Reduce,Reduce,383,"//===- FlatternCFG.cpp - Code to perform CFG flattening -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Reduce conditional branches in CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:33,Performance,perform,perform,33,"//===- FlatternCFG.cpp - Code to perform CFG flattening -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Reduce conditional branches in CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:19,Safety,avoid,avoid,19,"// For simplicity, avoid cases containing PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, avoid cases containing PHI nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:59,Safety,safe,safe,59,// Instructions in the internal condition blocks should be safe; // to hoist up.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:31,Availability,down,downstream,31,// make CB unreachable and let downstream to delete the block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:34,Integrability,depend,dependency,34,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:62,Safety,avoid,avoided,62,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity and speed, data dependency check can be; // avoided if read from memory doesn't exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp:64,Safety,safe,safe,64,// Check whether \param SecondEntryBlock has side-effect and is safe to; // speculate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FlattenCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:23,Integrability,rout,routine,23,"// TODO: the following routine coerce the metadata contents into constants; // or MDStrings before comparison.; // It ignores any other cases, so that the metadata nodes are considered; // equal even though this is not correct.; // We should structurally compare the metadata nodes to be perfect here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:37,Performance,optimiz,optimization,37,/// These metadata affects the other optimization passes by making assertions; /// or constraints.; /// Values that carry different expectations should be considered different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:67,Testability,assert,assertions,67,/// These metadata affects the other optimization passes by making assertions; /// or constraints.; /// Values that carry different expectations should be considered different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:127,Integrability,depend,depending,127,"// This handles ConstantDataArray and ConstantDataVector. Note that we; // compare the two raw data arrays, which might differ depending on the host; // endianness. This isn't a problem though, because the endiness of a module; // will affect the order of the constants, but this order is the same; // for a given input module and host platform.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:21,Safety,abort,abort,21,"// Unknown constant, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:115,Testability,test,test,115,"// Differences from Instruction::isSameOperationAs:; // * replace type comparison with calls to cmpTypes.; // * we test for I->getRawSubclassOptionalData (nuw/nsw/tail) at the top.; // * because of the above, we don't test for the tail bit on calls later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:218,Testability,test,test,218,"// Differences from Instruction::isSameOperationAs:; // * replace type comparison with calls to cmpTypes.; // * we test for I->getRawSubclassOptionalData (nuw/nsw/tail) at the top.; // * because of the above, we don't test for the tail bit on calls later on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:40,Performance,perform,perform,40,// Determine whether two GEP operations perform the same underlying arithmetic.; // Read method declaration comments for more details.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:51,Availability,down,down,51,"// When we have target data, we can reduce the GEP down to the value in bytes; // added to the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:36,Energy Efficiency,reduce,reduce,36,"// When we have target data, we can reduce the GEP down to the value in bytes; // added to the address.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:179,Safety,detect,detect,179,"/// Compare two values used by the two functions under pair-wise comparison. If; /// this is the first time the values are seen, they're added to the mapping so; /// that we will detect mismatches on next use.; /// See comments in declaration for more details.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:3,Testability,Test,Test,3,// Test whether two basic blocks have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp:3,Testability,Test,Test,3,// Test whether the two functions have equivalent behaviour.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionComparator.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:458,Performance,perform,perform,458,"//===- lib/Transforms/Utils/FunctionImportUtils.cpp - Importing utilities -===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the FunctionImportGlobalProcessing class, used; // to perform the necessary global value handling for function importing.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:188,Safety,avoid,avoid,188,"/// Uses the ""source_filename"" instead of a Module hash ID for the suffix of; /// promoted locals during LTO. NOTE: This requires that the source filename; /// has a unique name / path to avoid name collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:51,Security,hash,hash,51,"/// Uses the ""source_filename"" instead of a Module hash ID for the suffix of; /// promoted locals during LTO. NOTE: This requires that the source filename; /// has a unique name / path to avoid name collisions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:55,Modifiability,variab,variable,55,// Both the imported references and the original local variable must; // be promoted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:112,Usability,simpl,simply,112,"// We don't know for sure yet if we are importing this value (as either; // a reference or a def), since we are simply walking all values in the; // module. But by necessity if we end up importing it and it is local,; // it must be promoted, so unconditionally promote all values in the; // importing module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:88,Usability,GUID,GUID,88,"// When exporting, consult the index. We can have more than one local; // with the same GUID, in the case of same-named locals in different but; // same-named source files that were compiled in their respective directories; // (so the source file name and resulting GUID is the same). Find the one; // in this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:266,Usability,GUID,GUID,266,"// When exporting, consult the index. We can have more than one local; // with the same GUID, in the case of same-named locals in different but; // same-named source files that were compiled in their respective directories; // (so the source file name and resulting GUID is the same). Find the one; // in this module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:39,Testability,log,logic,39,// This needs to stay in sync with the logic in buildModuleSummaryIndex.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:13,Modifiability,variab,variable,13,"// Any local variable that is referenced by an exported function needs; // to be promoted to global scope. Since we don't currently know which; // functions reference which local variables/functions, we must treat; // all as potentially exported if this module is exporting anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:179,Modifiability,variab,variables,179,"// Any local variable that is referenced by an exported function needs; // to be promoted to global scope. Since we don't currently know which; // functions reference which local variables/functions, we must treat; // all as potentially exported if this module is exporting anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:121,Availability,avail,available,121,"// External and linkonce definitions are converted to available_externally; // definitions upon import, so that they are available for inlining; // and/or optimization, but are turned into declarations later; // during the EliminateAvailableExternally pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:155,Performance,optimiz,optimization,155,"// External and linkonce definitions are converted to available_externally; // definitions upon import, so that they are available for inlining; // and/or optimization, but are turned into declarations later; // during the EliminateAvailableExternally pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:56,Modifiability,variab,variable,56,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:229,Testability,assert,assert,229,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:291,Usability,simpl,simply,291,"// It would be incorrect to import an appending linkage variable,; // since it would cause global constructors/destructors to be; // executed multiple times. This should have already been handled; // by linkIfNeeded, and we will assert in shouldLinkFromSource; // if we try to import, so we simply return AppendingLinkage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:24,Modifiability,variab,variables,24,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:153,Modifiability,variab,variable,153,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:260,Modifiability,variab,variables,260,"// Mark read/write-only variables which can be imported with specific; // attribute. We can't internalize them now because IRMover will fail; // to link variable definitions to their external declarations during; // ThinLTO import. We'll internalize read-only variables later, after; // import is finished. See internalizeGVsAfterImport.; //; // If global value dead stripping is not enabled in summary then; // propagateConstants hasn't been run. We can't internalize GV; // in such case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:49,Usability,GUID,GUID,49,"// We can have more than one local with the same GUID, in the case of; // same-named locals in different but same-named source files that were; // compiled in their respective directories (so the source file name; // and resulting GUID is the same). Find the one in this module.; // Handle the case where there is no summary found in this module. That; // can happen in the distributed ThinLTO backend, because the index only; // contains summaries from the source modules if they are being imported.; // We might have a non-null VI and get here even in that case if the name; // matches one in this module (e.g. weak or appending linkage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:231,Usability,GUID,GUID,231,"// We can have more than one local with the same GUID, in the case of; // same-named locals in different but same-named source files that were; // compiled in their respective directories (so the source file name; // and resulting GUID is the same). Find the one in this module.; // Handle the case where there is no summary found in this module. That; // can happen in the distributed ThinLTO backend, because the index only; // contains summaries from the source modules if they are being imported.; // We might have a non-null VI and get here even in that case if the name; // matches one in this module (e.g. weak or appending linkage).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:169,Safety,avoid,avoid,169,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:115,Security,access,access,115,"// Objects referenced by writeonly GV initializer should not be; // promoted, because there is no any kind of read access to them; // on behalf of this writeonly GV. To avoid promotion we convert; // GV initializer to 'zeroinitializer'. This effectively drops; // references in IR module (not in combined index), so we can; // ignore them when computing import. We do not export references; // of writeonly object. See computeImportForReferencedGlobals",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:120,Security,access,access,120,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:8,Usability,Clear,ClearDSOLocalOnDeclarations,8,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:45,Usability,clear,clear,45,"// When ClearDSOLocalOnDeclarations is true, clear dso_local if GV is; // converted to a declaration, to disable direct access. Don't do this if GV; // is implicitly dso_local due to a non-default visibility.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp:32,Availability,avail,available,32,"// Remove functions imported as available externally defs from comdats,; // as this is a declaration for the linker, and will be dropped eventually.; // It is illegal for comdats to contain declarations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/FunctionImportUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:87,Deployability,release,release,87,"/// Return the stronger of the two ordering. If the two orderings are acquire; /// and release, then return AcquireRelease.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:10,Safety,safe,safe,10,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that while constants cannot be cyclic, they can be tree-like, so we; /// should keep a visited set to avoid exponential runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:190,Safety,avoid,avoid,190,"/// It is safe to destroy a constant iff it is only used by constants itself.; /// Note that while constants cannot be cyclic, they can be tree-like, so we; /// should keep a visited set to avoid exponential runtime.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:26,Performance,load,loads,26,// Don't hack on volatile loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:77,Security,access,accessed,77,"// Look through selects and PHIs to find if the pointer is; // conditionally accessed. Make sure we only visit an instruction; // once; otherwise, we can get infinite recursion or exponential; // compile time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp:17,Performance,load,load,17,// Any other non-load instruction might take address!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GlobalStatus.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp:402,Performance,perform,perform,402,"//===-- GuardUtils.cpp - Utils for work with guards -------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; // Utils that are used to perform transformations related to guards and their; // conditions.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/GuardUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:7,Integrability,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:54,Integrability,inject,injection,54,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:7,Security,Inject,InjectTLIMAppings,7,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:54,Security,inject,injection,54,"//===- InjectTLIMAppings.cpp - TLI to VFABI attribute injection ----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Populates the VFABI attribute with the scalar-to-vector mappings; // from the TargetLibraryInfo.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp:26,Energy Efficiency,power,powers,26,// All VFs in the TLI are powers of 2.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InjectTLIMappings.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:36,Performance,perform,perform,36,"//===- InlineFunction.cpp - Code to perform function inlining -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements inlining of a function into a call site, resolving; // parameters and the return value as appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:104,Performance,optimiz,optimizations,104,"// Disabled by default, because the added alignment assumptions may increase; // compile-time and block optimizations. This option is not suitable for use; // with frontends that emit comprehensive parameter alignment annotations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:33,Usability,resume,resume,33,/// Destination for the callee's resume.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:17,Usability,resume,resume,17,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is; /// a simple branch. When there is more than one predecessor, we need to; /// split the landing pad block after the landingpad instruction and jump; /// to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:145,Usability,simpl,simple,145,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is; /// a simple branch. When there is more than one predecessor, we need to; /// split the landing pad block after the landingpad instruction and jump; /// to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:75,Usability,Resume,ResumeInsts,75,// end anonymous namespace; /// Get or create a target for the branch from ResumeInsts.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:17,Usability,resume,resume,17,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is a simple; /// branch. When there is more than one predecessor, we need to split the; /// landing pad block after the landingpad instruction and jump to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:140,Usability,simpl,simple,140,"/// Forward the 'resume' instruction to the caller's landing pad block.; /// When the landing pad block has only one predecessor, this is a simple; /// branch. When there is more than one predecessor, we need to split the; /// landing pad block after the landingpad instruction and jump to there.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the PHIs in the destination. They were inserted in an order which; // makes this work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:113,Deployability,update,update,113,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:241,Deployability,update,updated,241,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:147,Performance,queue,queue,147,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:255,Performance,queue,queued,255,"// We only put pads on the worklist that aren't in the MemoMap. When; // we find an unwind dest for a pad we may update its ancestors, but; // the queue only ever contains uncles/great-uncles/etc. of CurrentPad,; // so they should never get updated while queued on the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:144,Usability,Simpl,SimplifyCFGOpt,144,"// Catchswitch doesn't have a 'nounwind' variant, and one might be; // annotated as ""unwinds to caller"" when really it's nounwind (see; // e.g. SimplifyCFGOpt::SimplifyUnreachable), so we can't infer the; // parent's unwind dest from this. We can check its catchpads'; // descendants, since they might include a cleanuppad with an; // ""unwinds to caller"" cleanupret, which can be trusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:160,Usability,Simpl,SimplifyUnreachable,160,"// Catchswitch doesn't have a 'nounwind' variant, and one might be; // annotated as ""unwinds to caller"" when really it's nounwind (see; // e.g. SimplifyCFGOpt::SimplifyUnreachable), so we can't infer the; // parent's unwind dest from this. We can check its catchpads'; // descendants, since they might include a cleanuppad with an; // ""unwinds to caller"" cleanupret, which can be trusted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:119,Availability,error,error,119,"// Intentionally ignore invokes here -- since the catchswitch is; // marked ""unwind to caller"", it would be a verifier error if it; // contained an invoke which unwinds out of it, so any invoke we'd; // encounter must unwind to some child of the catch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:43,Performance,queue,queue,43,// Haven't figured out this child pad yet; queue it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:36,Performance,queue,queue,36,// Haven't resolved this child yet; queue it and keep searching.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:66,Performance,queue,queued,66,"// If we haven't found an unwind dest for CurrentPad, we may have queued its; // children, so move on to the next in the worklist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:717,Availability,avail,available,717,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:809,Availability,down,down,809,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:251,Integrability,rout,routine,251,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:783,Integrability,rout,routine,783,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:990,Modifiability,rewrite,rewrite,990,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:849,Safety,avoid,avoid,849,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:933,Safety,avoid,avoid,933,"/// Given an EH pad, find where it unwinds. If it unwinds to an EH pad,; /// return that pad instruction. If it unwinds to caller, return; /// ConstantTokenNone. If it does not have a definitive unwind destination,; /// return nullptr.; ///; /// This routine gets invoked for calls in funclets in inlinees when inlining; /// an invoke. Since many funclets don't have calls inside them, it's queried; /// on-demand rather than building a map of pads to unwind dests up front.; /// Determining a funclet's unwind dest may require recursively searching its; /// descendants, and also ancestors and cousins if the descendants don't provide; /// an answer. Since most funclets will have their unwind dest immediately; /// available as the unwind dest of a catchswitch or cleanupret, this routine; /// searches top-down from the given pad and then up. To avoid worst-case; /// quadratic run-time given that approach, it uses a memo map to avoid; /// re-processing funclet trees. The callers that rewrite the IR as they go; /// take advantage of this, for correctness, by checking/forcing rewritten; /// pads' entries to match the original callee view.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:21,Availability,avail,available,21,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:321,Safety,avoid,avoid,321,"// No information is available for this EHPad from itself or any of its; // descendants. An unwind all the way out to a pad in the caller would; // need also to agree with the unwind dest of the parent funclet, so; // search up the chain to try to find a funclet with information. Put; // null entries in the memo map to avoid re-processing as we go up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:413,Testability,assert,assert,413,"// If the MemoMap had an entry mapping AncestorPad to nullptr, since we; // haven't yet called getUnwindDestTokenHelper for AncestorPad in this; // call to getUnwindDestToken, that would mean that AncestorPad had no; // information in itself, its descendants, or its ancestors. If that; // were the case, then we should also have recorded the lack of information; // for the descendant that we're coming from. So assert that we don't; // find a null entry in the MemoMap for AncestorPad.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:276,Availability,down,downward,276,"// We know that getUnwindDestTokenHelper was called on LastUselessPad and; // returned nullptr (and likewise for EHPad and any of its ancestors up to; // LastUselessPad), so LastUselessPad has no information from below. Since; // getUnwindDestTokenHelper must investigate all downward paths through; // no-information nodes to prove that a node has no information like this,; // and since any time it finds information it records it in the MemoMap for; // not just the immediately-containing funclet but also any ancestors also; // exited, it must be the case that, walking downward from LastUselessPad,; // visiting just those nodes which have not been mapped to an unwind dest; // by getUnwindDestTokenHelper (the nullptr TempMemos notwithstanding, since; // they are just used to keep getUnwindDestTokenHelper from repeating work),; // any node visited must have been exhaustively searched with no information; // for it found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:574,Availability,down,downward,574,"// We know that getUnwindDestTokenHelper was called on LastUselessPad and; // returned nullptr (and likewise for EHPad and any of its ancestors up to; // LastUselessPad), so LastUselessPad has no information from below. Since; // getUnwindDestTokenHelper must investigate all downward paths through; // no-information nodes to prove that a node has no information like this,; // and since any time it finds information it records it in the MemoMap for; // not just the immediately-containing funclet but also any ancestors also; // exited, it must be the case that, walking downward from LastUselessPad,; // visiting just those nodes which have not been mapped to an unwind dest; // by getUnwindDestTokenHelper (the nullptr TempMemos notwithstanding, since; // they are just used to keep getUnwindDestTokenHelper from repeating work),; // any node visited must have been exhaustively searched with no information; // for it found.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:302,Availability,down,downward,302,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Testability,Assert,Assert,3,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:247,Testability,assert,assert,247,// Assert as we enumerate users that 'UselessPad' doesn't have any unwind; // information that we'd be contradicting by making a map entry for it; // (which is something that getUnwindDestTokenHelper must have proved for; // us to get here). Just assert on is direct users here; the checks in; // this downward walk at its descendants will verify that they don't have; // any unwind edges that exit 'UselessPad' either (i.e. they either have no; // unwind edges or unwind to a sibling).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:196,Modifiability,rewrite,rewrites,196,"/// When we inline a basic block into an invoke,; /// we have to turn all of the calls that can throw into invokes.; /// This function analyze BB to see if there are any calls, and if so,; /// it rewrites them to be invokes that jump to InvokeDest and fills in the PHI; /// nodes in that block with the values specified in InvokeDestPHIValues.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:369,Testability,log,logic,369,"// We do not need to (and in fact, cannot) convert possibly throwing calls; // to @llvm.experimental_deoptimize (resp. @llvm.experimental.guard) into; // invokes. The caller's ""segment"" of the deoptimization continuation; // attached to the newly inlined @llvm.experimental_deoptimize; // (resp. @llvm.experimental.guard) call should contain the exception; // handling logic, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:151,Modifiability,rewrite,rewrite,151,"// The inlined code is currently at the end of the function, scan from the; // start of the inlined code to its end, checking for stuff we need to; // rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the exceptional block to indicate that there; // is now a new entry in them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:15,Usability,resume,resumes,15,// Forward any resumes that are remaining here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:351,Integrability,rout,routed,351,"// This catchswitch has no parent to inherit constraints from, and; // none of its descendants can have an unwind edge that exits it and; // targets another funclet in the inlinee. It may or may not have a; // descendant that definitively has an unwind to caller. In either; // case, we'll have to assume that any unwinds out of it may need to; // be routed to the caller, so treat it as though it has a definitive; // unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Modifiability,inherit,inherit,37,"// This catchswitch has no parent to inherit constraints from, and; // none of its descendants can have an unwind edge that exits it and; // targets another funclet in the inlinee. It may or may not have a; // descendant that definitively has an unwind to caller. In either; // case, we'll have to assume that any unwinds out of it may need to; // be routed to the caller, so treat it as though it has a definitive; // unwind to caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in the exceptional block to indicate that there; // is now a new entry in them.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:35,Performance,perform,performed,35,"// Because of the context trimming performed during matching, the callsite; // context could have more stack ids than the MIB. We match up to the end of; // the shortest stack context.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,"// Update the metadata on the inlined copy ClonedCall of a call OrigCall in the; // inlined callee body, based on the callsite metadata InlinedCallsiteMD from; // the call that was inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:59,Deployability,update,update,59,"// Check if the call originally had callsite metadata, and update it for the; // new call in the inlined body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update any memprof metadata on the cloned call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,"// Update memprof related metadata (!memprof and !callsite) based on the; // inlining of Callee into the callsite at CB. The updates include merging the; // inlined callee's callsite metadata with that of the inlined call,; // and moving the subset of any memprof contexts to the inlined callee; // allocations if they match the new inlined call stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:125,Deployability,update,updates,125,"// Update memprof related metadata (!memprof and !callsite) based on the; // inlining of Callee into the callsite at CB. The updates include merging the; // inlined callee's callsite metadata with that of the inlined call,; // and moving the subset of any memprof contexts to the inlined callee; // allocations if they match the new inlined call stack.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:16,Deployability,update,update,16,"// Only need to update if the inlined callsite had callsite metadata, or if; // there was any memprof metadata inlined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:73,Usability,simpl,simplified,73,"// See if this is a call that has been inlined and remapped, and not; // simplified away in the process.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:82,Security,access,access,82,"/// When inlining a call site that has !llvm.mem.parallel_loop_access,; /// !llvm.access.group, !alias.scope or !noalias metadata, that metadata should; /// be propagated to all memory-accessing cloned instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:185,Security,access,accessing,185,"/// When inlining a call site that has !llvm.mem.parallel_loop_access,; /// !llvm.access.group, !alias.scope or !noalias metadata, that metadata should; /// be propagated to all memory-accessing cloned instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:56,Security,access,access,56,// This metadata is only relevant for instructions that access memory.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:225,Performance,load,loads,225,"/// If the inlined function has noalias arguments,; /// then add new alias scopes for each noalias argument, tag the mapped noalias; /// parameters with noalias metadata specifying the new scope, and tag all; /// non-derived loads, stores and memory intrinsics with the new alias scopes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:34,Modifiability,variab,variable,34,"// To do a good job, if a noalias variable is captured, we need to know if; // the capture point dominates the particular use we're considering.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,Security,Access,Accesses,186,"// noalias indicates that pointer values based on the argument do not alias; // pointer values which are not based on it. So we add a new ""scope"" for each; // noalias function argument. Accesses using pointers based on that argument; // become part of that alias scope, accesses using pointers not based on that; // argument are tagged as noalias with that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:270,Security,access,accesses,270,"// noalias indicates that pointer values based on the argument do not alias; // pointer values which are not based on it. So we add a new ""scope"" for each; // noalias function argument. Accesses using pointers based on that argument; // become part of that alias scope, accesses using pointers not based on that; // argument are tagged as noalias with that scope.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:202,Integrability,depend,dependencies,202,"// Note: We always create a new anonymous root here. This is true regardless; // of the linkage of the callee because the aliasing ""scope"" is not just a; // property of the callee, but also all control dependencies in the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:64,Security,access,access,64,"// Iterate over all new instructions in the map; for all memory-access; // instructions, add the alias scope metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Security,access,access,37,"// If we know that the call does not access memory, then we'll still; // know that about the inlined clone of this call site, and we don't; // need to add metadata.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:67,Security,access,accessed,67,"// Only care about pointer arguments. If a noalias argument is; // accessed through a non-pointer argument, it must be captured; // first (e.g. via ptrtoint), and we protect against captures below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:61,Availability,reliab,reliably,61,// Nothing we can do if the used underlying object cannot be reliably; // determined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:331,Performance,load,load,331,"// First, we want to figure out all of the sets with which we definitely; // don't alias. Iterate over all noalias set, and add those for which:; // 1. The noalias argument is not in the set of objects from which we; // definitely derive.; // 2. The noalias argument has not yet been captured.; // An arbitrary function that might load pointers could see captured; // noalias arguments via other noalias arguments or globals, and so we; // must always check for prior capture.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:528,Integrability,depend,depend,528,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:302,Security,access,access,302,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:423,Security,access,access,423,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:510,Security,access,access,510,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:632,Security,access,access,632,"// Next, we want to figure out all of the sets to which we might belong.; // We might belong to a set if the noalias argument is in the set of; // underlying objects. If there is some non-noalias argument in our list; // of underlying objects, then we cannot add a scope because the fact; // that some access does not alias with any set of our noalias arguments; // cannot itself guarantee that it does not alias with this access; // (because there is some pointer of unknown origin involved and the; // other access might also depend on this pointer). We also cannot add; // scopes to arbitrary functions unless we know they don't access any; // non-parameter pointer-values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:119,Usability,Simpl,Simplification,119,"// Check that the cloned RetVal exists and is a call, otherwise we cannot; // add the attributes on the cloned RetVal. Simplification during inlining; // could have transformed the cloned instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:103,Integrability,depend,dependent,103,"// Backward propagation of attributes to the returned value may be incorrect; // if it is control flow dependent.; // Consider:; // @callee {; // %rv = call @foo(); // %rv2 = call @bar(); // if (%rv2 != null); // return %rv2; // if (%rv == null); // exit(); // return %rv; // }; // caller() {; // %val = call nonnull @callee(); // }; // Here we cannot add the nonnull attribute on either foo or bar. So, we; // limit the check to both RetVal and RI are in the same basic block and; // there are no throwing/exiting instructions between these instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:515,Deployability,Update,Update,515,"// Three checks.; // If the callsite has `noundef`, then a poison due to violating the; // return attribute will create UB anyways so we can always propagate.; // Otherwise, if the return value (callee to be inlined) has `noundef`, we; // can't propagate as a new poison return will cause UB.; // Finally, check if the return value has no uses whose behavior may; // change/may cause UB if we potentially return poison. At the moment this; // is implemented overly conservatively with a single-use check.; // TODO: Update the single-use check to iterate through uses and only bail; // if we have a potentially dangerous use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:22,Availability,redundant,redundant,22,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:6,Safety,avoid,avoid,6,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:22,Safety,redund,redundant,22,"// To avoid inserting redundant assumptions, we should check for assumptions; // already in the caller. To do this, we might need a DT of the caller.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:31,Testability,assert,asserted,31,"// If we can already prove the asserted alignment in the context of the; // caller, then don't bother inserting the assumption.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:114,Performance,optimiz,optimizations,114,// Always generate a memcpy of alignment 1 here because we don't know; // the alignment of the src pointer. Other optimizations can infer; // better alignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:129,Safety,safe,safe,129,"// If the called function is readonly, then it could not mutate the caller's; // copy of the byval'd memory. In this case, it is safe to elide the copy and; // temporary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:48,Safety,safe,safe,48,"// Otherwise, we have to make a memcpy to get a safe alignment. This is bad; // for code quality, but rarely happens and is required for correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:132,Performance,cache,cache,132,/// Returns a DebugLoc for a new DILocation which is a clone of \p OrigDL; /// inlined at \p InlinedAt. \p IANodes is an inlined-at cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update inlined instructions' line numbers to; /// to encode location where these instructions are inlined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Performance,Cache,Cache,3,"// Cache the inlined-at nodes as they're built so they are reused, without; // this every instruction's inlined-at chain would become distinct from each; // other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Deployability,update,updated,29,// Loop metadata needs to be updated so that the start and end locs; // reference inlined-at locations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:316,Deployability,update,update,316,"// If the inlined instruction has no line number, or if inline info; // is not being generated, make it look as if it originates from the call; // location. This is important for ((__always_inline, __nodebug__)); // functions which must use caller location for all instructions in their; // function body.; // Don't update static allocas, as they may get moved later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:18,Modifiability,variab,variables,18,// Find all local variables associated with the backing storage.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:8,Modifiability,variab,variables,8,// Skip variables from inlined functions - they are not local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:62,Modifiability,variab,variables,62,// Skip variables from inlined functions - they are not local variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update inlined instructions' DIAssignID metadata. We need to do this; /// otherwise a function inlined more than once into the same function; /// will cause DIAssignID to be shared by many instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update the block frequencies of the caller after a callee has been inlined.; ///; /// Each block cloned into the caller has its block frequency scaled by the; /// ratio of CallSiteFreq/CalleeEntryFreq. This ensures that the cloned copy of; /// callee's entry block gets the same frequency as the callsite block and the; /// relative frequencies of all cloned blocks remain the same after cloning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:4,Deployability,Update,Update,4,/// Update the branch metadata for cloned call instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:14,Deployability,update,update,14,// No need to update the callsite if it is pruned during inlining.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Availability,redundant,redundant,29,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:29,Safety,redund,redundant,29,"// FIXME: The check below is redundant and incomplete. According to spec, if a; // convergent call is missing a token, then the caller is using uncontrolled; // convergence. If the callee has an entry intrinsic, then the callee is using; // controlled convergence, and the call cannot be inlined. A proper; // implemenation of this check requires a whole new analysis that identifies; // convergence in every function. For now, we skip that and just do this one; // cursory check. The underlying assumption is that in a compiler flow that; // fully implements convergence control tokens, there is no mixing of; // controlled and uncontrolled convergent operations in the whole program.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:16,Safety,hazard,hazards,16,"// GC poses two hazards to inlining, which only occur when the callee has GC:; // 1. If the caller has no GC, then the callee's GC must be propagated to the; // caller.; // 2. If the caller has a differing GC, it is invalid to inline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:51,Performance,perform,perform,51,"// If the personality functions match, then we can perform the; // inlining. Otherwise, we can't inline.; // TODO: This isn't 100% true. Some personality functions are proper; // supersets of others and can be used in place of the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:31,Availability,toler,tolerate,31,// The MSVC personality cannot tolerate catches getting inlined into; // cleanup funclets.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:20,Availability,toler,tolerant,20,"// SEH is even less tolerant, there may not be any sort of exceptional; // funclet in the callee.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:42,Deployability,update,updated,42,// TODO: Remove this when users have been updated to the assume bundles.; // Add alignment assumptions if necessary. We do this before the inlined; // instructions are actually cloned into the caller so that we can easily; // check what will be known at the start of the inlined code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Updated,3,"// Updated caller/callee profiles only when requested. For sample loader; // inlining, the context-sensitive inlinee profile doesn't need to be; // subtracted from callee profile, and the inlined clone also doesn't need; // to be scaled based on call site count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:66,Performance,load,loader,66,"// Updated caller/callee profiles only when requested. For sample loader; // inlining, the context-sensitive inlinee profile doesn't need to be; // subtracted from callee profile, and the inlined clone also doesn't need; // to be scaled based on call site count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the BFI of blocks cloned into the caller.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Integrability,Inject,Inject,3,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Security,Inject,Inject,3,// Inject byval arguments initialization.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:37,Testability,log,logic,37,"// It may be useful to separate this logic (of handling operand; // bundles) out to a separate ""policy"" component if this gets crowded.; // Prepend the parent's deoptimization continuation to the newly; // inlined call's deoptimization continuation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:91,Safety,avoid,avoid,91,"// For 'nodebug' functions, the associated DISubprogram is always null.; // Conservatively avoid propagating the callsite debug location to; // instructions inlined from a function whose DISubprogram is not null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:44,Modifiability,variab,variables,44,// Interpret inlined stores to caller-local variables as assignments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update DIAssignID metadata attachments and uses so that they are; // unique to this inlined instance.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:14,Energy Efficiency,reduce,reduce,14,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:90,Safety,avoid,avoid,90,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:458,Safety,safe,safe,458,"// We need to reduce the strength of any inlined tail calls. For; // musttail, we have to avoid introducing potential unbounded stack; // growth. For example, if functions 'f' and 'g' are mutually recursive; // with musttail, we can inline 'g' into 'f' so long as we preserve; // musttail on the cloned call to 'f'. If either the inlined call site; // or the cloned call site is *not* musttail, the program already has; // one frame of stack growth, so it's safe to remove musttail. Here is; // a table of example transformations:; //; // f -> musttail g -> musttail f ==> f -> musttail f; // f -> musttail g -> tail f ==> f -> tail f; // f -> g -> musttail f ==> f -> f; // f -> g -> tail f ==> f -> f; //; // Inlined notail calls should remain notail calls.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:96,Safety,avoid,avoid,96,"// Call sites inlined through a 'nounwind' call site should be; // 'nounwind' as well. However, avoid marking call sites explicitly; // where possible. This helps expose more opportunities for CSE after; // inlining, commonly when the callee is an intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:163,Security,expose,expose,163,"// Call sites inlined through a 'nounwind' call site should be; // 'nounwind' as well. However, avoid marking call sites explicitly; // where possible. This helps expose more opportunities for CSE after; // inlining, commonly when the callee is an intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:157,Safety,avoid,avoid,157,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:175,Security,access,access,175,"// Leave lifetime markers for the static alloca's, scoping them to the; // function we just inlined.; // We need to insert lifetime intrinsics even at O0 to avoid invalid; // access caused by multithreaded coroutines. The check; // `Caller->isPresplitCoroutine()` would affect AlwaysInliner at O0 only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,Availability,redundant,redundant,112,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:112,Safety,redund,redundant,112,"// If the alloca is already scoped to something smaller than the whole; // function then there's no need to add redundant, less accurate markers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:62,Integrability,wrap,wrap,62,"// If the inlined code contained dynamic alloca instructions, wrap the inlined; // code with llvm.stacksave/llvm.stackrestore intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:70,Modifiability,rewrite,rewrite,70,"// If we are inlining for an invoke instruction, we must make sure to rewrite; // any call instructions into invoke instructions. This is sensitive to which; // funclet pads were top-level in the inlinee, so must be done before; // rewriting the ""parent pad"" links.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update the lexical scopes of the new funclets and callsites.; // Anything that had 'none' as its parent is now nested inside the callsite's; // EHPad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:186,Safety,safe,safe,186,"// Handle any inlined musttail call sites. In order for a new call site to be; // musttail, the source of the clone and the inlined call site must have been; // musttail. Therefore it's safe to return without merging control into the; // phi below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:242,Deployability,update,updates,242,"// Now that all of the transforms on the inlined code have taken place but; // before we splice the inlined code into the CFG and lose track of which; // blocks were actually inlined, collect the call sites. We only do this if; // call graph updates weren't requested, as those provide value handle based; // tracking of inlined call sites instead. Calls to intrinsics are not; // collected because they are not inlineable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:233,Integrability,depend,depends,233,"// Otherwise, we have the normal case, of more than one block to inline or; // multiple return sites.; // We want to clone the entire callee function into the hole between the; // ""starter"" and ""ender"" blocks. How we accomplish this depends on whether; // this is an invoke instruction or a call instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:80,Deployability,update,updated,80,"// Split the basic block. This guarantees that no PHI nodes will have to be; // updated due to new incoming edges, and make the invoke case more; // symmetric to the call case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update PHI nodes that use the ReturnBB to use the AfterCallBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:3,Deployability,Update,Update,3,// Update PHI nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp:170,Performance,optimiz,optimizations,170,"// If we inserted a phi node, check to see if it has a single value (e.g. all; // the entries are the same or undef). If so, remove the PHI so it doesn't; // block other optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InlineFunction.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp:500,Performance,optimiz,optimization,500,"//===- InstructionNamer.cpp - Give anonymous instructions names -----------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that gives instructions names, this is mostly; // useful when diffing the effect of an optimization because deleting an; // unnamed instruction can change all other instruction numbering, making the; // diff very noisy.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/InstructionNamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:615,Performance,tune,tuned,615,"//===-- IntegerDivision.cpp - Expand integer division ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains an implementation of 32bit and 64bit scalar integer; // division for targets that don't have native support. It's largely derived; // from compiler-rt's implementations of __udivsi3 and __udivmoddi4,; // but hand-tuned for targets that prefer less control flow.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:165,Performance,tune,tuned,165,"// The basic algorithm can be found in the compiler-rt project's; // implementation of __udivsi3.c. Here, we do a lower-level IR based approach; // that's been hand-tuned to lessen the amount of control flow involved.; // Some helper values",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:106,Integrability,rout,routines,106,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:203,Integrability,rout,routines,203,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:119,Modifiability,extend,extends,119,"/// Generate code to compute the remainder of two integers of bitwidth up to; /// 32 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 32 bits; that is, these routines are good for targets; /// that have no or very little suppport for smaller than 32 bit integer; /// arithmetic.; ///; /// Replace Rem with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:106,Integrability,rout,routines,106,/// Generate code to compute the remainder of two integers of bitwidth up to; /// 64 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 64 bits.; ///; /// Replace Rem with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:119,Modifiability,extend,extends,119,/// Generate code to compute the remainder of two integers of bitwidth up to; /// 64 bits. Uses the above routines and extends the inputs/truncates the; /// outputs to operate in 64 bits.; ///; /// Replace Rem with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:88,Integrability,rout,routines,88,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:185,Integrability,rout,routines,185,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:101,Modifiability,extend,extends,101,"/// Generate code to divide two integers of bitwidth up to 32 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 32 bits; that is, these routines are good for targets that have no; /// or very little support for smaller than 32 bit integer arithmetic.; ///; /// Replace Div with emulation code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 32 extend inputs, extend output and proceed; // with 32 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:88,Integrability,rout,routines,88,/// Generate code to divide two integers of bitwidth up to 64 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 64 bits.; ///; /// Replace Div with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:101,Modifiability,extend,extends,101,/// Generate code to divide two integers of bitwidth up to 64 bits. Uses the; /// above routines and extends the inputs/truncates the outputs to operate; /// in 64 bits.; ///; /// Replace Div with emulation code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:31,Modifiability,extend,extend,31,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp:46,Modifiability,extend,extend,46,"// If bitwidth smaller than 64 extend inputs, extend output and proceed; // with 64 bit division.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/IntegerDivision.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:824,Availability,redundant,redundant,824,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:966,Performance,optimiz,optimizations,966,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:824,Safety,redund,redundant,824,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:1010,Usability,simpl,simpler,1010,"//===-- LCSSA.cpp - Convert loops into loop-closed SSA form ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass transforms loops by placing phi nodes at the end of the loops for; // all values that are live across the loop boundary. For example, it turns; // the left into the right code:; //; // for (...) for (...); // if (c) if (c); // X1 = ... X1 = ...; // else else; // X2 = ... X2 = ...; // X3 = phi(X1, X2) X3 = phi(X1, X2); // ... = X3 + 4 X4 = phi(X3); // ... = X4 + 4; //; // This is still valid LLVM; the extra phi nodes are purely redundant, and will; // be trivially eliminated by InstCombine. The major benefit of this; // transformation is that it makes many other loop optimizations, such as; // LoopUnswitching, simpler.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:156,Modifiability,rewrite,rewrite,156,"/// For every instruction from the worklist, check to see if it has any uses; /// that are outside the current loop. If so, insert LCSSA PHI nodes and; /// rewrite the uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Performance,Cache,Cache,3,"// Cache the Loop ExitBlocks across this loop. We expect to get a lot of; // instructions within the same loops, computing the exit blocks is; // expensive, and we're not mutating the loop structure.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:112,Availability,avail,available,112,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:162,Testability,test,tests,162,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:313,Usability,usab,usable,313,"// We are applying the transformation; // Invoke instructions are special in that their result value is not; // available along their unwind edge. The code below tests to see whether; // DomBB dominates the value, so adjust DomBB to the normal destination; // block, which is effectively where the value is first usable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:42,Availability,alive,alive,42,// Remember that this phi makes the value alive in this block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:30,Usability,simpl,simplify,30,"// LoopSimplify might fail to simplify some loops (e.g. when indirect; // branches are involved). In such situations, it might happen that an; // exit for Loop L1 is the header of a disjoint Loop L2. Thus, when we; // create PHIs in such an exit block, we are also inserting PHIs into L2's; // header. This could break LCSSA form for L2 because these inserted PHIs; // can also have uses outside of L2. Remember all PHIs in such situation; // as to revisit than later on. FIXME: Remove this if indirectbr support; // into LoopSimplify gets improved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:16,Performance,cache,cached,16,"// If we have a cached SCEV for the original instruction, make sure the; // new LCSSA phi node is also cached. This makes sures that BECounts; // based on it will be invalidated when the LCSSA phi node is invalidated,; // which some passes rely on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:103,Performance,cache,cached,103,"// If we have a cached SCEV for the original instruction, make sure the; // new LCSSA phi node is also cached. This makes sures that BECounts; // based on it will be invalidated when the LCSSA phi node is invalidated,; // which some passes rely on.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all uses outside the loop in terms of the new PHIs we just; // inserted.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:36,Modifiability,rewrite,rewrite,36,"// If this use is in an exit block, rewrite to use the newly inserted PHI.; // This is required for correctness because SSAUpdate doesn't handle uses; // in the same block. It assumes the PHI we inserted is at the end of the; // block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Deployability,Update,Update,3,// Update pre-existing debug value uses that reside outside the loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:87,Deployability,update,update,87,// Post process PHI instructions that were inserted into another disjoint; // loop and update their exits properly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,Availability,redundant,redundant,539,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:539,Safety,redund,redundant,539,"// Remove PHI nodes that did not have any uses rewritten or add them to; // PHIsToRemove, so the caller can remove them after some additional cleanup.; // We need to redo the use_empty() check here, because even if the PHI node; // wasn't used when added to LocalPHIsToRemove, later added PHI nodes can be; // using it. This cleanup is not guaranteed to handle trees/cycles of PHI; // nodes that only are used by each other. Such situations has only been; // noticed when the input IR contains unreachable code, and leaving some extra; // redundant PHI nodes in such situations is considered a minor problem.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:18,Modifiability,variab,variable,18,// Silence unused variable warning.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:14,Safety,avoid,avoid,14,"// We want to avoid use-scanning leveraging dominance informations.; // If a block doesn't dominate any of the loop exits, the none of the values; // defined in the loop can be used outside.; // We compute the set of blocks fullfilling the conditions in advance; // walking the dominator tree upwards until we hit a loop header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:138,Modifiability,rewrite,rewrite,138,"// Look at all the instructions in the loop, checking to see if they have uses; // outside the loop. If so, put them into the worklist to rewrite those uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:3,Performance,Cache,Cached,3,// Cached analysis information for the current function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:21,Performance,perform,perform,21,// This is needed to perform LCSSA verification inside LPPassManager,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp:80,Deployability,update,updates,80,"// BPI maps terminators to probabilities, since we don't modify the CFG, no; // updates are needed to preserve it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LCSSA.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:739,Availability,error,error,739,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:793,Availability,error,error,793,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:991,Availability,error,error,991,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:400,Integrability,wrap,wraps,400,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:816,Integrability,depend,depends,816,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:943,Integrability,wrap,wrap,943,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:863,Performance,optimiz,optimization,863,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:678,Safety,safe,safely,678,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:1149,Security,expose,exposed,1149,"//===-- LibCallsShrinkWrap.cpp ----------------------------------*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass shrink-wraps a call to function if the result is not used.; // The call can set errno but is otherwise side effect free. For example:; // sqrt(val);; // is transformed to; // if (val < 0); // sqrt(val);; // Even if the result of library call is not being used, the compiler cannot; // safely delete the call because the function can set errno on error; // conditions.; // Note in many functions, the error condition solely depends on the incoming; // parameter. In this optimization, we can generate the condition can lead to; // the errno to shrink-wrap the call. Since the chances of hitting the error; // condition is low, the runtime call is effectively eliminated.; //; // These partially dead calls are usually results of C++ abstraction penalty; // exposed by inlining.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:92,Availability,error,error,92,// end anonymous namespace; // Perform the transformation to calls with errno set by domain error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:31,Performance,Perform,Perform,31,// end anonymous namespace; // Perform the transformation to calls with errno set by domain error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:63,Availability,error,error,63,// Perform the transformation to calls with errno set by range error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to calls with errno set by range error.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:72,Availability,error,errors,72,// Perform the transformation to calls with errno set by combination of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to calls with errno set by combination of errors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:11,Testability,log,log,11,// Same as log,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:243,Availability,error,error,243,"// A possible improvement is to handle the calls with the return value being; // used. If there is API for fast libcall implementation without setting; // errno, we can use the same framework to direct/wrap the call to the fast; // API in the error free path, and leave the original call in the slow path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:202,Integrability,wrap,wrap,202,"// A possible improvement is to handle the calls with the return value being; // used. If there is API for fast libcall implementation without setting; // errno, we can use the same framework to direct/wrap the call to the fast; // API in the error free path, and leave the original call in the slow path.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Integrability,Wrap,Wrap,3,// Wrap conditions that can potentially generate errno to the library call.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:3,Performance,Perform,Perform,3,// Perform the transformation to a single candidate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp:36,Deployability,update,updated,36,// Verify the dominator after we've updated it locally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LibCallsShrinkWrap.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:32,Performance,perform,perform,32,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:408,Performance,perform,perform,408,"//===- Local.cpp - Functions to perform local transformations -------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform various local transformations to the; // program.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:53,Safety,detect,detecting,53,// Max recursion depth for collectBitParts used when detecting bswap and; // bitreverse idioms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:394,Deployability,update,updated,394,"//===----------------------------------------------------------------------===//; // Local constant propagation.; //; /// ConstantFoldTerminator - If a terminator instruction is predicated on a; /// constant value, convert it into an unconditional branch to the constant; /// destination. This is a nontrivial operation because the successors of this; /// basic block must have their PHI nodes updated.; /// Also calls RecursivelyDeleteTriviallyDeadInstructions() on any branch/switch; /// conditions and indirectbr addresses this might make dead if; /// DeleteDeadConditions is true.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:9,Performance,optimiz,optimize,9,// Can't optimize uncond branch,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:78,Deployability,update,update,78,"// Removing this case may have made the condition constant. In that; // case, update CI and restart iteration through the cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update make.implicit metadata to the newly-created conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:191,Usability,simpl,simple,191,"// Guards on true are operationally no-ops. In the future we can; // consider more sophisticated tradeoffs for guards considering potential; // for check widening, but for now we keep things simple.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:34,Safety,safe,safe,34,"// TODO: These intrinsics are not safe to remove, because this may remove; // a well-defined trap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Safe,Safe,3,// Safe to delete llvm.stacksave and launder.invariant.group if dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:23,Performance,load,loads,23,// Non-volatile atomic loads from constants can be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:36,Usability,simpl,simplified,36,// Replace the instruction with its simplified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:4,Usability,Simpl,SimplifyInstructionsInBlock,4,"/// SimplifyInstructionsInBlock - Scan the specified basic block and try to; /// simplify any instructions in it and recursively delete dead instructions.; ///; /// This returns true if it changed the code, note that it can delete; /// instructions in other blocks as well in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:81,Usability,simpl,simplify,81,"/// SimplifyInstructionsInBlock - Scan the specified basic block and try to; /// simplify any instructions in it and recursively delete dead instructions.; ///; /// This returns true if it changed the code, note that it can delete; /// instructions in other blocks as well in this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:102,Usability,simpl,simplifications,102,"// In debug builds, ensure that the terminator of the block is never replaced; // or deleted by these simplifications. The idea of simplification is that it; // cannot introduce new instructions, and there is no way to replace the; // terminator of a block without introducing a new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:131,Usability,simpl,simplification,131,"// In debug builds, ensure that the terminator of the block is never replaced; // or deleted by these simplifications. The idea of simplification is that it; // cannot introduce new instructions, and there is no way to replace the; // terminator of a block without introducing a new instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:121,Safety,avoid,avoids,121,"// Iterate over the original function, only adding insts to the worklist; // if they actually need to be revisited. This avoids having to pre-init; // the worklist with the entire function's worth of instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:7,Deployability,update,updates,7,// DTU updates: Collect all the edges that enter; // PredBB. These dominator edges will be redirected to DestBB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Integrability,interface,interface,56,// The entry block was removed and there is no external interface for; // the dominator tree to be notified of this change. In this corner-case; // we recalculate the entire tree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:91,Safety,safe,safe,91,"// Shortcut, if there is only a single predecessor it must be BB and merging; // is always safe",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:224,Deployability,Update,Update,224,/// Determines the value to use as the phi node input for a block.; ///; /// Select between \p OldVal any value that we know flows from \p BB; /// to a particular phi on the basis of which one (if either) is not; /// undef. Update IncomingValues based on the selected value.; ///; /// \param OldVal The value we are considering selecting.; /// \param BB The block that the value flows in from.; /// \param IncomingValues A map from block-to-value for other phi inputs; /// that we have examined.; ///; /// \returns the selected value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Deployability,update,update,181,"// We are merging two blocks - BB, and the block containing PN - and; // as a result we need to redirect edges from the predecessors of BB; // to go to the block containing PN, and update PN; // accordingly. Since we allow merging blocks in the case where the; // predecessor and successor blocks both share some predecessors,; // and where some of those common predecessors might have undef; // values flowing into PN, we want to rewrite those values to be; // consistent with the non-undef values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:431,Modifiability,rewrite,rewrite,431,"// We are merging two blocks - BB, and the block containing PN - and; // as a result we need to redirect edges from the predecessors of BB; // to go to the block containing PN, and update PN; // accordingly. Since we allow merging blocks in the case where the; // predecessor and successor blocks both share some predecessors,; // and where some of those common predecessors might have undef; // values flowing into PN, we want to rewrite those values to be; // consistent with the non-undef values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:219,Testability,assert,asserts,219,"// Note that, since we are merging phi nodes and BB and Succ might; // have common predecessors, we could end up with a phi node with; // identical incoming branches. This will be cleaned up later (and; // will trigger asserts if we try to clean it up now, without also; // simplifying the corresponding conditional branch).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:274,Usability,simpl,simplifying,274,"// Note that, since we are merging phi nodes and BB and Succ might; // have common predecessors, we could end up with a phi node with; // identical incoming branches. This will be cleaned up later (and; // will trigger asserts if we try to clean it up now, without also; // simplifying the corresponding conditional branch).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update existing incoming values in PN for this; // predecessor of BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:12,Usability,simpl,simplify,12,// We can't simplify infinite loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:126,Safety,safe,safely,126,"// Check to see if merging these blocks/phis would cause conflicts for any of; // the phi nodes in BB or Succ. If not, we can safely merge.; // Check for cases where Succ has multiple predecessors and a PHI node in BB; // has uses which will not disappear when the PHI nodes are merged. It is; // possible to handle such cases, but difficult: it requires checking whether; // BB dominates Succ, which is non-trivial to calculate in the case where; // Succ has multiple predecessors. Also, it requires checking whether; // constructing the necessary self-referential PHI node doesn't introduce any; // conflicts; this isn't too difficult, but the previous code for doing this; // was incorrect.; //; // Note that if this check finds a live use, BB dominates Succ, so BB is; // something like a loop pre-header (or rarely, a part of an irreducible CFG);; // folding the branch isn't profitable in that case anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:6,Safety,avoid,avoid,6,// To avoid processing the same predecessor more than once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:43,Deployability,update,updates,43,// Clear the successor list of BB to match updates applying to DTU later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Usability,Clear,Clear,3,// Clear the successor list of BB to match updates applying to DTU later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:17,Testability,log,logic,17,// WARNING: this logic must be kept in sync with; // Instruction::isIdenticalToWhenDefined()!,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:166,Safety,safe,safe,166,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:13,Security,hash,hash,13,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:99,Security,expose,expose,99,"// Compute a hash value on the operands. Instcombine will likely have; // sorted them, which helps expose duplicates, but we have to check all; // the operands to be safe in case instcombine hasn't run.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:20,Security,hash,hash,20,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:85,Security,hash,hashing,85,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:243,Security,hash,hash,243,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:169,Testability,assert,assertion,169,"// If -phicse-debug-hash was specified, return a constant -- this; // will force all hashing to collide, so we'll exhaustively search; // the table for a match, and the assertion in isEqual will fire if; // there's a bug causing equal keys to hash differently.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:73,Security,hash,hash,73,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:40,Testability,assert,assert,40,"// These comparisons are nontrivial, so assert that equality implies; // hash equality (DenseMap demands this as an invariant).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:104,Safety,avoid,avoids,104,// If the preferred alignment is greater than the natural stack alignment; // then don't round up. This avoids dynamic stack realignment.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:222,Availability,reliab,reliably,222,"// If there is a large requested alignment and we can, bump up the alignment; // of the global. If the memory we set aside for the global may not be the; // memory used by the final program then it is impossible for us to reliably; // enforce the preferred alignment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,"// Avoid trouble with ridiculously large TrailZ values, such as; // those computed from a null pointer.; // LLVM doesn't support alignments larger than (1 << MaxAlignmentExponent).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:48,Modifiability,variab,variable,48,// We can't always calculate the size of the DI variable (e.g. if it is a; // VLA). Try to use the size of the alloca that the dbg intrinsic describes; // intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,// Could not determine size of variable. Conservatively return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:48,Modifiability,variab,variable,48,// We can't always calculate the size of the DI variable (e.g. if it is a; // VLA). Try to use the size of the alloca that the dbg intrinsic describes; // intead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,// Could not determine size of variable. Conservatively return false.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Energy Efficiency,allocate,allocate,56,"// RemoveDIs: if we're using the new debug-info format, allocate a; // DPValue directly instead of a dbg.value intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:56,Energy Efficiency,allocate,allocate,56,"// RemoveDIs: if we're using the new debug-info format, allocate a; // DPValue directly instead of a dbg.value intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:601,Modifiability,variab,variable,601,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:666,Modifiability,variab,variable,666,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:132,Performance,perform,perform,132,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,variab,variable,38,"// FIXME: If storing to a part of the variable described by the dbg.declare,; // then we want to insert a dbg.value for the corresponding fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Modifiability,variab,variable,50,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:175,Modifiability,variab,variable,175,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a dbg.value for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:27,Performance,load,loaded,27,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Performance,load,loaded,181,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:31,Modifiability,variab,variable,31,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:601,Modifiability,variab,variable,601,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:666,Modifiability,variab,variable,666,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:132,Performance,perform,perform,132,"// If the alloca describes the variable itself, i.e. the expression in the; // dbg.declare doesn't start with a dereference, we can perform the; // conversion if the value covers the entire fragment of DII.; // If the alloca describes the *address* of DIVar, i.e. DIExpr is; // *just* a DW_OP_deref, we use DV as is for the dbg.value.; // We conservatively ignore other dereferences, because the following two are; // not equivalent:; // dbg.declare(alloca, ..., !Expr(deref, plus_uconstant, 2)); // dbg.value(DV, ..., !Expr(deref, plus_uconstant, 2)); // The former is adding 2 to the address of the variable, whereas the latter; // is adding 2 to the value of the variable. As such, we insist on just a; // deref expression.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,variab,variable,38,"// FIXME: If storing to a part of the variable described by the dbg.declare,; // then we want to insert a dbg.value for the corresponding fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Modifiability,variab,variable,50,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:175,Modifiability,variab,variable,175,"// For now, when there is a store to parts of the variable (but we do not; // know which part) we insert an dbg.value intrinsic to indicate that we; // know nothing about the variable's content.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a dbg.value for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a DPValue for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:27,Performance,load,loaded,27,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:181,Performance,load,loaded,181,"// We are now tracking the loaded value instead of the address. In the; // future if multi-location support is added to the IR, it might be; // preferable to keep tracking both the loaded value and the original; // address in case the alloca can not be elided.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Modifiability,variab,variable,45,"// FIXME: If only referring to a part of the variable described by the; // dbg.declare, then we want to insert a DPValue for the corresponding; // fragment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:37,Modifiability,variab,variable,37,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:170,Modifiability,variab,variable,170,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:78,Performance,load,load,78,"// If this is an alloca for a scalar variable, insert a dbg.value; // at each load and store to the alloca and erase the dbg.declare.; // The dbg.values allow tracking a variable even if it is not; // stored on the stack, while the dbg.declare can only describe; // the stack slot (and at a lexical-scope granularity). Later; // passes will attempt to elide the stack slot.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:14,Performance,load,load,14,// A volatile load/store means that the alloca can't be elided anyway.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:85,Modifiability,variab,variable,85,// This is a call by-value or some other instruction that takes a; // pointer to the variable. Insert a *value* intrinsic that describes; // the variable by dereferencing the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:145,Modifiability,variab,variable,145,// This is a call by-value or some other instruction that takes a; // pointer to the variable. Insert a *value* intrinsic that describes; // the variable by dereferencing the alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:197,Deployability,update,update,197,"// Map a pair of the destination BB and old DPValue to the new DPValue,; // so that if a DPValue is being rewritten to use more than one of the; // inserted PHIs in the same destination BB, we can update the same DPValue; // with all the new PHIs instead of creating one copy for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:288,Deployability,update,updates,288,"// Then iterate through the new PHIs and look to see if they use one of the; // previously mapped PHIs. If so, create a new DPValue that will propagate; // the info through the new PHI. If we use more than one new PHI in a single; // destination BB with the same old dbg.value, merge the updates so that we; // get a single new DPValue with all the new PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting a debug-info record into an EH block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:203,Deployability,update,update,203,"// Map a pair of the destination BB and old dbg.value to the new dbg.value,; // so that if a dbg.value is being rewritten to use more than one of the; // inserted PHIs in the same destination BB, we can update the same dbg.value; // with all the new PHIs instead of creating one copy for each.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:300,Deployability,update,updates,300,"// Then iterate through the new PHIs and look to see if they use one of the; // previously mapped PHIs. If so, create a new dbg.value intrinsic that will; // propagate the info through the new PHI. If we use more than one new PHI in; // a single destination BB with the same old dbg.value, merge the updates so; // that we get a single new dbg.value with all the new PHIs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting an intrinsic into an EH block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:151,Performance,perform,performance,151,"// These are arbitrary chosen limits on the maximum number of values and the; // maximum size of a debug expression we can salvage up to, used for; // performance reasons.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:88,Deployability,update,updated,88,"// `I` may appear more than once in DII's location ops, and each use of `I`; // must be updated in the DIExpression and potentially have additional; // values added; thus we call salvageDebugInfoImpl for each `I` instance in; // DIILocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:88,Deployability,update,updated,88,"// 'I' may appear more than once in DPV's location ops, and each use of 'I'; // must be updated in the DIExpression and potentially have additional; // values added; thus we call salvageDebugInfoImpl for each 'I' instance in; // DPVLocation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite a GEP into a DIExpression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:74,Usability,simpl,simplified,74,// Add or Sub Instructions with a constant operand can potentially be; // simplified.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:49,Performance,load,load,49,"// *Not* to do: we should not attempt to salvage load instructions,; // because the validity and lifetime of a dbg.value containing; // DW_OP_deref becomes difficult to analyze. See PR40628 for examples.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:114,Deployability,update,update,114,// It's common to see a debug user between From and DomPoint. Move it; // after DomPoint to preserve the variable update without any reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:105,Modifiability,variab,variable,105,// It's common to see a debug user between From and DomPoint. Move it; // after DomPoint to preserve the variable update without any reordering.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update debug users without use-before-def risk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:45,Safety,risk,risk,45,// Update debug users without use-before-def risk.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:92,Availability,avail,available,92,// Handle integer-to-integer widening and narrowing.; // FIXME: Use DW_OP_convert when it's available everywhere.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:134,Modifiability,variab,variable,134,"// When the width of the result grows, assume that a debugger will only; // access the low `FromBits` bits when inspecting the source variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:76,Security,access,access,76,"// When the width of the result grows, assume that a debugger will only; // access the low `FromBits` bits when inspecting the source variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:90,Modifiability,variab,variable,90,// The width of the result has shrunk. Use sign/zero extension to describe; // the source variable's high bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:86,Deployability,update,update,86,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:50,Energy Efficiency,reduce,reduced,50,"// Delete the instructions backwards, as it has a reduced likelihood of; // having to update as many def-use and use-def chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Update,Update,3,// Update PHI nodes in the unwind destination,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:99,Safety,avoid,avoided,99,"// Note: we're round tripping operand bundles through memory here, and that; // can potentially be avoided with a cleverer API design that we do not have; // as of this time.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:77,Deployability,update,updates,77,"// Make sure that anything using the call now uses the invoke! This also; // updates the CallGraph if present, because it uses a WeakTrackingVH.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:165,Performance,optimiz,optimizer,165,"// Assumptions that are known to be false are equivalent to; // unreachable. Also, if the condition is undefined, then we make the; // choice most beneficial to the optimizer, and choose that to also be; // unreachable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:39,Performance,load,load,39,"// If K moves, only set the !invariant.load if it is present in both; // instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:22,Security,access,access,22,// Preserve !preserve.access.index in K.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:171,Performance,load,load,171,"// Set !invariant.group from J if J has it. If both instructions have it; // then we will just pick it from J - even when they are different.; // Also make sure that K is load or store - f.e. combining bitcast with load; // could produce bitcast with invariant.group metadata, which is invalid.; // FIXME: we should try to preserve both invariant.group md if they are; // different, but right now instruction can only have one invariant.group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:215,Performance,load,load,215,"// Set !invariant.group from J if J has it. If both instructions have it; // then we will just pick it from J - even when they are different.; // Also make sure that K is load or store - f.e. combining bitcast with load; // could produce bitcast with invariant.group metadata, which is invalid.; // FIXME: we should try to preserve both invariant.group md if they are; // different, but right now instruction can only have one invariant.group.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:79,Integrability,rout,routine,79,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:110,Performance,load,load,110,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:462,Performance,load,loads,462,"// Note, essentially every kind of metadata should be preserved here! This; // routine is supposed to clone a load instruction changing *only its type*.; // The only metadata it makes sense to drop is metadata which is invalidated; // when the pointer type changes. This should essentially never be the case; // in LLVM, but we explicitly switch over only known metadata to be; // conservatively correct. If you are adding metadata to LLVM which pertains; // to loads, you almost certainly want to add it here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Deployability,Patch,Patch,3,// Patch the replacement so that it is not more restrictive than the value; // being replaced.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:25,Performance,load,load,25,"// Note that if 'I' is a load being replaced by some operation,; // for example, by an arithmetic operation, then andIRFlags(); // would just erase all math flags from the original arithmetic; // operation, which is clearly not wanted and not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:216,Usability,clear,clearly,216,"// Note that if 'I' is a load being replaced by some operation,; // for example, by an arithmetic operation, then andIRFlags(); // would just erase all math flags from the original arithmetic; // operation, which is clearly not wanted and not needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:36,Safety,safe,safepoints,36,// Most LLVM intrinsics do not take safepoints.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:100,Availability,avail,available,100,"// Lib calls can be materialized by some passes, and won't be; // marked as 'gc-leaf-function.' All available Libcalls are; // GC-leaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:55,Performance,load,loads,55,// The only other translation we can do is to integral loads with !range; // metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Usability,Simpl,Simply,3,// Simply copy the metadata if the type did not change.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:107,Availability,reliab,reliably,107,"// Give up unless it is converted to a pointer where there is a single very; // valuable mapping we can do reliably.; // FIXME: It would be nice to propagate this in more ways, but the type; // conversions make it hard.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:863,Modifiability,Extend,Extend,863,"// Since we are moving the instructions out of its basic block, we do not; // retain their original debug locations (DILocations) and debug intrinsic; // instructions.; //; // Doing so would degrade the debugging experience and adversely affect the; // accuracy of profiling information.; //; // Currently, when hoisting the instructions, we take the following actions:; // - Remove their debug intrinsic instructions.; // - Set their debug locations to the values from the insertion point.; //; // As per PR39141 (comment #8), the more fundamental reason why the dbg.values; // need to be deleted, is because there will not be any instructions with a; // DILocation in either branch left after performing the transformation. We; // can only insert a dbg.value after the two branches are joined again.; //; // See PR38762, PR39243 for more details.; //; // TODO: Extend llvm.dbg.value to take more than one SSA Value (PR39141) to; // encode predicated DIExpressions that yield different results on different; // code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:695,Performance,perform,performing,695,"// Since we are moving the instructions out of its basic block, we do not; // retain their original debug locations (DILocations) and debug intrinsic; // instructions.; //; // Doing so would degrade the debugging experience and adversely affect the; // accuracy of profiling information.; //; // Currently, when hoisting the instructions, we take the following actions:; // - Remove their debug intrinsic instructions.; // - Set their debug locations to the values from the insertion point.; //; // As per PR39141 (comment #8), the more fundamental reason why the dbg.values; // need to be deleted, is because there will not be any instructions with a; // DILocation in either branch left after performing the transformation. We; // can only insert a dbg.value after the two branches are joined again.; //; // See PR38762, PR39243 for more details.; //; // TODO: Extend llvm.dbg.value to take more than one SSA Value (PR39141) to; // encode predicated DIExpressions that yield different results on different; // code paths.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:16,Testability,log,logical,16,"// If this is a logical shift by a constant, recurse then shift the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:3,Performance,Perform,Perform,3,"// Perform the ""shift"" on BitProvenance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:37,Availability,mask,mask,37,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:16,Testability,log,logical,16,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:47,Usability,clear,clears,47,"// If this is a logical 'and' with a mask that clears bits, recurse then; // unset the appropriate bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:18,Availability,mask,mask,18,"// Check that the mask allows a multiple of 8 bits for a bswap, for an; // early exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:40,Usability,clear,clear,40,"// If the AndMask is zero for this bit, clear the bit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:38,Modifiability,extend,extend,38,// If this is a zext instruction zero extend the result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:47,Performance,perform,perform,47,"// If the upper bits are zero, then attempt to perform as a truncated op.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:105,Usability,simpl,simple,105,"// gcroot is a special case, since it requires a constant argument which; // isn't also required to be a simple ConstantInt.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:17,Availability,mask,masks,17,// Shufflevector masks are constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp:130,Testability,log,logic,130,// Note: We explicitly check for attributes rather than using cover functions; // because some of the cover functions include the logic being implemented.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Local.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:47,Modifiability,variab,variable,47,"/// Given a loop with an deccreasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:80,Safety,safe,safely,80,"/// Given a loop with an deccreasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:58,Modifiability,variab,variable,58,// The predicate that we need to check that the induction variable lies; // within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:46,Modifiability,variab,variable,46,"/// Given a loop with an increasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:79,Safety,safe,safely,79,"/// Given a loop with an increasing induction variable, is it possible to; /// safely calculate the bounds of a new loop using the given Predicate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:58,Modifiability,variab,variable,58,// The predicate that we need to check that the induction variable lies; // within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:81,Availability,avail,available,81,"/// Returns estimate for max latch taken count of the loop of the narrowest; /// available type. If the latch block has such estimate, it is returned.; /// Otherwise, we use max exit count of whole loop (that is potentially of wider; /// type than latch check itself), which is still better than no estimate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:88,Modifiability,variab,variable,88,// `ICI` is interpreted as taking the backedge if the *next* value of the; // induction variable satisfies some constraint.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:46,Performance,optimiz,optimizations,46,// Add metadata to the loop L to disable loop optimizations. Callers need to; // confirm that optimizing loop L is not beneficial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:94,Performance,optimiz,optimizing,94,// Add metadata to the loop L to disable loop optimizations. Callers need to; // confirm that optimizing loop L is not beneficial.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:108,Modifiability,variab,variable,108,"// IterationsLeft - are there any more iterations left, given the original; // upper bound on the induction variable? If not, we branch to the ""real""; // exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:111,Deployability,update,updated,111,// The latch exit now has a branch from `RRI.ExitSelector' instead of; // `LS.Latch'. The PHI nodes need to be updated to reflect that.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:135,Deployability,update,update,135,"// We need to first add all the pre and post loop blocks into the loop; // structures (as part of createClonedLoopStructure), and then update the; // LCSSA form and LoopSimplifyForm. This is necessary for correctly updating; // LI when LoopSimplifyForm is generated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:50,Usability,Simpl,Simplify,50,// This function canonicalizes the loop into Loop-Simplify and LCSSA forms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:52,Performance,perform,perform,52,"// Pre/post loops are slow paths, we do not need to perform any loop; // optimizations on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:73,Performance,optimiz,optimizations,73,"// Pre/post loops are slow paths, we do not need to perform any loop; // optimizations on them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:128,Modifiability,variab,variable,128,"/// At this point:; /// - We've broken a ""main loop"" out of the loop in a way that the ""main loop""; /// runs with the induction variable in a subset of [Begin, End).; /// - There is no overflow when computing ""main loop"" exit limit.; /// - Max latch taken count of the loop is limited.; /// It guarantees that induction variable will not overflow iterating in the; /// ""main loop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp:320,Modifiability,variab,variable,320,"/// At this point:; /// - We've broken a ""main loop"" out of the loop in a way that the ""main loop""; /// runs with the induction variable in a subset of [Begin, End).; /// - There is no overflow when computing ""main loop"" exit limit.; /// - Max latch taken count of the loop is limited.; /// It guarantees that induction variable will not overflow iterating in the; /// ""main loop"".",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopConstrainer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:28,Usability,simpl,simplified,28,// Make sure the loop is in simplified form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:429,Deployability,update,update,429,"// The latch must either be the only exiting block or all non-latch exit; // blocks have either a deopt or unreachable terminator or compose a chain of; // blocks where the last one is either deopt or unreachable terminated. Both; // deopt and unreachable terminators are a strong indication they are not; // taken. Note that this is a profitability check, not a legality check. Also; // note that LoopPeeling currently can only update the branch weights of latch; // blocks and branch weights to blocks with deopt or unreachable do not need; // updating.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:1745,Modifiability,variab,variable,1745," {; // int x = 0;; // int y = 0;; // int a = 0;; // for(int i = 0; i <100000; ++i) {; // g(x);; // x = y;; // g(a);; // y = a + 1;; // a = 5;; // }; // }; // Peeling 3 iterations is beneficial because the values for x, y and a; // become known. The IR for this loop looks something like the following:; //; // %i = phi i32 [ 0, %entry ], [ %inc, %if.end ]; // %a = phi i32 [ 0, %entry ], [ 5, %if.end ]; // %y = phi i32 [ 0, %entry ], [ %add, %if.end ]; // %x = phi i32 [ 0, %entry ], [ %y, %if.end ]; // ...; // tail call void @_Z1gi(i32 signext %x); // tail call void @_Z1gi(i32 signext %a); // %add = add nuw nsw i32 %a, 1; // %inc = add nuw nsw i32 %i, 1; // %exitcond = icmp eq i32 %inc, 100000; // br i1 %exitcond, label %for.cond.cleanup, label %for.body; //; // The arguments for the calls to g will become known after 3 iterations; // of the loop, because the phi nodes values become known after 3 iterations; // of the loop (ie, they are known on the 4th iteration, so peel 3 iterations).; // The first iteration has g(0), g(0); the second has g(0), g(5); the; // third has g(1), g(5) and the fourth (and all subsequent) have g(6), g(5).; // Now consider the phi nodes:; // %a is a phi with constants so it is determined after iteration 1.; // %y is a phi based on a constant and %a so it is determined on; // the iteration after %a is determined, so iteration 2.; // %x is a phi based on a constant and %y so it is determined on; // the iteration after %y, so iteration 3.; // %i is based on itself (and is an induction variable) so it is; // never determined.; // This means that peeling off 3 iterations will result in being able to; // remove the phi nodes for %a, %y, and %x. The arguments for the; // corresponding calls to g are determined and the code for computing; // x, y, and a can be removed.; //; // The PhiAnalyzer class calculates how many times a loop should be; // peeled based on the above analysis of the phi nodes in the loop while; // respecting the maximum specified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:27,Safety,avoid,avoid,27,// Place Unknown to map to avoid infinite recursion. Such; // cycles can never stop on an invariant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:142,Performance,load,load,142,// unnamed namespace; // Try to find any invariant memory reads that will become dereferenceable in; // the remainder loop after peeling. The load must also be used (transitively); // by an exit condition. Returns the number of iterations to peel off (at the; // moment either 0 or 1).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:26,Performance,load,loads,26,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:119,Performance,load,loads,119,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:287,Performance,load,loads,287,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:356,Performance,load,load,356,"// Now look for invariant loads that dominate the latch and are not known to; // be dereferenceable. If there are such loads and no writes, they will become; // dereferenceable in the loop if the first iteration is peeled off. Also; // collect the set of instructions controlled by such loads. Only peel if an; // exit condition uses (transitively) such a load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Safety,Avoid,Avoid,3,"// Avoid huge SCEV computations in the loop below, make sure we only; // consider AddRecs of the loop we are trying to peel.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:12,Modifiability,extend,extending,12,// Check if extending the current DesiredPeelCount lets us evaluate Pred; // or !Pred in the loop body statically.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:298,Availability,reliab,reliable,298,"// If we don't know the trip count, but have reason to believe the average; // trip count is low, peeling should be beneficial, since we will usually; // hit the peeled section.; // We only do this in the presence of profile information, since otherwise; // our estimates of the trip count are not reliable enough.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:4,Deployability,Update,Update,4,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:617,Energy Efficiency,reduce,reduces,617,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:639,Safety,avoid,avoid,639,"/// Update the branch weights of an exiting block of a peeled-off loop; /// iteration.; /// Let F is a weight of the edge to continue (fallthrough) into the loop.; /// Let E is a weight of the edge to an exit.; /// F/(F+E) is a probability to go to loop and E/(F+E) is a probability to; /// go to exit.; /// Then, Estimated ExitCount = F / E.; /// For I-th (counting from 0) peeled off iteration we set the weights for; /// the peeled exit as (EC - I, 1). It gives us reasonable distribution,; /// The probability to go to exit 1/(EC-I) increases. At the same time; /// the estimated exit count in the remainder loop reduces by I.; /// To avoid dealing with division rounding we can just multiple both part; /// of weights to E and use weight as (F - I * E, E).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:186,Energy Efficiency,reduce,reduce,186,"// Don't set the probability of taking the edge from latch to loop header; // to less than 1:1 ratio (meaning Weight should not be lower than; // SubWeight), as this could significantly reduce the loop's hotness,; // which would be incorrect in the case of underestimating the trip count.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:22,Deployability,update,updateBranchWeights,22,// See the comment on updateBranchWeights() for an explanation of what we; // do here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:16,Deployability,update,update,16,// Don't try to update weights for degenerate case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:67,Deployability,update,update,67,"// For each block in the original loop, create a new copy,; // and update the value map with the newly created values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:24,Availability,avail,available,24,"// If dominator tree is available, insert nodes to represent cloned blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:32,Integrability,depend,depends,32,"// Identify what other metadata depends on the cloned version. After; // cloning, replace the metadata with the corrected version for both; // memory instructions and noalias intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:19,Deployability,update,updated,19,// LastValueMap is updated with the values for the current loop; // which are used the next time this function is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:470,Performance,optimiz,optimizations,470,"/// Peel off the first \p PeelCount iterations of loop \p L.; ///; /// Note that this does not peel them off as a single straight-line block.; /// Rather, each iteration is peeled off separately, and needs to check the; /// exit condition.; /// For loops that dynamically execute \p PeelCount iterations or less; /// this provides a benefit, since the peeled off iterations, which account; /// for the bulk of dynamic execution, can be further simplified by scalar; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:444,Usability,simpl,simplified,444,"/// Peel off the first \p PeelCount iterations of loop \p L.; ///; /// Note that this does not peel them off as a single straight-line block.; /// Rather, each iteration is peeled off separately, and needs to check the; /// exit condition.; /// For loops that dynamically execute \p PeelCount iterations or less; /// this provides a benefit, since the peeled off iterations, which account; /// for the bulk of dynamic execution, can be further simplified by scalar; /// optimizations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:160,Integrability,rout,routes,160,"// Remember dominators of blocks we might reach through exits to change them; // later. Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can reach it from the peeled; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:55,Deployability,update,update,55,"// If we have branch weight information, we'll want to update it for the; // newly created branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Deployability,Update,Update,3,// Update IDoms of the blocks reachable through exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:3,Deployability,Update,Update,3,// Update Metadata for count of peeled off iterations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:25,Deployability,update,update,25,"// We modified the loop, update SE.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:24,Deployability,update,update,24,// FIXME: Incrementally update loop-simplify,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp:36,Usability,simpl,simplify,36,// FIXME: Incrementally update loop-simplify,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopPeel.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:453,Testability,test,test,453,"//===----------------- LoopRotationUtils.cpp -----------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file provides utilities to convert a loop into a loop with bottom test.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:6,Usability,simpl,simple,6,/// A simple loop rotation transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:4,Modifiability,Rewrite,RewriteUsesOfClonedInstructions,4,"/// RewriteUsesOfClonedInstructions - We just cloned the instructions from the; /// old header into the preheader. If there were uses of the values produced by; /// these instruction that were outside of the loop, we have to insert PHI nodes; /// to merge the two values. Do this now.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:93,Modifiability,rewrite,rewrite,93,"// If there are no uses of the value (e.g. because it returns void), there; // is nothing to rewrite.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:209,Availability,avail,available,209,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:160,Safety,avoid,avoid,160,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:209,Availability,avail,available,209,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:160,Safety,avoid,avoid,160,"// Users in the OrigPreHeader need to use the value to which the; // original definitions are mapped and anything else can be handled by; // the SSAUpdater. To avoid adding PHINodes, check if the value is; // available in UserBB, if not substitute undef.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:227,Availability,down,down,227,"// There is at least one non-deoptimizing exit.; //; // Note, that BasicBlock::getPostdominatingDeoptimizeCall is not exact,; // as it can conservatively return false for deoptimizing exits with; // complex enough control flow down to deoptimize call.; //; // That means here we can report success for a case where; // all exits are deoptimizing but one of them has complex enough; // control flow (e.g. with loops).; //; // That should be a very rare case and false positives for this function; // have compile-time effect only.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,"// Update branch weights. Consider the following edge-counts:; //; // | |-------- |; // V V | V; // Br i1 ... | Br i1 ...; // | | | | |; // x| y| | becomes: | y0| |-----; // V V | | V V |; // Exit Loop | | Loop |; // | | | Br i1 ... |; // ----- | | | |; // x0| x1| y1 | |; // V V ----; // Exit; //; // The following must hold:; // - x == x0 + x1 # counts to ""exit"" must stay the same.; // - y0 == x - x0 == x1 # how often loop was entered at all.; // - y1 == y - y0 # How often loop was repeated (after first iter.).; //; // We cannot generally deduce how often we had a zero-trip count loop so we; // have to make a guess for how to distribute x among the new x0 and x1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:369,Safety,avoid,avoid,369,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:423,Safety,avoid,avoid,423,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:73,Usability,Simpl,SimplifiedLatch,73,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:311,Usability,simpl,simplified,311,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:335,Usability,Simpl,SimplifiedLatch,335,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:571,Usability,simpl,simplifying,571,"/// Rotate loop LP. Return true if the loop is rotated.; ///; /// \param SimplifiedLatch is true if the latch was just folded into the final; /// loop exit. In this case we may want to rotate even though the new latch is; /// now an exiting branch. This rotation would have happened had the latch not; /// been simplified. However, if SimplifiedLatch is false, then we avoid; /// rotating loops in which the latch exits to avoid excessive or endless; /// rotation. LoopRotate should be repeatable and converge to a canonical; /// form. This property is satisfied because simplifying the loop latch can only; /// happen once across multiple invocations of the LoopRotate pass.; ///; /// If -loop-rotate-multi is enabled we can do multiple rotations in one go; /// so to reach a suitable (non-deoptimizing) exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:95,Usability,simpl,simplified,95,"// Rotate if either the loop latch does *not* exit the loop, or if the loop; // latch was just simplified. Or if we think it will be profitable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:27,Safety,avoid,avoid,27,"// When preparing for LTO, avoid rotating loops with calls that could be; // inlined during the LTO stage.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:68,Performance,cache,cached,68,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:125,Performance,cache,caches,125,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:187,Performance,cache,cached,187,"// We may hoist some instructions out of loop. In case if they were cached; // as ""loop variant"" or ""loop computable"", these caches must be dropped.; // We also may fold basic blocks, so cached block dispositions also need; // to be dropped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:28,Availability,avail,available,28,"// For PHI nodes, the value available in OldPreHeader is just the; // incoming value from OldPreHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,Safety,avoid,avoid,60,// Record all debug intrinsics preceding LoopEntryBranch to avoid; // duplication.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:17,Security,hash,hashes,17,"// Build DPValue hashes for DPValues attached to the terminator, which isn't; // considered in the loop above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:151,Safety,avoid,avoids,151,"// Remember the local noalias scope declarations in the header. After the; // rotation, they must be duplicated and the scope must be cloned. This; // avoids unwanted interaction across iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:347,Availability,down,down,347,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:508,Safety,avoid,avoid,508,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:812,Safety,avoid,avoids,812,"// Track the next DPValue to clone. If we have a sequence where an; // instruction is hoisted instead of being cloned:; // DPValue blah; // %foo = add i32 0, 0; // DPValue xyzzy; // %bar = call i32 @foobar(); // where %foo is hoisted, then the DPValue ""blah"" will be seen twice, once; // attached to %foo, then when %foo his hoisted it will ""fall down"" onto the; // function call:; // DPValue blah; // DPValue xyzzy; // %bar = call i32 @foobar(); // causing it to appear attached to the call too.; //; // To avoid this, cloneDebugInfoFrom takes an optional ""start cloning from; // here"" position to account for this behaviour. We point it at any DPValues; // on the next instruction, here labelled xyzzy, before we hoist %foo.; // Later, we only only clone DPValues from that position (xyzzy) onwards,; // which avoids cloning DPValue ""blah"" multiple times.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:99,Safety,safe,safe,99,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:285,Safety,safe,safe,285,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:340,Safety,safe,safe,340,"// If the instruction's operands are invariant and it doesn't read or write; // memory, then it is safe to hoist. Doing this doesn't change the order of; // execution in the preheader, but does prevent the instruction from; // executing in each iteration of the loop. This means it is safe to hoist; // something that might trap, but isn't safe to hoist something that reads; // memory (without proving that the loop doesn't write).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Safety,Avoid,Avoid,3,// Avoid inserting the same intrinsic twice.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:89,Usability,simpl,simplifyable,89,"// With the operands remapped, see if the instruction constant folds or is; // otherwise simplifyable. This commonly occurs because the entry from PHI; // nodes allows icmps and other instructions to fold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:115,Usability,simpl,simplified,115,"// MemorySSA cares whether the cloned instruction was inserted or not, and; // not whether it can be remapped to a simplified value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:267,Integrability,depend,depending,267,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:791,Safety,safe,safe,791,"// There are noalias scope declarations:; // (general):; // Original: OrigPre { OrigHeader NewHeader ... Latch }; // after: (OrigPre+OrigHeader') { NewHeader ... Latch OrigHeader }; //; // with D: llvm.experimental.noalias.scope.decl,; // U: !noalias or !alias.scope depending on D; // ... { D U1 U2 } can transform into:; // (0) : ... { D U1 U2 } // no relevant rotation for this part; // (1) : ... D' { U1 U2 D } // D is part of OrigHeader; // (2) : ... D' U1' { U2 D U1 } // D, U1 are part of OrigHeader; //; // We now want to transform:; // (1) -> : ... D' { D U1 U2 D'' }; // (2) -> : ... D' U1' { D U2 D'' U1'' }; // D: original llvm.experimental.noalias.scope.decl; // D', U1': duplicate with replaced scopes; // D'', U1'': different duplicate with replaced scopes; // This ensures a safe fallback to 'may_alias' introduced by the rotate,; // as U1'' and U1' scopes will not be compatible wrt to the local restrict; // Clone the llvm.experimental.noalias.decl again for the NewHeader.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:44,Energy Efficiency,adapt,adapting,44,"// Keep the compile time impact low by only adapting the inserted block; // of instructions in the OrigPreHeader. This might result in slightly; // more aliasing between these instructions and those that were already; // present, but it will be much faster when the original PreHeader is; // large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:44,Modifiability,adapt,adapting,44,"// Keep the compile time impact low by only adapting the inserted block; // of instructions in the OrigPreHeader. This might result in slightly; // more aliasing between these instructions and those that were already; // present, but it will be much faster when the original PreHeader is; // large.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,// Update MemorySSA before the rewrite call below changes the 1:1; // instruction:cloned_instruction_or_value mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:31,Modifiability,rewrite,rewrite,31,// Update MemorySSA before the rewrite call below changes the 1:1; // instruction:cloned_instruction_or_value mapping.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:88,Deployability,update,update,88,"// If there were any uses of instructions in the duplicated block outside the; // loop, update them, inserting PHI nodes as required",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:2,Deployability,Update,UpdateDT,2,/*UpdateDT=*/,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:113,Usability,simpl,simplified,113,"// At this point, we've finished our major CFG changes. As part of cloning; // the loop into the preheader we've simplified instructions and the; // duplicated conditional branch may now be branching on a constant. If it is; // branching on a constant and if that constant means that we enter the loop,; // then we fold away the cond branch to an uncond branch. This simplifies the; // loop in cases important for nested loops, and it also means we don't have; // to split as many edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:367,Usability,simpl,simplifies,367,"// At this point, we've finished our major CFG changes. As part of cloning; // the loop into the preheader we've simplified instructions and the; // duplicated conditional branch may now be branching on a constant. If it is; // branching on a constant and if that constant means that we enter the loop,; // then we fold away the cond branch to an uncond branch. This simplifies the; // loop in cases important for nested loops, and it also means we don't have; // to split as many edges.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,Usability,simpl,simpler,78,"// We can fold the conditional branch in the preheader, this makes things; // simpler. The first step is to remove the extra edge to the Exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:51,Availability,avail,available,51,"// With our CFG finalized, update DomTree if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:27,Deployability,update,update,27,"// With our CFG finalized, update DomTree if it is available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:23,Availability,avail,available,23,"// Update MSSA too, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Deployability,Update,Update,3,"// Update MSSA too, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:217,Modifiability,extend,extend,217,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:194,Performance,perform,performance,194,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:206,Performance,bottleneck,bottleneck,206,"// Check that new latch is a deoptimizing exit and then repeat rotation if possible.; // Deoptimizing latch exit is not a generally typical case, so we just loop over.; // TODO: if it becomes a performance bottleneck extend rotation algorithm; // to handle multiple rotations in one go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:60,Safety,safe,safely,60,/// Determine whether the instructions in this range may be safely and cheaply; /// speculated. This is not an important enough situation to develop complex; /// heuristics. We handle a single arithmetic instruction along with any type; /// conversions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:406,Availability,down,downstream,406,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:156,Usability,simpl,simple,156,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:344,Usability,simpl,simplifyLoopLatch,344,"/// Fold the loop tail into the loop exit by speculating the loop tail; /// instructions. Typically, this is a single post-increment. In the case of a; /// simple 2-block loop, hoisting the increment can be much better than; /// duplicating the entire loop header. In the case of loops with early exits,; /// rotation will not work anyway, but simplifyLoopLatch will put the loop in; /// canonical form so downstream passes can handle it.; ///; /// I don't believe this invalidates SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:71,Performance,cache,cache,71,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:88,Performance,cache,cache,88,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:78,Usability,Clear,Clear,78,// Merging blocks may remove blocks reference in the block disposition cache. Clear the cache.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:3,Usability,Simpl,Simplify,3,// Simplify the loop latch before attempting to rotate the header; // upward. Rotation may not be needed if the loop tail can be folded into the; // loop exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp:58,Testability,test,test,58,/// The utility to convert a loop into a loop with bottom test.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopRotationUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1859,Deployability,update,updates,1859,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:393,Performance,perform,performs,393,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:464,Usability,simpl,simpler,464,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:530,Usability,simpl,simpler,530,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:709,Usability,simpl,simplifies,709,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1050,Usability,simpl,simplifies,1050,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:1654,Usability,simpl,simplifycfg,1654,"//===- LoopSimplify.cpp - Loop Canonicalization Pass ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass performs several transformations to transform natural loops into a; // simpler form, which makes subsequent analyses and transformations simpler and; // more effective.; //; // Loop pre-header insertion guarantees that there is a single, non-critical; // entry edge from outside of the loop to the loop header. This simplifies a; // number of analyses and transformations, such as LICM.; //; // Loop exit-block insertion guarantees that all exit blocks from the loop; // (blocks which are outside of the loop that have predecessors inside of the; // loop) only have predecessors from inside of the loop (and are thus dominated; // by the loop header). This simplifies transformations such as store-sinking; // that are built into LICM.; //; // This pass also guarantees that loops will have exactly one backedge.; //; // Indirectbr instructions introduce several complications. If the loop; // contains or is entered by an indirectbr instruction, it may not be possible; // to transform the loop and make these guarantees. Client code should check; // that these conditions are true before relying on them.; //; // Similar complications arise from callbr instructions, particularly in; // asm-goto where blockaddress expressions are used.; //; // Note that the simplifycfg pass will clean up blocks which are split out but; // end up being unnecessary, so usage of this pass should not pessimize; // generated code.; //; // This pass obviously modifies the CFG, but updates loop information and; // dominator information.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:588,Availability,avail,available,588,"// Treat the presence of convergent functions conservatively. The; // transformation is invalid if calls to certain convergent; // functions (like an AMDGPU barrier) get included in the resulting; // inner loop. But blocks meant for the inner loop will be; // identified later at a point where it's too late to abort the; // transformation. Also, the convergent attribute is not really; // sufficient to express the semantics of functions that are; // affected by this transformation. So we choose to back off if such; // a function call is present until a better alternative becomes; // available. This is similar to the conservative treatment of; // convergent function calls in GVNHoist and JumpThreading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:311,Safety,abort,abort,311,"// Treat the presence of convergent functions conservatively. The; // transformation is invalid if calls to certain convergent; // functions (like an AMDGPU barrier) get included in the resulting; // inner loop. But blocks meant for the inner loop will be; // identified later at a point where it's too late to abort the; // transformation. Also, the convergent attribute is not really; // sufficient to express the semantics of functions that are; // affected by this transformation. So we choose to back off if such; // a function call is present until a better alternative becomes; // available. This is similar to the conservative treatment of; // convergent function calls in GVNHoist and JumpThreading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:39,Integrability,depend,depends,39,// Unique backedge insertion currently depends on having a preheader.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:9,Performance,optimiz,optimization,9,"// As an optimization, if all incoming values in the new PhiNode (which is a; // subset of the incoming values of the old PHI node) have the same value,; // eliminate the PHI Node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:9,Deployability,Update,Update,9,//===--- Update all analyses which we must preserve now -----------------===//; // Update Loop Information - we know that this block is now in the current; // loop and all parent loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:83,Deployability,Update,Update,83,//===--- Update all analyses which we must preserve now -----------------===//; // Update Loop Information - we know that this block is now in the current; // loop and all parent loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:3,Deployability,Update,Update,3,// Update dominator information,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,Performance,queue,queue,26,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:4,Usability,Simpl,Simplify,4,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:50,Usability,simpl,simplification,50,/// Simplify one loop and queue further loops for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:135,Usability,simpl,simplify,135,"// If there are exiting blocks with branches on undef, resolve the undef in; // the direction which will exit the loop. This will help simplify loop; // trip count computations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:66,Usability,clear,clear,66,// GCC doesn't tail recursion eliminate this.; // FIXME: It isn't clear we can't rely on LLVM to TRE this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:160,Availability,down,down,160,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:137,Usability,simpl,simplified,137,"// Scan over the PHI nodes in the loop header. Since they now have only two; // incoming values (the loop is canonicalized), we may have simplified the PHI; // down to 'X = phi [X, Y]', which should be replaced with 'Y'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:212,Usability,Simpl,SimplifyCFG,212,"// If this loop has multiple exits and the exits all go to the same; // block, attempt to merge the exits. This helps several passes, such; // as LoopRotation, which do not support loops with multiple exits.; // SimplifyCFG also does this (and this code uses the same utility; // function), however this code is loop-aware, where SimplifyCFG is; // not. That gives it the advantage of being able to hoist; // loop-invariant instructions out of the way to open up more; // opportunities, and the disadvantage of having the responsibility; // to preserve dominator information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:330,Usability,Simpl,SimplifyCFG,330,"// If this loop has multiple exits and the exits all go to the same; // block, attempt to merge the exits. This helps several passes, such; // as LoopRotation, which do not support loops with multiple exits.; // SimplifyCFG also does this (and this code uses the same utility; // function), however this code is loop-aware, where SimplifyCFG is; // not. That gives it the advantage of being able to hoist; // loop-invariant instructions out of the way to open up more; // opportunities, and the disadvantage of having the responsibility; // to preserve dominator information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:26,Usability,clear,cleared,26,// The block has now been cleared of all instructions except for; // a comparison and a conditional branch. SimplifyCFG may be able; // to fold it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:108,Usability,Simpl,SimplifyCFG,108,// The block has now been cleared of all instructions except for; // a comparison and a conditional branch. SimplifyCFG may be able; // to fold it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:67,Deployability,update,update,67,"// Success. The block is now dead, so remove it from the loop,; // update the dominator tree and delete it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:38,Performance,queue,queue,38,// Worklist maintains our depth-first queue of loops in this nest to process.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:182,Usability,simpl,simple,182,"// Walk the worklist from front to back, pushing newly found sub loops onto; // the back. This will let us process loops from back to front in depth-first; // order. We can use this simple process because loops form a tree.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:203,Usability,simpl,simplifyOneLoop,203,"// Changing exit conditions for blocks may affect exit counts of this loop and; // any of its parents, so we must invalidate the entire subtree if we've made; // any changes. Do this here rather than in simplifyOneLoop() as the top-most; // loop is going to be the same for all child loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:24,Availability,down,down,24,"/// runOnFunction - Run down all loops in the CFG (recursively, but we could do; /// it in any convenient order) inserting preheaders...; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:3,Usability,Simpl,Simplify,3,// Simplify each loop nest in the function.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:87,Usability,simpl,simplifying,87,"// Note that we don't preserve LCSSA in the new PM, if you need it run LCSSA; // after simplifying the loops. MemorySSA is preserved if it exists.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:34,Testability,assert,assert,34,"// It used to be possible to just assert L->isLoopSimplifyForm(), however; // with the introduction of indirectbr, there are now cases where it's; // not possible to transform a loop as necessary. We can at least check; // that there is an indirectbr near any time there's trouble.; // Indirectbr can interfere with preheader and unique backedge insertion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp:15,Integrability,rout,routine,15,"// FIXME: This routine is being called mid-way through the loop pass manager; // as loop passes destroy this analysis. That's actually fine, but we have no; // way of expressing that here. Once all of the passes that destroy this are; // hoisted out of the loop pass manager we can add back verification here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopSimplify.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:519,Performance,perform,perform,519,"//===-- UnrollLoop.cpp - Loop unrolling utilities -------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements some loop unrolling utilities. It does not define any; // actual pass or policy, but provides a single function to perform loop; // unrolling.; //; // The process of unrolling can produce extraneous basic blocks linked with; // unconditional branches. This will be corrected in the future.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:4,Performance,Perform,Perform,4,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:29,Usability,simpl,simplifications,29,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:92,Usability,simpl,simplify,92,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:154,Usability,simpl,simplify,154,"/// Perform some cleanup and simplifications on loops after unrolling. It is; /// useful to simplify the IV's in the new loop, as well as do a quick; /// simplify/dce pass of the instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:30,Modifiability,variab,variables,30,// Simplify any new induction variables in the partially unrolled loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Usability,Simpl,Simplify,3,// Simplify any new induction variables in the partially unrolled loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:48,Usability,simpl,simplifyLoopIVs,48,// Aggressively clean up dead instructions that simplifyLoopIVs already; // identified. Any remaining should be cleaned up below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:43,Performance,Perform,Perform,43,"// At this point, the code is well formed. Perform constprop, instsimplify,; // and dce.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:163,Usability,simpl,simple,163,"// Fold ((add X, C1), C2) to (add X, C1+C2). This is very common in; // unrolled loops, and handling this early allows following code to; // identify the IV as a ""simple recurrence"" without first folding away; // a long chain of adds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:42,Safety,avoid,avoid,42,// The loop-rotate pass can be helpful to avoid this in many cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Performance,perform,performing,23,// There's no point in performing runtime unrolling if this unroll count; // results in a full unroll.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:212,Modifiability,extend,extended,212,"// The current loop unroll pass can unroll loops that have; // (1) single latch; and; // (2a) latch is unconditional; or; // (2b) latch is conditional and is an exiting block; // FIXME: The implementation can be extended to work with more complicated; // cases, e.g. loops with multiple latches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:59,Performance,optimiz,optimized,59,"// A conditional branch which exits the loop, which can be optimized to an; // unconditional branch in the unrolled loop in some cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:130,Integrability,depend,dependencies,130,"// Loops containing convergent instructions cannot use runtime unrolling,; // as the prologue/epilogue may add additional control-dependencies to; // convergent operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:66,Performance,cache,cached,66,"// We are going to make changes to this loop. SCEV may be keeping cached info; // about it, in particular about backedge taken count. The changes we make; // are guaranteed to invalidate this information for our loop. It is tempting; // to only invalidate the loop being unrolled, but it is incorrect as long as; // all exiting branches from all inner loops have impact on the outer loops,; // and if something changes inside them then any of outer loops may also; // change. When we forget outermost loop, we also forget all contained loops; // and this is what we need here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:30,Deployability,update,update,30,// The current on-the-fly SSA update requires blocks to be processed in; // reverse postorder so that LastValueMap contains the correct value at each; // exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:97,Usability,simpl,simplified,97,"// Loop Unrolling might create new loops. While we do preserve LoopInfo, we; // might break loop-simplified form for these loops (as they, e.g., would; // share the same exit blocks). We'll keep track of loops for which we can; // break this so that later we can re-simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:266,Usability,simpl,simplify,266,"// Loop Unrolling might create new loops. While we do preserve LoopInfo, we; // might break loop-simplified form for these loops (as they, e.g., would; // share the same exit blocks). We'll keep track of loops for which we can; // break this so that later we can re-simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update our running map of newest clones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,"// Update DomTree: since we just copy the loop body, and each copy has a; // dedicated entry block (copy of the header block), this header's copy; // dominates all copied blocks. That means, dominance relations in the; // copied body are the same as in the original body.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:32,Integrability,depend,depends,32,"// Identify what other metadata depends on the cloned version. After; // cloning, replace the metadata with the corrected version for both; // memory instructions and noalias intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,"// Update dominators of blocks we might reach through exits.; // Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can now reach it from the copied; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:137,Integrability,rout,routes,137,"// Update dominators of blocks we might reach through exits.; // Immediate dominator of such block might change, because we add more; // routes which can lead to the exit: we can now reach it from the copied; // iterations too.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,Safety,safe,safely,57,"// If we know the trip count or a multiple of it, we can safely use an; // unconditional branch for some iterations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:259,Deployability,update,updates,259,"// We don't fold known-exiting branches for non-latch exits here,; // because this ensures that both all loop blocks and all exit blocks; // remain reachable in the CFG.; // TODO: We could fold these branches, but it would require much more; // sophisticated updates to LoopInfo.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:12,Deployability,update,update,12,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:128,Deployability,update,update,128,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:379,Deployability,update,update,379,"// Manually update the DT if there's a single exiting node. In that case; // there's a single exit node and it is sufficient to update the nodes; // immediately dominated by the original exiting block. They will become; // dominated by the first exiting block that leaves the loop after; // unrolling. Note that the CFG inside the loop does not change, so there's; // no need to update the DT inside the unrolled loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Deployability,update,update,23,"// There is no need to update the DT here, because there must be a unique; // latch. Hence if the latch is not exiting it must directly branch back to; // the original loop header and does not dominate any nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:35,Deployability,Update,Update,35,// Dest has been folded into Fold. Update our worklists accordingly.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:9,Deployability,update,updates,9,// Apply updates to the DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:50,Usability,simpl,simplify,50,"// At this point, the code is well formed. We now simplify the unrolled loop,; // doing constant propagation and dead code elimination as we go.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if the loop is completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Deployability,Update,Update,3,// Update the trip count. Note that the remainder has already logic; // computing it in `UnrollRuntimeLoopRemainder`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:62,Testability,log,logic,62,// Update the trip count. Note that the remainder has already logic; // computing it in `UnrollRuntimeLoopRemainder`.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:175,Security,expose,exposed,175,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:23,Usability,simpl,simplify,23,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:62,Usability,simpl,simplify,62,// Make sure that loop-simplify form is preserved. We want to simplify; // at least one layer outside of the loop that was unrolled so that any; // changes to the parent loop exposed by the unrolling are considered.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:57,Usability,simpl,simplify,57,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:93,Usability,simpl,simplify,93,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:129,Usability,simpl,simplify,129,"// OuterL includes all loops for which we can break loop-simplify, so; // it's sufficient to simplify only it (it'll recursively simplify inner; // loops too).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:167,Deployability,update,updated,167,// LCSSA must be performed on the outermost affected loop. The unrolled; // loop's last loop latch is guaranteed to be in the outermost loop; // after LoopInfo's been updated by LoopInfo::erase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:17,Performance,perform,performed,17,// LCSSA must be performed on the outermost affected loop. The unrolled; // loop's last loop latch is guaranteed to be in the outermost loop; // after LoopInfo's been updated by LoopInfo::erase.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:93,Usability,simpl,simplified,93,// TODO: That potentially might be compile-time expensive. We should try; // to fix the loop-simplified form incrementally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:3,Usability,Simpl,Simplify,3,// Simplify loops for which we might've broken loop-simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp:52,Usability,simpl,simplify,52,// Simplify loops for which we might've broken loop-simplify form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnroll.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:429,Integrability,rout,routine,429,"//===-- LoopUnrollAndJam.cpp - Loop unrolling utilities -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements loop unroll and jam as a routine, much like; // LoopUnroll.cpp implements loop unroll.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:16,Performance,perform,performs,16,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:445,Performance,load,loads,445,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:47,Usability,simpl,simple,47,"/*; This method performs Unroll and Jam. For a simple loop like:; for (i = ..); Fore(i); for (j = ..); SubLoop(i, j); Aft(i). Instead of doing normal inner or outer unrolling, we do:; for (i = .., i+=2); Fore(i); Fore(i+1); for (j = ..); SubLoop(i, j); SubLoop(i+1, j); Aft(i); Aft(i+1). So the outer loop is essetially unrolled and then the inner loops are fused; (""jammed"") together into a single loop. This can increase speed when there; are loads in SubLoop that are invariant to i, as they become shared between; the now jammed inner loops. We do this by spliting the blocks in the loop into Fore, Subloop and Aft.; Fore blocks are those before the inner loop, Aft are those after. Normal; Unroll code is used to copy each of these sets of blocks and the results are; combined together into the final form above. isSafeToUnrollAndJam should be used prior to calling this to make sure the; unrolling will be valid. Checking profitablility is also advisable. If EpilogueLoop is non-null, it receives the epilogue loop (if it was; necessary to create one and not fully unrolled).; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:64,Safety,safe,safe,64,// When we enter here we should have already checked that it is safe,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:30,Deployability,update,update,30,// The current on-the-fly SSA update requires blocks to be processed in; // reverse postorder so that LastValueMap contains the correct value at each; // exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update our running maps of newest clones,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update DomTree:,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:201,Deployability,Update,Update,201,"// Now that all the basic blocks for the unrolled iterations are in place,; // finish up connecting the blocks and phi nodes. At this point LastValueMap; // is the last unrolled iterations values.; // Update Phis in BB from OldBB to point to NewBB and use the latest value; // from LastValueMap",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update the PHI values outside the loop to point to the last block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update ForeBlocks successors and phi nodes,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update the PHI values to point to the last aft block,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:9,Deployability,update,updates,9,// Apply updates to the DomTree.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:3,Deployability,Update,Update,3,// Update LoopInfo if the loop is completely removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:49,Usability,simpl,simplify,49,// We shouldn't have done anything to break loop simplify form or LCSSA.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:34,Performance,load,loads,34,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:84,Performance,load,loads,84,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:77,Usability,simpl,simple,77,// Scan the BBs and collect legal loads and stores.; // Returns false if non-simple loads/stores are found.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,Integrability,depend,dependency,31,// UnrollLevel might carry the dependency Src --> Dst; // Does a different loop after unrolling?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:31,Integrability,depend,dependency,31,// UnrollLevel might carry the dependency Dst --> Src,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:12,Integrability,depend,dependencies,12,// Backward dependencies are only preserved if not interleaved.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:83,Integrability,depend,dependency,83,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:377,Integrability,depend,dependency,377,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:36,Safety,safe,safe,36,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:348,Safety,safe,safe,348,"// Check whether it is semantically safe Src and Dst considering any potential; // dependency between them.; //; // @param UnrollLevel The level of the loop being unrolled; // @param JamLevel The level of the loop being jammed; if Src and Dst are on; // different levels, the outermost common loop counts as jammed level; //; // @return true if is safe and false if there is a dependency violation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:16,Integrability,depend,dependencies,16,// Ignore Input dependencies.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:46,Integrability,depend,dependency,46,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:85,Integrability,depend,dependency,85,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:352,Integrability,depend,dependence,352,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:380,Integrability,depend,dependence,380,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:484,Integrability,depend,dependency,484,"// Check whether unroll-and-jam may violate a dependency.; // By construction, every dependency will be lexicographically non-negative; // (if it was, it would violate the current execution order), such as; // (0,0,>,*,*); // Unroll-and-jam changes the GT execution of two executions to the same; // iteration of the chosen unroll level. That is, a GT dependence becomes a GE; // dependence (or EQ, if we fully unrolled the loop) at the loop's position:; // (0,0,>=,*,*); // Now, the dependency is not necessarily non-negative anymore, i.e.; // unroll-and-jam may violate correctness.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:122,Security,access,accessed,122,"// If outer levels (levels enclosing the loop being unroll-and-jammed) have a; // non-equal direction, then the locations accessed in the inner levels cannot; // overlap in memory. We assumes the indexes never overlap into neighboring; // dimensions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:143,Security,access,accesses,143,"// If the distance carried by the unrolled loop is 0, then after unrolling; // that distance will become non-zero resulting in non-overlapping accesses in; // the inner loops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:35,Usability,simpl,simplify,35,// All loops in Root need to be in simplify and rotated form.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:978,Safety,safe,safe,978,"/* We currently handle outer loops like this:; |; ForeFirst <------\ }; Blocks | } ForeBlocks of L; ForeLast | }; | |; ... |; | |; ForeFirst <----\ | }; Blocks | | } ForeBlocks of a inner loop of L; ForeLast | | }; | | |; JamLoopFirst <\ | | }; Blocks | | | } JamLoopBlocks of the innermost loop; JamLoopLast -/ | | }; | | |; AftFirst | | }; Blocks | | } AftBlocks of a inner loop of L; AftLast ------/ | }; | |; ... |; | |; AftFirst | }; Blocks | } AftBlocks of L; AftLast --------/ }; |. There are (theoretically) any number of blocks in ForeBlocks, SubLoopBlocks; and AftBlocks, providing that there is one edge from Fores to SubLoops,; one edge from SubLoops to Afts and a single outer loop exit (from Afts).; In practice we currently limit Aft blocks to a single block, and limit; things further in the profitablility checks of the unroll and jam pass. Because of the way we rearrange basic blocks, we also require that; the Fore blocks of L on all unrolled iterations are safe to move before the; blocks of the direct child of L of all iterations. So we require that the; phi node looping operands of ForeHeader can be moved to at least the end of; ForeEnd, so that we can arrange cloned Fore Blocks before the subloop and; match up Phi's correctly. i.e. The old order of blocks used to be; (F1)1 (F2)1 J1_1 J1_2 (A2)1 (A1)1 (F1)2 (F2)2 J2_1 J2_2 (A2)2 (A1)2.; It needs to be safe to transform this to; (F1)1 (F1)2 (F2)1 (F2)2 J1_1 J1_2 J2_1 J2_2 (A2)1 (A2)2 (A1)1 (A1)2. There are then a number of checks along the lines of no calls, no; exceptions, inner loop IV is consistent, etc. Note that for loops requiring; runtime unrolling, UnrollRuntimeLoopRemainder can also fail in; UnrollAndJamLoop if the trip count cannot be easily calculated.; */; // Split blocks into Fore/SubLoop/Aft based on dominators",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:1382,Safety,safe,safe,1382,"/* We currently handle outer loops like this:; |; ForeFirst <------\ }; Blocks | } ForeBlocks of L; ForeLast | }; | |; ... |; | |; ForeFirst <----\ | }; Blocks | | } ForeBlocks of a inner loop of L; ForeLast | | }; | | |; JamLoopFirst <\ | | }; Blocks | | | } JamLoopBlocks of the innermost loop; JamLoopLast -/ | | }; | | |; AftFirst | | }; Blocks | | } AftBlocks of a inner loop of L; AftLast ------/ | }; | |; ... |; | |; AftFirst | }; Blocks | } AftBlocks of L; AftLast --------/ }; |. There are (theoretically) any number of blocks in ForeBlocks, SubLoopBlocks; and AftBlocks, providing that there is one edge from Fores to SubLoops,; one edge from SubLoops to Afts and a single outer loop exit (from Afts).; In practice we currently limit Aft blocks to a single block, and limit; things further in the profitablility checks of the unroll and jam pass. Because of the way we rearrange basic blocks, we also require that; the Fore blocks of L on all unrolled iterations are safe to move before the; blocks of the direct child of L of all iterations. So we require that the; phi node looping operands of ForeHeader can be moved to at least the end of; ForeEnd, so that we can arrange cloned Fore Blocks before the subloop and; match up Phi's correctly. i.e. The old order of blocks used to be; (F1)1 (F2)1 J1_1 J1_2 (A2)1 (A1)1 (F1)2 (F2)2 J2_1 J2_2 (A2)2 (A1)2.; It needs to be safe to transform this to; (F1)1 (F1)2 (F2)1 (F2)2 J1_1 J1_2 J2_1 J2_2 (A2)1 (A2)2 (A1)1 (A1)2. There are then a number of checks along the lines of no calls, no; exceptions, inner loop IV is consistent, etc. Note that for loops requiring; runtime unrolling, UnrollRuntimeLoopRemainder can also fail in; UnrollAndJamLoop if the trip count cannot be easily calculated.; */; // Split blocks into Fore/SubLoop/Aft based on dominators",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:18,Safety,safe,safety,18,// Check the loop safety info for exceptions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:20,Integrability,depend,dependencies,20,"// Check for memory dependencies which prohibit the unrolling we are doing.; // Because of the way we are unrolling Fore/Sub/Aft blocks, we need to check; // there are no dependencies between Fore-Sub, Fore-Aft, Sub-Aft and Sub-Sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp:171,Integrability,depend,dependencies,171,"// Check for memory dependencies which prohibit the unrolling we are doing.; // Because of the way we are unrolling Fore/Sub/Aft blocks, we need to check; // there are no dependencies between Fore-Sub, Fore-Aft, Sub-Aft and Sub-Sub.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollAndJam.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:250,Performance,tune,tuned,250,"// Probability that the loop trip count is so small that after the prolog; // we do not enter the unrolled loop at all.; // It is unlikely that the loop trip count is smaller than the unroll factor;; // other than that, the choice of constant is not tuned yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:269,Performance,tune,tuned,269,"// Probability that the loop trip count is so small that we skip the unrolled; // loop completely and immediately enter the epilogue loop.; // It is unlikely that the loop trip count is smaller than the unroll factor;; // other than that, the choice of constant is not tuned yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,Performance,perform,performs,237,/// Connect the unrolling prolog code to the original loop.; /// The unrolling prolog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Create PHI nodes at prolog end block to combine values; /// that exit the prolog code and jump around the prolog.; /// - Add a PHI operand to a PHI node at the loop exit block; /// for values that exit the prolog and go around the loop.; /// - Branch around the original loop if the trip count is less; /// than the unroll factor.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update the existing PHI node operand with the value from the; // new PHI node. How this is done depends on if the existing; // PHI node is in the original loop block, or the exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:99,Integrability,depend,depends,99,"// Update the existing PHI node operand with the value from the; // new PHI node. How this is done depends on if the existing; // PHI node is in the original loop block, or the exit block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:44,Usability,simpl,simplified,44,// Make sure that created prolog loop is in simplified form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:268,Deployability,Update,Update,268,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:468,Deployability,Update,Update,468,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:237,Performance,perform,performs,237,/// Connect the unrolling epilog code to the original loop.; /// The unrolling epilog code contains code to execute the; /// 'extra' iterations if the run-time trip count modulo the; /// unroll count is non-zero.; ///; /// This function performs the following:; /// - Update PHI nodes at the unrolling loop exit and epilog loop exit; /// - Create PHI nodes at the unrolling loop exit to combine; /// values that exit the unrolling loop code and jump around it.; /// - Update PHI operands in the epilog loop by the new PHI nodes; /// - Branch around the epilog loop if extra iters (ModVal) is zero.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:209,Deployability,Update,Update,209,// Loop structure should be the following:; //; // PreHeader; // NewPreHeader; // Header; // ...; // Latch; // NewExit (PN); // EpilogPreHeader; // EpilogHeader; // ...; // EpilogLatch; // Exit (EpilogPN); // Update PHI nodes at NewExit and Exit.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:82,Deployability,Update,Update,82,// Create PHI nodes at NewExit (from the unrolling loop Latch and PreHeader).; // Update corresponding PHI nodes in epilog loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:27,Deployability,update,updated,27,// Skip this as we already updated phis in exit blocks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:48,Deployability,update,update,48,// Add new PHI nodes to the loop exit block and update epilog; // PHIs with the new PHI values.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,// Update the existing PHI node operand with the value from the new PHI; // node. Corresponding instruction in epilog loop should be PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:195,Availability,down,down,195,"/// Create a clone of the blocks in a loop and connect them together. A new; /// loop will be created including all cloned blocks, and the iterator of the; /// new loop switched to count NewIter down to 0.; /// The cloned blocks should be inserted between InsertTop and InsertBot.; /// InsertTop should be new preheader, InsertBot new loop exit.; /// Returns the new cloned loop that is created.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:67,Deployability,update,update,67,"// For each block in the original loop, create a new copy,; // and update the value map with the newly created values.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:105,Integrability,wrap,wrapped,105,"// Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: NewIter can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:189,Integrability,wrap,wrapping,189,"// Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: NewIter can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:83,Performance,optimiz,optimized,83,"// Unnecessary backedge, should never be taken. The conditional; // jump should be optimized away later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:641,Safety,predict,predictability,641,"// The main pain point with multi-exit loop unrolling is that once unrolled,; // we will not be able to merge all blocks into a straight line code.; // There are branches within the unrolled loop that go to the OtherExits.; // The second point is the increase in code size, but this is true; // irrespective of multiple exits.; // Note: Both the heuristics below are coarse grained. We are essentially; // enabling unrolling of loops that have a single side exit other than the; // normal LatchExit (i.e. exiting into a deoptimize block).; // The heuristics considered are:; // 1. low number of branches in the unrolled version.; // 2. high predictability of these extra branches.; // We avoid unrolling loops that have more than two exiting blocks. This; // limits the total number of branches in the unrolled loop to be atmost; // the unroll factor (since one of the exiting blocks is the latch block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:688,Safety,avoid,avoid,688,"// The main pain point with multi-exit loop unrolling is that once unrolled,; // we will not be able to merge all blocks into a straight line code.; // There are branches within the unrolled loop that go to the OtherExits.; // The second point is the increase in code size, but this is true; // irrespective of multiple exits.; // Note: Both the heuristics below are coarse grained. We are essentially; // enabling unrolling of loops that have a single side exit other than the; // normal LatchExit (i.e. exiting into a deoptimize block).; // The heuristics considered are:; // 1. low number of branches in the unrolled version.; // 2. high predictability of these extra branches.; // We avoid unrolling loops that have more than two exiting blocks. This; // limits the total number of branches in the unrolled loop to be atmost; // the unroll factor (since one of the exiting blocks is the latch block).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:242,Safety,predict,predictable,242,"// The second heuristic is that L has one exit other than the latchexit and; // that exit is a deoptimize block. We know that deoptimize blocks are rarely; // taken, which also implies the branch leading to the deoptimize block is; // highly predictable. When UnrollRuntimeOtherExitPredictable is specified, we; // assume the other exit branch is predictable even if it has no deoptimize; // call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:347,Safety,predict,predictable,347,"// The second heuristic is that L has one exit other than the latchexit and; // that exit is a deoptimize block. We know that deoptimize blocks are rarely; // taken, which also implies the branch leading to the deoptimize block is; // highly predictable. When UnrollRuntimeOtherExitPredictable is specified, we; // assume the other exit branch is predictable even if it has no deoptimize; // call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:148,Modifiability,extend,extend,148,"// TODO: These can be fine-tuned further to consider code size or deopt states; // that are captured by the deoptimize exit block.; // Also, we can extend this to support more cases, if we actually; // know of kinds of multiexit loops that would benefit from unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:27,Performance,tune,tuned,27,"// TODO: These can be fine-tuned further to consider code size or deopt states; // that are captured by the deoptimize exit block.; // Also, we can extend this to support more cases, if we actually; // know of kinds of multiexit loops that would benefit from unrolling.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:107,Safety,safe,safe,107,// As (BECount + 1) can potentially unsigned overflow we count; // (BECount % Count) + 1 which is overflow safe as BECount % Count < Count.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:357,Energy Efficiency,power,power-of-two,357,"/// Insert code in the prolog/epilog code when unrolling a loop with a; /// run-time trip-count.; ///; /// This method assumes that the loop unroll factor is total number; /// of loop bodies in the loop after unrolling. (Some folks refer; /// to the unroll factor as the number of *extra* copies added).; /// We assume also that the loop unroll factor is a power-of-two. So, after; /// unrolling the loop, the number of loop bodies executed is 2,; /// 4, 8, etc. Note - LLVM converts the if-then-sequence to a switch; /// instruction in SimplifyCFG.cpp. Then, the backend decides how code for; /// the switch instruction is generated.; ///; /// ***Prolog case***; /// extraiters = tripcount % loopfactor; /// if (extraiters == 0) jump Loop:; /// else jump Prol:; /// Prol: LoopBody;; /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.; /// if (tripcount < loopfactor) jump End:; /// Loop:; /// ...; /// End:; ///; /// ***Epilog case***; /// extraiters = tripcount % loopfactor; /// if (tripcount < loopfactor) jump LoopExit:; /// unroll_iters = tripcount - extraiters; /// Loop: LoopBody; (executes unroll_iter times);; /// unroll_iter -= 1; /// if (unroll_iter != 0) jump Loop:; /// LoopExit:; /// if (extraiters == 0) jump EpilExit:; /// Epil: LoopBody; (executes extraiters times); /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.; /// EpilExit:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:537,Usability,Simpl,SimplifyCFG,537,"/// Insert code in the prolog/epilog code when unrolling a loop with a; /// run-time trip-count.; ///; /// This method assumes that the loop unroll factor is total number; /// of loop bodies in the loop after unrolling. (Some folks refer; /// to the unroll factor as the number of *extra* copies added).; /// We assume also that the loop unroll factor is a power-of-two. So, after; /// unrolling the loop, the number of loop bodies executed is 2,; /// 4, 8, etc. Note - LLVM converts the if-then-sequence to a switch; /// instruction in SimplifyCFG.cpp. Then, the backend decides how code for; /// the switch instruction is generated.; ///; /// ***Prolog case***; /// extraiters = tripcount % loopfactor; /// if (extraiters == 0) jump Loop:; /// else jump Prol:; /// Prol: LoopBody;; /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Prol: // Omitted if unroll factor is 2.; /// if (tripcount < loopfactor) jump End:; /// Loop:; /// ...; /// End:; ///; /// ***Epilog case***; /// extraiters = tripcount % loopfactor; /// if (tripcount < loopfactor) jump LoopExit:; /// unroll_iters = tripcount - extraiters; /// Loop: LoopBody; (executes unroll_iter times);; /// unroll_iter -= 1; /// if (unroll_iter != 0) jump Loop:; /// LoopExit:; /// if (extraiters == 0) jump EpilExit:; /// Epil: LoopBody; (executes extraiters times); /// extraiters -= 1 // Omitted if unroll factor is 2.; /// if (extraiters != 0) jump Epil: // Omitted if unroll factor is 2.; /// EpilExit:",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:42,Safety,avoid,avoid,42,// The loop-rotate pass can be helpful to avoid this in many cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:123,Usability,simpl,simplification,123,// Use Scalar Evolution to compute the trip count. This allows more loops to; // be unrolled than relying on induction var simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:134,Integrability,depend,depending,134,"//; // For each extra loop iteration, create a copy of the loop's basic blocks; // and generate a condition that branches to the copy depending on the; // number of 'left over' iterations.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:165,Deployability,update,update,165,"// Now the loop blocks are cloned and the other exiting blocks from the; // remainder are connected to the original Loop's exit blocks. The remaining; // work is to update the phi nodes in the original loop, and take in the; // values from the cloned region.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update the immediate dominator of the exit blocks and blocks that are; // reachable from the exit blocks. This is needed because we now have paths; // from both the original loop and the remainder code reaching the exit; // blocks. While the IDom of these exit blocks were from the original loop,; // now the IDom is the preheader (which decides whether the original loop or; // remainder code should run).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:322,Modifiability,Rewrite,Rewrite,322,// Loop structure should be the following:; // Epilog Prolog; //; // PreHeader PreHeader; // NewPreHeader PrologPreHeader; // Header PrologHeader; // ... ...; // Latch PrologLatch; // NewExit PrologExit; // EpilogPreHeader NewPreHeader; // EpilogHeader Header; // ... ...; // EpilogLatch Latch; // LatchExit LatchExit; // Rewrite the cloned instruction operands to use the values created when the; // clone is created.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:52,Deployability,update,update,52,// Connect the epilog code to the original loop and update the; // PHI functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Deployability,Update,Update,3,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:147,Integrability,wrap,wrapped,147,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:231,Integrability,wrap,wrapping,231,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:124,Testability,Test,TestVal,124,"// Update counter in loop for unrolling.; // Use an incrementing IV. Pre-incr/post-incr is backedge/trip count.; // Subtle: TestVal can be 0 if we wrapped when computing the trip count,; // thus we must compare the post-increment (wrapping) value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:52,Deployability,update,update,52,// Connect the prolog code to the original loop and update the; // PHI functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp:3,Usability,Simpl,Simplify,3,// Simplify loop values after breaking the backedge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUnrollRuntime.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:13,Modifiability,rewrite,rewrite,13,// We cannot rewrite exiting edges from an indirectbr.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:83,Energy Efficiency,adapt,adapted,83,// FIXME: I believe that this could use copy_if if the Inst reference could; // be adapted into a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:83,Modifiability,adapt,adapted,83,// FIXME: I believe that this could use copy_if if the Inst reference could; // be adapted into a pointer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:91,Integrability,depend,depends,91,"// By definition, all loop passes need the LoopInfo analysis and the; // Dominator tree it depends on. Because they all participate in the loop; // pass manager, they must also preserve these.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:60,Security,access,access,60,// We must also preserve LoopSimplify and LCSSA. We locally access their IDs; // here because users shouldn't directly get them from this header.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Performance,perform,perform,40,// This is used in the LPPassManager to perform LCSSA verification on passes; // which preserve lcssa form,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:320,Availability,robust,robust,320,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:475,Security,audit,audit,475,"// Loop passes are designed to run inside of a loop pass manager which means; // that any function analyses they require must be required by the first loop; // pass in the manager (so that it is computed before the loop pass manager; // runs) and preserved by all loop pasess in the manager. To make this; // reasonably robust, the set needed for most loop passes is maintained here.; // If your loop pass requires an analysis not listed here, you will need to; // carefully audit the loop pass manager nesting structure that results.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Integrability,depend,dependency,40,"/// Manually defined generic ""LoopPass"" dependency initialization. This is used; /// to initialize the exact set of passes from above in \c; /// getLoopAnalysisUsage. It can be used within a loop pass's initialization; /// with:; ///; /// INITIALIZE_PASS_DEPENDENCY(LoopPass); ///; /// As-if ""LoopPass"" were a pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:119,Deployability,update,update,119,/// Set input string into loop metadata by keeping other values intact.; /// If the string is already in loop metadata update value if it is; /// different.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:14,Deployability,update,update,14,"// We need to update the value, so just skip it here and it will; // be added after copying other existed nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:10,Modifiability,inherit,inherit,10,// Do not inherit excluded attributes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,Safety,safe,safe,35,"// Now that we know the removal is safe, remove the loop by changing the; // branch from the preheader to go to the single exit block.; //; // Because we're deleting a large chunk of code at once, the sequence in which; // we remove things is very important to avoid invalidation issues.; // Tell ScalarEvolution that the loop is deleted. Do this before; // deleting the loop so that ScalarEvolution can look at the loop; // to determine what it needs to clean up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:261,Safety,avoid,avoid,261,"// Now that we know the removal is safe, remove the loop by changing the; // branch from the preheader to go to the single exit block.; //; // Because we're deleting a large chunk of code at once, the sequence in which; // we remove things is very important to avoid invalidation issues.; // Tell ScalarEvolution that the loop is deleted. Do this before; // deleting the loop so that ScalarEvolution can look at the loop; // to determine what it needs to clean up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:117,Deployability,update,update,117,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:576,Deployability,update,update,576,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:607,Deployability,update,update,607,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:90,Performance,perform,perform,90,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:545,Performance,perform,perform,545,"// Connect the preheader to the exit block. Keep the old edge to the header; // around to perform the dominator tree update in two separate steps; // -- #1 insertion of the edge preheader -> exit and #2 deletion of the edge; // preheader -> header.; //; //; // 0. Preheader 1. Preheader 2. Preheader; // | | | |; // V | V |; // Header <--\ | Header <--\ | Header <--\; // | | | | | | | | | | |; // | V | | | V | | | V |; // | Body --/ | | Body --/ | | Body --/; // V V V V V; // Exit Exit Exit; //; // By doing this is two separate steps we can perform the dominator tree; // update without using the batch update API.; //; // Even when the loop is never executed, we cannot remove the edge from the; // source block to the exit block. Consider the case where the unexecuted loop; // branches back to an outer loop. If we deleted the loop and removed the edge; // coming to this inner loop, this will break the outer loop structure (by; // deleting the backedge of the outer loop). If the outer loop is indeed a; // non-loop, it will be deleted in a future iteration of loop deletion pass.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite phis in the exit block to get their inputs from the Preheader; // instead of the exiting block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:19,Modifiability,variab,variable,19,"// For one of each variable encountered, preserve a debug intrinsic (set; // to Poison) and transfer it to the loop exit. This terminates any; // variable locations that were set during the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:146,Modifiability,variab,variable,146,"// For one of each variable encountered, preserve a debug intrinsic (set; // to Poison) and transfer it to the loop exit. This terminates any; // variable locations that were set during the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:282,Availability,avail,available,282,"// After the loop has been deleted all the values defined and modified; // inside the loop are going to be unavailable. Values computed in the; // loop will have been deleted, automatically causing their debug uses; // be be replaced with undef. Loop invariant values will still be available.; // Move dbg.values out the loop so that earlier location ranges are still; // terminated and loop invariant assignments are preserved.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:155,Safety,safe,safe,155,// Erase the instructions and the blocks without having to worry; // about ordering because we already dropped the references.; // NOTE: This iteration is safe because erasing the block does not remove; // its entry from the loop's block list. We do that in the next section.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:23,Deployability,update,update,23,"// The last step is to update LoopInfo now that we've eliminated this loop.; // Note: LoopInfo::erase remove the given loop and relink its subloops with; // its parent. While removeLoop/removeChildLoop remove the given loop but; // not relink its subloops, which is what we want.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Deployability,Update,Update,3,// Update the CFG and domtree. We chose to special case a couple of; // of common cases for code quality and test readability reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Testability,test,test,109,// Update the CFG and domtree. We chose to special case a couple of; // of common cases for code quality and test readability reasons.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:153,Testability,test,test,153,"// If the loop we broke had a parent, then changeToUnreachable might have; // caused a block to be removed from the parent loop (see loop_nest_lcssa; // test case in zero-btc.ll for an example), thus changing the parent's; // exit blocks. If that happened, we need to rebuild LCSSA on the outermost; // loop which might have a had a block removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:111,Modifiability,extend,extend,111,"// At the moment, we currently support changing the estimate trip count of; // the latch branch only. We could extend this API to manipulate estimated; // trip counts for any exit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:7,Deployability,Update,Update,7,// Set/Update profile metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:11,Energy Efficiency,power,power,11,"// VF is a power of 2 so we can emit the reduction using log2(VF) shuffles; // and vector ops, reducing the set of values being computed by half each; // round.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:61,Deployability,configurat,configuration,61,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Deployability,configurat,configuration,245,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:61,Modifiability,config,configuration,61,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Modifiability,config,configuration,245,"// Note: fast-math-flags flags are controlled by the builder configuration; // and are assumed to apply to all generated arithmetic instructions. Other; // poison generating flags (nsw/nuw/inbounds/inrange/exact) are not part; // of the builder configuration, and since they're not passed explicitly,; // will never be relevant here. Note that it would be generally unsound to; // propagate these from an intrinsic call to the expansion anyways as we/; // change the order of operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:24,Availability,mask,mask,24,// Fill the rest of the mask with undef.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:90,Energy Efficiency,reduce,reduce,90,// Create a splat vector with the new value and compare this to the vector; // we want to reduce.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:102,Modifiability,inherit,inherit,102,// TODO: Support in-order reductions based on the recurrence descriptor.; // All ops in the reduction inherit fast-math-flags from the recurrence; // descriptor.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:167,Energy Efficiency,reduce,reduces,167,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:85,Modifiability,rewrite,rewriteLoopExitValues,85,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Performance,Optimiz,Optimize,109,"//===----------------------------------------------------------------------===//; // rewriteLoopExitValues - Optimize IV users outside the loop.; // As a side effect, reduces the amount of IV processing within the loop.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:71,Modifiability,rewrite,rewriteLoopExitValues,71,// Collect information about PHI nodes which can be transformed in; // rewriteLoopExitValues.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:245,Modifiability,enhance,enhance,245,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:154,Testability,test,testcase,154,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:257,Testability,log,logic,257,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:122,Usability,simpl,simplicity,122,"// In LoopDeletion pass Loop can be deleted when ExitingBlocks.size() > 1.; // We obviate multiple ExitingBlocks case for simplicity.; // TODO: If we see testcase with multiple ExitingBlocks can be deleted; // after exit value rewriting, we can enhance the logic here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:42,Modifiability,Rewrite,RewritePhiSet,42,"// If the Incoming value of P is found in RewritePhiSet, we know it; // could be rewritten to use a loop invariant value in transformation; // phase later. Skip it in the loop invariant check below.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:20,Safety,safe,safe,20,"/// Checks if it is safe to call InductionDescriptor::isInductionPHI for \p Phi,; /// and returns true if this Phi is an induction phi in the loop. When; /// isInductionPHI returns true, \p ID will be also be set by isInductionPHI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:174,Deployability,update,update,174,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Modifiability,variab,variables,40,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:165,Modifiability,variab,variable,165,"// Find exit values which are induction variables in the loop, and are; // unused in the loop, with the only use being the exit block PhiNode,; // and the induction variable update binary operator.; // The exit value can be replaced with the final value when it is cheap; // to do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:97,Deployability,update,update,97,"// This is an induction PHI. Check that the only users are PHI; // nodes, and induction variable update binary operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:88,Modifiability,variab,variable,88,"// This is an induction PHI. Check that the only users are PHI; // nodes, and induction variable update binary operators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:58,Deployability,update,update,58,"// If it is not an induction phi, it must be an induction update; // binary operator with an induction phi user.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:80,Safety,predict,predictably,80,"// Okay, this instruction has a user outside of the current loop; // and varies predictably *inside* the loop. Evaluate the value it; // contains when the loop exits, if possible. We prefer to start with; // expressions which are true for all exits (so as to maximize; // expression reuse by the SCEVExpander), but resort to per-exit; // evaluation if that fails.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:132,Performance,optimiz,optimized,132,// Computing the value outside of the loop brings no benefit if it is; // definitely used inside the loop in a way which can not be optimized; // away. Avoid doing so unless we know we have a value which computes; // the ExitValue already. TODO: This should be merged into SCEV; // expander to leverage its knowledge of existing expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:152,Safety,Avoid,Avoid,152,// Computing the value outside of the loop brings no benefit if it is; // definitely used inside the loop in a way which can not be optimized; // away. Avoid doing so unless we know we have a value which computes; // the ExitValue already. TODO: This should be merged into SCEV; // expander to leverage its knowledge of existing expressions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:25,Performance,perform,perform,25,"// Note that we must not perform expansions until after; // we query *all* the costs, because if we perform temporary expansion; // inbetween, one that we might not intend to keep, said expansion; // *may* affect cost calculation of the next SCEV's we'll query,; // and next SCEV may errneously get smaller cost.; // Collect all the candidate PHINodes to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:100,Performance,perform,perform,100,"// Note that we must not perform expansions until after; // we query *all* the costs, because if we perform temporary expansion; // inbetween, one that we might not intend to keep, said expansion; // *may* affect cost calculation of the next SCEV's we'll query,; // and next SCEV may errneously get smaller cost.; // Collect all the candidate PHINodes to be rewritten.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:15,Modifiability,rewrite,rewrite,15,"// Only do the rewrite when the ExitValue can be expanded cheaply.; // If LoopCanBeDel is true, rewrite exit value aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:96,Modifiability,rewrite,rewrite,96,"// Only do the rewrite when the ExitValue can be expanded cheaply.; // If LoopCanBeDel is true, rewrite exit value aggressively.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:66,Safety,avoid,avoid,66,"// If this instruction is dead now, delete it. Don't do it now to avoid; // invalidating iterators.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:87,Modifiability,rewrite,rewriter,87,// The insertion point instruction may have been deleted; clear it out; // so that the rewriter doesn't trip over it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:58,Usability,clear,clear,58,// The insertion point instruction may have been deleted; clear it out; // so that the rewriter doesn't trip over it later.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:337,Energy Efficiency,reduce,reduces,337,"// If the Low and High values are themselves loop-variant, then we may want; // to expand the range to include those covered by the outer loop as well.; // There is a trade-off here with the advantage being that creating checks; // using the expanded range permits the runtime memory checks to be hoisted; // out of the outer loop. This reduces the cost of entering the inner loop,; // which can be significant for low trip counts. The disadvantage is that; // there is a chance we may now never enter the vectorized inner loop,; // whereas using a restricted range check could have allowed us to enter at; // least once. This is why the behaviour is not currently the default and is; // controlled by the parameter 'HoistRuntimeChecks'.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:45,Performance,cache,cache,45,// Here we're relying on the SCEV Expander's cache to only emit code for the; // same bounds once.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:35,Security,access,accessed,35,"// [A|B].Start points to the first accessed byte under base [A|B].; // [A|B].End points to the last accessed byte, plus one.; // There is no conflict when the intervals are disjoint:; // NoConflict = (B.Start >= A.End) || (A.Start >= B.End); //; // bound0 = (B.Start < A.End); // bound1 = (A.Start < B.End); // IsConflict = bound0 & bound1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:100,Security,access,accessed,100,"// [A|B].Start points to the first accessed byte under base [A|B].; // [A|B].End points to the last accessed byte, plus one.; // There is no conflict when the intervals are disjoint:; // NoConflict = (B.Start >= A.End) || (A.Start >= B.End); //; // bound0 = (B.Start < A.End); // bound1 = (A.Start < B.End); // IsConflict = bound0 & bound1",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:127,Availability,redundant,redundant,127,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:104,Safety,detect,detecting,104,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:127,Safety,redund,redundant,127,"// Map to keep track of created compares, The key is the pair of operands for; // the compare, to allow detecting and re-using redundant compares.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:21,Security,Access,AccessSize,21,// Compute VF * IC * AccessSize.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:40,Performance,load,loads,40,// Do not duplicate volatile and atomic loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:3,Performance,Queue,Queue,3,// Queue the defining access to check for alias checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:22,Security,access,access,22,// Queue the defining access to check for alias checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:55,Deployability,patch,patch,55,"// First, collect all blocks in the loop that are on a patch from Succ; // to the header.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:150,Security,Access,AccessedLocs,150,"// Next, check if there are any MemoryDefs that are on the path through; // the loop (in the Seen set) and they may-alias any of the locations in; // AccessedLocs. If that is the case, they may modify the condition and; // partial unswitching is not possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:27,Security,access,accesses,27,// MemoryUse are read-only accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp:109,Availability,avail,available,109,"// We could also allow loops with known trip counts without mustprogress,; // but ScalarEvolution may not be available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:420,Performance,perform,perform,420,"//===- LoopVersioning.cpp - Utility to version a loop ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:514,Security,access,accesses,514,"//===- LoopVersioning.cpp - Utility to version a loop ---------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines a utility class to perform loop versioning. The versioned; // loop speculates that otherwise may-aliasing memory accesses don't overlap and; // emits checks to prove this.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:91,Usability,Simpl,SimplifyLoop,91,// Clone the loop including the preheader.; //; // FIXME: This does not currently preserve SimplifyLoop because the exit; // block is a join between the two loops.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp:9,Energy Efficiency,allocate,allocate,9,"// First allocate an aliasing scope for each pointer checking group.; //; // While traversing through the checking groups in the loop, also create a; // reverse map from pointers to the pointer checking group they were assigned; // to.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LoopVersioning.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:473,Integrability,wrap,wrapper,473,"//===-- LowerGlobalDtors.cpp - Lower @llvm.global_dtors -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; ///; /// \file; /// Lower @llvm.global_dtors.; ///; /// Implement @llvm.global_dtors by creating wrapper functions that are; /// registered in @llvm.global_ctors and which contain a call to; /// `__cxa_atexit` to register their destructor functions.; ///; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:3,Security,Validat,Validate,3,// Validate @llvm.global_dtor's type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:107,Testability,stub,stub,107,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:184,Usability,simpl,simply,184,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp:208,Usability,clear,clear,208,// If __cxa_atexit is defined (e.g. in the case of LTO) and arg0 is not; // actually used (i.e. it's dummy/stub function as used in emscripten when; // the program never exits) we can simply return early and clear out; // @llvm.global_dtors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerGlobalDtors.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp:668,Usability,simpl,simplifycfg,668,"//===- LowerInvoke.cpp - Eliminate Invoke instructions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This transformation is designed for use by code generators which do not yet; // support stack unwinding. This pass converts 'invoke' instructions to 'call'; // instructions, so that any exception-handling 'landingpad' blocks become dead; // code (which can be removed by running the '-simplifycfg' pass afterwards).; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp:10,Integrability,Interface,Interface,10,// Public Interface To the LowerInvoke pass.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerInvoke.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:11,Deployability,update,update,11,"// Need to update the pre-loop basic block to branch to the correct place.; // branch to the main loop if the count is non-zero, branch to the residual; // loop if the copy size is smaller then 1 iteration of the main loop but; // non-zero and finally branch to after the residual loop if the memcpy; // size is zero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,load,38,// Copy the residual with single byte load/store loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:23,Performance,load,loads,23,// Set alias scope for loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:38,Performance,load,loads,38,// Indicate that stores don't overlap loads.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp:171,Deployability,patch,patch,171,"// In this case the loop operand type was a byte, and there is no need for a; // residual loop to copy the remaining memory after the main loop.; // We do however need to patch up the control flow by creating the; // terminators for the preloop block and the memcpy loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerMemIntrinsics.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:414,Modifiability,rewrite,rewrites,414,"//===- LowerSwitch.cpp - Eliminate Switch instructions --------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // The LowerSwitch transformation rewrites switch instructions with a sequence; // of branches, which allows targets to get away with not implementing the; // switch instruction until it is convenient.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:4,Deployability,Update,Update,4,"/// Update the first occurrence of the ""switch statement"" BB in the PHI; /// node with the ""new"" BB. The other occurrences will:; ///; /// 1) Be updated by subsequent calls to this function. Switch statements may; /// have more than one outcoming edge into the same BB if they all have the same; /// value. When the switch statement is converted these incoming edges are now; /// coming from multiple BBs.; /// 2) Removed if subsequent incoming values now share the same case, i.e.,; /// multiple outcome edges are condensed into one. This is necessary to keep the; /// number of phi values equal to the number of branches to SuccBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:145,Deployability,update,updated,145,"/// Update the first occurrence of the ""switch statement"" BB in the PHI; /// node with the ""new"" BB. The other occurrences will:; ///; /// 1) Be updated by subsequent calls to this function. Switch statements may; /// have more than one outcoming edge into the same BB if they all have the same; /// value. When the switch statement is converted these incoming edges are now; /// coming from multiple BBs.; /// 2) Removed if subsequent incoming values now share the same case, i.e.,; /// multiple outcome edges are condensed into one. This is necessary to keep the; /// number of phi values equal to the number of branches to SuccBB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:8,Deployability,update,update,8,// Only update the first occurrence if NewBB exists.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:12,Deployability,update,updated,12,// Skip the updated incoming block so that it will not be removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:3,Deployability,Update,Update,3,// Update the PHI incoming value/block for the default.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:50,Modifiability,rewrite,rewrite,50,"// If there were any PHI nodes in this successor, rewrite one entry; // from OrigBlock to come from NewLeaf.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:125,Safety,avoid,avoid,125,// Check if the Case Range is perfectly squeezed in between; // already checked Upper and Lower bounds. If it is then we can avoid; // emitting the code that checks if the value actually falls in the range; // because the bounds already tell us so.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:79,Safety,safe,safe,79,// Because NewLowerBound is never the smallest representable integer; // it is safe here to subtract one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:14,Usability,simpl,simple,14,/// Transform simple list of \p SI's cases into list of CaseRange's \p Cases.; /// \post \p Cases wouldn't contain references to \p SI's default BB.; /// \returns Number of \p SI's cases that do not reference \p SI's default BB.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:15,Usability,simpl,simple,15,"// Start with ""simple"" cases",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:54,Deployability,update,update,54,"// As the default block in the switch is unreachable, update the PHI nodes; // (remove all of the references to the default block) to reflect this.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:20,Integrability,interface,interface,20,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:12,Security,expose,exposed,12,// Publicly exposed interface to pass...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp:27,Integrability,Interface,Interface,27,// createLowerSwitchPass - Interface to this file...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/LowerSwitch.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:42,Integrability,wrap,wrapper,42,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:410,Integrability,wrap,wrapper,410,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:463,Security,expose,exposed,463,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:398,Usability,simpl,simple,398,"//===- Mem2Reg.cpp - The -mem2reg pass, a wrapper around the Utils lib ----===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass is a simple pass wrapper around the PromoteMemToReg function call; // exposed by the Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:25,Safety,safe,safe,25,"// Find allocas that are safe to promote, by looking at all instructions in; // the entry node",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp:93,Safety,safe,safe,93,"// runOnFunction - To run this pass, first we calculate the alloca; // instructions that are safe for promotion, then we promote each one.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/Mem2Reg.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:25,Usability,user-friendly,user-friendly,25,// For intrinsics:; // * user-friendly name; // * size,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:80,Integrability,message,message,80,// Emit the false cases under ExtraArgs. This won't show them in the remark; // message but will end up in the serialized remarks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:118,Modifiability,variab,variable,118,"// Try to get an llvm.dbg.declare, which has a DILocalVariable giving us the; // real debug info name and size of the variable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp:26,Modifiability,variab,variable,26,// Find if Ptr is a known variable we can give more information on.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryOpRemark.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:93,Safety,avoid,avoid,93,"// If there's a mix of covered and non-covered exits, just put the untag; // on exits, so we avoid the redundancy of untagging twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:103,Safety,redund,redundancy,103,"// If there's a mix of covered and non-covered exits, just put the untag; // on exits, so we avoid the redundancy of untagging twice.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp:3,Safety,safe,safe,3,// safe allocas are not interesting,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MemoryTaggingSupport.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:57,Usability,simpl,simple,57,// This PRNG is from the ISO C spec. It is intentionally simple and; // unsuitable for cryptographic use. We're just looking for enough; // variety to surprise and delight users.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:83,Safety,avoid,avoid,83,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:22,Usability,simpl,simple,22,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:76,Usability,simpl,simply,76,"// Seed our PRNG with simple additive sum of ModuleID. We're looking to; // simply avoid always having the same function names, and we need to; // remain deterministic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp:21,Modifiability,variab,variables,21,// Rename all global variables,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MetaRenamer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:1430,Integrability,message,message,1430,"//===--- MisExpect.cpp - Check the use of llvm.expect with PGO data -------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This contains code to emit warnings for potentially incorrect usage of the; // llvm.expect intrinsic. This utility extracts the threshold values from; // metadata associated with the instrumented Branch or Switch instruction. The; // threshold values are then used to determine if a warning should be emmited.; //; // MisExpect's implementation relies on two assumptions about how branch weights; // are managed in LLVM.; //; // 1) Frontend profiling weights are always in place before llvm.expect is; // lowered in LowerExpectIntrinsic.cpp. Frontend based instrumentation therefore; // needs to extract the branch weights and then compare them to the weights; // being added by the llvm.expect intrinsic lowering.; //; // 2) Sampling and IR based profiles will *only* have branch weight metadata; // before profiling data is consulted if they are from a lowered llvm.expect; // intrinsic. These profiles thus always extract the expected weights and then; // compare them to the weights collected during profiling to determine if a; // diagnostic message is warranted.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:61,Testability,assert,assertion,61,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:307,Testability,assert,assert,307,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:245,Usability,simpl,simply,245,"// FIXME: When we've addressed sample profiling, restore the assertion; //; // We cannot calculate branch probability if either of these invariants aren't; // met. However, MisExpect diagnostics should not prevent code from compiling,; // so we simply forgo emitting diagnostics here, and return early.; // assert((TotalBranchWeight >= LikelyBranchWeight) && (TotalBranchWeight > 0); // && ""TotalBranchWeight is less than the Likely branch weight"");",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:9,Availability,toler,tolerance,9,"// clamp tolerance range to [0, 100)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp:62,Availability,toler,tolerance,62,"// Allow users to relax checking by N% i.e., if they use a 5% tolerance,; // then we check against 0.95*ScaledThreshold",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MisExpect.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:408,Performance,perform,perform,408,"//===-- ModuleUtils.cpp - Functions to manipulate Modules -----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This family of functions perform manipulations on Modules.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:25,Modifiability,variab,variable,25,// Create the new global variable and replace all uses of; // the old global variable with the new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:77,Modifiability,variab,variable,77,// Create the new global variable and replace all uses of; // the old global variable with the new one.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:90,Deployability,patch,patchable-function-prefix,90,"// If the module was compiled with -fpatchable-function-entry, ensure; // we use the same patchable-function-prefix.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:110,Performance,concurren,concurrent,110,"// FIXME: Sink this logic into the module, similar to the handling of; // globals. This will make moving to a concurrent model much easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:20,Testability,log,logic,20,"// FIXME: Sink this logic into the module, similar to the handling of; // globals. This will make moving to a concurrent model much easier.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:3,Deployability,Update,Update,3,// Update all users to load a pointer from the global table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp:23,Performance,load,load,23,// Update all users to load a pointer from the global table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ModuleUtils.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:23,Safety,detect,detect,23,// Traverse the CFG to detect cycles `UsersDominator` would be part of.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp:7,Performance,Perform,Perform,7,//; // Perform the actual substitution.; //,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/MoveAutoInit.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:22,Security,hash,hash,22,"// Compute a ""unique"" hash for the module based on the name of the public; // globals.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:31,Security,hash,hash,31,/// Return the lazily computed hash.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp:3,Performance,Cache,Cache,3,// Cache hit :),MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/NameAnonGlobals.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:3,Performance,Perform,Perform,3,// Perform a strict weak ordering on instructions and arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:8,Performance,perform,performs,8,"// This performs the necessary local basic block ordering checks to tell; // whether A comes before B, where both are in the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:170,Safety,detect,detect,170,"// This stores info about each operand or comparison result we make copies; // of. The real ValueInfos start at index 1, index 0 is unused so that we; // can more easily detect invalid indexing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:45,Safety,detect,detect,45,// Push an empty operand info so that we can detect 0 as not finding one,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:95,Integrability,depend,depending,95,"// The maximum number of things we should be trying to materialize at once; // right now is 4, depending on if we had an assume, a branch, and both used; // and of conditions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:408,Safety,detect,detect,408,"// For edge predicates, we can just place the operand in the block before; // the terminator. For assume, we have to place it right before the assume; // to ensure we dominate all of our uses. Always insert right before the; // relevant instruction (terminator, assume), so that we insert in proper; // order in the case of multiple predicateinfo in the same block.; // The number of named values is used to detect if a new declaration was; // added. If so, that declaration is tracked so that it can be removed when; // the analysis is done. The corner case were a new declaration results in; // a name clash and the old name being renamed is not considered as that; // represents an invalid module.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:1235,Modifiability,variab,variable,1235,"// Instead of the standard SSA renaming algorithm, which is O(Number of; // instructions), and walks the entire dominator tree, we walk only the defs +; // uses. The standard SSA renaming algorithm does not really rely on the; // dominator tree except to order the stack push/pops of the renaming stacks, so; // that defs end up getting pushed before hitting the correct uses. This does; // not require the dominator tree, only the *order* of the dominator tree. The; // complete and correct ordering of the defs and uses, in dominator tree is; // contained in the DFS numbering of the dominator tree. So we sort the defs and; // uses into the DFS ordering, and then just use the renaming stack as per; // normal, pushing when we hit a def (which is a predicateinfo instruction),; // popping when we are out of the dfs scope for that def, and replacing any uses; // with top of stack if it exists. In order to handle liveness without; // propagating liveness info, we don't actually insert the predicateinfo; // instruction def until we see a use that it would dominate. Once we see such; // a use, we materialize the predicateinfo instruction in the right place and; // use it.; //; // TODO: Use this algorithm to perform fast single-variable renaming in; // promotememtoreg and memoryssa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:1215,Performance,perform,perform,1215,"// Instead of the standard SSA renaming algorithm, which is O(Number of; // instructions), and walks the entire dominator tree, we walk only the defs +; // uses. The standard SSA renaming algorithm does not really rely on the; // dominator tree except to order the stack push/pops of the renaming stacks, so; // that defs end up getting pushed before hitting the correct uses. This does; // not require the dominator tree, only the *order* of the dominator tree. The; // complete and correct ordering of the defs and uses, in dominator tree is; // contained in the DFS numbering of the dominator tree. So we sort the defs and; // uses into the DFS ordering, and then just use the renaming stack as per; // normal, pushing when we hit a def (which is a predicateinfo instruction),; // popping when we are out of the dfs scope for that def, and replacing any uses; // with top of stack if it exists. In order to handle liveness without; // propagating liveness info, we don't actually insert the predicateinfo; // instruction def until we see a use that it would dominate. Once we see such; // a use, we materialize the predicateinfo instruction in the right place and; // use it.; //; // TODO: Use this algorithm to perform fast single-variable renaming in; // promotememtoreg and memoryssa.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:56,Performance,perform,perform,56,"// Otherwise, we are in the split block (even though we perform; // insertion in the branch block).; // Insert a possible copy at the split block and before the branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:115,Testability,assert,asserting,115,"// Collect function pointers in set first, as SmallSet uses a SmallVector; // internally and we have to remove the asserting value handles first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp:22,Testability,assert,assertion,22,// TODO: Make this an assertion once RenamedOp is fully accurate.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PredicateInfo.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:669,Modifiability,rewrite,rewrite,669,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:499,Performance,load,loads,499,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:677,Performance,load,loads,677,"//===- PromoteMemoryToRegister.cpp - Convert allocas to registers ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file promotes memory references to be register references. It promotes; // alloca instructions which only have loads and stores as uses. An alloca is; // transformed by using iterated dominator frontiers to place PHI nodes, then; // traversing the function in depth-first order to rewrite loads and stores as; // appropriate.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:38,Performance,load,loads,38,// Only allow direct and non-volatile loads and stores...,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,loads,20,// Note that atomic loads can be transformed; atomic semantics do; // not have any meaning for a local alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:66,Modifiability,variab,variable,66,/// DbgAssignIntrinsics linked to the alloca with at most one per variable; /// fragment. (i.e. not be a comprehensive set if there are multiple; /// dbg.assigns for one variable fragment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:170,Modifiability,variab,variable,170,/// DbgAssignIntrinsics linked to the alloca with at most one per variable; /// fragment. (i.e. not be a comprehensive set if there are multiple; /// dbg.assigns for one variable fragment).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,/// Update assignment tracking debug info given for the to-be-deleted store; /// \p ToDelete that stores to this alloca.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:56,Modifiability,variab,variables,56,// There's nothing to do if the alloca doesn't have any variables using; // assignment tracking.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:169,Energy Efficiency,reduce,reduce,169,// Insert a dbg.value where the linked dbg.assign is and remember to delete; // the dbg.assign later. Demoting to dbg.value isn't necessary for; // correctness but does reduce compile time and memory usage by reducing; // unnecessary function-local metadata. Remember that we've seen a; // dbg.assign for each variable fragment for the untracked store handling; // (after this loop).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:310,Modifiability,variab,variable,310,// Insert a dbg.value where the linked dbg.assign is and remember to delete; // the dbg.assign later. Demoting to dbg.value isn't necessary for; // correctness but does reduce compile time and memory usage by reducing; // unnecessary function-local metadata. Remember that we've seen a; // dbg.assign for each variable fragment for the untracked store handling; // (after this loop).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:21,Modifiability,variab,variables,21,// It's possible for variables using assignment tracking to have no; // dbg.assign linked to this store. These are variables in DbgAssigns that; // are missing from VarHasDbgAssignForStore. Since there isn't a dbg.assign; // to mark the assignment - and the store is going to be deleted - insert a; // dbg.value to do that now. An untracked store may be either one that; // cannot be represented using assignment tracking (non-const offset or; // size) or one that is trackable but has had its DIAssignID attachment; // dropped accidentally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:115,Modifiability,variab,variables,115,// It's possible for variables using assignment tracking to have no; // dbg.assign linked to this store. These are variables in DbgAssigns that; // are missing from VarHasDbgAssignForStore. Since there isn't a dbg.assign; // to mark the assignment - and the store is going to be deleted - insert a; // dbg.value to do that now. An untracked store may be either one that; // cannot be represented using assignment tracking (non-const offset or; // size) or one that is trackable but has had its DIAssignID attachment; // dropped accidentally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,/// Update assignment tracking debug info given for the newly inserted PHI \p; /// NewPhi.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:14,Deployability,update,update,14,/// Helper to update assignment tracking debug info.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:106,Performance,load,loads,106,"// As we scan the uses of the alloca instruction, keep track of stores,; // and decide whether all of the loads and stores to the alloca are within; // the same basic block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:58,Modifiability,variab,variable,58,"// Otherwise it must be a load instruction, keep track of variable; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:26,Performance,load,load,26,"// Otherwise it must be a load instruction, keep track of variable; // reads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,Performance,load,load,57,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:113,Performance,load,load,113,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:191,Safety,avoid,avoids,191,/// This assigns and keeps a per-bb relative ordering of load/store; /// instructions in the block that directly load or store an alloca.; ///; /// This functionality is important because it avoids scanning large basic; /// blocks multiple times when promoting many allocas in the same block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:28,Security,access,accesses,28,/// This code only looks at accesses to allocas.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:145,Safety,avoid,avoid,145,"// Scan the whole block to get the instruction. This accumulates; // information for every interesting instruction in the block, in order to; // avoid gratuitus rescans.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:6,Performance,cache,cache,6,/// A cache of @llvm.assume intrinsics used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:47,Usability,Simpl,SimplifyInstruction,47,/// A cache of @llvm.assume intrinsics used by SimplifyInstruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:301,Energy Efficiency,efficient,efficient,301,"/// The PhiNodes we're adding.; ///; /// That map is used to simplify some Phi nodes as we iterate over it, so; /// it should have deterministic iterators. We could use a MapVector, but; /// since we already maintain a map from BasicBlock* to a stable numbering; /// (BBNumbers), the DenseMap is more efficient (also supports removal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Usability,simpl,simplify,61,"/// The PhiNodes we're adding.; ///; /// That map is used to simplify some Phi nodes as we iterate over it, so; /// it should have deterministic iterators. We could use a MapVector, but; /// since we already maintain a map from BasicBlock* to a stable numbering; /// (BBNumbers), the DenseMap is more efficient (also supports removal).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:90,Deployability,update,update,90,"/// For each alloca, keep an instance of a helper class that gives us an easy; /// way to update assignment tracking debug info if the alloca is promoted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:51,Safety,avoid,avoid,51,/// Contains a stable numbering of basic blocks to avoid non-determinstic; /// behavior.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:40,Performance,Load,LoadInst,40,// end anonymous namespace; /// Given a LoadInst LI this adds assume(LI != null) after it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:10,Performance,load,load,10,"// If the load was marked as nonnull we don't want to lose that information; // when we erase this Load. So we preserve it with an assume. As !nonnull; // returns poison while assume violations are immediate undefined behavior,; // we can only do this if the value is known non-poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:99,Performance,Load,Load,99,"// If the load was marked as nonnull we don't want to lose that information; // when we erase this Load. So we preserve it with an assume. As !nonnull; // returns poison while assume violations are immediate undefined behavior,; // we can only do this if the value is known non-poison.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:106,Performance,load,load,106,"// Knowing that this alloca is promotable, we know that it's safe to kill all; // instructions except for load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Safety,safe,safe,61,"// Knowing that this alloca is promotable, we know that it's safe to kill all; // instructions except for load and store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Modifiability,Rewrite,Rewrite,4,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,loads,20,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:175,Performance,load,loads,175,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:330,Performance,load,loads,330,"/// Rewrite as many loads as possible given a single store.; ///; /// When there is only a single store, we can use the domtree to trivially; /// replace all of the dominated loads with the stored value. Do so, and return; /// true if this has successfully promoted the alloca entirely. If this returns; /// false there were some loads which were not dominated by the single store; /// and thus must be phi-ed with undef. We fall back to the standard alloca; /// promotion algorithm in that case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Usability,Clear,Clear,3,// Clear out UsingBlocks. We will reconstruct it here if needed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:22,Performance,load,load,22,"// Okay, if we have a load from the alloca, we want to replace it with the; // only value stored to the alloca. We can do this if the value is; // dominated by the store. If not, we use the rest of the mem2reg machinery; // to insert the phi nodes as needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:148,Performance,load,load,148,"// If we have a use that is in the same block as the store, compare the; // indices of the two instructions to see which one came first. If the; // load came before the store, we can't handle it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:21,Performance,load,load,21,"// Can't handle this load, bail out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:10,Performance,load,load,10,"// If the load and store are in different blocks, use BB dominance to; // check their relationships. If the store doesn't dom the use, bail; // out.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:30,Modifiability,rewrite,rewrite,30,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:43,Performance,load,load,43,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:23,Safety,safe,safely,23,"// Otherwise, we *can* safely rewrite this load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:35,Performance,load,load,35,"// If the replacement value is the load, this must occur in unreachable; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update assignment tracking info for the store we're going to delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:177,Performance,perform,performing,177,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:86,Safety,avoid,avoid,86,"/// Many allocas are only used within a single basic block. If this is the; /// case, avoid traversing the CFG and inserting a lot of potentially useless; /// PHI nodes by just performing a single linear pass over the basic block; /// using the Alloca.; ///; /// If we cannot promote this alloca (because it is read before it is written),; /// return false. This is necessary in cases where, due to control flow, the; /// alloca is undefined only on some control flow paths. e.g. code like; /// this is correct in LLVM IR:; /// // A is an alloca with no stores so far; /// for (...) {; /// int t = *A;; /// if (!first_iteration); /// use(t);; /// *A = 42;; /// }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:245,Energy Efficiency,efficient,efficient,245,"// The trickiest case to handle is when we have large blocks. Because of this,; // this code is optimized assuming that large blocks happen. This does not; // significantly pessimize the small block case. This uses LargeBlockInfo to; // make it efficient to get the index of various operations in the block.; // Walk the use-def list of the alloca, getting the locations of all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:96,Performance,optimiz,optimized,96,"// The trickiest case to handle is when we have large blocks. Because of this,; // this code is optimized assuming that large blocks happen. This does not; // significantly pessimize the small block case. This uses LargeBlockInfo to; // make it efficient to get the index of various operations in the block.; // Walk the use-def list of the alloca, getting the locations of all stores.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:45,Energy Efficiency,efficient,efficient,45,"// Sort the stores by their index, making it efficient to do a lookup with a; // binary search.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:19,Performance,load,loads,19,"// Walk all of the loads from this alloca, replacing them with the nearest; // store above them, if any.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:59,Performance,load,load,59,// Find the nearest store that has a lower index than this load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:31,Performance,load,load,31,"// If there are no stores, the load takes the undef value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:33,Performance,load,load,33,"// There is no store before this load, bail out (load may be affected; // by the following stores - see main comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:49,Performance,load,load,49,"// There is no store before this load, bail out (load may be affected; // by the following stores - see main comment).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:44,Performance,load,load,44,"// Otherwise, there was a store before this load, the load takes its; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:54,Performance,load,load,54,"// Otherwise, there was a store before this load, the load takes its; // value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:35,Performance,load,load,35,"// If the replacement value is the load, this must occur in unreachable; // code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update assignment tracking info for the store we're going to delete.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:136,Modifiability,variab,variable,136,// Calculate the set of read and write-locations for each alloca. This is; // analogous to finding the 'uses' and 'definitions' of each variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:62,Performance,load,loads,62,"// If there is only a single store to this value, replace any loads of; // it that are directly dominated by the definition with the value stored.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:67,Performance,perform,perform,67,"// If the alloca is only read and written in one basic block, just perform a; // linear sweep over the block to eliminate it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:41,Energy Efficiency,efficient,efficient,41,// Unique the set of defining blocks for efficient lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:180,Performance,optimiz,optimize,180,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:206,Safety,avoid,avoiding,206,"// At this point, we're committed to promoting the alloca using IDF's, and; // the standard SSA construction algorithm. Determine which blocks need phi; // nodes and see if we can optimize out some work by avoiding insertion of; // dead phi nodes.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:124,Performance,load,load,124,"// Set the incoming values for the basic block to be null values for all of; // the alloca's. We do this in case there is a load of a value that has not; // been stored yet. In this case, it will get this null value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:42,Performance,perform,performing,42,// Walks all basic blocks in the function performing the SSA rename algorithm; // and inserting the phi nodes we marked as necessary,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:39,Safety,avoid,avoid,39,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:61,Usability,Clear,Clear,61,// The renamer uses the Visited set to avoid infinite loops. Clear it now.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Availability,redundant,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:60,Safety,redund,redundant,60,// Remove dbg.assigns linked to the alloca as these are now redundant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:57,Safety,safe,safe,57,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:76,Usability,simpl,simplify,76,"// Iterating over NewPhiNodes is deterministic, so it is safe to try to; // simplify and RAUW them as we go. If it was not, we could add uses to; // the values we replace with in a non-deterministic order, thus creating; // non-deterministic def->use chains.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:139,Energy Efficiency,efficient,efficient,139,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:153,Security,access,access,153,"// Ok, now we know that all of the PHI nodes are missing entries for some; // basic blocks. Start by sorting the incoming predecessors for efficient; // access.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:8,Testability,log,log,8,// Do a log(n) search of the Preds list for the entry we want.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:125,Deployability,Update,Update,125,"// At this point, the blocks left in the preds list must have dummy; // entries inserted into every PHI nodes for the block. Update all the phi; // nodes in this block that we are inserting (there could be phis before; // mem2reg runs).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:122,Safety,avoid,avoid,122,"/// Determine which blocks the value is live in.; ///; /// These are blocks which lead to uses. Knowing this allows us to avoid; /// inserting PHI nodes into blocks which don't lead to uses (thus, the; /// inserted phi nodes would be dead).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:43,Performance,load,load,43,// We found a store to the alloca before a load. The alloca is not; // actually live-in here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:20,Performance,load,load,20,"// Okay, we found a load before a store to the alloca. It is actually; // live into this block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:140,Modifiability,variab,variable,140,/// Queue a phi-node to be added to a basic-block for a specific Alloca.; ///; /// Returns true if there wasn't already a phi-node for that variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Performance,Queue,Queue,4,/// Queue a phi-node to be added to a basic-block for a specific Alloca.; ///; /// Returns true if there wasn't already a phi-node for that variable,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:4,Deployability,Update,Update,4,"/// Update the debug location of a phi. \p ApplyMergedLoc indicates whether to; /// create a merged location incorporating \p DL, or to set \p DL directly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:59,Performance,load,loads,59,"/// Recursively traverse the CFG of the function, renaming loads and; /// stores to the allocas which we are promoting.; ///; /// IncomingVals indicates what value each Alloca contains on exit from the; /// predecessor block Pred.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:27,Deployability,update,update,27,"// If we have PHI nodes to update, compute the number of edges from Pred to; // BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:3,Deployability,Update,Update,3,// Update the location of the phi node.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:24,Modifiability,variab,variable,24,// The currently active variable for this block is now the PHI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp:22,Performance,load,load,22,// Anything using the load now uses the current value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/PromoteMemoryToRegister.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:103,Usability,simpl,simplify,103,"// If lookup table has more than one user,; // do not generate a relative lookup table.; // This is to simplify the analysis that needs to be done for this pass.; // TODO: Add support for lookup tables with multiple uses.; // For ex, this can happen when a function that uses a lookup table gets; // inlined into multiple call sites.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:136,Performance,optimiz,optimization,136,"// If the original lookup table does not have local linkage and is; // not dso_local, do not generate a relative lookup table.; // This optimization creates a relative lookup table that consists of; // offsets between the start of the lookup table and its elements.; // To be able to generate these offsets, relative lookup table and; // its elements should have internal linkage and be dso_local, which means; // that they should resolve to symbols within the same linkage unit.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:22,Performance,load,load,22,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:53,Performance,LOAD,LOAD,53,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:106,Performance,LOAD,LOAD,106,"// Insert the call to load.relative intrinsic before LOAD.; // GEP might not be immediately followed by a LOAD, like it can be hoisted; // outside the loop or another instruction might be inserted them in between.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:20,Performance,load,load,20,// Create a call to load.relative intrinsic that computes the target address; // by adding base address (lookup table address) and relative offset.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:11,Performance,load,load,11,// Replace load instruction with the new generated instruction sequence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp:10,Performance,Load,Load,10,// Remove Load and GEP instructions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/RelLookupTableConverter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the distance and the parent node/edge,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:23,Performance,queue,queue,23,"// Add the node to the queue, if it is not there yet",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:4,Deployability,Update,Update,4,/// Update the current flow along the augmenting path.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:48,Safety,avoid,avoid,48,"// We use a stack based implemenation of DFS to avoid recursion.; // Defining DFS data structures:; // A pair (NodeIdx, EdgeIdx) at the top of the Stack denotes that; // - we are currently visiting Nodes[NodeIdx] and; // - the next edge to scan is Edges[NodeIdx][EdgeIdx]",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:4,Deployability,Update,Update,4,"/// Update the current flow along the given (acyclic) subgraph specified by; /// the vertex order, AugmentingOrder. The objective is to send as much flow; /// as possible while evenly distributing flow among successors of each node.; /// After the update at least one edge is saturated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:248,Deployability,update,update,248,"/// Update the current flow along the given (acyclic) subgraph specified by; /// the vertex order, AugmentingOrder. The objective is to send as much flow; /// as possible while evenly distributing flow among successors of each node.; /// After the update at least one edge is saturated.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:12,Deployability,Update,Update,12,// Phase 4: Update flow values along all edges,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update flow values along the edge and its reverse copy,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:53,Performance,queue,queue,53,/// An indicator of whether the current node is in a queue.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update reachability,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:131,Safety,avoid,avoid,131,"/// A distance of a path for a given jump.; /// In order to incite the path to use blocks/jumps with large positive flow,; /// and avoid changing branch probability of outgoing edges drastically,; /// set the jump distance so as:; /// - to minimize the number of unlikely jumps used and subject to that,; /// - to minimize the number of Flow == 0 jumps used and subject to that,; /// - minimizes total multiplicative Flow increase for the remaining edges.; /// To capture this objective with integer distances, we round off fractional; /// parts to a multiple of 1 / BaseDistance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:14,Performance,queue,queue,14,// Add to the queue all successors with zero local in-degree,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:35,Deployability,update,update,35,// Process all successor jumps and update corresponding flow values,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:20,Integrability,depend,depending,20,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:3,Deployability,Update,Update,3,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:20,Integrability,depend,depending,20,// Update the costs depending on the block metadata,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp:140,Safety,avoid,avoid,140,"// Verify that there are no isolated flow components; // One could modify FlowFunction to hold edges indexed by the sources, which; // will avoid a creation of the object",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileInference.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:49,Performance,load,loader,49,"//===- SampleProfileLoaderBaseUtil.cpp - Profile loader Util func ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SampleProfileLoader base utility functions.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:1011,Performance,perform,performance,1011,"/// Return true if the given callsite is hot wrt to hot cutoff threshold.; ///; /// Functions that were inlined in the original binary will be represented; /// in the inline stack in the sample profile. If the profile shows that; /// the original inline decision was ""good"" (i.e., the callsite is executed; /// frequently), then we will recreate the inline decision and apply the; /// profile from the inlined callsite.; ///; /// To decide whether an inlined callsite is hot, we compare the callsite; /// sample count with the hot cutoff computed by ProfileSummaryInfo, it is; /// regarded as hot if the count is above the cutoff value.; ///; /// When ProfileAccurateForSymsInList is enabled and profile symbol list; /// is present, functions in the profile symbol list but without profile will; /// be regarded as cold and much less inlining will happen in CGSCC inlining; /// pass, so we tend to lower the hot criteria here to allow more early; /// inlining to happen for warm callsites and it is helpful for performance.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:20,Modifiability,variab,variable,20,/// Create a global variable to flag FSDiscriminators are used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp:14,Modifiability,variab,variable,14,// Place this variable to llvm.used so it won't be GC'ed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SampleProfileLoaderBaseUtil.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:7,Security,Sanitiz,SanitizerStats,7,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:28,Security,Sanitiz,Sanitizer,28,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp:414,Security,sanitiz,sanitizer,414,"//===- SanitizerStats.cpp - Sanitizer statistics gathering ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Implements code generation for sanitizer statistics gathering.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SanitizerStats.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:6,Testability,assert,assert,6,// We assert at the end of the function since IP might point to an; // instruction with different dominance properties than a cast; // (an invoke for example) and not dominate BIP (but the cast does).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:126,Safety,Avoid,Avoid,126,"// Adjust insert point to be after instructions inserted by the expander, so; // we can re-use already inserted instructions. Avoid skipping past the; // original \p MustDominate, in case it is an inserted instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:159,Safety,safe,safe,159,"// inttoptr only works for integral pointers. For non-integral pointers, we; // can create a GEP on null with the integral value as index. Note that; // it is safe to use GEP of null instead of inttoptr here, because only; // expressions already based on a GEP of null should be converted to pointers; // during expansion.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:122,Availability,redundant,redundant,122,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:93,Safety,avoid,avoid,93,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:122,Safety,redund,redundant,122,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:218,Safety,safe,safe,218,"/// InsertBinop - Insert the specified binary operator, doing a small amount; /// of work to avoid inserting an obviously redundant operation, and hoisting; /// to an outer loop when the opportunity is there and it is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:51,Safety,avoid,avoid,51,"// Don't count dbg.value against the ScanLimit, to avoid perturbing the; // generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:18,Integrability,wrap,wrap,18,// Ensure that no-wrap flags match.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:79,Deployability,install,installed,79,"// Conservatively, do not use any instruction which has any of exact; // flags installed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1200,Availability,down,down,1200,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:399,Integrability,depend,depends,399,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:987,Performance,optimiz,optimization,987,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1055,Performance,optimiz,optimization,1055,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:543,Safety,safe,safely,543,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:949,Usability,simpl,simple,949,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1285,Usability,undo,undone,1285,"/// expandAddToGEP - Expand an addition expression with a pointer type into; /// a GEP instead of using ptrtoint+arithmetic+inttoptr. This helps; /// BasicAliasAnalysis and other passes analyze the result. See the rules; /// for getelementptr vs. inttoptr in; /// http://llvm.org/docs/LangRef.html#pointeraliasing; /// for details.; ///; /// Design note: The correctness of using getelementptr here depends on; /// ScalarEvolution not recognizing inttoptr and ptrtoint operators, as; /// they may introduce pointer arithmetic which may not be safely converted; /// into getelementptr.; ///; /// Design note: It might seem desirable for this function to be more; /// loop-aware. If some of the indices are loop-invariant while others; /// aren't, it might seem desirable to emit multiple GEPs, keeping the; /// loop-invariant portions of the overall computation outside the loop.; /// However, there are a few reasons this is not done here. Hoisting simple; /// arithmetic is a low-level optimization that often isn't very; /// important until late in the optimization process. In fact, passes; /// like InstructionCombining will combine GEPs, even if it means; /// pushing loop-invariant computation down into loops, so even if the; /// GEPs were split here, the work would quickly be undone. The; /// LoopStrengthReduction pass, which is usually run quite late (and; /// after the last InstructionCombining pass), takes care of hoisting; /// loop-invariant portions of expressions, after considering what; /// can be folded using target addressing modes.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:51,Safety,avoid,avoid,51,"// Don't count dbg.value against the ScanLimit, to avoid perturbing the; // generated code.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Testability,Test,Test,3,// Test whether we've already computed the most relevant loop for this SCEV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:5,Usability,simpl,simple,5,// A simple add.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:110,Energy Efficiency,power,powers,110,"// Expand the calculation of X pow N in the following manner:; // Let N = P1 + P2 + ... + PK, where all P are powers of 2. Then:; // X pow N = (X pow P1) * (X pow P2) * ... * (X pow PK).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:90,Energy Efficiency,power,power,90,// Calculate how many times the same operand from the same loop is included; // into this power.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,Energy Efficiency,power,power,166,"// No one sane will ever try to calculate such huge exponents, but if we; // need this, we stop on UINT64_MAX / 2 because we need to exit the loop; // below when the power of 2 exceeds our Exponent, and we want it to be; // 1u << 31 at most to not deal with unsigned overflow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:13,Energy Efficiency,power,powers,13,"// Calculate powers with exponents 1, 2, 4, 8 etc. and include those of them; // that are needed into the result.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:5,Usability,simpl,simple,5,// A simple mul.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Usability,clear,clear,3,// clear nsw flag if shl will produce poison value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:41,Modifiability,variab,variable,41,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:77,Modifiability,variab,variable,77,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:301,Usability,simpl,simple,301,"/// getIVIncOperand returns an induction variable increment's induction; /// variable operand.; ///; /// If allowScale is set, any type of GEP is allowed as long as the nonIV; /// operands dominate InsertPos.; ///; /// If allowScale is not set, ensure that a GEP increment conforms to one of the; /// simple patterns generated by getAddRecExprPHILiterally and; /// expandAddtoGEP. If the pattern isn't recognized, return NULL.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:15,Usability,simpl,simple,15,// Check for a simple Add/Sub or GEP of a loop invariant step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:135,Deployability,update,update,135,"/// If the insert point of the current builder or any of the builders on the; /// stack of saved builders has 'I' as its insert point, update it to point to; /// the instruction after 'I'. This is intended to be used when the instruction; /// 'I' is being moved. If this fixup is not done and 'I' is moved to a; /// different block, the inconsistent insert point (with a mismatched; /// Instruction and Block) can lead to an instruction being inserted in a block; /// other than its parent.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,Availability,avail,available,87,"/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make; /// it available to other uses in this loop. Recursively hoist any operands,; /// until we reach a value that dominates InsertPos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:35,Usability,simpl,simple,35,"/// hoistStep - Attempt to hoist a simple IV increment above InsertPos to make; /// it available to other uses in this loop. Recursively hoist any operands,; /// until we reach a value that dominates InsertPos.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:11,Safety,safe,safe,11,// IncV is safe to hoist.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:81,Availability,avail,available,81,/// Check whether we can cheaply express the requested SCEV in terms of; /// the available PHI SCEV by truncation and/or inversion of the step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:42,Safety,avoid,avoid,42,// TODO: this possibly can be reworked to avoid this cast at all.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:32,Usability,usab,usable,32,"// Ok, the add recurrence looks usable.; // Remember this PHI, even in post-inc mode.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:10,Integrability,wrap,wrap,10,// The no-wrap behavior proved by IsIncrement(NUW|NSW) is only applicable if; // we actually do emit an addition. It does not apply if we emit a; // subtraction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:79,Safety,safe,safe,79,"// We might be introducing a new use of the post-inc IV that is not poison; // safe, in which case we should drop poison generating flags. Only keep; // those flags for which SCEV has proven that they always hold.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:17,Modifiability,variab,variable,17,"// The induction variable's postinc expansion does not dominate this use.; // IVUsers tries to prevent this case, so it is rare. However, it can; // happen when an IVUser outside the loop is not dominated by the latch; // block. Adjusting IVIncInsertPos before expansion begins cannot handle; // all cases. Consider a phi outside whose operand is replaced during; // expansion with the value of the postinc user. Without fundamentally; // changing the way postinc users are tracked, the only remedy is; // inserting an extra IV increment. StepV might fold into PostLoopOffset,; // but hopefully expandCodeFor handles that.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:41,Modifiability,variab,variable,41,// We have decided to reuse an induction variable of a dominating loop. Apply; // truncation and/or inversion of the step.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:166,Safety,avoid,avoid,166,"// In canonical mode we compute the addrec as an expression of a canonical IV; // using evaluateAtIteration and expand the resulting SCEV expression. This; // way we avoid introducing new IVs to carry on the computation of the addrec; // throughout the loop.; //; // For nested addrecs evaluateAtIteration might need a canonical IV of a; // type wider than the addrec itself. Emitting a canonical IV of the; // proper type might produce non-legal types, for example expanding an i64; // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall; // back to non-canonical mode for nested addrecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:541,Safety,avoid,avoid,541,"// In canonical mode we compute the addrec as an expression of a canonical IV; // using evaluateAtIteration and expand the resulting SCEV expression. This; // way we avoid introducing new IVs to carry on the computation of the addrec; // throughout the loop.; //; // For nested addrecs evaluateAtIteration might need a canonical IV of a; // type wider than the addrec itself. Emitting a canonical IV of the; // proper type might produce non-legal types, for example expanding an i64; // {0,+,2,+,1} addrec would need an i65 canonical IV. To avoid this just fall; // back to non-canonical mode for nested addrecs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:3,Modifiability,Rewrite,Rewrite,3,"// Rewrite an AddRec in terms of the canonical induction variable, if; // its type is more narrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:57,Modifiability,variab,variable,57,"// Rewrite an AddRec in terms of the canonical induction variable, if; // its type is more narrow.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:52,Modifiability,variab,variable,52,// Create and insert the PHI node for the induction variable in the; // specified loop.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:44,Modifiability,variab,variable,44,"// {0,+,1} --> Insert a canonical induction variable into the loop!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:44,Usability,simpl,simple,44,"// {0,+,F} --> {0,+,1} * F; // If this is a simple linear addrec, emit it now as a special case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:156,Usability,simpl,simplify,156,"// If this is a chain of recurrences, turn it into a closed form, using the; // folders, then expandCodeFor the closed form. This allows the folders to; // simplify the expression without having to build a bunch of special code; // into this folder.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:23,Availability,down,down,23,"// Truncate the result down to the original type, if needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,Safety,safe,safe,47,// Make sure reusing the instruction is poison-safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:94,Safety,risk,risky,94,// We can move insertion point only if there is no div or rem operations; // otherwise we are risky to move it over the check for zero denominator.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:87,Usability,simpl,simplify,87,"// LSR sets the insertion point for AddRec start/step values to the; // block start to simplify value reuse, even though it's an invalid; // position. SCEVExpander must correct for this in all cases.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:125,Usability,simpl,simply,125,"// Remember the expanded value for this SCEV at this location.; //; // This is independent of PostIncLoops. The mapped value simply materializes; // the expression at this insertion point. If the mapped value happened to be; // a postinc expansion, it could be reused by a non-postinc user, but only if; // its insertion point was already at the head of the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:202,Integrability,depend,depend,202,/// replaceCongruentIVs - Check for congruent phis in this loop header and; /// replace them with their most canonical representative. Return the number of; /// phis eliminated.; ///; /// This does not depend on any SCEVExpander state but should be used in; /// the same context that SCEVExpander is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:94,Testability,log,logic,94,// Fold constant phis. They may be congruent to other constant phis and; // would confuse the logic below that expects proper IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:21,Modifiability,rewrite,rewrite,21,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:52,Modifiability,variab,variables,52,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:35,Usability,simpl,simple,35,"// Make sure we only rewrite using simple induction variables;; // otherwise, we can make the trip count of a loop unanalyzable; // to SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:65,Safety,redund,redundancy,65,"// Replacing the congruent phi is sufficient because acyclic; // redundancy elimination, CSE/GVN, should handle the; // rest. However, once SCEV proves that a phi is congruent,; // it's often the head of an IV user cycle that is isomorphic; // with the original phi. It's worth eagerly cleaning up the; // common case of a single IV increment so that DeleteDeadPHIs; // can remove cycles that had postinc uses.; // Because we may potentially introduce a new use of OrigIV that didn't; // exist before at this point, its poison flags need readjustment.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:30,Usability,simpl,simple,30,// Look for suitable value in simple conditions at the loop exits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:16,Testability,log,logic,16,// Use expand's logic which is used for reusing a previous Value in; // ExprValueMap. Note that we don't currently model the cost of; // needing to drop poison generating flags on the instruction if we; // want to reuse it. We effectively assume that has zero cost.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,Safety,safe,safety,7,// The safety net against poison.; // FIXME: this is broken.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:84,Energy Efficiency,charge,charge,84,"// In this polynominal, we may have some zero operands, and we shouldn't; // really charge for those. So how many non-zero coefficients are there?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:101,Availability,avail,available,101,"// We have already accounted for this expression.; // If we can find an existing value for this scev available at the point ""At""; // then consider the expression cheap.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:46,Performance,optimiz,optimizing,46,// Only evalulate the costs of constants when optimizing for size.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:231,Usability,simpl,simple,231,"// UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or; // HowManyLessThans produced to compute a precise expression, rather than a; // UDiv from the user's code. If we can't find a UDiv in the code with some; // simple searching, we need to account for it's cost.; // At the beginning of this function we already tried to find existing; // value for plain 'S'. Now try to lookup 'S + 1' since it is common; // pattern involving division. This is just a simple search heuristic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:472,Usability,simpl,simple,472,"// UDivExpr is very likely a UDiv that ScalarEvolution's HowFarToZero or; // HowManyLessThans produced to compute a precise expression, rather than a; // UDiv from the user's code. If we can't find a UDiv in the code with some; // simple searching, we need to account for it's cost.; // At the beginning of this function we already tried to find existing; // value for plain 'S'. Now try to lookup 'S + 1' since it is common; // pattern involving division. This is just a simple search heuristic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:7,Usability,simpl,simple,7,// The simple nary expr will require one less op (or pair of ops); // than the number of it's terms.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:159,Integrability,depend,depending,159,"// Compute |Step| * Backedge; // Compute:; // 1. Start + |Step| * Backedge < Start; // 2. Start - |Step| * Backedge > Start; //; // And select either 1. or 2. depending on whether step is positive or; // negative. If Step is known to be positive or negative, only create; // either 1. or 2.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:48,Modifiability,extend,extended,48,// Get the backedge taken count and truncate or extended to the AR type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:195,Performance,optimiz,optimized,195,"// Special-case Step of one. Potentially-costly `umul_with_overflow` isn't; // needed, there is never an overflow, so to avoid artificially inflating; // the cost of the check, directly emit the optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:121,Safety,avoid,avoid,121,"// Special-case Step of one. Potentially-costly `umul_with_overflow` isn't; // needed, there is never an overflow, so to avoid artificially inflating; // the cost of the check, directly emit the optimized IR.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:1008,Energy Efficiency,reduce,reduced,1008,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:47,Safety,safe,safe,47,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:142,Safety,unsafe,unsafe,142,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp:404,Safety,safe,safe,404,"// Search for a SCEV subexpression that is not safe to expand. Any expression; // that may expand to a !isSafeToSpeculativelyExecute value is unsafe, namely; // UDiv expressions. We don't know if the UDiv is derived from an IR divide; // instruction, but the important thing is that we prove the denominator is; // nonzero before expansion.; //; // IVUsers already checks that IV-derived expressions are safe. So this check is; // only needed when the expression includes some subexpression that is not IV; // derived.; //; // Currently, we only allow division by a value provably non-zero here.; //; // We cannot generally expand recurrences unless the step dominates the loop; // header. The expander handles the special case of affine recurrences by; // scaling the recurrence outside the loop, but this technique isn't generally; // applicable. Expanding a nested recurrence outside a loop requires computing; // binomial coefficients. This could be done, but the recurrence has to be in a; // perfectly reduced form, which can't be guaranteed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:225,Performance,load,loads,225,"// Some instructions can be handled but are rejected above. Catch; // those cases by falling through to here.; // TODO: Mark globals as being constant earlier, so; // TODO: wouldInstructionBeTriviallyDead() knows that atomic loads; // TODO: are safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:245,Safety,safe,safe,245,"// Some instructions can be handled but are rejected above. Catch; // those cases by falling through to here.; // TODO: Mark globals as being constant earlier, so; // TODO: wouldInstructionBeTriviallyDead() knows that atomic loads; // TODO: are safe to remove.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:223,Deployability,update,updated,223,"// Replacing `musttail` instructions with constant breaks `musttail` invariant; // unless the call itself can be removed.; // Calls with ""clang.arc.attachedcall"" implicitly use the return value and; // those uses cannot be updated with a constant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:33,Modifiability,variab,variable,33,// Replaces all of the uses of a variable with uses of the constant.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:51,Testability,log,logical,51,"// If the shifted value is not negative, this is a logical shift right.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:35,Deployability,update,update,35,// Wire up the new instruction and update state.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:82,Modifiability,variab,variable,82,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:128,Security,access,accessor,128,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:255,Usability,simpl,simply,255,"/// GlobalValue - If we are tracking any values for the contents of a global; /// variable, we keep a mapping from the constant accessor to the element of; /// the global, to the currently known value. If the value becomes; /// overdefined, it's entry is simply removed from this map.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:100,Usability,clear,cleared,100,"/// The set of values whose lattice has been invalidated.; /// Populated by resetLatticeValueFor(), cleared after resolving undefs.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:95,Energy Efficiency,efficient,efficient,95,/// MRVFunctionsTracked - Each function in TrackedMultipleRetVals is; /// represented here for efficient lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:109,Deployability,update,updated,109,"// Helper to push \p V to the worklist, after updating it to \p IV. Also; // prints a debug message with the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:92,Integrability,message,message,92,"// Helper to push \p V to the worklist, after updating it to \p IV. Also; // prints a debug message with the updated value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:181,Deployability,update,updated,181,"// markConstant - Make a value be marked as ""constant"". If the value; // is not already a constant, add it to the instruction work list so that; // the users of the instruction are updated later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:200,Deployability,update,updated,200,"// markOverdefined - Make a value be marked as ""overdefined"". If the; // value is not already overdefined, add it to the overdefined instruction; // work list so that the users of the instruction are updated later.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:169,Deployability,update,update,169,"// OperandChangedState - This method is invoked on all of the users of an; // instruction that was just changed state somehow. Based on this; // information, we need to update the specified user of this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:148,Deployability,update,update,148,// Functions include their arguments in the use-list. Changed function; // values mean that the result of the function changed. We only need to; // update the call sites with the new function result and do not have to; // propagate the call arguments.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:25,Modifiability,variab,variables,25,"// Overdefined condition variables, and branches on unfoldable constant; // conditions, mean the branch could go either way.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:22,Modifiability,variab,variables,22,// Constant condition variables mean the branch can only go a single way.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:109,Availability,down,down,109,"// Quick exit; // Super-extra-high-degree PHI nodes are unlikely to ever be marked constant,; // and slow us down a lot. Just mark them overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Usability,simpl,simplify,10,// Try to simplify to a constant range.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Performance,cache,cache,10,"// Do not cache this lookup, getValueState calls later in the function might; // invalidate the reference.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:76,Availability,avail,available,76,"// For parameters, use ParamState which includes constant range info if; // available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:10,Performance,load,load,10,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:111,Performance,load,load,111,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:125,Performance,load,loaded,125,"// Handle load instructions. If the operand is a constant pointer to a constant; // global, we can replace the load with the loaded constant value!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:11,Performance,load,load,11,"// If this load is of a struct or the load is volatile, just mark the result; // as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:38,Performance,load,load,38,"// If this load is of a struct or the load is volatile, just mark the result; // as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:3,Performance,load,load,3,// load null is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:13,Performance,load,load,13,// Transform load (constant global) into the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:51,Performance,load,loaded,51,// Transform load (constant global) into the value loaded.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:13,Performance,load,load,13,// Transform load from a constant into a constant if possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:266,Deployability,Update,Update,266,"// ""I"" got into the work list because it either made the transition from; // bottom to constant, or to overdefined.; //; // Anything on this worklist that is overdefined need not be visited; // since all of its users will have already been marked as overdefined; // Update all of the users of this instruction's value.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:240,Deployability,Update,Update,240,"// ""I"" got into the work list because it made the transition from undef to; // constant.; //; // Anything on this worklist that is overdefined need not be visited; // since all of its users will have already been marked as overdefined.; // Update all of the users of this instruction's value.; //",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:5,Performance,load,load,5,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:42,Performance,load,load,42,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:77,Performance,load,load,77,"// A load here means one of two things: a load of undef from a global,; // a load from an unknown pointer. Either way, having it return undef; // is okay.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp:777,Usability,simpl,simplicity,777,"/// While solving the dataflow for a function, we don't compute a result for; /// operations with an undef operand, to allow undef to be lowered to a; /// constant later. For example, constant folding of ""zext i8 undef to i16""; /// would result in ""i16 0"", and if undef is later lowered to ""i8 1"", then the; /// zext result would become ""i16 1"" and would result into an overdefined; /// lattice value once merged with the previous result. Not computing the; /// result of the zext (treating undef the same as unknown) allows us to handle; /// a later undef->constant lowering more optimally.; ///; /// However, if the operand remains undef when the solver returns, we do need; /// to assign some result to the instruction (otherwise we would treat it as; /// unreachable). For simplicity, we mark any instructions that are still; /// unknown as overdefined.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SCCPSolver.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:33,Performance,perform,perform,33,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:392,Performance,optimiz,optimize,392,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,Simpl,SimplifyCFG,7,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Usability,simpl,simplification,45,"//===- SimplifyCFG.cpp - Code to perform CFG simplification ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // Peephole optimize the CFG.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:59,Energy Efficiency,power,power,59,"// Chosen as 2 so as to be cheap, but still to have enough power to fold; // a select, so the ""clamp"" idiom (of a min followed by a max) will be caught.; // To catch this, we need to fold a compare and a select, hence '2' being the; // minimum reasonable default.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Testability,log,logical,45,// Two is chosen to allow one negation and a logical combine.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Safety,safe,safe,25,/// Return true if it is safe to merge these two; /// terminator instructions together.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Safety,safe,safe,40,"// Can't merge with self!; // It is not safe to merge these two switch instructions if they have a common; // successor, and if that successor has a PHI node, and if *that* PHI node has; // conflicting incoming values from the two switch blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:4,Deployability,Update,Update,4,"/// Update PHI nodes in Succ to indicate that there will now be entries in it; /// from the 'NewPred' block. The values that will be flowing into the PHI nodes; /// will be the same as those coming in from ExistPred, an existing predecessor; /// of Succ.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:97,Safety,safe,safe,97,"/// Compute an abstract ""cost"" of speculating the given instruction,; /// which is assumed to be safe to speculate. TCC_Free means cheap,; /// TCC_Basic means less cheap, and TCC_Expensive means prohibitively; /// expensive.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:242,Safety,avoid,avoid,242,"// It is possible to hit a zero-cost cycle (phi/gep instructions for example),; // so limit the recursion depth.; // TODO: While this recursion limit does prevent pathological behavior, it; // would be better to track visited instructions to avoid cycles.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:364,Performance,optimiz,optimizations,364,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,safe,safe,95,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:289,Usability,undo,undone,289,// Allow exactly one instruction to be speculated regardless of its cost; // (as long as it is safe to do so).; // This is intended to flatten the CFG even if the instruction is a division; // or other expensive operation. The speculation of an expensive instruction; // is expected to be undone in CodeGenPrepare if the speculation has not; // enabled further IR optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Safety,safe,safe,14,"// Okay, it's safe to do this! Remember this instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,Availability,recover,recover,105,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:105,Safety,recover,recover,105,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:515,Security,validat,validate,515,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:611,Testability,test,test,611,"/// Given a chain of or (||) or and (&&) comparison of a value against a; /// constant, this will try to recover the information required for a switch; /// structure.; /// It will depth-first traverse the chain of comparison, seeking for patterns; /// like %a == 12 or %a < 4 and combine them to produce a set of integer; /// representing the different cases for the switch.; /// Note that if the chain is composed of '||' it will build the set of elements; /// that matches the comparisons (i.e. any of this value validate the chain); /// while for a chain of '&&' it will build the set elements that make the test; /// fail.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,Availability,failure,failure,199,"/// Try to match Instruction ""I"" as a comparison against a constant and; /// populates the array Vals with the set of values that match (or do not; /// match depending on isEQ).; /// Return false on failure. On success, the Value the comparison matched; /// against is placed in CompValue.; /// If CompValue is already set, the function is expected to fail if a match; /// is found but the value compared to is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:158,Integrability,depend,depending,158,"/// Try to match Instruction ""I"" as a comparison against a constant and; /// populates the array Vals with the set of values that match (or do not; /// match depending on isEQ).; /// Return false on failure. On success, the Value the comparison matched; /// against is placed in CompValue.; /// If CompValue is already set, the function is expected to fail if a match; /// is found but the value compared to is different.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,Usability,undo,undoes,86,// Pattern match a special case; // (x & ~2^z) == y --> x == y || x == y|2^z; // This undoes a transformation done by instcombine to fuse 2 compares.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:254,Availability,mask,mask,254,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:306,Availability,mask,mask,306,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:327,Availability,mask,mask,327,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:360,Availability,mask,mask,360,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:385,Availability,mask,mask,385,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:405,Availability,mask,mask,405,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:439,Availability,mask,mask,439,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1057,Availability,mask,mask,1057,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1083,Availability,mask,mask,1083,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1119,Availability,mask,mask,1119,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1261,Availability,mask,mask,1261,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1282,Availability,mask,mask,1282,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:1315,Availability,mask,mask,1315,"// It's a little bit hard to see why the following transformations are; // correct. Here is a CVC3 program to verify them for 64-bit values:; /*; ONE : BITVECTOR(64) = BVZEROEXTEND(0bin1, 63);; x : BITVECTOR(64);; y : BITVECTOR(64);; z : BITVECTOR(64);; mask : BITVECTOR(64) = BVSHL(ONE, z);; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */; // Please note that each pattern must be a dual implication (<--> or; // iff). One directional implication can create spurious matches. If the; // implication is only one-way, an unsatisfiable condition on the left; // side can imply a satisfiable condition on the right side. Dual; // implication ensures that satisfiable conditions are transformed to; // other satisfiable conditions and unsatisfiable conditions are; // transformed to other unsatisfiable conditions.; // Here is a concrete example of a unsatisfiable condition on the left; // implying a satisfiable condition on the right:; //; // mask = (1 << z); // (x & ~mask) == y --> (x == y || x == (y | mask)); //; // Substituting y = 3, z = 0 yields:; // (x & -2) == 3 --> (x == 3 || x == 2); // Pattern match a special case:; /*; QUERY( (y & ~mask = y) =>; ((x & ~mask = y) <=> (x = y OR x = (y | mask))); );; */",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:50,Availability,mask,mask,50,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Availability,mask,mask,70,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:104,Availability,mask,mask,104,// Pattern match a special case:; /*; QUERY( (y | mask = y) =>; ((x | mask = y) <=> (x = y OR x = (y & ~mask))); );; */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Integrability,depend,depending,24,"// If it is a || (or && depending on isEQ), process the operands.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:38,Safety,abort,abort,38,"// Failed to parse a proper sequence, abort now",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:283,Usability,simpl,simplify,283,"/// If TI is known to be a terminator instruction and its block is known to; /// only have a single predecessor block, check to see if that predecessor is; /// also a value comparison with the same value, and if that comparison; /// determines the outcome of this comparison. If so, simplify TI. This does a; /// very limited form of jump threading.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:109,Usability,simpl,simplify,109,"// Remove default from cases.; // If TI's block is the default block from Pred's comparison, potentially; // simplify TI based on this knowledge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Usability,simpl,simplify,160,"// If we are here, we know that the value is none of those cases listed in; // PredCases. If there are any cases in ThisCases that are in PredCases, we; // can simplify TI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Integrability,depend,depend,84,/// This class implements a stable ordering of constant; /// integers that does not depend on their address. This is important for; /// applications that sort ConstantInt's to ensure uniqueness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:194,Safety,avoid,avoid,194,"// Unless the instruction has the same !dbg location as the original; // branch, drop it. When we fold the bonus instructions we want to make; // sure we reset their debug locations in order to avoid stepping on; // dead code caused by folding dead branches.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,"// Update (liveout) uses of bonus instructions,; // now that the bonus instruction has been cloned into predecessor.; // Note that we expect to be in a block-closed SSA form for this to work!",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update the branch weight metadata along the way,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Deployability,update,update,84,"// Okay, at this point, we know which new successor Pred will get. Make; // sure we update the number of entries in the PHI nodes for these; // successors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Deployability,update,updated,31,"// Now that the successors are updated, create the new Switch instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:240,Safety,safe,safe,240,"/// The specified terminator is a value equality comparison instruction; /// (either a switch or a branch on ""X == c"").; /// See if any of the predecessors of the terminator block are value comparisons; /// on the same value. If so, and if safe to do so, fold them together.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Safety,safe,safe,25,// Returns true if it is safe to reorder an instruction across preceding; // instructions in a basic block.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Performance,load,load,32,// Don't reorder a store over a load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,Safety,unsafe,unsafe,58,"// If we have seen an instruction with side effects, it's unsafe to reorder an; // instruction which reads memory or itself has side effects.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,unsafe,unsafe,13,// It's also unsafe/illegal to hoist an instruction above its instruction; // operands,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:168,Performance,perform,perform,168,"/// Hoist any common code in the successor blocks up into the block. This; /// function guarantees that BB dominates all successors. If EqTermsOnly is; /// given, only perform hoisting in case both blocks only contain a terminator.; /// In that case, only the original BI will be replaced and selects for PHIs are; /// added.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:61,Safety,safe,safe,61,"// Even if the instructions are identical, it may not; // be safe to hoist them if we have skipped over; // instructions with side effects or their operands; // weren't hoisted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:162,Usability,simpl,simply,162,"// The debug location is an integral part of a debug info intrinsic; // and can't be separated from it or replaced. Instead of attempting; // to merge locations, simply hoist both copies of the intrinsic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Availability,redundant,redundant,160,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Safety,redund,redundant,160,"// For a normal instruction, we just move one to right before the; // branch, then replace all uses of the other with the first. Finally,; // we remove the now redundant second instruction.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:89,Safety,safe,safety,89,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:129,Testability,Test,Test,129,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:144,Testability,test,test,144,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:160,Usability,Simpl,SimplifyCFG,160,"// In the case of an if statement, we try to hoist an invoke.; // FIXME: Can we define a safety predicate for CallBr?; // FIXME: Test case llvm/test/Transforms/SimplifyCFG/2009-06-15-InvokeCrash.ll; // removed in 4c923b3b3fd0ac1edebf0603265ca3ba51724937 commit?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:15,Safety,safe,safe,15,"// Okay, it is safe to hoist the terminator.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update any PHI nodes in our new successors.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:90,Modifiability,variab,variables,90,// TODO: Refine this. This should avoid cases like turning constant memcpy sizes; // into variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,Safety,avoid,avoid,34,// TODO: Refine this. This should avoid cases like turning constant memcpy sizes; // into variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Performance,load,load,45,"// swifterror pointers can only be used by a load or store; sinking a load; // or store would require introducing a select for the pointer operand,; // which isn't allowed for swifterror pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Performance,load,load,70,"// swifterror pointers can only be used by a load or store; sinking a load; // or store would require introducing a select for the pointer operand,; // which isn't allowed for swifterror pointers.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:379,Availability,down,down,379,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:80,Performance,load,loads,80,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:217,Performance,load,loads,217,"// Because SROA can't handle speculating stores of selects, try not to sink; // loads, stores or lifetime markers of allocas when we'd have to create a; // PHI for the address operand. Also, because it is likely that loads or; // stores of allocas will disappear when Mem2Reg/SROA is run, don't sink; // them.; // This can cause code churn which can have unintended consequences down; // the line - see https://llvm.org/bugs/show_bug.cgi?id=30244.; // FIXME: This is a workaround for a deficiency in SROA - see; // https://llvm.org/bugs/show_bug.cgi?id=30188",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:106,Usability,simpl,simplifycfg,106,"// This check is different to that in canSinkInstructions. There, we; // cared about the global view once simplifycfg (and instcombine) have; // completed - it takes into account PHIs that become trivially; // simplifiable. However here we need a more local view; if an operand; // differs we create a PHI and rely on instcombine to clean up the very; // small mess we may make.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:210,Usability,simpl,simplifiable,210,"// This check is different to that in canSinkInstructions. There, we; // cared about the global view once simplifycfg (and instcombine) have; // completed - it takes into account PHIs that become trivially; // simplifiable. However here we need a more local view; if an operand; // differs we create a PHI and rely on instcombine to clean up the very; // small mess we may make.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,"// Update metadata and IR flags, and merge debug locations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:375,Usability,simpl,simplified,375,"// The debug location for the ""common"" instruction is the merged locations; // of all the commoned instructions. We start with the original location; // of the ""common"" instruction and iteratively merge each location in the; // loop below.; // This is an N-way merge, which will be inefficient if I0 is a CallInst.; // However, as N-way merge for CallInst is rare, so we use simplified API; // instead of using complex API for N-way merge.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,Integrability,depend,depends,197,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:426,Safety,detect,detect,426,"// We've determined that we are going to sink last ScanIdx instructions,; // and recorded them in InstructionsToSink. Now, some instructions may be; // unprofitable to sink. But that determination depends on the instructions; // that we are going to sink.; // First, forward scan: find the first instruction unprofitable to sink,; // recording all the ones that are profitable to sink.; // FIXME: would it be better, after we detect that not all are profitable.; // to either record the profitable ones, or erase the unprofitable ones?; // Maybe we need to choose (at runtime) the one that will touch least; // instrs?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:208,Performance,perform,performant,208,"// If we detect that an instruction becomes unprofitable to sink,; // all earlier instructions won't be sunk either,; // so preemptively keep InstructionsProfitableToSink in sync.; // FIXME: is this the most performant approach?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Safety,detect,detect,9,"// If we detect that an instruction becomes unprofitable to sink,; // all earlier instructions won't be sunk either,; // so preemptively keep InstructionsProfitableToSink in sync.; // FIXME: is this the most performant approach?",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:61,Performance,perform,perform,61,"// Now that we've analyzed all potential sinking candidates, perform the; // actual sink. We iteratively sink the last non-terminator of the source; // blocks into their common successor unless doing so would require too; // many PHI instructions to be generated (currently only one PHI is allowed; // per sunk instruction).; //; // We can use InstructionsToSink to discount values needing PHI-merging that will; // actually be sunk in a later iteration. This allows us to be more; // aggressive in what we sink. This does allow a false positive where we; // sink presuming a later value will also be sunk, but stop half way through; // and never actually sink it which means we produce more PHIs than intended.; // This is unlikely in practice though.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,"// Perform a linear scan over all the existing sets, see if the new `invoke`; // is compatible with any particular set. Since we know that all the `invokes`; // within a set are compatible, only check the first `invoke` in each set.; // WARNING: at worst, this has quadratic complexity.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:155,Deployability,update,update,155,"// We've ensured that each PHI node has compatible (identical) incoming values; // when coming from each of the `invoke`s in the current merge set,; // so update the PHI nodes accordingly.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,Security,access,accesses,81,// Skip pseudo probe intrinsic calls which are not really killing any memory; // accesses.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:86,Safety,avoid,avoid,86,"// Found the previous store to same location and type. Make sure it is; // simple, to avoid introducing a spurious non-atomic write after an; // atomic write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:75,Usability,simpl,simple,75,"// Found the previous store to same location and type. Make sure it is; // simple, to avoid introducing a spurious non-atomic write after an; // atomic write.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:268,Performance,concurren,concurrently,268,"// Local objects (created by an `alloca` instruction) are always; // writable, so once we are past a read from a location it is valid to; // also write to that same location.; // If the address of the local object never escapes the function, that; // means it's never concurrently read or written, hence moving the store; // from under the condition will not introduce a data race.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:20,Performance,load,load,20,"// Found a previous load, return it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Performance,load,load,7,"// The load didn't work out, but we may still find a store.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:641,Energy Efficiency,power,powerful,641,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:562,Performance,optimiz,optimizations,562,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,risk,risky,95,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:551,Usability,simpl,simplistic,551,"/// Speculate a conditional basic block flattening the CFG.; ///; /// Note that this is a very risky transform currently. Speculating; /// instructions like this is most often not desirable. Instead, there is an MI; /// pass which can do it with full awareness of the resource constraints.; /// However, some cases are ""obvious"" and we should do directly. An example of; /// this is speculating a single, reasonably cheap instruction.; ///; /// There is only one distinct advantage to flattening the CFG at the IR level:; /// it makes very common but simplistic optimizations such as are common in; /// instcombine and the DAG combiner more powerful by removing CFG edges and; /// modeling their effects with easier to reason about SSA value graphs.; ///; ///; /// An illustration of this transform is turning this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// br i1 %cmp, label %EndBB, label %ThenBB; /// ThenBB:; /// %sub = sub %x, %y; /// br label BB2; /// EndBB:; /// %phi = phi [ %sub, %ThenBB ], [ 0, %EndBB ]; /// ...; /// \endcode; ///; /// Into this IR:; /// \code; /// BB:; /// %cmp = icmp ult %x, %y; /// %sub = sub %x, %y; /// %cond = select i1 %cmp, 0, %sub; /// ...; /// \endcode; ///; /// \returns true if the conditional block is removed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:46,Safety,predict,predicted,46,"// If the branch is non-unpredictable, and is predicted to *not* branch to; // the `then` block, then avoid speculating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:102,Safety,avoid,avoid,102,"// If the branch is non-unpredictable, and is predicted to *not* branch to; // the `then` block, then avoid speculating it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:122,Performance,optimiz,optimization,122,"// Skip pseudo probes. The consequence is we lose track of the branch; // probability for ThenBB, which is fine since the optimization here takes; // place regardless of the branch probability.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Safety,unsafe,unsafe,39,// Don't hoist the instruction if it's unsafe or expensive.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:19,Integrability,depend,dependent,19,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:297,Integrability,depend,dependent,297,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:150,Safety,avoid,avoid,150,"// Metadata can be dependent on the condition we are hoisting above.; // Strip all UB-implying metadata on the instruction. Drop the debug loc; // to avoid making it appear as if the condition is a constant, which would; // be misleading while debugging.; // Similarly strip attributes that maybe dependent on condition we are; // hoisting above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Deployability,update,update,9,// Don't update the DILocation of dbg.assign intrinsics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Modifiability,rewrite,rewrite,22,// Insert selects and rewrite the PHI operands.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:29,Energy Efficiency,reduce,reduce,29,"// TODO: These just exist to reduce test diff, we can drop them if we like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:36,Testability,test,test,36,"// TODO: These just exist to reduce test diff, we can drop them if we like.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update PHI nodes.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update operands due to translation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:21,Usability,simpl,simplification,21,// Check for trivial simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:52,Performance,cache,cache,52,// Register the new instruction with the assumption cache if necessary.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:133,Safety,avoid,avoids,133,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,simpl,simplicity,7,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:156,Usability,Simpl,SimplifyCFG,156,"// For simplicity, we created a separate basic block for the edge. Merge; // it back into the predecessor if possible. This not only avoids; // unnecessary SimplifyCFG iterations, but also makes sure that we don't; // bypass the check for trivial cycles above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:18,Usability,simpl,simplifying,18,"// Signal repeat, simplifying any other constants.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:292,Integrability,depend,dependence,292,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Usability,simpl,simple,63,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:107,Usability,simpl,simple,107,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:335,Usability,simpl,simplifycfg,335,"// Ok, this is a two entry PHI node. Check to see if this is a simple ""if; // statement"", which has a very simple dominance structure. Basically, we; // are trying to find the condition that is being branched on, which; // subsequently causes this merge to happen. We really want control; // dependence information for this check, but simplifycfg can't keep it up; // to date, and this catches most of the cases we care about anyway.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,Safety,predict,predictably,56,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:143,Safety,predict,predictably,143,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:312,Safety,predict,predictably,312,"// If the branch is non-unpredictable, see if we either predictably jump to; // the merge bb (if we have only a single 'then' block), or if we predictably; // jump to one specific 'then' block (if we have two of them).; // It isn't beneficial to speculatively execute the code; // from the block that we know is predictably not entered.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,Usability,simpl,simplified,103,"// If we folded the first phi, PN dangles at this point. Refresh it. If; // we ran out of PHIs then we simplified them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:64,Testability,test,tests,64,"// If we can still promote the PHI nodes after this gauntlet of tests,; // do all of the PHI's now.; // Move all 'aggressive' instructions, which are defined in the; // conditional parts of the if's up to the dominating block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:143,Safety,avoid,avoid,143,"// At this point, all IfBlocks are empty, so our if statement; // has been flattened. Change DomBlock to jump directly to our new block to; // avoid other simplifycfg's kicking in on the diamond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:155,Usability,simpl,simplifycfg,155,"// At this point, all IfBlocks are empty, so our if statement; // has been flattened. Change DomBlock to jump directly to our new block to; // avoid other simplifycfg's kicking in on the diamond.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:16,Testability,log,logical,16,// Try to relax logical op to binary op.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Availability,avail,available,54,"/// Return true if either PBI or BI has branch weight available, and store; /// the weights in {Pred|Succ}{True|False}Weight. If one of PBI and BI does; /// not have branch weight, use 1:1 as its weight.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:95,Safety,predict,predictable,95,"// We have the potential to fold the conditions together, but if the; // predecessor branch is predictable, we may not want to merge them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:123,Deployability,update,update,123,"// Before cloning instructions, notify the successor basic block that it; // is about to have a new predecessor. This will update PHI nodes,; // which will allow us to update live-out uses of bonus instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:168,Deployability,update,update,168,"// Before cloning instructions, notify the successor basic block that it; // is about to have a new predecessor. This will update PHI nodes,; // which will allow us to update live-out uses of bonus instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:10,Deployability,update,update,10,// Try to update branch weights.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:8,Deployability,update,update,8,"// Now, update the CFG.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:159,Testability,log,logical,159,"/// If this basic block is simple enough, and if a predecessor branches to us; /// and one of our successors, fold the block into the predecessor and use; /// logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:27,Usability,simpl,simple,27,"/// If this basic block is simple enough, and if a predecessor branches to us; /// and one of our successors, fold the block into the predecessor and use; /// logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:58,Performance,perform,performing,58,// Check the cost of inserting the necessary logic before performing the; // transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Testability,log,logic,45,// Check the cost of inserting the necessary logic before performing the; // transformation.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,safe,safe,13,// I must be safe to execute unconditionally.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:27,Performance,Perform,Perform,27,"// Ok, we have the budget. Perform the transformation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:268,Performance,perform,performance,268,"// For every pointer, there must be exactly two stores, one coming from; // PTB or PFB, and the other from QTB or QFB. We don't support more than one; // store (to any address) in PTB,PFB or QTB,QFB.; // FIXME: We could relax this restriction with a bit more work and performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:284,Testability,test,testing,284,"// For every pointer, there must be exactly two stores, one coming from; // PTB or PFB, and the other from QTB or QFB. We don't support more than one; // store (to any address) in PTB,PFB or QTB,QFB.; // FIXME: We could relax this restriction with a bit more work and performance; // testing.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:251,Availability,down,down,251,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:365,Performance,load,loads,365,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:653,Safety,safe,safe,653,"// Check that sinking the store won't cause program behavior changes. Sinking; // the store out of the Q blocks won't change any behavior as we're sinking; // from a block to its unconditional successor. But we're moving a store from; // the P blocks down through the middle block (QBI) and past both QFB and QTB.; // So we need to check that there are no aliasing loads or stores in; // QBI, QTB and QFB. We also need to check there are no conflicting memory; // operations between PStore and the end of its parent block.; //; // The ideal way to do this is to query AliasAnalysis, but we don't; // preserve AA currently so that is dangerous. Be super safe and just; // check there are no other memory operations at all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:44,Performance,optimiz,optimize,44,"// If we're not in aggressive mode, we only optimize if we have some; // confidence that by optimizing we'll allow P and/or Q to be if-converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:92,Performance,optimiz,optimizing,92,"// If we're not in aggressive mode, we only optimize if we have some; // confidence that by optimizing we'll allow P and/or Q to be if-converted.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:197,Safety,safe,safe,197,"// Choose the minimum alignment. If we could prove both stores execute, we; // could use biggest one. In this case, though, we only know that one of the; // stores executes. And we don't know it's safe to take the alignment from a; // store that doesn't execute.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:422,Energy Efficiency,reduce,reduce,422,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:576,Performance,optimiz,optimization,576,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:625,Testability,test,test-and-set,625,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:704,Usability,simpl,simple,704,"// The intention here is to find diamonds or triangles (see below) where each; // conditional block contains a store to the same address. Both of these; // stores are conditional, so they can't be unconditionally sunk. But it may; // be profitable to speculatively sink the stores into one merged store at the; // end, and predicate the merged store on the union of the two conditions of; // PBI and QBI.; //; // This can reduce the number of stores executed if both of the conditions are; // true, and can allow the blocks to become small enough to be if-converted.; // This optimization will also chain, so that ladders of test-and-set; // sequences can be if-converted away.; //; // We only deal with simple diamonds or triangles:; //; // PBI or PBI or a combination of the two; // / \ | \; // PTB PFB | PFB; // \ / | /; // QBI QBI; // / \ | \; // QTB QFB | QFB; // \ / | /; // PostBB PostBB; //; // We model triangles as a type of diamond with a nullptr ""true"" block.; // Triangles are canonicalized so that the fallthrough edge is represented by; // a true condition, as in the diagram above.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:81,Usability,clear,clear,81,// set_intersect mutates PStoreAddresses in place. Rename it here to make it; // clear what it contains.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:222,Safety,safe,safety,222,"/// If the previous block ended with a widenable branch, determine if reusing; /// the target block is profitable and legal. This will have the effect of; /// ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:103,Usability,simpl,simply,103,// TODO: This can be generalized in two important ways:; // 1) We can allow phi nodes in IfFalseBB and simply reuse all the input; // values from the PBI edge.; // 2) We can sink side effecting instructions into BI's fallthrough; // successor provided they doesn't contribute to computation of; // BI's condition.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Safety,avoid,avoid,23,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:48,Usability,Simpl,SimplifyCondBranchToCondBranch,48,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:93,Usability,undo,undo,93,// TODO; // This helps avoid infinite loop with SimplifyCondBranchToCondBranch which; // may undo the transform done here.; // TODO: There might be a more fine-grained solution to this.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:99,Usability,simpl,simplify,99,"/// If we have a conditional branch as a predecessor of another block,; /// this function tries to simplify it. We know; /// that PBI and BI are both conditional branches, and BI is in one of the; /// successor blocks of PBI - PBI branches to BI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Availability,redundant,redundant,161,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Safety,redund,redundant,161,"// If this block ends with a branch instruction, and if there is a; // predecessor that ends on a branch of the same condition, make; // this conditional branch redundant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:219,Safety,safe,safety,219,"// If the previous block ended with a widenable branch, determine if reusing; // the target block is profitable and legal. This will have the effect of; // ""widening"" PBI, but doesn't require us to reason about hosting safety.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:164,Testability,log,logical,164,"// If this is a conditional branch in an empty block, and if any; // predecessors are a conditional branch to one of our destinations,; // fold the conditions into logical ops and one cond br.; // Ignore dbg intrinsics.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:10,Performance,perform,perform,10,"// Do not perform this transformation if it would require; // insertion of a large number of select instructions. For targets; // without predication/cmovs, this is a big pessimization.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Testability,log,logical,54,"// Finally, if everything is ok, fold the branches to logical ops.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:199,Safety,avoid,avoids,199,"// If OtherDest *is* BB, then BB is a basic block with a single conditional; // branch in it, where one edge (OtherDest) goes back to itself but the other; // exits. We don't *know* that the program avoids the infinite loop; // (even though that seems likely). If we do this xform naively, we'll end up; // recursively unpeeling the loop. Since we know that (after the xform is; // done) that the block *is* infinite if reached, we just make it an obviously; // infinite loop with no cond branch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update branch weight for PBI.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:151,Testability,log,logical,151,"// Although the select has the same condition as PBI, the original branch; // weights for PBI do not apply to the new select because the select's; // 'logical' edges are incoming edges of the phi that is eliminated, not; // the outgoing edges of PBI.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplifies,3,// Simplifies a terminator by replacing it with a branch to TrueBB if Cond is; // true or to FalseBB if Cond is false.; // Takes care of updating the successors and removing the old terminator.; // Also makes sure not to introduce new successors by assuming that edges to; // non-successor TrueBBs and FalseBBs aren't reachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Usability,simpl,simplification,22,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:22,Usability,simpl,simplification,22,// Perform the actual simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:261,Usability,simpl,simplified,261,"/// This is called when we find an icmp instruction; /// (a seteq/setne with a constant) as the only instruction in a; /// block that ends with an uncond branch. We are looking for a very specific; /// pattern that occurs when ""A == 1 || A == 2 || A == 3"" gets simplified. In; /// this case, we merge the first two ""or's of icmp"" into a switch, but then the; /// default value goes to an uncond block with a seteq in it, we get something; /// like:; ///; /// switch i8 %A, label %DEFAULT [ i8 1, label %end i8 2, label %end ]; /// DEFAULT:; /// %tmp = icmp eq i8 %A, 92; /// br label %end; /// end:; /// ... = phi i1 [ true, %entry ], [ %tmp, %DEFAULT ], [ true, %entry ]; ///; /// We prefer to split the edge to 'end' so that there is a true/false entry to; /// the PHI, merging the third icmp into the switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:204,Usability,simpl,simplify,204,// The pattern we're looking for is where our only predecessor is a switch on; // 'V' and this block is the default case for the switch. In this case we can; // fold the compared value into the switch to simplify things.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:53,Usability,simpl,simply,53,"// If BB is reachable on a non-default case, then we simply know the value of; // V in this block. Substitute it and constant fold the icmp instruction; // away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Usability,simpl,simplify,39,"// BB is now empty, so it is likely to simplify away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:39,Usability,simpl,simplify,39,"// BB is now empty, so it is likely to simplify away.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:87,Integrability,depend,depending,87,// Replace ICI (which is used by the PHI for the default value) with true or; // false depending on if it is EQ or NE.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,Avoid,Avoid,3,// Avoid turning single icmps into a switch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:7,Usability,resume,resume,7,// The resume must unwind the exception that caused control to branch here.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplify,3,// Simplify resume that is shared by several landing pads (phi of landing pad).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,resume,resume,12,// Simplify resume that is shared by several landing pads (phi of landing pad).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:113,Usability,resume,resume,113,// Check that there are no other instructions except for debug and lifetime; // intrinsics between the phi's and resume instruction.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:84,Integrability,depend,dependents,84,"// If the block has other successors, we can not delete it because; // it has other dependents.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:45,Usability,simpl,simplifications,45,"// If no trivial unwind blocks, don't do any simplifications.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Usability,simpl,simplified,23,"// Blocks that will be simplified should be removed from the phi node.; // Note there could be multiple edges to the resume block, and we need; // to remove them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:117,Usability,resume,resume,117,"// Blocks that will be simplified should be removed from the phi node.; // Note there could be multiple edges to the resume block, and we need; // to remove them all.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,Usability,Simpl,SimplifyCFG,11,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:122,Usability,Simpl,SimplifyCFG,122,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:217,Usability,resume,resume,217,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:265,Usability,resume,resume,265,"// In each SimplifyCFG run, only the current processed block can be erased.; // Otherwise, it will break the iteration of SimplifyCFG pass. So instead; // of erasing TrivialBB, we only remove the branch to the common resume; // block so that we can later erase the resume block since it has no; // predecessors.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Usability,resume,resume,14,// Delete the resume block if all its predecessors have been removed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Usability,Simpl,Simplify,3,// Simplify resume that is only used by a single (non-phi) landing pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,resume,resume,12,// Simplify resume that is only used by a single (non-phi) landing pad.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:183,Deployability,update,updated,183,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:456,Deployability,update,updated,456,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:383,Usability,simpl,simplified,383,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:531,Usability,simpl,simplified,531,"// If this is a trivial cleanup pad that executes no instructions, it can be; // eliminated. If the cleanup pad continues to the caller, any predecessor; // that is an EH pad will be updated to continue to the caller and any; // predecessor that terminates with an invoke instruction will have its invoke; // instruction converted to a call instruction. If the cleanup pad being; // simplified does not continue to the caller, each predecessor will be; // updated to continue to the unwind destination of the cleanup pad being; // simplified.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Usability,simpl,simplifying,32,"// If the cleanup return we are simplifying unwinds to the caller, this will; // set UnwindDest to nullptr.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:164,Safety,avoid,avoids,164,"// We're about to remove BB from the control flow. Before we do, sink any; // PHINodes into the unwind destination. Doing this before changing the; // control flow avoids some potentially slow checks, since we can currently; // be certain that UnwindDest and BB have no common predecessors (since they; // are both EH pads).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:53,Deployability,update,update,53,"// First, go through the PHI nodes in UnwindDest and update any nodes that; // reference the block we are removing",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:148,Modifiability,inherit,inherit,148,"// Otherwise, sink this PHI node into UnwindDest.; // Any predecessors to UnwindDest which are not already represented; // must be back edges which inherit the value from the path through; // BB. In this case, the PHI value must reference itself.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:85,Safety,safe,safe,85,"// This cleanupret isn't the only predecessor of this cleanuppad, it wouldn't; // be safe to merge without code duplication.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:11,Usability,simpl,simply,11,"// Now, we simply replace the cleanupret with a branch to the unwind; // destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:541,Modifiability,variab,variable,541,"// Can not drop any more instructions. We're done here.; // Otherwise, this instruction can be freely erased,; // even if it is not side-effect free.; // Note that deleting EH's here is in fact okay, although it involves a bit; // of subtle reasoning. If this inst is an EH, all the predecessors of this; // block will be the unwind edges of Invoke/CatchSwitch/CleanupReturn,; // and we can therefore guarantee this block will be erased.; // If we're deleting this, we're deleting any subsequent dbg.values, so; // delete DPValue records of variable information.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:131,Usability,simpl,simplify,131,"// If the unreachable instruction is the first in the block, take a gander; // at all of the predecessors of this instruction, and simplify them.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite all preds to unwind to caller (or from invoke to call).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Deployability,Update,Update,3,// Update weight for the newly-created conditional branch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Availability,mask,masked,12,/// Compute masked bits for the condition of a switch; /// and use it to remove dead cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,avoid,avoid,3,/* avoid overflow */,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:32,Usability,simpl,simplification,32,"/// If BB would be eligible for simplification by; /// TryToSimplifyUncondBranchFromEmptyBlock (i.e. it is empty and terminated; /// by an unconditional branch), look at the phi node for BB in the successor; /// block and see if the incoming value is equal to CaseValue. If so, return; /// the phi node, and set PhiIndex to BB's index in the phi node.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:42,Usability,simpl,simplification,42,// BB must be empty to be a candidate for simplification.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:120,Modifiability,variab,variable,120,"// Replace phi operands in successor blocks that are using the constant case; // value rather than the switch condition variable:; // switchbb:; // switch i32 %x, label %default [; // i32 17, label %succ; // ...; // succ:; // %r = phi i32 ... [ 17, %switchbb ] ...; // -->; // %r = phi i32 ... [ %x, %switchbb ] ...",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:67,Usability,simpl,simple,67,"/// Try to fold instruction I into a constant. This works for; /// simple instructions such as binary operations where both operands are; /// constant or can be replaced by constants from the ConstantPool. Returns the; /// resulting constant on success, 0 otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:26,Usability,simpl,simple,26,"// If the terminator is a simple branch, continue to the next block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:148,Safety,safe,safe,148,"// Instruction is side-effect free and constant.; // If the instruction has uses outside this block or a phi node slot for; // the block, it is not safe to bypass the instruction since it would then; // no longer dominate all its uses.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:44,Safety,abort,abort,44,"// If the destination isn't the common one, abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:98,Deployability,update,updated,98,// Helper function used to add CaseVal to the list of cases that generate; // Result. Returns the updated number of cases that generate this result.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:37,Safety,abort,abort,37,// If the default value is not found abort unless the default destination; // is unreachable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Usability,simpl,simple,63,"// If we are selecting between only two cases transform into a simple; // select or a two-way select if default is possible.; // Example:; // switch (a) { %0 = icmp eq i32 %a, 10; // case 10: return 42; %1 = select i1 %0, i32 42, i32 4; // case 20: return 2; ----> %2 = icmp eq i32 %a, 20; // default: return 4; %3 = select i1 %2, i32 2, i32 %1; // }",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Integrability,Depend,Depending,3,"// Depending on the contents of the table, it can be represented in; // different ways.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:118,Usability,simpl,simple,118,// For tables where there is a linear relationship between table index; // and values. We calculate the result with a simple multiplication; // and addition instead of a table lookup.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:156,Availability,mask,mask,156,"// For small tables with integer elements, we can pack them into a bitmap; // that fits into a target-legal register. Values are retrieved by; // shift and mask operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:70,Performance,load,load,70,// The table is stored as an array of values. Values are retrieved by load; // instructions from the table.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:64,Performance,load,loading,64,// Set the alignment to that of an array items. We will be only loading one; // value out of it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:161,Safety,safe,safe,161,"// Cast Index to the same type as the bitmap.; // Note: The Index is <= the number of elements in the table, so; // truncating it to the width of the bitmask is safe.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:9,Availability,down,down,9,// Shift down.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Availability,Mask,Mask,3,// Mask off.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:127,Safety,Avoid,Avoid,127,"// FIXME: If the type is wider than it needs to be, e.g. i8 but all values; // are <= 15, we could try to narrow the type.; // Avoid overflow, fitsInLegalInteger uses unsigned int for the width.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:14,Energy Efficiency,power,power,14,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:169,Performance,load,loads,169,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:328,Performance,load,load,328,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:401,Performance,load,load,401,// Also allow power of 2 integer types that have at least 8 bits and fit in; // a register. These types are common in frontend languages and targets; // usually support loads of these types.; // TODO: We could relax this to any integer that fits in a register and rely; // on ABI alignment and padding in the table to allow the load to be widened.; // Or we could widen the constants and truncate the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Safety,Avoid,Avoid,3,// Avoid multiplication overflows below.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:348,Modifiability,extend,extend,348,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:244,Performance,load,loads,244,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:365,Performance,load,load,365,"/// Determine whether a lookup table should be built for this switch, based on; /// the number of cases, size of the table, and the types of the results.; // TODO: We could support larger than legal types by limiting based on the; // number of loads required and/or table size. If the constants are small we; // could use smaller table entries and extend after the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:260,Performance,optimiz,optimized,260,/// Try to reuse the switch table index compare. Following pattern:; /// \code; /// if (idx < tablesize); /// r = table[idx]; // table does not contain default_value; /// else; /// r = default_value;; /// if (r != default_value); /// ...; /// \endcode; /// Is optimized to:; /// \code; /// cond = idx < tablesize;; /// if (cond); /// r = table[idx];; /// else; /// r = default_value;; /// if (cond); /// ...; /// \endcode; /// Jump threading will then eliminate the second if(cond).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:66,Usability,simpl,simple,66,"// Check if the branch instruction dominates the phi node. It's a simple; // dominance check, but sufficient for our needs.; // Although this check is invariant in the calling loops, it's better to do it; // at this late stage. Practically we do it at most once for a switch.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Testability,test,test,40,// As an extra penalty for the validity test we require more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:37,Testability,benchmark,benchmark,37,// FIXME: Find best threshold value (benchmark).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:110,Modifiability,variab,variable,110,"// If the default destination is unreachable, or if the lookup table covers; // all values of the conditional variable, branch directly to the lookup table; // BB. Otherwise, check that the condition is within the case range.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:56,Safety,avoid,avoid,56,"// Grow the table to cover all possible index values to avoid the range check.; // It will use the default result to fill in the table hole later, so make; // sure it exist.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:138,Availability,mask,mask,138,// Note: We call removeProdecessor later since we need to be able to get the; // PHI value for the default case in case we're using a bit mask.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Availability,mask,mask,12,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:49,Energy Efficiency,power,power-of-,49,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:63,Safety,avoid,avoid,63,// Make the mask's bitwidth at least 8-bit and a power-of-2 to avoid; // unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:6,Performance,cache,cached,6,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:34,Safety,avoid,avoid,34,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:40,Security,access,accessing,40,"// We cached PHINodes in PHIs. To avoid accessing deleted PHINodes later,; // do not delete PHINodes here.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:23,Performance,optimiz,optimization,23,// Do a small peephole optimization: re-use the switch table compare if; // possible.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:185,Energy Efficiency,reduce,reduced,185,"/// Try to transform a switch that has ""holes"" in it to a contiguous sequence; /// of cases.; ///; /// A switch such as: switch(i) {case 5: case 9: case 13: case 17:} can be; /// range-reduced to: switch ((i-5) / 4) {case 0: case 1: case 2: case 3:}.; ///; /// This converts a sparse switch into a dense switch which allows better; /// lowering and could also allow transforming into a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Performance,optimiz,optimization,25,// Only bother with this optimization if there are more than 3 switch cases;; // SDAG will only bother creating jump tables for 4 or more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:140,Performance,optimiz,optimize,140,"// This transform is agnostic to the signedness of the input or case values. We; // can treat the case values as signed or unsigned. We can optimize more common; // cases such as a sequence crossing zero {-4,0,4,8} if we interpret case values; // as signed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:321,Performance,perform,performs,321,"// The obvious transform is to shift the switch condition right and emit a; // check that the condition actually cleanly divided by GCD, i.e.; // C & (1 << Shift - 1) == 0; // inserting a new CFG edge to handle the case where it didn't divide cleanly.; //; // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the; // shift and puts the shifted-off bits in the uppermost bits. If any of these; // are nonzero then the switch condition will be very large and will hit the; // default case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:293,Usability,simpl,simple,293,"// The obvious transform is to shift the switch condition right and emit a; // check that the condition actually cleanly divided by GCD, i.e.; // C & (1 << Shift - 1) == 0; // inserting a new CFG edge to handle the case where it didn't divide cleanly.; //; // A cheaper way of doing this is a simple ROTR(C, Shift). This performs the; // shift and puts the shifted-off bits in the uppermost bits. If any of these; // are nonzero then the switch condition will be very large and will hit the; // default case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:33,Energy Efficiency,power,powers,33,"/// Tries to transform switch of powers of two to reduce switch range.; /// For example, switch like:; /// switch (C) { case 1: case 2: case 64: case 128: }; /// will be transformed to:; /// switch (count_trailing_zeros(C)) { case 0: case 1: case 6: case 7: }; ///; /// This transformation allows better lowering and could allow transforming into; /// a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:50,Energy Efficiency,reduce,reduce,50,"/// Tries to transform switch of powers of two to reduce switch range.; /// For example, switch like:; /// switch (C) { case 1: case 2: case 64: case 128: }; /// will be transformed to:; /// switch (count_trailing_zeros(C)) { case 0: case 1: case 6: case 7: }; ///; /// This transformation allows better lowering and could allow transforming into; /// a lookup table.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:25,Performance,optimiz,optimization,25,// Only bother with this optimization if there are more than 3 switch cases.; // SDAG will only bother creating jump tables for 4 or more cases.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:151,Energy Efficiency,power,power,151,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:6,Performance,perform,perform,6,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:19,Performance,optimiz,optimization,19,// We perform this optimization only for switches with; // unreachable default case.; // This assumtion will save us from checking if `Condition` is a power of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Energy Efficiency,power,powers,31,// Check that switch cases are powers of two.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:184,Deployability,pipeline,pipeline,184,"// Try to transform the switch into an icmp and a branch.; // The conversion from switch to comparison may lose information on; // impossible switch values, so disable it early in the pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:327,Deployability,pipeline,pipeline,327,"// The conversion from switch to lookup tables results in difficult-to-analyze; // code and makes pruning branches much harder. This is a problem if the; // switch expression itself can still be restricted as a result of inlining or; // CVP. Therefore, only apply this transformation during late stages of the; // optimisation pipeline.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Availability,redundant,redundant,13,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:13,Safety,redund,redundant,13,// Eliminate redundant destinations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:359,Energy Efficiency,schedul,scheduling,359,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:430,Performance,optimiz,optimizer,430,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:635,Performance,optimiz,optimization,635,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:666,Performance,perform,performing,666,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:716,Performance,optimiz,optimization,716,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:660,Safety,avoid,avoid,660,"/// Given an block with only a single landing pad and a unconditional branch; /// try to find another basic block which this one can be merged with. This; /// handles cases where we have multiple invokes with unique landing pads, but; /// a shared handler.; ///; /// We specifically choose to not worry about merging non-empty blocks; /// here. That is a PRE/scheduling problem and is best solved elsewhere. In; /// practice, the optimizer produces empty landing pad blocks quite frequently; /// when dealing with exception dense code. (see: instcombine, gvn, if-else; /// sinking in this file); ///; /// This is primarily a code size optimization. We need to avoid performing; /// any transform which might inhibit optimization (such as our ability to; /// specialize a particular handler via tail commoning). We do this by not; /// merging any blocks which require us to introduce a phi. Since the same; /// values are flowing through both blocks, we don't lose any ability to; /// specialize. If anything, we make such specialization more likely.; ///; /// TODO - This transformation could remove entries from a phi in the target; /// block when the inputs in the phi are the same for the two blocks being; /// merged. In some cases, this could result in removal of the PHI entirely.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:35,Deployability,Update,Update,35,// We've found an identical block. Update our predecessors to take that; // path instead and make ourselves dead.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:125,Deployability,update,update,125,// The debug info in OtherPred doesn't cover the merged control flow that; // used to go through BB. We need to delete it or update it.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:54,Usability,simpl,simplify,54,"// If the Terminator is the only non-phi instruction, simplify the block.; // If LoopHeader is provided, check if the block or its successor is a loop; // header. (This is for early invocations before loop simplify and; // vectorization to keep canonical loop forms for nested loops. These blocks; // can be eliminated when the pass is invoked later in the back-end.); // Note that if BB has only one predecessor then we do not introduce new; // backedge, so we can eliminate BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:206,Usability,simpl,simplify,206,"// If the Terminator is the only non-phi instruction, simplify the block.; // If LoopHeader is provided, check if the block or its successor is a loop; // header. (This is for early invocations before loop simplify and; // vectorization to keep canonical loop forms for nested loops. These blocks; // can be eliminated when the pass is invoked later in the back-end.); // Note that if BB has only one predecessor then we do not introduce new; // backedge, so we can eliminate BB.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:99,Usability,simpl,simplify,99,"// If the only instruction in the block is a seteq/setne comparison against a; // constant, try to simplify the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:189,Deployability,update,update,189,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and our successor, fold the comparison into the; // predecessor and use logical operations to update the incoming value; // for PHI nodes in common successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:167,Testability,log,logical,167,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and our successor, fold the comparison into the; // predecessor and use logical operations to update the incoming value; // for PHI nodes in common successor.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:175,Testability,log,logical,175,"// If this basic block is ONLY a compare and a branch, and if a predecessor; // branches to us and one of our successors, fold the comparison into the; // predecessor and use logical operations to pick the right destination.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:31,Safety,avoid,avoid,31,"// Only look at the first use, avoid hurting compile time with long uselists",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Performance,load,load,24,// Look through GEPs. A load from a GEP derived from NULL is still undefined,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Load,Load,3,// Load from null is undefined.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:12,Usability,simpl,simplify,12,// Repeated simplify BB as long as resimplification is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:3,Performance,Perform,Perform,3,// Perform one round of simplifcation. Resimplify flag will be set if; // another iteration is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp:24,Usability,simpl,simplifcation,24,// Perform one round of simplifcation. Resimplify flag will be set if; // another iteration is requested.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyCFG.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:39,Modifiability,variab,variable,39,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:414,Modifiability,variab,variable,414,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:555,Modifiability,variab,variables,555,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:8,Usability,Simpl,SimplifyIndVar,8,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Usability,simpl,simplification,48,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:423,Usability,simpl,simplification,423,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:527,Usability,simpl,simplify,527,"//===-- SimplifyIndVar.cpp - Induction variable simplification ------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements induction variable simplification. It does; // not define any actual pass or policy, but provides a single function to; // simplify a loop's induction variables based on ScalarEvolution.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Modifiability,variab,variables,48,"/// This is a utility for simplifying induction variables; /// based on ScalarEvolution. It is the primary instrument of the; /// IndvarSimplify pass, but it may also be directly invoked to cleanup after; /// other loop passes that preserve SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:26,Usability,simpl,simplifying,26,"/// This is a utility for simplifying induction variables; /// based on ScalarEvolution. It is the primary instrument of the; /// IndvarSimplify pass, but it may also be directly invoked to cleanup after; /// other loop passes that preserve SCEV.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:94,Modifiability,variab,variable,94,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Performance,perform,perform,16,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Usability,simpl,simplification,24,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:155,Usability,simpl,simplifications,155,/// Iteratively perform simplification on a worklist of users of the; /// specified induction variable. This is the top-level driver that applies; /// all simplifications to users of an IV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:72,Safety,safe,safely,72,"/// Find a point in code which dominates all given instructions. We can safely; /// assume that, whatever fact we can prove at the found point, this fact is; /// also true for each of the given instructions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:266,Modifiability,variab,variable,266,"/// Fold an IV operand into its use. This removes increments of an; /// aligned IV when used by a instruction that ignores the low bits.; ///; /// IVOperand is guaranteed SCEVable, but UseInst may not be.; ///; /// Return the operand of IVOperand for this induction variable if IVOperand can; /// be folded (in case more folding opportunities have been exposed).; /// Otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:353,Security,expose,exposed,353,"/// Fold an IV operand into its use. This removes increments of an; /// aligned IV when used by a instruction that ignores the low bits.; ///; /// IVOperand is guaranteed SCEVable, but UseInst may not be.; ///; /// Return the operand of IVOperand for this induction variable if IVOperand can; /// be folded (in case more folding opportunities have been exposed).; /// Otherwise return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:89,Modifiability,variab,variable,89,/// SimplifyIVUsers helper for eliminating useless; /// comparisons against an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,SimplifyIVUsers,4,/// SimplifyIVUsers helper for eliminating useless; /// comparisons against an induction variable.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:143,Performance,optimiz,optimizations,143,"// If we were unable to make anything above, all we can is to canonicalize; // the comparison hoping that it will open the doors for other; // optimizations. If we find out that we compare two non-negative values,; // we turn the instruction's predicate to its unsigned version. Note that; // we cannot rely on Pred here unless we check if we have swapped it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Usability,Simpl,Simplify,3,// Simplify unnecessary loops away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:103,Modifiability,variab,variable,103,/// SimplifyIVUsers helper for eliminating useless remainder operations; /// operating on an induction variable or replacing srem by urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,SimplifyIVUsers,4,/// SimplifyIVUsers helper for eliminating useless remainder operations; /// operating on an induction variable or replacing srem by urem.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Usability,Simpl,Simplify,3,// Simplify unnecessary loops away.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:682,Performance,optimiz,optimizations,682,"// It is always legal to replace; // icmp <pred> i32 trunc(iv), n; // with; // icmp <pred> i64 sext(trunc(iv)), sext(n), if pred is signed predicate.; // Or with; // icmp <pred> i64 zext(trunc(iv)), zext(n), if pred is unsigned predicate.; // Or with either of these if pred is an equality predicate.; //; // If we can prove that iv == sext(trunc(iv)) or iv == zext(trunc(iv)) for; // every comparison which uses trunc, it means that we can replace each of; // them with comparison of iv against sext/zext(n). We no longer need trunc; // after that.; //; // TODO: Should we do this if we can widen *some* comparisons, but not all; // of them? Sometimes it is enough to enable other optimizations, but the; // trunc instruction will stay in the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Safety,safe,safely,24,"// For equality, we can safely zext both parts.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:43,Usability,simpl,simple,43,"/// Eliminate an operation that consumes a simple IV and has no observable; /// side-effect given the range of IV values. IVOperand is guaranteed SCEVable,; /// but UseInst may not be.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:66,Safety,safe,safe,66,/// Replace the UseInst with a loop invariant expression if it is safe.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,Availability,redundant,redundant,14,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:14,Safety,redund,redundant,14,/// Eliminate redundant type cast between integer and float.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Testability,log,logic,24,"// To match InstCombine logic, we only need sext if both fptosi and; // sitofp are used. If one of them is unsigned, then we can use zext.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:105,Performance,perform,performing,105,"// The getStrengthenedNoWrapFlagsFromBinOp() check inferred additional nowrap; // flags on addrecs while performing zero/sign extensions. We could call; // forgetValue() here to make sure those flags also propagate to any other; // SCEV expressions based on the addrec. However, this can have pathological; // compile-time impact, see https://bugs.llvm.org/show_bug.cgi?id=50384.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:3,Safety,Avoid,Avoid,3,"// Avoid infinite or exponential worklist processing.; // Also ensure unique worklist users.; // If Def is a LoopPhi, it may not be in the Simplified set, so check for; // self edges first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:139,Usability,Simpl,Simplified,139,"// Avoid infinite or exponential worklist processing.; // Also ensure unique worklist users.; // If Def is a LoopPhi, it may not be in the Simplified set, so check for; // self edges first.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:48,Usability,simpl,simple,48,/// Return true if this instruction generates a simple SCEV; /// expression in terms of that IV.; ///; /// This is similar to IVUsers' isInteresting() but processes each instruction; /// non-recursively when the operand is already known to be a simpleIVUser.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:245,Usability,simpl,simpleIVUser,245,/// Return true if this instruction generates a simple SCEV; /// expression in terms of that IV.; ///; /// This is similar to IVUsers' isInteresting() but processes each instruction; /// non-recursively when the operand is already known to be a simpleIVUser.; ///,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,Availability,down,down,459,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:94,Modifiability,variab,variable,94,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:379,Modifiability,variab,variables,379,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Performance,perform,perform,16,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:513,Performance,optimiz,optimization,513,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Usability,simpl,simplification,24,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:120,Usability,simpl,simplification,120,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:199,Usability,simpl,simplification,199,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:287,Usability,simpl,simplifies,287,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:507,Usability,clear,clear,507,"/// Iteratively perform simplification on a worklist of users; /// of the specified induction variable. Each successive simplification may push; /// more users which may themselves be candidates for simplification.; ///; /// This algorithm does not require IVUsers analysis. Instead, it simplifies; /// instructions in-place during analysis. Rather than rewriting induction; /// variables bottom-up from their users, it transforms a chain of IVUsers; /// top-down, updating the IR only when it encounters a clear optimization; /// opportunity.; ///; /// Once DisableIVRewrite is default, LSR will be the only client of IVUsers.; ///",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:29,Usability,Simpl,SimplifyIndvar,29,// Instructions processed by SimplifyIndvar for CurrIV.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:24,Safety,avoid,avoid,24,// Bypass back edges to avoid extra work.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:69,Usability,simpl,simplifications,69,// Try to replace UseInst with a loop invariant before any other; // simplifications.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:6,Performance,queue,queue,6,// re-queue uses of the now modified binary operator and fall; // through to the checks that remain.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:6,Performance,queue,queue,6,// Re-queue the potentially new direct uses of IVOperand.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:50,Modifiability,variab,variable,50,/// Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,Simplify,4,/// Simplify instructions that use this induction variable; /// by using ScalarEvolution to analyze the IV's recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:32,Modifiability,variab,variables,32,/// Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:4,Usability,Simpl,Simplify,4,/// Simplify users of induction variables within this; /// loop. This does not actually change or add IVs.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:101,Modifiability,Variab,Variables,101,//===----------------------------------------------------------------------===//; // Widen Induction Variables - Extend the width of an IV to cover its; // widest uses.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:113,Modifiability,Extend,Extend,113,//===----------------------------------------------------------------------===//; // Widen Induction Variables - Extend the width of an IV to cover its; // widest uses.; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:101,Safety,avoid,avoid,101,// Does the module have any calls to the llvm.experimental.guard intrinsic; // at all? If not we can avoid scanning instructions looking for guards.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:22,Integrability,depend,dependent,22,// A map with control-dependent ranges for post increment IV uses. The key is; // a pair of IV def and a use of this def denoting the context. The value is; // a ConstantRange representing possible values of the def at the given; // context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:132,Safety,avoid,avoids,132,/// Record a link in the Narrow IV def-use chain along with the WideIV that; /// computes the same value as the Narrow IV def. This avoids caching Use*; /// pointers.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:148,Safety,safe,safely,148,/// Instantiate a wide operation to replace a narrow operation. This only needs; /// to handle operations that can evaluation to SCEVAddRec. It can safely return; /// 0 for any operation we decide not to clone.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:271,Modifiability,extend,extending,271,"// We're trying to find X such that; //; // Widen(NarrowDef `op` NonIVNarrowDef) == WideAR == WideDef `op.wide` X; //; // We guess two solutions to X, sext(NonIVNarrowDef) and zext(NonIVNarrowDef),; // and check using SCEV if any of them are correct.; // Returns true if extending NonIVNarrowDef according to `SignExt` is a; // correct solution to X.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:7,Integrability,wrap,wrap,7,"/// No-wrap operations can transfer sign extension of their result to their; /// operands. Generate the SCEV value for the widened operation without; /// actually modifying the IR yet. If the expression after extending the; /// operands is an AddRec for this loop, return the AddRec and the kind of; /// extension used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:209,Modifiability,extend,extending,209,"/// No-wrap operations can transfer sign extension of their result to their; /// operands. Generate the SCEV value for the widened operation without; /// actually modifying the IR yet. If the expression after extending the; /// operands is an AddRec for this loop, return the AddRec and the kind of; /// extension used.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:44,Modifiability,extend,extended,44,// One operand (NarrowDef) has already been extended to WideDef. Now determine; // if extending the other will lead to a recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:86,Modifiability,extend,extending,86,// One operand (NarrowDef) has already been extended to WideDef. Now determine; // if extending the other will lead to a recurrence.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:104,Modifiability,extend,extend,104,"// For a non-negative NarrowDef, we can choose either type of; // extension. We want to use the current extend kind if legal; // (see above), and we only hit this code if we need to check; // the opposite case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:150,Integrability,wrap,wrap,150,"// When creating this SCEV expr, don't apply the current operations NSW or NUW; // flags. This instruction may be guarded by control flow that the no-wrap; // behavior depends on. Non-control-equivalent instructions can be mapped to; // the same SCEV expression, and it would be incorrect to transfer NSW/NUW; // semantics to those operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:168,Integrability,depend,depends,168,"// When creating this SCEV expr, don't apply the current operations NSW or NUW; // flags. This instruction may be guarded by control flow that the no-wrap; // behavior depends on. Non-control-equivalent instructions can be mapped to; // the same SCEV expression, and it would be incorrect to transfer NSW/NUW; // semantics to those operations.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:130,Modifiability,extend,extend,130,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:262,Modifiability,extend,extended,262,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:346,Modifiability,Extend,ExtendKind,346,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:140,Safety,safe,safely,140,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:60,Usability,simpl,simplification,60,"/// Is this instruction potentially interesting for further simplification after; /// widening it's type? In other words, can the extend be safely hoisted out of; /// the loop with SCEV reducing the value to a recurrence on the same loop. If; /// so, return the extended recurrence and the kind of extension used. Otherwise; /// return {nullptr, ExtendKind::Unknown}.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:113,Modifiability,extend,extend,113,"/// If the narrow use is a compare instruction, then widen the compare; // (and possibly the other operand). The extend operation is hoisted into the; // loop preheader as far as possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:277,Modifiability,extend,extending,277,"// We can legally widen the comparison in the following two cases:; //; // - The signedness of the IV extension and comparison match; //; // - The narrow IV is always positive (and thus its sign extension is equal; // to its zero extension). For instance, let's say we're zero extending; // %narrow for the following use; //; // icmp slt i32 %narrow, %val ... (A); //; // and %narrow is always positive. Then; //; // (A) == icmp slt i32 sext(%narrow), sext(%val); // == icmp slt i32 zext(%narrow), sext(%val)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:438,Modifiability,extend,extended,438,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:827,Modifiability,extend,extended,827,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:210,Performance,load,load,210,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:18,Safety,avoid,avoids,18,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:310,Safety,avoid,avoid,310,"// The widenIVUse avoids generating trunc by evaluating the use as AddRec, this; // will not work when:; // 1) SCEV traces back to an instruction inside the loop that SCEV can not; // expand, eg. add %indvar, (load %addr); // 2) SCEV finds a loop variant, eg. add %indvar, %loopvariant; // While SCEV fails to avoid trunc, we can still try to use instruction; // combining approach to prove trunc is not required. This can be further; // extended with other instruction combining checks, but for now we handle the; // following case (sub can be ""add"" and ""mul"", ""nsw + sext"" can be ""nus + zext""); //; // Src:; // %c = sub nsw %b, %indvar; // %d = sext %c to i64; // Dst:; // %indvar.ext1 = sext %indvar to i64; // %m = sext %b to i64; // %d = sub nsw i64 %m, %indvar.ext1; // Therefore, as long as the result of add/sub/mul is extended to wide type, no; // trunc is required regardless of how %b is generated. This pattern is common; // when calculating address in 64 bit architecture",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:173,Modifiability,extend,extend,173,// Check that all uses are either:; // - narrow def (in case of we are widening the IV increment);; // - single-input LCSSA Phis;; // - comparison of the chosen type;; // - extend of the chosen type (raison d'etre).,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:148,Modifiability,extend,extend,148,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:165,Modifiability,extend,extend,165,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:237,Modifiability,extend,extend,237,"// We have 3 types of predicates: signed, unsigned and equality; // predicates. For equality, it's legal to widen icmp for either sign and; // zero extend. For sign extend, we can also do so for signed predicates,; // likeweise for zero extend we can widen icmp for unsigned predicates.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:62,Integrability,wrap,wrap,62,"// Because InstCombine turns 'sub nuw' to 'add' losing the no-wrap flag, we; // will most likely not see it. Let's try to prove it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:65,Usability,Simpl,SimplifyCFG,65,"// For LCSSA phis, sink the truncate outside the loop.; // After SimplifyCFG most loop exit targets have a single predecessor.; // Otherwise fall back to a truncate within the loop.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:55,Testability,log,logical,55,// Widening the PHI requires us to insert a trunc. The logical place; // for this trunc is in the same BB as the PHI. This is not possible if; // the BB is terminated by a catchswitch.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:11,Modifiability,extend,extend,11,// A wider extend was hidden behind a narrower one. This may induce; // another round of IV widening in which the intermediate IV becomes; // dead. It should be very rare.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:16,Modifiability,extend,extend,16,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:43,Security,expose,expose,43,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:86,Usability,simpl,simplification,86,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:135,Usability,Simpl,SimplifyIVUsers,135,"// Now that the extend is gone, we want to expose it's uses for potential; // further simplification. We don't need to directly inform SimplifyIVUsers; // of the new users, because their parent IV will be processed later as a; // new loop phi. If we preserved IVUsers analysis, we would also want to; // push the uses of WideDef here.; // No further widening is needed. The deceased [sz]ext had done it for us.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:76,Modifiability,extend,extended,76,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:196,Modifiability,extend,extended,196,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:331,Usability,simpl,simply,331,"// Evaluation of WideAddRec ensured that the narrow expression could be; // extended outside the loop without overflow. This suggests that the wide use; // evaluates to the same expression as the extended narrow use, but doesn't; // absolutely guarantee it. Hence the following failsafe check. In rare cases; // where it fails, we simply throw away the newly created wide use.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:74,Performance,perform,performance,74,"// We are here about to generate a truncate instruction that may hurt; // performance because the scalar evolution expression computed earlier; // in WideAddRec.first does not indicate a polynomial induction expression.; // In that case, look at the operands of the use instruction to determine; // if we can still widen the use instead of truncating its operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:27,Integrability,depend,dependent,27,// We might have a control-dependent range information for this context.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:31,Modifiability,variab,variable,31,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:100,Modifiability,variab,variable,100,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:459,Safety,avoid,avoid,459,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:401,Usability,simpl,simpler,401,"/// Process a single induction variable. First use the SCEVExpander to create a; /// wide induction variable that evaluates to the same recurrence as the; /// original narrow IV. Then use a worklist to forward traverse the narrow IV's; /// def-use chain. After widenIVUse has processed all interesting IV users, the; /// narrow IV will be isolated for removal by DeleteDeadPHIs.; ///; /// It would be simpler to delete uses as they are processed, but we must avoid; /// invalidating SCEV expressions.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:28,Modifiability,variab,variable,28,// Is this phi an induction variable?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:23,Modifiability,variab,variable,23,// Widen the induction variable expression.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:17,Modifiability,extend,extended,17,// Can the IV be extended outside the loop without overflow?,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:189,Integrability,depend,dependent,189,"// Iterate over IV uses (including transitive ones) looking for IV increments; // of the form 'add nsw %iv, <const>'. For each increment and each use of; // the increment calculate control-dependent range information basing on; // dominating conditions inside of the loop (e.g. a range check inside of the; // loop). Calculated ranges are stored in PostIncRangeInfos map.; //; // Control-dependent range information is later used to prove that a narrow; // definition is not negative (see pushNarrowIVUsers). It's difficult to do; // this on demand because when pushNarrowIVUsers needs this information some; // of the dominating conditions might be already widened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:388,Integrability,depend,dependent,388,"// Iterate over IV uses (including transitive ones) looking for IV increments; // of the form 'add nsw %iv, <const>'. For each increment and each use of; // the increment calculate control-dependent range information basing on; // dominating conditions inside of the loop (e.g. a range check inside of the; // loop). Calculated ranges are stored in PostIncRangeInfos map.; //; // Control-dependent range information is later used to prove that a narrow; // definition is not negative (see pushNarrowIVUsers). It's difficult to do; // this on demand because when pushNarrowIVUsers needs this information some; // of the dominating conditions might be already widened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:7,Modifiability,rewrite,rewriter,7,"// The rewriter provides a value for the desired IV expression. This may; // either find an existing phi or materialize a new one. Either way, we; // expect a well-formed cyclic phi-with-increments. i.e. any operand not part; // of the phi-SCC dominates the loop entry.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp:23,Integrability,depend,dependent,23,/// Calculates control-dependent range for the given def at the given context; /// by looking at dominating conditions inside of the loop,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyIndVar.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Usability,Simpl,SimplifyLibCalls,12,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:49,Usability,simpl,simplifier,49,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:422,Usability,simpl,simplifier,422,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:510,Usability,simpl,simplifications,510,"//===------ SimplifyLibCalls.cpp - Library calls simplifier ---------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the library calls simplifier. It does not implement; // any pass, but can't be used by other passes to do simplifications.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:327,Safety,avoid,avoids,327,"// Convert the entire string Str representing an integer in Base, up to; // the terminating nul if present, to a constant according to the rules; // of strtoul[l] or, when AsSigned is set, of strtol[l]. On success; // return the result, otherwise null.; // The function assumes the string is encoded in ASCII and carefully; // avoids converting sequences (including """") that the corresponding; // library call might fail and set errno for.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:151,Integrability,wrap,wrapped,151,"// Copy CallInst ""flags"" like musttail, notail, and tail. Return New param for; // easier chaining. Calls to emit* and B.createCall should probably be wrapped; // in this function when New is created to replace Old. Callers should take; // care to check Old.isMustTailCall() if they aren't replacing Old directly; // with New.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:13,Safety,avoid,avoid,13,// Helper to avoid truncating the length if size_t is 32-bits.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Performance,Optimiz,Optimizations,116,//===----------------------------------------------------------------------===//; // String and Memory Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:33,Usability,simpl,simple,33,"// Unbias length.; // Handle the simple, do-nothing case: strcat(x, """") -> x",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Performance,optimiz,optimize,12,// We don't optimize this case.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:75,Performance,optimiz,optimized,75,"// strncat(x, s, c) -> strcat(x, s); // s is constant so the strcat can be optimized further.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:74,Availability,avail,available,74,"// Try to expand strrchr to the memrchr nonstandard extension if it's; // available, or simply fail otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:88,Usability,simpl,simply,88,"// Try to expand strrchr to the memrchr nonstandard extension if it's; // available, or simply fail otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a memcmp or, when StrNCmp is true, strncmp call CI with constant; // arrays LHS and RHS and nonconstant Size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Safety,Avoid,Avoid,3,// Avoid truncating the 64-bit Length to 32 bits in ILP32.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a call to size_t strlcpy(char*, const char*, size_t).",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:129,Safety,avoid,avoid,129,"// Try to determine the length of the source, substituting its size; // when it's not nul-terminated (as it's required to be) to avoid; // reading past its end.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a call CI to either stpncpy when RetEnd is true, or to strncpy; // otherwise.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:29,Security,access,access,29,"// Both st{p,r}ncpy(D, S, N) access the source and destination arrays; // only when N is nonzero.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:421,Performance,optimiz,optimization,421,"// If s is a constant pointer pointing to a string literal, we can fold; // strlen(s + x) to strlen(s) - x, when x is known to be in the range; // [0, strlen(s)] or the string has a single null terminator '\0' at the end.; // We only try to simplify strlen when the pointer s points to an array; // of CharSize elements. Otherwise, we would need to scale the offset x before; // doing the subtraction. This will make the optimization more complex, and; // it's not very useful because calling strlen for a pointer of other types is; // very uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:241,Usability,simpl,simplify,241,"// If s is a constant pointer pointing to a string literal, we can fold; // strlen(s + x) to strlen(s) - x, when x is known to be in the range; // [0, strlen(s)] or the string has a single null terminator '\0' at the end.; // We only try to simplify strlen when the pointer s points to an array; // of CharSize elements. Otherwise, we would need to scale the offset x before; // doing the subtraction. This will make the optimization more complex, and; // it's not very useful because calling strlen for a pointer of other types is; // very uncommon.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:77,Performance,optimiz,optimize,77,"// If Offset is not provably in the range [0, NullTermIdx], we can still; // optimize if we can prove that the program has undefined behavior when; // Offset is outside that range. That is the case when GEP->getOperand(0); // is a pointer to an object whose memory extent is NullTermIdx+1.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:13,Performance,perform,perform,13,// We cannot perform this optimization without wchar_size metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:26,Performance,optimiz,optimization,26,// We cannot perform this optimization without wchar_size metadata.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:22,Security,access,accesses,22,// Punt out-of-bounds accesses to sanitizers and/or libc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:34,Security,sanitiz,sanitizers,34,// Punt out-of-bounds accesses to sanitizers and/or libc.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:40,Performance,load,load,40,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:32,Safety,safe,safe,32,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:138,Safety,safe,safe,138,"// S is dereferenceable so it's safe to load from it and fold; // memchr(S, C, N) == S to N && *S == C for any C and N.; // TODO: This is safe even for nonconstant S.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:18,Modifiability,variab,variable,18,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:121,Testability,test,test,121,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:104,Usability,simpl,simple,104,"// If the char is variable but the input str and length are not we can turn; // this memchr call into a simple bit field test. Of course this only works; // when the return value is only checked against null.; //; // It would be really nice to reuse switch lowering here but we can't change; // the CFG at this point.; //; // memchr(""\r\n"", C, 2) != nullptr -> (1 << C & ((1 << '\r') | (1 << '\n'))); // != 0; // after bounds check.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimization,17,// Restrict this optimization to profitable cases with one or two range; // checks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:27,Energy Efficiency,power,power-of-,27,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:67,Safety,avoid,avoid,67,// For the bit field use a power-of-2 type with at least 8 bits to avoid; // creating unnecessary illegal types.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:51,Availability,mask,mask,51,"// Adjust width of ""C"" to the bitfield width, then mask off the high bits.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:34,Security,access,access,34,// First check that the bit field access is within bounds.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize a memcmp or, when StrNCmp is true, strncmp call CI with constant; // arrays LHS and RHS and nonconstant Size.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,// Optimize a memcmp call CI with constant size Len.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:28,Performance,load,loads,28,"// Don't generate unaligned loads. If either source is constant data,; // alignment doesn't matter for that source because there is no load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:135,Performance,load,load,135,"// Don't generate unaligned loads. If either source is constant data,; // alignment doesn't matter for that source because there is no load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:8,Usability,simpl,simplifications,8,// Most simplifications for memcmp also apply to bcmp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:71,Energy Efficiency,efficient,efficient,71,"// memcmp(x, y, Len) == 0 -> bcmp(x, y, Len) == 0; // bcmp can be more efficient than memcmp because it only has to know that; // there is a difference, not how different one is to the other.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Integrability,Wrap,Wrap,3,// Wrap arg 'c' of type int to char,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:98,Performance,Optimiz,Optimizations,98,//===----------------------------------------------------------------------===//; // Math Library Optimizations; //===----------------------------------------------------------------------===//; // Replace a libcall \p CI with a call to intrinsic \p IID,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:153,Usability,simpl,simply,153,"/// Return a variant of Val with float type.; /// Currently this works in two cases: If Val is an FPExtension of a float; /// value to something bigger, simply return the operand.; /// If Val is a ConstantFP but can be converted to a float ConstantFP without; /// loss of precision do so.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:21,Modifiability,extend,extended,21,// Return a properly extended integer (DstWidth bits wide) if the operation is; // an itofp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:79,Safety,avoid,avoiding,79,"// Make sure that the exponent fits inside an ""int"" of size DstWidth,; // thus avoiding any range issues that FP has not.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:792,Availability,avail,available,792,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:419,Safety,safe,safe,419,"// Evaluate special cases related to a nested function as the base.; // pow(exp(x), y) -> exp(x * y); // pow(exp2(x), y) -> exp2(x * y); // If exp{,2}() is used only once, it is better to fold two transcendental; // math functions into one. If used again, exp{,2}() would still have to be; // called with the original argument, then keep both original transcendental; // functions. However, this transformation is only safe with fully relaxed; // math semantics, since, besides rounding differences, it changes overflow; // and underflow behavior quite dramatically. For example:; // pow(exp(1000), 0.001) = pow(inf, 0.001) = inf; // Whereas:; // exp(1000 * 0.001) = exp(1); // TODO: Loosen the requirement for fully relaxed math semantics.; // TODO: Handle exp10() when more targets have it available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:88,Performance,optimiz,optimizePow,88,"// pow(1, inf) is defined to be 1 but exp2(log2(1) * inf) evaluates to NaN.; // Luckily optimizePow has already handled the x == 1 case.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:36,Security,access,accesses,36,"// If we have a pow() library call (accesses memory) and we can't guarantee; // that the base is not an infinity, give up:; // pow(-Inf, 0.5) is optionally required to have a result of +Inf (not setting; // errno), but sqrt(-Inf) is required by various standards to set errno.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:110,Performance,optimiz,optimization,110,"// The LLVM intrinsics minnum/maxnum correspond to fmin/fmax. Canonicalize to; // the intrinsics for improved optimization (for example, vectorization).; // No-signed-zeros is implied by the definitions of fmax/fmin themselves.; // From the C standard draft WG14/N1256:; // ""Ideally, fmax would be sensitive to the sign of zero, for example; // fmax(-0.0, +0.0) would return +0; however, implementation in software; // might be impractical.""",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:30,Testability,log,log,30,"// This is only applicable to log(), log2(), log10().",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Testability,log,log,3,"// log(pow(x,y)) -> y*log(x)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:22,Testability,log,log,22,"// log(pow(x,y)) -> y*log(x)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Testability,log,log,3,"// log(exp{,2,10}(y)) -> y*log({e,2,10}); // TODO: There is no exp10() intrinsic yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:27,Testability,log,log,27,"// log(exp{,2,10}(y)) -> y*log({e,2,10}); // TODO: There is no exp10() intrinsic yet.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Usability,Simpl,Simple,3,// Simple match: the operands of the multiply are identical.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,Usability,simpl,simplified,124,"// If we found a non-repeated factor, we still need to get its square; // root. We then multiply that by the value that was simplified out; // of the square root calculation.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Safety,abort,abort,116,"// Make sure the prototype is as expected, otherwise the rest of the; // function is probably invalid and likely to abort.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:106,Performance,Optimiz,Optimizations,106,//===----------------------------------------------------------------------===//; // Integer Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:116,Performance,Optimiz,Optimizations,116,//===----------------------------------------------------------------------===//; // Formatting and IO Library Call Optimizations; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Availability,Error,Error,3,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:268,Safety,Predict,Prediction,268,"// Error reporting calls should be cold, mark them as such.; // This applies even to non-builtin calls: it is only a hint and applies to; // functions that the frontend might not understand as builtins.; // This heuristic was suggested in:; // Improving Static Branch Prediction in a Compiler; // Brian L. Deitrich, Ben-Chung Cheng, Wen-mei W. Hwu; // Proceedings of PACT'98, Oct. 1998, IEEE",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Availability,Toler,Tolerate,3,// Tolerate printf's declared void.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:78,Safety,avoid,avoid,78,// Convert the character to unsigned char before passing it to putchar; // to avoid host-specific sign extension in the IR. Putchar converts; // it to unsigned char regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:78,Safety,avoid,avoid,78,// Convert the character to unsigned char before passing it to putchar; // to avoid host-specific sign extension in the IR. Putchar converts; // it to unsigned char regardless.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:3,Performance,Optimiz,Optimize,3,"// Optimize specific format strings.; // printf(""%c"", chr) --> putchar(chr)",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:25,Integrability,depend,depend,25,// All the optimizations depend on the format string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:11,Performance,optimiz,optimizations,11,// All the optimizations depend on the format string.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:17,Performance,optimiz,optimizations,17,"// The remaining optimizations require the format string to be ""%s"" or ""%c""; // and have an extra operand.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:9,Modifiability,rewrite,rewrite,9,// Don't rewrite fputs to fwrite when optimising for size because fwrite; // requires more arguments and thus extra MOVs are required.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:12,Performance,optimiz,optimize,12,// We can't optimize if return value is used.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:9,Performance,optimiz,optimize,9,// Don't optimize calls that require strict floating point semantics.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:134,Performance,optimiz,optimized,134,// TODO: Split out the code below that operates on FP calls so that; // we can all non-FP calls with the StrictFP attribute to be; // optimized.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:86,Performance,optimiz,optimizeFloatingPointLibCall,86,// Command-line parameter overrides instruction attribute.; // This can't be moved to optimizeFloatingPointLibCall() because it may be; // used by the intrinsic optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:161,Performance,optimiz,optimizations,161,// Command-line parameter overrides instruction attribute.; // This can't be moved to optimizeFloatingPointLibCall() because it may be; // used by the intrinsic optimizations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:15,Usability,simpl,simplify,15,// Also try to simplify calls to fortified library functions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:831,Performance,Optimiz,Optimizations,831,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:214,Testability,log,log,214,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:235,Testability,log,log,235,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:240,Testability,log,logf,240,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:246,Testability,log,logl,246,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:258,Testability,log,log,258,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:281,Testability,log,log,281,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:298,Testability,log,log,298,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:311,Testability,log,log,311,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:330,Testability,log,log,330,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:344,Testability,log,log,344,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:364,Testability,log,log,364,"// TODO:; // Additional cases that we need to add to this file:; //; // cbrt:; // * cbrt(expN(X)) -> expN(x/3); // * cbrt(sqrt(x)) -> pow(x,1/6); // * cbrt(cbrt(x)) -> pow(x,1/9); //; // exp, expf, expl:; // * exp(log(x)) -> x; //; // log, logf, logl:; // * log(exp(x)) -> x; // * log(exp(y)) -> y*log(e); // * log(exp10(y)) -> y*log(10); // * log(sqrt(x)) -> 0.5*log(x); //; // pow, powf, powl:; // * pow(sqrt(x),y) -> pow(x,y*0.5); // * pow(pow(x,y),z)-> pow(x,y*z); //; // signbit:; // * signbit(cnst) -> cnst'; // * signbit(nncst) -> 0 (if pstv is a non-negative constant); //; // sqrt, sqrtf, sqrtl:; // * sqrt(expN(x)) -> expN(x*0.5); // * sqrt(Nroot(x)) -> pow(x,1/(2*N)); // * sqrt(pow(x,y)) -> pow(|x|,y*0.5); //; //===----------------------------------------------------------------------===//; // Fortified Library Call Optimizations; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:80,Performance,perform,perform,80,"// If this function takes a flag argument, the implementation may use it to; // perform extra checks. Don't fold into the non-checking variant.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:124,Availability,avail,availability,124,"// FIXME: We shouldn't be changing ""nobuiltin"" or TLI unavailable calls here.; // Some clang users checked for _chk libcall availability using:; // __has_builtin(__builtin___memcpy_chk); // When compiling with -fno-builtin, this is always true.; // When passing -ffreestanding/-mkernel, which both imply -fno-builtin, we; // end up with fortified libcalls, which isn't acceptable in a freestanding; // environment which only provides their non-fortified counterparts.; //; // Until we change clang and/or teach external users to check for availability; // differently, disregard the ""nobuiltin"" attribute and TLI::has.; //; // PR23093.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp:539,Availability,avail,availability,539,"// FIXME: We shouldn't be changing ""nobuiltin"" or TLI unavailable calls here.; // Some clang users checked for _chk libcall availability using:; // __has_builtin(__builtin___memcpy_chk); // When compiling with -fno-builtin, this is always true.; // When passing -ffreestanding/-mkernel, which both imply -fno-builtin, we; // end up with fortified libcalls, which isn't acceptable in a freestanding; // environment which only provides their non-fortified counterparts.; //; // Until we change clang and/or teach external users to check for availability; // differently, disregard the ""nobuiltin"" attribute and TLI::has.; //; // PR23093.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SimplifyLibCalls.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp:33,Performance,optimiz,optimization,33,"//===-- SizeOpts.cpp - code size optimization related code ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp:424,Performance,optimiz,optimization,424,"//===-- SizeOpts.cpp - code size optimization related code ----------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file contains some shared code size optimization related code.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SizeOpts.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:565,Performance,optimiz,optimization,565,"//===- SplitModule.cpp - Split a module into partitions -------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the function llvm::SplitModule, which splits a module; // into multiple linkable partitions. It can be used to implement parallel code; // generation for link-time optimization.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:25,Performance,queue,queue,25,// Pre-populate priority queue with N slot blanks.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:20,Security,hash,hash,20,// Partition by MD5 hash. We only need a few bits for evenness as the number; // of partitions will generally be in the 1-2 figure range; the low 16 bits; // are enough.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp:8,Performance,perform,performs,8,"// This performs splitting without a need for externalization, which might not; // always be possible.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SplitModule.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:41,Deployability,Update,Update,41,"//===- SSAUpdater.cpp - Unstructured SSA Update Tool ----------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SSAUpdater class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:44,Modifiability,variab,variable,44,"// If there is no definition of the renamed variable in this block, just use; // GetValueAtEndOfBlock to do our work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:68,Availability,avail,available,68,"// Otherwise, we do need a PHI: check to see if we already have one available; // in this block that produces the right value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:44,Availability,avail,available,44,"// Set the DebugLoc of the inserted PHI, if available.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:113,Energy Efficiency,allocate,allocate,113,"/// FindPredecessorBlocks - Put the predecessors of Info->BB into the Preds; /// vector, set Info->NumPreds, and allocate space in Info->Preds.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:43,Availability,Avail,AvailableVals,43,"// end namespace llvm; /// Check to see if AvailableVals has an entry for the specified BB and if so,; /// return it. If not, construct SSA form by first calculating the required; /// placement of PHIs and then inserting new PHIs where needed.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:85,Performance,Load,LoadAndStorePromoter,85,//===----------------------------------------------------------------------===//; // LoadAndStorePromoter Implementation; //===----------------------------------------------------------------------===//,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:116,Performance,load,loads,116,"// Okay, now we can iterate over all the blocks in the function with uses,; // processing them. Keep track of which loads are loading a live-in value.; // Walk the uses in the use-list order to be determinstic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:126,Performance,load,loading,126,"// Okay, now we can iterate over all the blocks in the function with uses,; // processing them. Keep track of which loads are loading a live-in value.; // Walk the uses in the use-list order to be determinstic.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:100,Modifiability,rewrite,rewrite,100,"// Okay, this is the first use in the block. If this block just has a; // single user in it, we can rewrite it trivially.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:39,Modifiability,rewrite,rewrite,39,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:21,Performance,load,load,21,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:27,Performance,queue,queue,27,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:60,Performance,load,load,60,"// Otherwise it is a load, queue it to rewrite as a live-in load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:48,Performance,load,loads,48,"// Otherwise, check to see if this block is all loads.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:71,Energy Efficiency,efficient,efficient,71,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:17,Performance,queue,queue,17,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:43,Performance,load,loads,43,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:181,Performance,load,loads,181,"// If so, we can queue them all as live in loads. We don't have an; // efficient way to tell which on is first in the block and don't want to; // scan large blocks, so just add all loads as live ins.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:28,Performance,load,loads,28,"// Otherwise, we have mixed loads and stores (or just a bunch of stores).; // Since SSAUpdater is purely for cross-block values, we need to determine; // the order of these instructions in the block. If the first use in the; // block is a load, then it uses the live in value. The last store defines; // the live out value. We handle this by doing a linear scan of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:239,Performance,load,load,239,"// Otherwise, we have mixed loads and stores (or just a bunch of stores).; // Since SSAUpdater is purely for cross-block values, we need to determine; // the order of these instructions in the block. If the first use in the; // block is a load, then it uses the live in value. The last store defines; // the live out value. We handle this by doing a linear scan of the block.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Performance,load,load,16,"// If this is a load from an unrelated pointer, ignore it.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Modifiability,rewrite,rewrite,16,"// Okay, now we rewrite all loads that use live-in values in the loop,; // inserting PHI nodes as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:28,Performance,load,loads,28,"// Okay, now we rewrite all loads that use live-in values in the loop,; // inserting PHI nodes as necessary.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:3,Safety,Avoid,Avoid,3,// Avoid assertions in unreachable code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:9,Testability,assert,assertions,9,// Avoid assertions in unreachable code.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:250,Deployability,update,updates,250,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:16,Performance,load,load,16,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:51,Performance,load,load,51,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:163,Performance,load,loaded,163,"// If this is a load that still has uses, then the load must have been added; // as a live value in the SSAUpdate data structure for a block (e.g. because; // the loaded value was stored later). In this case, we need to recursively; // propagate the updates until we get to the real value.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:13,Availability,down,down,13,"// Propagate down to the ultimate replacee. The intermediately loads; // could theoretically already have been deleted, so we don't want to; // dereference the Value*'s.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp:63,Performance,load,loads,63,"// Propagate down to the ultimate replacee. The intermediately loads; // could theoretically already have been deleted, so we don't want to; // dereference the Value*'s.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdater.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:45,Deployability,Update,Update,45,"//===- SSAUpdaterBulk.cpp - Unstructured SSA Update Tool ------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file implements the SSAUpdaterBulk class.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:14,Modifiability,variab,variable,14,/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:34,Modifiability,rewrite,rewriter,34,/// Add a new variable to the SSA rewriter. This needs to be called before; /// AddAvailableValue or AddUse calls.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:39,Availability,avail,available,39,/// Indicate that a rewritten value is available in the specified block with the; /// specified value.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:57,Deployability,update,updated,57,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:98,Modifiability,Rewrite,RewriteAllUses,98,/// Record a use of the symbolic value. This use will be updated with a; /// rewritten value when RewriteAllUses is called.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:30,Deployability,update,updates,30,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:101,Deployability,update,update,101,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:4,Performance,Perform,Perform,4,"/// Perform all the necessary updates, including new PHI-nodes insertion and the; /// requested uses update.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp:3,Modifiability,Rewrite,Rewrite,3,// Rewrite actual uses with the inserted definitions.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SSAUpdaterBulk.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:62,Modifiability,Rewrite,RewriteStatePoints,62,"//===- StripGCRelocates.cpp - Remove gc.relocates inserted by RewriteStatePoints===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that removes the gc.relocates inserted by; // RewriteStatepointsForGC. Note that the generated IR is incorrect,; // but this is useful as a single pass in itself, for analysis of IR, without; // the GC.relocates. The statepoint and gc.result intrinsics would still be; // present.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:464,Modifiability,Rewrite,RewriteStatepointsForGC,464,"//===- StripGCRelocates.cpp - Remove gc.relocates inserted by RewriteStatePoints===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This is a little utility pass that removes the gc.relocates inserted by; // RewriteStatepointsForGC. Note that the generated IR is incorrect,; // but this is useful as a single pass in itself, for analysis of IR, without; // the GC.relocates. The statepoint and gc.result intrinsics would still be; // present.; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp:154,Usability,clear,clear,154,"// Replace all uses of gc.relocate and delete the gc.relocate; // There maybe unncessary bitcasts back to the OrigPtr type, an instcombine; // pass would clear this up.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/StripGCRelocates.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:549,Deployability,configurat,configuration,549,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:586,Deployability,configurat,configuration,586,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:35,Modifiability,Rewrite,Rewriter,35,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:423,Modifiability,rewrite,rewrite,423,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:523,Modifiability,config,configured,523,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:549,Modifiability,config,configuration,549,"//===- SymbolRewriter.cpp - Symbol Rewriter -------------------------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumer",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:586,Modifiability,config,configuration,586,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:635,Modifiability,Rewrite,RewriteMapFile,635,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:653,Modifiability,Rewrite,RewriteDescriptors,653,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:676,Modifiability,Rewrite,RewriteDescriptors,676,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:698,Modifiability,Rewrite,RewriteDescriptor,698,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:718,Modifiability,Rewrite,RewriteDescriptors,718,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:741,Modifiability,Rewrite,RewriteDescriptor,741,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:762,Modifiability,Rewrite,RewriteDescriptorType,762,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:792,Modifiability,Rewrite,RewriteDescriptorFields,792,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:824,Modifiability,Rewrite,RewriteDescriptorFields,824,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:851,Modifiability,Rewrite,RewriteDescriptorField,851,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:876,Modifiability,Rewrite,RewriteDescriptorFields,876,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:904,Modifiability,Rewrite,RewriteDescriptorField,904,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:969,Modifiability,Rewrite,RewriteDescriptorType,969,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1402,Modifiability,variab,variable,1402,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1437,Modifiability,variab,variable,1437,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1507,Modifiability,variab,variable,1507,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1864,Modifiability,rewrite,rewrite,1864,"SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // SymbolRewriter is a LLVM pass which can rewrite symbols transparently within; // existing code. It is implemented as a compiler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapPa",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1914,Modifiability,rewrite,rewrite,1914,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1958,Modifiability,extend,extended,1958,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:1971,Modifiability,rewrite,rewrite,1971,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2025,Modifiability,Rewrite,RewriteDescriptor,2025,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2044,Modifiability,Rewrite,RewriteDescriptorType,2044,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2171,Modifiability,extend,extending,2171,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2185,Modifiability,rewrite,rewrite,2185,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2222,Modifiability,Rewrite,RewriteMapParser,2222,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2271,Modifiability,rewrite,rewrite,2271,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2303,Modifiability,rewrite,rewrite-symbols,2303,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:2392,Modifiability,rewrite,rewrite-map-file,2392,"ler pass and is configured via a; // YAML configuration file.; //; // The YAML configuration file format is as follows:; //; // RewriteMapFile := RewriteDescriptors; // RewriteDescriptors := RewriteDescriptor | RewriteDescriptors; // RewriteDescriptor := RewriteDescriptorType ':' '{' RewriteDescriptorFields '}'; // RewriteDescriptorFields := RewriteDescriptorField | RewriteDescriptorFields; // RewriteDescriptorField := FieldIdentifier ':' FieldValue ','; // RewriteDescriptorType := Identifier; // FieldIdentifier := Identifier; // FieldValue := Identifier; // Identifier := [0-9a-zA-Z]+; //; // Currently, the following descriptor types are supported:; //; // - function: (function rewriting); // + Source (original name of the function); // + Target (explicit transformation); // + Transform (pattern transformation); // + Naked (boolean, whether the function is undecorated); // - global variable: (external linkage global variable rewriting); // + Source (original name of externally visible variable); // + Target (explicit transformation); // + Transform (pattern transformation); // - global alias: (global alias rewriting); // + Source (original name of the aliased name); // + Target (explicit transformation); // + Transform (pattern transformation); //; // Note that source and exactly one of [Target, Transform] must be provided; //; // New rewrite descriptors can be created. Addding a new rewrite descriptor; // involves:; //; // a) extended the rewrite descriptor kind enumeration; // (<anonymous>::RewriteDescriptor::RewriteDescriptorType); // b) implementing the new descriptor; // (c.f. <anonymous>::ExplicitRewriteFunctionDescriptor); // c) extending the rewrite map parser; // (<anonymous>::RewriteMapParser::parseEntry); //; // Specify to rewrite the symbols using the `-rewrite-symbols` option, and; // specify the map file to use for the rewriting via the `-rewrite-map-file`; // option.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named (function) symbol. Both the; /// source function name and target function name of the transformation are; /// explicitly spelt out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:57,Modifiability,variab,variable,57,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:96,Modifiability,variab,variable,96,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:121,Modifiability,variab,variable,121,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:189,Modifiability,variab,variables,189,/// Represents a rewrite for an explicitly named (global variable) symbol. Both; /// the source variable name and target variable name are spelt out. This; /// applies only to module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for an explicitly named global alias. Both the source; /// and target name are explicitly spelt out.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for a regular expression based pattern for functions.; /// A pattern for the function name is provided and a transformation for that; /// pattern to determine the target function name create the rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:220,Modifiability,rewrite,rewrite,220,/// Represents a rewrite for a regular expression based pattern for functions.; /// A pattern for the function name is provided and a transformation for that; /// pattern to determine the target function name create the rewrite rule.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:17,Modifiability,rewrite,rewrite,17,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:38,Modifiability,variab,variable,38,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:95,Modifiability,variab,variable,95,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:252,Modifiability,variab,variables,252,/// Represents a rewrite for a global variable based upon a matching pattern.; /// Each global variable matching the provided pattern will be transformed as; /// described in the transformation pattern for the target. Applies only to; /// module level variables.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:54,Modifiability,rewrite,rewrite,54,/// PatternRewriteNamedAliasDescriptor - represents a rewrite for global; /// aliases which match a given pattern. The provided transformation will be; /// applied to each of the matching names.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp:65,Modifiability,rewrite,rewrite,65,// TODO see if there is a more elegant solution to selecting the rewrite; // descriptor type,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/SymbolRewriter.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp:797,Testability,assert,assert,797,"//===- UnifyLoopExits.cpp - Redirect exiting edges to one block -*- C++ -*-===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // For each natural loop with multiple exit blocks, this pass creates a new; // block N such that all exiting blocks now branch to N, and then control flow; // is redistributed to all the original exit blocks.; //; // Limitation: This assumes that all terminators in the CFG are direct branches; // (the ""br"" instruction). The presence of any other control flow; // such as indirectbr, switch or callbr will cause an assert.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp:183,Energy Efficiency,efficient,efficient,183,"// To unify the loop exits, we need a list of the exiting blocks as; // well as exit blocks. The functions for locating these lists both; // traverse the entire loop body. It is more efficient to first; // locate the exiting blocks and then examine their successors to; // locate the exit blocks.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/UnifyLoopExits.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:25,Integrability,Interface,Interface,25,"//===- ValueMapper.cpp - Interface shared by lib/Transforms/Utils ---------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This file defines the MapValue function, which is shared by various parts of; // the lib/Transforms/Utils library.; //; //===----------------------------------------------------------------------===//",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:113,Deployability,update,update,113,"// Post-order traversal.; /// Propagate changed operands through the post-order traversal.; ///; /// Iteratively update \a Data::HasChanged for each node based on \a; /// Data::HasChanged of its operands, until fixed point.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:500,Integrability,depend,depends,500,"/// Map a metadata node (and its transitive operands).; ///; /// Map all the (unmapped) nodes in the subgraph under \c N. The iterative; /// algorithm handles distinct nodes and uniqued node subgraphs using; /// different strategies.; ///; /// Distinct nodes are immediately mapped and added to \a DistinctWorklist; /// using \a mapDistinctNode(). Their mapping can always be computed; /// immediately without visiting operands, even if their operands change.; ///; /// The mapping for uniqued nodes depends on whether their operands change.; /// \a mapTopLevelUniquedNode() traverses the transitive uniqued subgraph of; /// a node to calculate uniqued node mappings in bulk. Distinct leafs are; /// added to \a DistinctWorklist with \a mapDistinctNode().; ///; /// After mapping \c N itself, this function remaps the operands of the; /// distinct nodes in \a DistinctWorklist until the entire subgraph under \c; /// N has been mapped.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:164,Integrability,depend,depending,164,"/// Map all the nodes in the given uniqued graph.; ///; /// This visits all the nodes in \c G in post-order, using the identity; /// mapping or creating a new node depending on \a Data::HasChanged.; ///; /// \pre \a getMappedOp() returns std::nullopt for nodes in \c G, but not for; /// any of their operands outside of \c G. \pre \a Data::HasChanged is true; /// for a node in \c G iff any of its operands have changed. \post \a; /// getMappedOp() returns the mapped node for every node in \c G.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:104,Deployability,update,update,104,/// Remap a node's operands using the given functor.; ///; /// Iterate through the operands of \c N and update them in place using \c; /// mapOperand.; ///; /// \pre N.isDistinct() or N.isTemporary().,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:9,Modifiability,variab,variables,9,// Remap variables and DILocations.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:99,Safety,avoid,avoid,99,///< Current operand of \c N.; /// Keep a flag of whether operands have changed in the worklist to avoid; /// hitting the map in \a UniquedGraph.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:3,Deployability,Update,Update,3,// Update graph with all nodes that have changed.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:178,Deployability,update,updated,178,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:90,Integrability,depend,depends,90,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:81,Modifiability,variab,variable,81,"// mapAppendingVariable call can change AppendingInits if initalizer for; // the variable depends on another appending global, because of that inits; // need to be extracted and updated before the call.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:10,Testability,log,logic,10,// Finish logic for block addresses now that all global values have been; // handled.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:42,Testability,assert,assert,42,"// If we aren't ignoring missing entries, assert that something happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:42,Testability,assert,assert,42,"// If we aren't ignoring missing entries, assert that something happened.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp:15,Deployability,upgrade,upgrade,15,// FIXME: This upgrade is done during linking to support the C API. See; // also IRLinker::linkAppendingVarProto() in IRMover.cpp.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/ValueMapper.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:46,Performance,load,load,46,// The store has to be at least as big as the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:60,Performance,load,load,60,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:151,Performance,Load,LoadedTy,151,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:179,Performance,load,load,179,"/// If we saw a store of a value to memory, and; /// then a load from a must-aliased pointer of a different type, try to coerce; /// the stored value. LoadedTy is the type of the load we want to replace.; /// IRB is IRBuilder used to insert new instructions.; ///; /// If we can't do it, return null.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:26,Performance,load,load,26,// Cast to pointer if the load needs a pointer type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,Availability,avail,available,43,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:112,Availability,avail,available,112,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded value is smaller than the available value, then we can; // extract out a piece from it. If the available value is too small, then we; // can't do anything.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:62,Availability,down,down,62,"// If this is a big-endian system, we need to shift the value down to the low; // bits so that a truncate will work.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:61,Performance,load,load,61,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:212,Performance,load,load,212,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:484,Performance,load,load,484,"/// This function is called when we have a memdep query of a load that ends up; /// being a clobbering memory write (store, memset, memcpy, memmove). This; /// means that the write *may* provide bits used by the load but we can't be; /// sure because the pointers don't must-alias.; ///; /// Check this case to see if there is anything more we can do before we give; /// up. This returns -1 if we have to give up, or a byte number in the stored; /// value of the piece that feeds the load.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,load,loaded,10,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,"// If the loaded/stored value is a first class array/struct, or scalable type,; // don't try to transform them. We need to be able to bitcast to integer.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:10,Performance,Load,Load,10,"// If the Load isn't completely contained within the stored bits, we don't; // have all the bits to feed it. We could do something crazy in the future; // (issue a smaller load then merge the bits in) but this seems unlikely to be; // valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:172,Performance,load,load,172,"// If the Load isn't completely contained within the stored bits, we don't; // have all the bits to feed it. We could do something crazy in the future; // (issue a smaller load then merge the bits in) but this seems unlikely to be; // valuable.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:95,Performance,load,load,95,"// Okay, we can do this transformation. Return the number of bytes into the; // store that the load is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering store.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,scalab,scalable,64,// Cannot handle reading from store of first-class aggregate or scalable type.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:111,Performance,load,load,111,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:139,Performance,load,load,139,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:169,Performance,load,load,169,/// This function is called when we have a; /// memdep query of a load that ends up being clobbered by another load. See if; /// the other load can feed into the second load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:14,Security,access,access,14,// See if the access is within the bounds of the transfer.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:44,Performance,load,load,44,"// Otherwise, see if we can constant fold a load from the constant with the; // offset applied as appropriate.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:128,Safety,avoid,avoids,128,"// If two pointers are in the same address space, they have the same size,; // so we don't need to do any truncation, etc. This avoids introducing; // ptrtoint instructions for pointers that may be non-integral.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:64,Performance,load,load,64,// Compute which bits of the stored value are being used by the load. Convert; // to an integer type to start with.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:43,Integrability,depend,depending,43,// Shift the bits to the least significant depending on endianness.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:66,Performance,load,load,66,/// This function is called when we have a; /// memdep query of a load that ends up being a clobbering mem intrinsic.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:101,Performance,load,load,101,// We know that this method is only called when the mem transfer fully; // provides the bits for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:54,Modifiability,variab,variable,54,"// memset(P, 'x', 1234) -> splat('x'), even if x is a variable, and; // independently of what the offset is.",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp:101,Performance,load,load,101,// We know that this method is only called when the mem transfer fully; // provides the bits for the load.,MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Utils/VNCoercion.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:762,Deployability,pipeline,pipeline,762,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp:7,Performance,Load,LoadStoreVectorizer,7,"//===- LoadStoreVectorizer.cpp - GPU Load & Store Vectorizer --------------===//; //; // Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.; // See https://llvm.org/LICENSE.txt for license information.; // SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception; //; //===----------------------------------------------------------------------===//; //; // This pass merges loads/stores to/from sequential memory addresses into vector; // loads/stores. Although there's nothing GPU-specific in here, this pass is; // motivated by the microarchitectural quirks of nVidia and AMD GPUs.; //; // (For simplicity below we talk about loads only, but everything also applies; // to stores.); //; // This pass is intended to be run late in the pipeline, after other; // vectorization opportunities have been exploited. So the assumption here is; // that immediately following our new vector load we'll need to extract out the; // individual elements of the load, so we can operate on them individually.; //; // On CPUs this transformation is usually not beneficial, because extracting the; // elements of a vector register is expensive on most architectures. It's; // usually better just to load each element individually into its own scalar; // register.; //; // However, nVidia and AMD GPUs don't have proper vector registers. Instead, a; // ""vector load"" loads directly into a series of scalar registers. In effect,; // extracting the elements of the vector is free. It's therefore always; // beneficial to vectorize a sequence of loads on these architectures.; //; // Vectorizing (perhaps a better name might be ""coalescing"") loads can have; // large performance impacts on GPU kernels, and opportunities for vectorizing; // are common in GPU code. This pass tries very hard to find such; // opportunities; its runtime is quadratic in the number of loads in a BB.; //; // Some CPU architectures, such as ARM, have instructions that load into; // multiple scalar registers, simila",MatchSource.CODE_COMMENT,interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp,root-project,root,v6-32-06,https://root.cern,https://github.com/root-project/root/tree/v6-32-06/interpreter/llvm-project/llvm/lib/Transforms/Vectorize/LoadStoreVectorizer.cpp
